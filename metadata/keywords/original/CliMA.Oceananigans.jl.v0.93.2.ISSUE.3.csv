id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/pull/2123:447,Testability,test,tests,447,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123
https://github.com/CliMA/Oceananigans.jl/pull/2124:400,Availability,down,downstream,400,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124
https://github.com/CliMA/Oceananigans.jl/pull/2124:338,Deployability,release,release,338,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124
https://github.com/CliMA/Oceananigans.jl/pull/2124:424,Integrability,depend,depend,424,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124
https://github.com/CliMA/Oceananigans.jl/pull/2124:151,Testability,test,tested,151,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124
https://github.com/CliMA/Oceananigans.jl/pull/2124:257,Testability,test,tests,257,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124
https://github.com/CliMA/Oceananigans.jl/pull/2124:443,Testability,test,tests,443,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124
https://github.com/CliMA/Oceananigans.jl/issues/2126:19,Energy Efficiency,allocate,allocate,19,"It appears that we allocate memory for a few more 3D arrays than needed in order to calculate pressure in `NonhydrostaticModel`. We currently allocate 3 arrays: one for hydrostatic pressure, one for non-hydrostatic pressure, and a third array with `Complex{Float64}` elements that's used for in-place FFTs while solving the pressure Poisson equation. For our algorithm to be correct, however, we only need one array with `Complex{Float64}` elements. This array can than be used as scratch space when calculating the hydrostatic pressure and computing hydrostatic pressure gradients. It will then be overwritten when calculating the nonhydrostatic pressure component. The distinction between the solver field with `Complex{Float64}` elements and the nonhydrostatic pressure is just that the nonhydrostatic pressure is `real`, which we enforce when copying it over:. https://github.com/CliMA/Oceananigans.jl/blob/4f80c386930a5b703f753bafd4af76419dbbcac9/src/Solvers/fft_based_poisson_solver.jl#L102-L105. However, we could just as easily extract the real component when computing the pressure gradient:. https://github.com/CliMA/Oceananigans.jl/blob/4f80c386930a5b703f753bafd4af76419dbbcac9/src/Models/NonhydrostaticModels/pressure_correction.jl#L34-L40",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2126
https://github.com/CliMA/Oceananigans.jl/issues/2126:142,Energy Efficiency,allocate,allocate,142,"It appears that we allocate memory for a few more 3D arrays than needed in order to calculate pressure in `NonhydrostaticModel`. We currently allocate 3 arrays: one for hydrostatic pressure, one for non-hydrostatic pressure, and a third array with `Complex{Float64}` elements that's used for in-place FFTs while solving the pressure Poisson equation. For our algorithm to be correct, however, we only need one array with `Complex{Float64}` elements. This array can than be used as scratch space when calculating the hydrostatic pressure and computing hydrostatic pressure gradients. It will then be overwritten when calculating the nonhydrostatic pressure component. The distinction between the solver field with `Complex{Float64}` elements and the nonhydrostatic pressure is just that the nonhydrostatic pressure is `real`, which we enforce when copying it over:. https://github.com/CliMA/Oceananigans.jl/blob/4f80c386930a5b703f753bafd4af76419dbbcac9/src/Solvers/fft_based_poisson_solver.jl#L102-L105. However, we could just as easily extract the real component when computing the pressure gradient:. https://github.com/CliMA/Oceananigans.jl/blob/4f80c386930a5b703f753bafd4af76419dbbcac9/src/Models/NonhydrostaticModels/pressure_correction.jl#L34-L40",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2126
https://github.com/CliMA/Oceananigans.jl/issues/2127:871,Availability,recover,recover,871,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127
https://github.com/CliMA/Oceananigans.jl/issues/2127:571,Deployability,update,update,571,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127
https://github.com/CliMA/Oceananigans.jl/issues/2127:767,Energy Efficiency,power,power,767,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127
https://github.com/CliMA/Oceananigans.jl/issues/2127:633,Integrability,depend,depended,633,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127
https://github.com/CliMA/Oceananigans.jl/issues/2127:595,Modifiability,parameteriz,parameterization,595,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127
https://github.com/CliMA/Oceananigans.jl/issues/2127:871,Safety,recover,recover,871,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127
https://github.com/CliMA/Oceananigans.jl/pull/2131:16,Testability,test,test,16,"This PR fixes a test that compares the conjugate gradient and matrix-based implicit implicit free surface solvers. This test is failing because `tracer_advection = WENO5()`, which requires `halo = (3, 3, 3)`, while grid halos were left at the default `halo = (1, 1, 1)`. I also cleaned up some of the test formatting. @christophernhill @simone-silvestri any idea how this failing test got merged? I guess tests passed on a PR but not on `main` where #2105 was merged with #2108. This PR should be merged before #2130.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131
https://github.com/CliMA/Oceananigans.jl/pull/2131:120,Testability,test,test,120,"This PR fixes a test that compares the conjugate gradient and matrix-based implicit implicit free surface solvers. This test is failing because `tracer_advection = WENO5()`, which requires `halo = (3, 3, 3)`, while grid halos were left at the default `halo = (1, 1, 1)`. I also cleaned up some of the test formatting. @christophernhill @simone-silvestri any idea how this failing test got merged? I guess tests passed on a PR but not on `main` where #2105 was merged with #2108. This PR should be merged before #2130.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131
https://github.com/CliMA/Oceananigans.jl/pull/2131:301,Testability,test,test,301,"This PR fixes a test that compares the conjugate gradient and matrix-based implicit implicit free surface solvers. This test is failing because `tracer_advection = WENO5()`, which requires `halo = (3, 3, 3)`, while grid halos were left at the default `halo = (1, 1, 1)`. I also cleaned up some of the test formatting. @christophernhill @simone-silvestri any idea how this failing test got merged? I guess tests passed on a PR but not on `main` where #2105 was merged with #2108. This PR should be merged before #2130.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131
https://github.com/CliMA/Oceananigans.jl/pull/2131:380,Testability,test,test,380,"This PR fixes a test that compares the conjugate gradient and matrix-based implicit implicit free surface solvers. This test is failing because `tracer_advection = WENO5()`, which requires `halo = (3, 3, 3)`, while grid halos were left at the default `halo = (1, 1, 1)`. I also cleaned up some of the test formatting. @christophernhill @simone-silvestri any idea how this failing test got merged? I guess tests passed on a PR but not on `main` where #2105 was merged with #2108. This PR should be merged before #2130.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131
https://github.com/CliMA/Oceananigans.jl/pull/2131:405,Testability,test,tests,405,"This PR fixes a test that compares the conjugate gradient and matrix-based implicit implicit free surface solvers. This test is failing because `tracer_advection = WENO5()`, which requires `halo = (3, 3, 3)`, while grid halos were left at the default `halo = (1, 1, 1)`. I also cleaned up some of the test formatting. @christophernhill @simone-silvestri any idea how this failing test got merged? I guess tests passed on a PR but not on `main` where #2105 was merged with #2108. This PR should be merged before #2130.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2131
https://github.com/CliMA/Oceananigans.jl/issues/2135:139,Testability,test,test,139,Is `nothing` missing from here? Or something else?. https://github.com/CliMA/Oceananigans.jl/blob/4f80c386930a5b703f753bafd4af76419dbbcac9/test/test_matrix_poisson_solver.jl#L70. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135
https://github.com/CliMA/Oceananigans.jl/issues/2136:606,Usability,simpl,simple,606,"Mentioned in #2134, I want to include both a `Relaxation` and `Forcing` for a velocity component, specifically a sponge layer at the top and bottom of the domain and a forcing function within the non-sponge domain. One potential syntax for this suggested by @glwagner is passing a tuple to the model constructor: ; ```; forcing = (; u = (u_relaxation, u_sponge)),; ```. This seems like a straightforward syntax from a user perspective since it's similar to other model constructor syntax, e.g., specifying tracers. Since a `Relaxation` can be called from within a `Forcing` function, it might be easier to simple provide an example of that syntax to create a combined `Forcing`. The calling order of the forcings is explicit in that case since the user is writing the function and it doesn't require any additional development (well, other than an example).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2136
https://github.com/CliMA/Oceananigans.jl/issues/2139:22,Deployability,pipeline,pipelines,22,"Some of the buildkite pipelines take way too long. Specifically the `time_stepping_2`, `regression` and `solver` tests. I suggest we further split them?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139
https://github.com/CliMA/Oceananigans.jl/issues/2139:113,Testability,test,tests,113,"Some of the buildkite pipelines take way too long. Specifically the `time_stepping_2`, `regression` and `solver` tests. I suggest we further split them?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139
https://github.com/CliMA/Oceananigans.jl/pull/2141:216,Usability,Simpl,SimplifiedInversePreconditioner,216,"This PR implements the formulation of the default preconditioner for GPU following Marshall J. et al., ""Finite-volume, incompressible Navier Stokes model for studies of the ocean on parallel computers"" (here called `SimplifiedInversePreconditioner`). Also, the `Jacobi` preconditioner has been removed as it gives no benefits in terms of speed",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2141
https://github.com/CliMA/Oceananigans.jl/issues/2142:19,Availability,error,error,19,Should we throw an error if users try to run code with a julia version that's too low?. cc @mukund-gupta,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2142
https://github.com/CliMA/Oceananigans.jl/issues/2148:76,Availability,down,down,76,"For some cases, we _want_ these two parameters to be different (eg to ""slow down"" the free surface wave speed by using reduced gravity). But it might be friendly to some unsuspecting users to throw a warning in the constructor for `HydrostaticFreeSurfaceModel`, just in case this was not intended. cc @simonbyrne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2148
https://github.com/CliMA/Oceananigans.jl/issues/2148:119,Energy Efficiency,reduce,reduced,119,"For some cases, we _want_ these two parameters to be different (eg to ""slow down"" the free surface wave speed by using reduced gravity). But it might be friendly to some unsuspecting users to throw a warning in the constructor for `HydrostaticFreeSurfaceModel`, just in case this was not intended. cc @simonbyrne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2148
https://github.com/CliMA/Oceananigans.jl/issues/2149:118,Performance,perform,performance,118,"We might need to implement the K-Profile boundary layer turbulence closure so that we can use it to compare the CATKE performance. . Ideally, we'd like to calibrate the K-Profile parametrisation using [OceanTurbulenceParameterEstimation.jl](http://github.com/CliMA/OceanTurbulenceParameterEstimation.jl) alongside with CATKE closure and then compare how the two perform under various scenarios. @glwagner, would it be easy to implement KPP, similarly as done in [OceanTurb.jl](https://github.com/glwagner/OceanTurb.jl)?. cc @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2149
https://github.com/CliMA/Oceananigans.jl/issues/2149:362,Performance,perform,perform,362,"We might need to implement the K-Profile boundary layer turbulence closure so that we can use it to compare the CATKE performance. . Ideally, we'd like to calibrate the K-Profile parametrisation using [OceanTurbulenceParameterEstimation.jl](http://github.com/CliMA/OceanTurbulenceParameterEstimation.jl) alongside with CATKE closure and then compare how the two perform under various scenarios. @glwagner, would it be easy to implement KPP, similarly as done in [OceanTurb.jl](https://github.com/glwagner/OceanTurb.jl)?. cc @rafferrari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2149
https://github.com/CliMA/Oceananigans.jl/pull/2150:246,Modifiability,variab,variable,246,"At the moment . `ΔF[i-1] = C[i] - C[i-1]` where `C` and `F` are the center and face coordinate, respectively. On the other hand, the derivative on the face `[i]` is calculated with `(c[i] - c[i-1]) / ΔF[i]` (where `c` is the value of the derived variable at the centers). therefore, it has to be that `ΔF[i] = C[i] - C[i-1]`. Because of how we test, this bug was miraculously eluding all testing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2150
https://github.com/CliMA/Oceananigans.jl/pull/2150:344,Testability,test,test,344,"At the moment . `ΔF[i-1] = C[i] - C[i-1]` where `C` and `F` are the center and face coordinate, respectively. On the other hand, the derivative on the face `[i]` is calculated with `(c[i] - c[i-1]) / ΔF[i]` (where `c` is the value of the derived variable at the centers). therefore, it has to be that `ΔF[i] = C[i] - C[i-1]`. Because of how we test, this bug was miraculously eluding all testing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2150
https://github.com/CliMA/Oceananigans.jl/pull/2150:388,Testability,test,testing,388,"At the moment . `ΔF[i-1] = C[i] - C[i-1]` where `C` and `F` are the center and face coordinate, respectively. On the other hand, the derivative on the face `[i]` is calculated with `(c[i] - c[i-1]) / ΔF[i]` (where `c` is the value of the derived variable at the centers). therefore, it has to be that `ΔF[i] = C[i] - C[i-1]`. Because of how we test, this bug was miraculously eluding all testing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2150
https://github.com/CliMA/Oceananigans.jl/pull/2152:213,Testability,test,test,213,"PR #2121 changed some function signatures, which broke functionality provided by `single_column_model_mode.jl` that sets `model.free_surface = nothing`. This PR restores that functionality. I think we could add a test, but the experimental nature of `single_column_model_mode.jl` could also mean it'd be better to wait.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2152
https://github.com/CliMA/Oceananigans.jl/issues/2154:50,Energy Efficiency,schedul,schedule,50,We need to add a test for `ConsecutiveIterations` schedule that was introduced by #2100,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2154
https://github.com/CliMA/Oceananigans.jl/issues/2154:17,Testability,test,test,17,We need to add a test for `ConsecutiveIterations` schedule that was introduced by #2100,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2154
https://github.com/CliMA/Oceananigans.jl/issues/2156:347,Availability,robust,robust,347,"An important missing component of our user interface is a function-based API for extracting properties from models. For example, we often write. ```julia; u, v, w = model.velocities; ```. when we really should write something like. ```julia; u, v, w = velocity_field(model); ```. A major advantage of a function-based interface is that it is more robust to changes to the underlying model implementation. For example, we will eventually need a `VectorField` implementation for velocities (eg for the cubed sphere, or non-orthogonal grids). We'll be sorry that we've written `u, v, w = model.velocities` everywhere when we need to change `model.velocities` to `model.velocity_field`. But with a function-based interface we only have to change `velocity_field(model) = model.velocities` to `velocity_field(model) = model.velocity_field`. A few other functions besides `velocity_field` that we might want are. * `tracers(model)`; * `free_surface_displacement(model)`; * `kinematic_pressure(model)`; * `buoyancy(model)`. `viscosity(model)` and `diffusivities(model)` might be nice too. One challenge there is figuring out what to do when the viscosity or diffusivities are really tensors rather than scalars (eg we need `VectorField` but we also may need `TensorField`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156
https://github.com/CliMA/Oceananigans.jl/issues/2156:43,Integrability,interface,interface,43,"An important missing component of our user interface is a function-based API for extracting properties from models. For example, we often write. ```julia; u, v, w = model.velocities; ```. when we really should write something like. ```julia; u, v, w = velocity_field(model); ```. A major advantage of a function-based interface is that it is more robust to changes to the underlying model implementation. For example, we will eventually need a `VectorField` implementation for velocities (eg for the cubed sphere, or non-orthogonal grids). We'll be sorry that we've written `u, v, w = model.velocities` everywhere when we need to change `model.velocities` to `model.velocity_field`. But with a function-based interface we only have to change `velocity_field(model) = model.velocities` to `velocity_field(model) = model.velocity_field`. A few other functions besides `velocity_field` that we might want are. * `tracers(model)`; * `free_surface_displacement(model)`; * `kinematic_pressure(model)`; * `buoyancy(model)`. `viscosity(model)` and `diffusivities(model)` might be nice too. One challenge there is figuring out what to do when the viscosity or diffusivities are really tensors rather than scalars (eg we need `VectorField` but we also may need `TensorField`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156
https://github.com/CliMA/Oceananigans.jl/issues/2156:318,Integrability,interface,interface,318,"An important missing component of our user interface is a function-based API for extracting properties from models. For example, we often write. ```julia; u, v, w = model.velocities; ```. when we really should write something like. ```julia; u, v, w = velocity_field(model); ```. A major advantage of a function-based interface is that it is more robust to changes to the underlying model implementation. For example, we will eventually need a `VectorField` implementation for velocities (eg for the cubed sphere, or non-orthogonal grids). We'll be sorry that we've written `u, v, w = model.velocities` everywhere when we need to change `model.velocities` to `model.velocity_field`. But with a function-based interface we only have to change `velocity_field(model) = model.velocities` to `velocity_field(model) = model.velocity_field`. A few other functions besides `velocity_field` that we might want are. * `tracers(model)`; * `free_surface_displacement(model)`; * `kinematic_pressure(model)`; * `buoyancy(model)`. `viscosity(model)` and `diffusivities(model)` might be nice too. One challenge there is figuring out what to do when the viscosity or diffusivities are really tensors rather than scalars (eg we need `VectorField` but we also may need `TensorField`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156
https://github.com/CliMA/Oceananigans.jl/issues/2156:709,Integrability,interface,interface,709,"An important missing component of our user interface is a function-based API for extracting properties from models. For example, we often write. ```julia; u, v, w = model.velocities; ```. when we really should write something like. ```julia; u, v, w = velocity_field(model); ```. A major advantage of a function-based interface is that it is more robust to changes to the underlying model implementation. For example, we will eventually need a `VectorField` implementation for velocities (eg for the cubed sphere, or non-orthogonal grids). We'll be sorry that we've written `u, v, w = model.velocities` everywhere when we need to change `model.velocities` to `model.velocity_field`. But with a function-based interface we only have to change `velocity_field(model) = model.velocities` to `velocity_field(model) = model.velocity_field`. A few other functions besides `velocity_field` that we might want are. * `tracers(model)`; * `free_surface_displacement(model)`; * `kinematic_pressure(model)`; * `buoyancy(model)`. `viscosity(model)` and `diffusivities(model)` might be nice too. One challenge there is figuring out what to do when the viscosity or diffusivities are really tensors rather than scalars (eg we need `VectorField` but we also may need `TensorField`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156
https://github.com/CliMA/Oceananigans.jl/pull/2157:72,Energy Efficiency,reduce,reduced,72,"This PR generalizes the broadcasting implementation to work with fields reduced in any direction. The changes mean that, for example, if broadcasting to a field that's reduced in _two_ directions (eg a 1D field on a 3D grid), the kernel that's launched to do the computation will be 1D and therefore will not ""waste"" computation. It also turns out that the ""generalization"" requires less code than the original implementation (doh). This PR also adds more tests for broadcasting to reduced fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2157
https://github.com/CliMA/Oceananigans.jl/pull/2157:168,Energy Efficiency,reduce,reduced,168,"This PR generalizes the broadcasting implementation to work with fields reduced in any direction. The changes mean that, for example, if broadcasting to a field that's reduced in _two_ directions (eg a 1D field on a 3D grid), the kernel that's launched to do the computation will be 1D and therefore will not ""waste"" computation. It also turns out that the ""generalization"" requires less code than the original implementation (doh). This PR also adds more tests for broadcasting to reduced fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2157
https://github.com/CliMA/Oceananigans.jl/pull/2157:482,Energy Efficiency,reduce,reduced,482,"This PR generalizes the broadcasting implementation to work with fields reduced in any direction. The changes mean that, for example, if broadcasting to a field that's reduced in _two_ directions (eg a 1D field on a 3D grid), the kernel that's launched to do the computation will be 1D and therefore will not ""waste"" computation. It also turns out that the ""generalization"" requires less code than the original implementation (doh). This PR also adds more tests for broadcasting to reduced fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2157
https://github.com/CliMA/Oceananigans.jl/pull/2157:456,Testability,test,tests,456,"This PR generalizes the broadcasting implementation to work with fields reduced in any direction. The changes mean that, for example, if broadcasting to a field that's reduced in _two_ directions (eg a 1D field on a 3D grid), the kernel that's launched to do the computation will be 1D and therefore will not ""waste"" computation. It also turns out that the ""generalization"" requires less code than the original implementation (doh). This PR also adds more tests for broadcasting to reduced fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2157
https://github.com/CliMA/Oceananigans.jl/issues/2158:141,Modifiability,variab,variables,141,"These are just functions which retrieve `Ax`, `Ay`, `Az` and `V` on the location of interest. On the other hand, they conflict with the same variables exported from `AbstractOperations`. I think they should be exported only by the latter because as `AbstractOperations` they have a unique functionality whereas from `Operators` they are just a renaming of `Axᵃᵃᵃ`, `Ayᵃᵃᵃ`, `Azᵃᵃᵃ`and `Vᵃᵃᵃ`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2158
https://github.com/CliMA/Oceananigans.jl/pull/2163:287,Availability,error,error,287,"This PR adds a step in the outer `Field` constructor that validates boundary conditions. We check three things:. 1. That boundary conditions are compatible with the topology. Namely, we are restricted to default choices in `Periodic` or `Flat` directions; anything but default throws an error. 2. If a topology is `Bounded`, we check that boundary conditions are compatible with field location. Mostly we cannot support flux, value, or gradient boundary conditions for fields at faces, and we only support `nothing` for fields in `Flat` directions. 3. That boundary condition arrays are on the right architecture. TODO:. - [x] Test. Resolves #419; Resolves #890. Supercedes #1732",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163
https://github.com/CliMA/Oceananigans.jl/pull/2163:58,Security,validat,validates,58,"This PR adds a step in the outer `Field` constructor that validates boundary conditions. We check three things:. 1. That boundary conditions are compatible with the topology. Namely, we are restricted to default choices in `Periodic` or `Flat` directions; anything but default throws an error. 2. If a topology is `Bounded`, we check that boundary conditions are compatible with field location. Mostly we cannot support flux, value, or gradient boundary conditions for fields at faces, and we only support `nothing` for fields in `Flat` directions. 3. That boundary condition arrays are on the right architecture. TODO:. - [x] Test. Resolves #419; Resolves #890. Supercedes #1732",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163
https://github.com/CliMA/Oceananigans.jl/pull/2163:627,Testability,Test,Test,627,"This PR adds a step in the outer `Field` constructor that validates boundary conditions. We check three things:. 1. That boundary conditions are compatible with the topology. Namely, we are restricted to default choices in `Periodic` or `Flat` directions; anything but default throws an error. 2. If a topology is `Bounded`, we check that boundary conditions are compatible with field location. Mostly we cannot support flux, value, or gradient boundary conditions for fields at faces, and we only support `nothing` for fields in `Flat` directions. 3. That boundary condition arrays are on the right architecture. TODO:. - [x] Test. Resolves #419; Resolves #890. Supercedes #1732",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163
https://github.com/CliMA/Oceananigans.jl/pull/2169:369,Testability,test,tests,369,"This PR adds comparison operators to our supported operators, and also cleans up `Field` constructors for cases where computations or reductions return non-floating-point elements (such as Booleans). This support is progress towards allowing users to specify things like conditional averages as diagnostics, using `AbstractOperation`s. It's still a WIP because we need tests, and probably should also wait for a few other PRs before merging (eg #2097).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2169
https://github.com/CliMA/Oceananigans.jl/pull/2170:48,Deployability,update,updates,48,This has drifted a bit from latest APIs. . This updates to make validation cube sphere eddying aquaplanet great again. . Will allow to be used to start testing @simone-silvestri @jm-c @glwagner fixed up immersed boundaries with functioning implicit vertical terms plus working stretched grid 👍 awesomeness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170
https://github.com/CliMA/Oceananigans.jl/pull/2170:64,Security,validat,validation,64,This has drifted a bit from latest APIs. . This updates to make validation cube sphere eddying aquaplanet great again. . Will allow to be used to start testing @simone-silvestri @jm-c @glwagner fixed up immersed boundaries with functioning implicit vertical terms plus working stretched grid 👍 awesomeness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170
https://github.com/CliMA/Oceananigans.jl/pull/2170:152,Testability,test,testing,152,This has drifted a bit from latest APIs. . This updates to make validation cube sphere eddying aquaplanet great again. . Will allow to be used to start testing @simone-silvestri @jm-c @glwagner fixed up immersed boundaries with functioning implicit vertical terms plus working stretched grid 👍 awesomeness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170
https://github.com/CliMA/Oceananigans.jl/pull/2171:282,Energy Efficiency,efficient,efficiently,282,"This PR adds `OneField` and `ConstantField` and generalizes `ZeroField` to be capable of producing zeros of any type. In particular it may be useful to use a `ZeroField(Bool)` since `false` is a ""strong"" zero. @simone-silvestri you may find `OneField` useful for estimating lengths efficiently, along with `ConditionalOperation`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2171
https://github.com/CliMA/Oceananigans.jl/pull/2172:37,Deployability,update,updates,37,"This captures a few changes, such as updates to `show`, `Callback` `parameters`, new field types, and boundary condition validation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2172
https://github.com/CliMA/Oceananigans.jl/pull/2172:121,Security,validat,validation,121,"This captures a few changes, such as updates to `show`, `Callback` `parameters`, new field types, and boundary condition validation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2172
https://github.com/CliMA/Oceananigans.jl/pull/2173:110,Testability,test,tests,110,This PR fixes `Average` to correctly to use `mean!` when reducing over regular dimensions. It also adds a few tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2173
https://github.com/CliMA/Oceananigans.jl/pull/2174:174,Modifiability,extend,extends,174,"This PR checks whether two grids are only different in the vertical dimension using runtime information, rather then relying on both fields being `SingleColumnGrid`. It also extends `total_length` for directions that are `Flat`, but have non-zero grid points (for simulations representing ensembles of simulations). Closes #2067",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2174
https://github.com/CliMA/Oceananigans.jl/issues/2176:41,Availability,down,down,41,To make sure that the code does not slow down in between merges it would be useful to have a standard case and test that the time stepping is not significantly increased between different PRs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176
https://github.com/CliMA/Oceananigans.jl/issues/2176:111,Testability,test,test,111,To make sure that the code does not slow down in between merges it would be useful to have a standard case and test that the time stepping is not significantly increased between different PRs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176
https://github.com/CliMA/Oceananigans.jl/issues/2177:334,Availability,mask,mask,334,"Where is a reduced field located in the `Nothing` direction?. It is natural to locate the free surface at the surface, (`k = grid.Nz`), but for other fields which are Averages or sums the choice is not that natural. This is important in the context of Immersed boundaries to check if a Reduced Field is immersed or not (and eventally mask it). For the free surface it is enough to check `solid_interface(i, j, grid.Nz, grid)`, for averaged fields it might be necessary to check the whole column `all(solid_interface(i, j, 1:grid.Nz, grid))`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177
https://github.com/CliMA/Oceananigans.jl/issues/2177:11,Energy Efficiency,reduce,reduced,11,"Where is a reduced field located in the `Nothing` direction?. It is natural to locate the free surface at the surface, (`k = grid.Nz`), but for other fields which are Averages or sums the choice is not that natural. This is important in the context of Immersed boundaries to check if a Reduced Field is immersed or not (and eventally mask it). For the free surface it is enough to check `solid_interface(i, j, grid.Nz, grid)`, for averaged fields it might be necessary to check the whole column `all(solid_interface(i, j, 1:grid.Nz, grid))`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177
https://github.com/CliMA/Oceananigans.jl/issues/2177:286,Energy Efficiency,Reduce,Reduced,286,"Where is a reduced field located in the `Nothing` direction?. It is natural to locate the free surface at the surface, (`k = grid.Nz`), but for other fields which are Averages or sums the choice is not that natural. This is important in the context of Immersed boundaries to check if a Reduced Field is immersed or not (and eventally mask it). For the free surface it is enough to check `solid_interface(i, j, grid.Nz, grid)`, for averaged fields it might be necessary to check the whole column `all(solid_interface(i, j, 1:grid.Nz, grid))`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177
https://github.com/CliMA/Oceananigans.jl/pull/2178:171,Testability,test,tested,171,"This pull request changes the compat entry for the `PencilFFTs` package from `0.12` to `0.12, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2178
https://github.com/CliMA/Oceananigans.jl/pull/2178:277,Testability,test,tests,277,"This pull request changes the compat entry for the `PencilFFTs` package from `0.12` to `0.12, 0.13`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2178
https://github.com/CliMA/Oceananigans.jl/issues/2179:157,Availability,down,downside,157,"I think it might make sense to serialize grids in JLD2 files with `CPU` architecture by default; this way they can be loaded on systems without a GPU. . The downside is that users with GPUs would have to write. ```julia; cpu_grid = file[""serialized/grid""]; grid = on_architecture(GPU(), cpu_grid); ```. to load their grid on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179
https://github.com/CliMA/Oceananigans.jl/issues/2179:118,Performance,load,loaded,118,"I think it might make sense to serialize grids in JLD2 files with `CPU` architecture by default; this way they can be loaded on systems without a GPU. . The downside is that users with GPUs would have to write. ```julia; cpu_grid = file[""serialized/grid""]; grid = on_architecture(GPU(), cpu_grid); ```. to load their grid on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179
https://github.com/CliMA/Oceananigans.jl/issues/2179:306,Performance,load,load,306,"I think it might make sense to serialize grids in JLD2 files with `CPU` architecture by default; this way they can be loaded on systems without a GPU. . The downside is that users with GPUs would have to write. ```julia; cpu_grid = file[""serialized/grid""]; grid = on_architecture(GPU(), cpu_grid); ```. to load their grid on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179
https://github.com/CliMA/Oceananigans.jl/issues/2180:189,Availability,error,error,189,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/issues/2180:248,Availability,error,error,248,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/issues/2180:430,Availability,error,error,430,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/issues/2180:44,Energy Efficiency,schedul,schedule,44,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/issues/2180:166,Energy Efficiency,schedul,schedule,166,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/issues/2180:340,Energy Efficiency,schedul,schedule,340,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/issues/2180:152,Security,validat,validates,152,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/issues/2180:326,Testability,test,test-call,326,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/issues/2180:106,Usability,user-friendly,user-friendly,106,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180
https://github.com/CliMA/Oceananigans.jl/pull/2181:54,Testability,test,tests,54,Some cleaning up in the implicit free surface solvers tests. Resolves #2184.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2181
https://github.com/CliMA/Oceananigans.jl/issues/2183:142,Testability,test,test,142,"Perhaps we can split the `.jl` file, e.g., put these:. https://github.com/CliMA/Oceananigans.jl/blob/c71770c10f40ebd0789491a33bbb3f8b4f6de14a/test/test_poisson_solvers.jl#L280-L312. in a different script and on their own buildkite process?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2183
https://github.com/CliMA/Oceananigans.jl/issues/2184:1145,Availability,toler,tolerance,1145,"ocs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> using Oceananigans.Units. julia> arch = CPU(). julia> grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (0, 1000kilometers), y = (0, 1), z = (-400, 0),; topology = (Bounded, Periodic, Bounded)); 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Bounded x ∈ [0.0, 1.0e6] regularly spaced with Δx=7812.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-400.0, 0.0] regularly spaced with Δz=80.0. julia> model_pcg = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> model_mat = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> typeof(model_pcg.free_surface.implicit_step_solver.right_hand_side); Field{Center, Center, Nothing, Nothing, RectilinearGri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184
https://github.com/CliMA/Oceananigans.jl/issues/2184:1710,Availability,toler,tolerance,1710,"d x ∈ [0.0, 1.0e6] regularly spaced with Δx=7812.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-400.0, 0.0] regularly spaced with Δz=80.0. julia> model_pcg = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> model_mat = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> typeof(model_pcg.free_surface.implicit_step_solver.right_hand_side); Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184
https://github.com/CliMA/Oceananigans.jl/issues/2184:3413,Testability,test,test,3413,"Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> model_mat = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> typeof(model_pcg.free_surface.implicit_step_solver.right_hand_side); Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}. julia> typeof(model_mat.free_surface.implicit_step_solver.right_hand_side); Vector{Float64} (alias for Array{Float64, 1}); ```. If this is OK then we need to drop `interior()` from the `right_hand_side` at:; https://github.com/CliMA/Oceananigans.jl/blob/4f730161c8ea189779eed8c3b56961065f7699d3/test/test_implicit_free_surface_solver.jl#L111. cc: @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184
https://github.com/CliMA/Oceananigans.jl/pull/2186:121,Energy Efficiency,reduce,reduced,121,"~Also bumps to 0.68.8.~. The application for this kind of regridding is from a field that, while living on a 3D grid, is reduced in x and y. Because the field is reduced in x and y it's a valid source field for a target field that's on a 1D grid. We should probably add a test to this PR (regridding from a reduced field on a 3D grid to a non-reduced field on a 1D grid). cc @adelinehillier @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186
https://github.com/CliMA/Oceananigans.jl/pull/2186:162,Energy Efficiency,reduce,reduced,162,"~Also bumps to 0.68.8.~. The application for this kind of regridding is from a field that, while living on a 3D grid, is reduced in x and y. Because the field is reduced in x and y it's a valid source field for a target field that's on a 1D grid. We should probably add a test to this PR (regridding from a reduced field on a 3D grid to a non-reduced field on a 1D grid). cc @adelinehillier @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186
https://github.com/CliMA/Oceananigans.jl/pull/2186:307,Energy Efficiency,reduce,reduced,307,"~Also bumps to 0.68.8.~. The application for this kind of regridding is from a field that, while living on a 3D grid, is reduced in x and y. Because the field is reduced in x and y it's a valid source field for a target field that's on a 1D grid. We should probably add a test to this PR (regridding from a reduced field on a 3D grid to a non-reduced field on a 1D grid). cc @adelinehillier @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186
https://github.com/CliMA/Oceananigans.jl/pull/2186:343,Energy Efficiency,reduce,reduced,343,"~Also bumps to 0.68.8.~. The application for this kind of regridding is from a field that, while living on a 3D grid, is reduced in x and y. Because the field is reduced in x and y it's a valid source field for a target field that's on a 1D grid. We should probably add a test to this PR (regridding from a reduced field on a 3D grid to a non-reduced field on a 1D grid). cc @adelinehillier @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186
https://github.com/CliMA/Oceananigans.jl/pull/2186:272,Testability,test,test,272,"~Also bumps to 0.68.8.~. The application for this kind of regridding is from a field that, while living on a 3D grid, is reduced in x and y. Because the field is reduced in x and y it's a valid source field for a target field that's on a 1D grid. We should probably add a test to this PR (regridding from a reduced field on a 3D grid to a non-reduced field on a 1D grid). cc @adelinehillier @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2186
https://github.com/CliMA/Oceananigans.jl/issues/2188:15,Integrability,interface,interface,15,"We need a user interface to `ConditionalOperand`, so it can be user-facing. #2185 is related. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2188
https://github.com/CliMA/Oceananigans.jl/issues/2189:2426,Availability,ERROR,ERROR,2426,"64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Int64, Int64}}(Statistics.mean!, 4×4×5 Field{Face, Face, Face} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=Nothing, top=Nothing, immersed=ZeroFlux; └── data: 6×6×7 OffsetArray(::Array{Float64, 3}, 0:5, 0:5, 0:6) with eltype Float64 with indices 0:5×0:5×0:6; └── max=0.0, min=0.0, mean=0.0, (1, 2)). julia> Average(field, dims=(1,3)); ERROR: UndefVarError: Ayᶠᶠᶠ not defined; Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:360 [inlined]; [3] eval; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/AbstractOperations.jl:1 [inlined]; [4] metric_function; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/grid_metrics.jl:139 [inlined]; [5] Oceananigans.AbstractOperations.GridMetricOperation(L::Tuple{DataType, DataType, DataType}, metric::Oceananigans.AbstractOperations.YAreaMetric, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia_bkp/packag",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2189
https://github.com/CliMA/Oceananigans.jl/issues/2189:4496,Availability,mask,mask,4496,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/grid_metrics.jl:159; [6] Reduction(avg::Average, field::Field{Face, Face, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}; condition::Nothing, mask::Int64, dims::Tuple{Int64, Int64}); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/metric_field_reductions.jl:38; [7] #Average#7; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/metric_field_reductions.jl:59 [inlined]; [8] top-level scope; @ REPL[26]:1; ```. And indeed, looking at `src/Operators/spacings_and_areas_and_volumes.jl`, I don't see `Ayᶠᶠᶠ` anywhere: https://github.com/CliMA/Oceananigans.jl/blob/e90b22bcfcf3cba53ed61e46024d3a759f35ef56/src/Operators/spacings_and_areas_and_volumes.jl#L93-L105",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2189
https://github.com/CliMA/Oceananigans.jl/issues/2189:403,Modifiability,variab,variably,403,"Apparently there are some averages that don't work when the grid is stretched:. ```julia; julia> grid = RectilinearGrid(size = (4, 4, 4), x = (0, 1), y=(0, 1), z=(k,) -> k); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> field = Field{Face, Face, Face}(grid); 4×4×5 Field{Face, Face, Face} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=Nothing, top=Nothing, immersed=ZeroFlux; └── data: 6×6×7 OffsetArray(::Array{Float64, 3}, 0:5, 0:5, 0:6) with eltype Float64 with indices 0:5×0:5×0:6; └── max=0.0, min=0.0, mean=0.0. julia> Average(field, dims=(1,2)); Reduction{typeof(Statistics.mean!), Field{Face, Face, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Int64, Int64}}(Statistics.mean!, 4×4×5 Field{Face, Face, Face} on RectilinearGri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2189
https://github.com/CliMA/Oceananigans.jl/issues/2191:996,Availability,error,error,996,"Using a variable grid spacing like the [Ocean wind mixing and convection example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/) in a direction other than `z` raises a `MethodError` when creating a `NonhydrostaticModel`. Modified from OWM&C:; ```; using Oceananigans; Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. # Normalized height ranging from 0 to 1; h(k) = (k - 1) / Nz. # Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. # Bottom-intensified stretching function; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). # Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, Nz, 32),; x = (0, 64),; y = z_faces,; z = ( 0, 64 )). model = NonhydrostaticModel( grid = grid ); ```. I get the following error if I try to use the above code or put the variable grid spacing in the x-direction; ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191
https://github.com/CliMA/Oceananigans.jl/issues/2191:1091,Availability,ERROR,ERROR,1091,"Using a variable grid spacing like the [Ocean wind mixing and convection example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/) in a direction other than `z` raises a `MethodError` when creating a `NonhydrostaticModel`. Modified from OWM&C:; ```; using Oceananigans; Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. # Normalized height ranging from 0 to 1; h(k) = (k - 1) / Nz. # Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. # Bottom-intensified stretching function; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). # Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, Nz, 32),; x = (0, 64),; y = z_faces,; z = ( 0, 64 )). model = NonhydrostaticModel( grid = grid ); ```. I get the following error if I try to use the above code or put the variable grid spacing in the x-direction; ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191
https://github.com/CliMA/Oceananigans.jl/issues/2191:8,Modifiability,variab,variable,8,"Using a variable grid spacing like the [Ocean wind mixing and convection example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/) in a direction other than `z` raises a `MethodError` when creating a `NonhydrostaticModel`. Modified from OWM&C:; ```; using Oceananigans; Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. # Normalized height ranging from 0 to 1; h(k) = (k - 1) / Nz. # Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. # Bottom-intensified stretching function; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). # Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, Nz, 32),; x = (0, 64),; y = z_faces,; z = ( 0, 64 )). model = NonhydrostaticModel( grid = grid ); ```. I get the following error if I try to use the above code or put the variable grid spacing in the x-direction; ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191
https://github.com/CliMA/Oceananigans.jl/issues/2191:1044,Modifiability,variab,variable,1044,"Using a variable grid spacing like the [Ocean wind mixing and convection example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/) in a direction other than `z` raises a `MethodError` when creating a `NonhydrostaticModel`. Modified from OWM&C:; ```; using Oceananigans; Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. # Normalized height ranging from 0 to 1; h(k) = (k - 1) / Nz. # Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. # Bottom-intensified stretching function; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). # Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, Nz, 32),; x = (0, 64),; y = z_faces,; z = ( 0, 64 )). model = NonhydrostaticModel( grid = grid ); ```. I get the following error if I try to use the above code or put the variable grid spacing in the x-direction; ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191
https://github.com/CliMA/Oceananigans.jl/issues/2192:407,Modifiability,variab,variably,407,"For example, the grid below is perfectly regularly spaced in all dimensions but Oceananigans doesn't ""see"" it that way... ```Julia; julia> grid = RectilinearGrid(size = (4, 4, 2), x = (0, 1), y=[0, 1//4, 2//4, 3//4, 1], z=[0, 0.5, 1]); 4×4×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) variably spaced with min(Δy)=0.25, max(Δy)=0.25; └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.5, max(Δz)=0.5; ```. (This may be also relevant in a solution/warning to be shown to the user regarding #2191.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192
https://github.com/CliMA/Oceananigans.jl/issues/2192:483,Modifiability,variab,variably,483,"For example, the grid below is perfectly regularly spaced in all dimensions but Oceananigans doesn't ""see"" it that way... ```Julia; julia> grid = RectilinearGrid(size = (4, 4, 2), x = (0, 1), y=[0, 1//4, 2//4, 3//4, 1], z=[0, 0.5, 1]); 4×4×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) variably spaced with min(Δy)=0.25, max(Δy)=0.25; └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.5, max(Δz)=0.5; ```. (This may be also relevant in a solution/warning to be shown to the user regarding #2191.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192
https://github.com/CliMA/Oceananigans.jl/pull/2193:181,Modifiability,flexible,flexible,181,"It seems like the behavior of `WindowedSpatialAverage` can now be achieved by using `Field(Average(field, dims=dims, condition=condition))`. It might be a bit slower, but it's more flexible, so I think we should get rid of `WindowedSpatialAverage`. Closes https://github.com/CliMA/Oceananigans.jl/issues/2185",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2193
https://github.com/CliMA/Oceananigans.jl/pull/2195:6,Deployability,update,updates,6,A few updates. Closes #2194.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2195
https://github.com/CliMA/Oceananigans.jl/pull/2196:77,Testability,test,test,77,"I thought I had fixed this previously but it looks like not. So I've added a test that `isnothing(model.free_surface)` when `grid isa SingleColumnGrid`. For the sake of a verbose explanation:. When `grid isa SingleColumnGrid`, the constructor-helper `FreeSurface` should return `nothing` rather than some other free surface object, like `ExplicitFreeSurface`, etc. THEN, when `isnothing(model.free_surface)`, the handy function `fields(model)` should _omit_ the free surface displacement `η` from the `NamedTuple` of model fields. A bug crept into the code because we didn't have a test during #2121 when some of the function signatures changed (because we don't need `arch` _and_ `grid` if `arch` is stored in `grid`). cc @navidcy ; cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2196
https://github.com/CliMA/Oceananigans.jl/pull/2196:582,Testability,test,test,582,"I thought I had fixed this previously but it looks like not. So I've added a test that `isnothing(model.free_surface)` when `grid isa SingleColumnGrid`. For the sake of a verbose explanation:. When `grid isa SingleColumnGrid`, the constructor-helper `FreeSurface` should return `nothing` rather than some other free surface object, like `ExplicitFreeSurface`, etc. THEN, when `isnothing(model.free_surface)`, the handy function `fields(model)` should _omit_ the free surface displacement `η` from the `NamedTuple` of model fields. A bug crept into the code because we didn't have a test during #2121 when some of the function signatures changed (because we don't need `arch` _and_ `grid` if `arch` is stored in `grid`). cc @navidcy ; cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2196
https://github.com/CliMA/Oceananigans.jl/pull/2200:174,Availability,mask,mask,174,"In case we have reductions on a function (e.g `maximum(abs, f, condition = (i, j, k, f.grid, f) -> i < 3)`) we want to be able to apply the function to the field _first_ and mask the field where `condition = true` _after_. _to be more specific:_; When a reduction is called with a function as an argument such as; ```; sum(sin, a::AbstractField); ```; the function will be evaluated element-wise with `mapreduce`. i.e., the function is applied _first_ and the reduction is applied _after_; ```; mapreduce(x -> sin(x), +, a); ```; For this reason the `neutral_element` of a ""functional"" reduction is not the `neutral_element` of its basic operation (as we implemented) but the neutral element of `basic_operation(f())`. The neutral element is found by inverting this operation `f⁻¹(neutral_element(basic_operation))` In the example above it would be; ```; neutral_element = sin⁻¹(neutral_element(+)) = sin⁻¹(0); ```. In principle, we should mask the field with `f⁻¹(neutral_element(reduction))` so that applying `f` and then the reduction would effectively exclude the masked areas. Unfortunately, we do not know a-priori the inverse of the function. Therefore, this PR implements a workaround:. - `ConditionalOperation` has now a property `func`, which is a unary function applied to the elements of `operand` in `Base.getindex`; - functional reductions are implemented as `sum(f, c; condition) = sum(identity, conditional_operand(f, c, condition))` . this PR also introduces a docstring and a `show` method for `ConditionalOperation` ; closes #2188",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200
https://github.com/CliMA/Oceananigans.jl/pull/2200:940,Availability,mask,mask,940,"In case we have reductions on a function (e.g `maximum(abs, f, condition = (i, j, k, f.grid, f) -> i < 3)`) we want to be able to apply the function to the field _first_ and mask the field where `condition = true` _after_. _to be more specific:_; When a reduction is called with a function as an argument such as; ```; sum(sin, a::AbstractField); ```; the function will be evaluated element-wise with `mapreduce`. i.e., the function is applied _first_ and the reduction is applied _after_; ```; mapreduce(x -> sin(x), +, a); ```; For this reason the `neutral_element` of a ""functional"" reduction is not the `neutral_element` of its basic operation (as we implemented) but the neutral element of `basic_operation(f())`. The neutral element is found by inverting this operation `f⁻¹(neutral_element(basic_operation))` In the example above it would be; ```; neutral_element = sin⁻¹(neutral_element(+)) = sin⁻¹(0); ```. In principle, we should mask the field with `f⁻¹(neutral_element(reduction))` so that applying `f` and then the reduction would effectively exclude the masked areas. Unfortunately, we do not know a-priori the inverse of the function. Therefore, this PR implements a workaround:. - `ConditionalOperation` has now a property `func`, which is a unary function applied to the elements of `operand` in `Base.getindex`; - functional reductions are implemented as `sum(f, c; condition) = sum(identity, conditional_operand(f, c, condition))` . this PR also introduces a docstring and a `show` method for `ConditionalOperation` ; closes #2188",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200
https://github.com/CliMA/Oceananigans.jl/pull/2200:1068,Availability,mask,masked,1068,"In case we have reductions on a function (e.g `maximum(abs, f, condition = (i, j, k, f.grid, f) -> i < 3)`) we want to be able to apply the function to the field _first_ and mask the field where `condition = true` _after_. _to be more specific:_; When a reduction is called with a function as an argument such as; ```; sum(sin, a::AbstractField); ```; the function will be evaluated element-wise with `mapreduce`. i.e., the function is applied _first_ and the reduction is applied _after_; ```; mapreduce(x -> sin(x), +, a); ```; For this reason the `neutral_element` of a ""functional"" reduction is not the `neutral_element` of its basic operation (as we implemented) but the neutral element of `basic_operation(f())`. The neutral element is found by inverting this operation `f⁻¹(neutral_element(basic_operation))` In the example above it would be; ```; neutral_element = sin⁻¹(neutral_element(+)) = sin⁻¹(0); ```. In principle, we should mask the field with `f⁻¹(neutral_element(reduction))` so that applying `f` and then the reduction would effectively exclude the masked areas. Unfortunately, we do not know a-priori the inverse of the function. Therefore, this PR implements a workaround:. - `ConditionalOperation` has now a property `func`, which is a unary function applied to the elements of `operand` in `Base.getindex`; - functional reductions are implemented as `sum(f, c; condition) = sum(identity, conditional_operand(f, c, condition))` . this PR also introduces a docstring and a `show` method for `ConditionalOperation` ; closes #2188",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200
https://github.com/CliMA/Oceananigans.jl/pull/2201:42,Testability,test,test-,42,Quick fixes as I recklessly merged a _non-test-passing_ PR,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2201
https://github.com/CliMA/Oceananigans.jl/issues/2202:1657,Deployability,configurat,configuration,1657,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202
https://github.com/CliMA/Oceananigans.jl/issues/2202:1657,Modifiability,config,configuration,1657,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202
https://github.com/CliMA/Oceananigans.jl/issues/2202:1574,Performance,load,loaded,1574,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202
https://github.com/CliMA/Oceananigans.jl/issues/2202:128,Safety,avoid,avoid,128,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202
https://github.com/CliMA/Oceananigans.jl/issues/2202:1554,Testability,benchmark,benchmark,1554,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202
https://github.com/CliMA/Oceananigans.jl/issues/2209:158,Availability,down,down,158,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209
https://github.com/CliMA/Oceananigans.jl/issues/2209:142,Energy Efficiency,adapt,adapted,142,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209
https://github.com/CliMA/Oceananigans.jl/issues/2209:267,Energy Efficiency,sustainab,sustainable,267,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209
https://github.com/CliMA/Oceananigans.jl/issues/2209:142,Modifiability,adapt,adapted,142,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209
https://github.com/CliMA/Oceananigans.jl/issues/2209:301,Modifiability,refactor,refactoring,301,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209
https://github.com/CliMA/Oceananigans.jl/issues/2210:79,Availability,error,error,79,"Column Hydrostatic models don't have a free surface and, therefore, produce an error here:; https://github.com/CliMA/Oceananigans.jl/blob/ce461f90e991a85105962e165ca4ceab15b1159a/src/Models/HydrostaticFreeSurfaceModels/show_hydrostatic_free_surface_model.jl#L13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2210
https://github.com/CliMA/Oceananigans.jl/pull/2212:24,Safety,avoid,avoid,24,This is a workaround to avoid printing `solver: Default` and instead print `solver: FFTImplicitFreeSurfaceSolver`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2212
https://github.com/CliMA/Oceananigans.jl/pull/2213:1112,Testability,test,test,1112,"The clause that controls the definition of `cell_diffusion_timescale` in `TimeStepWizard` had a bug. I re-wrote in a way that's clearer to understand and that fixes the bug. Consider the MWE below:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8, 8, 8), extent = (1,1,1),; topology=(Periodic, Periodic, Bounded)). closure = IsotropicDiffusivity(ν=1); model = NonhydrostaticModel(grid = grid,; closure = closure); @info """" model; ; wizard = TimeStepWizard(diffusive_cfl=0.1,); ```. Before this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); Inf. julia> @which wizard.cell_diffusion_timescale(model); infinite_diffusion_timescale(args...) in Oceananigans.Simulations at /home/tomas/.julia/packages/Oceananigans/IHPoE/src/Simulations/time_step_wizard.jl:12; ```. After this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); 0.015625. julia> @which wizard.cell_diffusion_timescale(model); cell_diffusion_timescale(model) in Oceananigans.TurbulenceClosures at /home/tomas/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:15; ```. I'll also add a test to catch this in the future, since there are no tests for `diffusive_cfl` that I could tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213
https://github.com/CliMA/Oceananigans.jl/pull/2213:1165,Testability,test,tests,1165,"The clause that controls the definition of `cell_diffusion_timescale` in `TimeStepWizard` had a bug. I re-wrote in a way that's clearer to understand and that fixes the bug. Consider the MWE below:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8, 8, 8), extent = (1,1,1),; topology=(Periodic, Periodic, Bounded)). closure = IsotropicDiffusivity(ν=1); model = NonhydrostaticModel(grid = grid,; closure = closure); @info """" model; ; wizard = TimeStepWizard(diffusive_cfl=0.1,); ```. Before this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); Inf. julia> @which wizard.cell_diffusion_timescale(model); infinite_diffusion_timescale(args...) in Oceananigans.Simulations at /home/tomas/.julia/packages/Oceananigans/IHPoE/src/Simulations/time_step_wizard.jl:12; ```. After this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); 0.015625. julia> @which wizard.cell_diffusion_timescale(model); cell_diffusion_timescale(model) in Oceananigans.TurbulenceClosures at /home/tomas/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:15; ```. I'll also add a test to catch this in the future, since there are no tests for `diffusive_cfl` that I could tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213
https://github.com/CliMA/Oceananigans.jl/pull/2213:128,Usability,clear,clearer,128,"The clause that controls the definition of `cell_diffusion_timescale` in `TimeStepWizard` had a bug. I re-wrote in a way that's clearer to understand and that fixes the bug. Consider the MWE below:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8, 8, 8), extent = (1,1,1),; topology=(Periodic, Periodic, Bounded)). closure = IsotropicDiffusivity(ν=1); model = NonhydrostaticModel(grid = grid,; closure = closure); @info """" model; ; wizard = TimeStepWizard(diffusive_cfl=0.1,); ```. Before this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); Inf. julia> @which wizard.cell_diffusion_timescale(model); infinite_diffusion_timescale(args...) in Oceananigans.Simulations at /home/tomas/.julia/packages/Oceananigans/IHPoE/src/Simulations/time_step_wizard.jl:12; ```. After this PR:. ```julia; julia> wizard.cell_diffusion_timescale(model); 0.015625. julia> @which wizard.cell_diffusion_timescale(model); cell_diffusion_timescale(model) in Oceananigans.TurbulenceClosures at /home/tomas/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:15; ```. I'll also add a test to catch this in the future, since there are no tests for `diffusive_cfl` that I could tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2213
https://github.com/CliMA/Oceananigans.jl/pull/2214:1206,Availability,redundant,redundant,1206,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214
https://github.com/CliMA/Oceananigans.jl/pull/2214:769,Energy Efficiency,reduce,reduced,769,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214
https://github.com/CliMA/Oceananigans.jl/pull/2214:126,Integrability,depend,depend,126,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214
https://github.com/CliMA/Oceananigans.jl/pull/2214:1206,Safety,redund,redundant,1206,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214
https://github.com/CliMA/Oceananigans.jl/pull/2215:133,Modifiability,parameteriz,parameterizations,133,This is a wilderness of the code with not many tests. This is part of ongoing work to build infrastructure for calibrating mesoscale parameterizations in conjunction with `OceanTurbulenceParameterEstimation.jl`. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2215
https://github.com/CliMA/Oceananigans.jl/pull/2215:47,Testability,test,tests,47,This is a wilderness of the code with not many tests. This is part of ongoing work to build infrastructure for calibrating mesoscale parameterizations in conjunction with `OceanTurbulenceParameterEstimation.jl`. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2215
https://github.com/CliMA/Oceananigans.jl/issues/2216:613,Integrability,interface,interface,613,"Over in `OceanTurbulenceParameterEstimation` we've developed a utility called `FieldTimeSeriesCollector` that can be used in a callback to ""collect"" field data on the fly while a simulation is running. This is useful for idealized problems and quick experimentation where saving data to disk is unnecessary:. https://github.com/CliMA/OceanTurbulenceParameterEstimation.jl/blob/a05d1d8959ef40f0f3e7873b32caf4271f102592/src/Observations.jl#L257-L308. It'd probably be nice to move this feature into `Oceananigans` proper at some point so it's more visible and more people can benefit. And we can tweak the design / interface too. Because ""field_time_serieses"" (a `NamedTuple` collection of `FieldTimeSeries`) doesn't quite roll off the tongue. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2216
https://github.com/CliMA/Oceananigans.jl/issues/2217:128,Energy Efficiency,schedul,schedule,128,"`NetCDFOutputWriter` and `JLD2OutputWriter` currently have different options. ```; NetCDFOutputWriter(model, outputs; filepath, schedule; array_type = Array{Float32},; field_slicer = FieldSlicer(),; global_attributes = Dict(),; output_attributes = Dict(),; dimensions = Dict(),; mode = nothing,; compression = 0,; verbose = false); ```. ```; JLD2OutputWriter(model, outputs; prefix, schedule,; dir = ""."",; field_slicer = FieldSlicer(),; array_type = Array{Float32},; max_filesize = Inf,; force = false,; init = noinit,; including = [:grid, :coriolis, :buoyancy, :closure],; verbose = false,; part = 1,; jld2_kw = Dict{Symbol, Any}()); ```. Some arguments are unique to each writer, but I think it would make things easier and more usable if we unified some of the arguments that really do the same thing. Specifically `filepath` could replace `dir` and `prefix`, and `mode` could replace`force`. I understand that the NetCDF and JLD2 libraries work differently when writing to disk (probably that's where the difference come from) but maybe we can do some translation behind the scenes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2217
https://github.com/CliMA/Oceananigans.jl/issues/2217:383,Energy Efficiency,schedul,schedule,383,"`NetCDFOutputWriter` and `JLD2OutputWriter` currently have different options. ```; NetCDFOutputWriter(model, outputs; filepath, schedule; array_type = Array{Float32},; field_slicer = FieldSlicer(),; global_attributes = Dict(),; output_attributes = Dict(),; dimensions = Dict(),; mode = nothing,; compression = 0,; verbose = false); ```. ```; JLD2OutputWriter(model, outputs; prefix, schedule,; dir = ""."",; field_slicer = FieldSlicer(),; array_type = Array{Float32},; max_filesize = Inf,; force = false,; init = noinit,; including = [:grid, :coriolis, :buoyancy, :closure],; verbose = false,; part = 1,; jld2_kw = Dict{Symbol, Any}()); ```. Some arguments are unique to each writer, but I think it would make things easier and more usable if we unified some of the arguments that really do the same thing. Specifically `filepath` could replace `dir` and `prefix`, and `mode` could replace`force`. I understand that the NetCDF and JLD2 libraries work differently when writing to disk (probably that's where the difference come from) but maybe we can do some translation behind the scenes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2217
https://github.com/CliMA/Oceananigans.jl/issues/2217:731,Usability,usab,usable,731,"`NetCDFOutputWriter` and `JLD2OutputWriter` currently have different options. ```; NetCDFOutputWriter(model, outputs; filepath, schedule; array_type = Array{Float32},; field_slicer = FieldSlicer(),; global_attributes = Dict(),; output_attributes = Dict(),; dimensions = Dict(),; mode = nothing,; compression = 0,; verbose = false); ```. ```; JLD2OutputWriter(model, outputs; prefix, schedule,; dir = ""."",; field_slicer = FieldSlicer(),; array_type = Array{Float32},; max_filesize = Inf,; force = false,; init = noinit,; including = [:grid, :coriolis, :buoyancy, :closure],; verbose = false,; part = 1,; jld2_kw = Dict{Symbol, Any}()); ```. Some arguments are unique to each writer, but I think it would make things easier and more usable if we unified some of the arguments that really do the same thing. Specifically `filepath` could replace `dir` and `prefix`, and `mode` could replace`force`. I understand that the NetCDF and JLD2 libraries work differently when writing to disk (probably that's where the difference come from) but maybe we can do some translation behind the scenes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2217
https://github.com/CliMA/Oceananigans.jl/issues/2219:14,Testability,test,tests,14,"There are few tests for this functionality, but it's crucial for `OceanTurbulenceParameterEstimation.jl`. We should add more tests (especially for slice ensemble models which I think have zero tests now). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2219
https://github.com/CliMA/Oceananigans.jl/issues/2219:125,Testability,test,tests,125,"There are few tests for this functionality, but it's crucial for `OceanTurbulenceParameterEstimation.jl`. We should add more tests (especially for slice ensemble models which I think have zero tests now). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2219
https://github.com/CliMA/Oceananigans.jl/issues/2219:193,Testability,test,tests,193,"There are few tests for this functionality, but it's crucial for `OceanTurbulenceParameterEstimation.jl`. We should add more tests (especially for slice ensemble models which I think have zero tests now). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2219
https://github.com/CliMA/Oceananigans.jl/pull/2220:22,Modifiability,extend,extend,22,"The signature used to extend `FFTImplicitFreeSurfaceSolver` was not used by `build_implicit_free_surface_solver`; thus, slice ensemble models had incorrect free surface solvers. This PR fixes it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2220
https://github.com/CliMA/Oceananigans.jl/issues/2222:71,Availability,error,error,71,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2222:135,Availability,ERROR,ERROR,135,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2222:334,Availability,error,error,334,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2222:63,Performance,load,loading,63,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2222:142,Performance,Load,LoadError,142,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2222:153,Performance,Load,LoadError,153,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2222:27,Testability,test,tests,27,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2222:318,Testability,test,test,318,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2222:323,Usability,clear,clears,323,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222
https://github.com/CliMA/Oceananigans.jl/issues/2223:45,Availability,ERROR,ERROR,45,"```Julia; [ Info: Running the simulation...; ERROR: LoadError: KeyError: key ""timestepper/Gⁿ/w"" not found; Stacktrace:; [1] pathize(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String, create::Bool); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/groups.jl:70; [2] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/groups.jl:95; [3] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/JLD2.jl:379; [4] set_time_stepper_tendencies!(timestepper::Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223
https://github.com/CliMA/Oceananigans.jl/issues/2223:14629,Availability,checkpoint,checkpointer,14629,"{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}); @ Oceananigans.OutputWriters /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:246; [5] set_time_stepper!(timestepper::Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223
https://github.com/CliMA/Oceananigans.jl/issues/2223:28725,Availability,checkpoint,checkpointer,28725,"{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}); @ Oceananigans.OutputWriters /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:265; [6] (::Oceananigans.OutputWriters.var""#52#53""{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223
https://github.com/CliMA/Oceananigans.jl/issues/2223:54494,Availability,checkpoint,checkpointer,54494,"ion{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String})(file::JLD2.JLDFile{JLD2.MmapIO}); @ Oceananigans.OutputWriters /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:227; [7] jldopen(::Oceananigans.OutputWriters.var""#52#53""{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223
https://github.com/CliMA/Oceananigans.jl/issues/2223:80500,Availability,checkpoint,checkpointer,80500,"cePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:4; [8] jldopen; @ /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:2 [inlined]; [9] set!; @ /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:199 [inlined]; [10] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223
https://github.com/CliMA/Oceananigans.jl/issues/2223:52,Performance,Load,LoadError,52,"```Julia; [ Info: Running the simulation...; ERROR: LoadError: KeyError: key ""timestepper/Gⁿ/w"" not found; Stacktrace:; [1] pathize(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String, create::Bool); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/groups.jl:70; [2] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/groups.jl:95; [3] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/JLD2.jl:379; [4] set_time_stepper_tendencies!(timestepper::Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223
https://github.com/CliMA/Oceananigans.jl/issues/2223:80311,Performance,load,loadsave,80311," StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:4; [8] jldopen; @ /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:2 [inlined]; [9] set!; @ /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:199 [inlined]; [10] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223
https://github.com/CliMA/Oceananigans.jl/issues/2223:80391,Performance,load,loadsave,80391,"}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:4; [8] jldopen; @ /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:2 [inlined]; [9] set!; @ /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:199 [inlined]; [10] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundary",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223
https://github.com/CliMA/Oceananigans.jl/pull/2224:23,Testability,test,tests,23,Let's be real; we need tests. Closes #2223 maybe,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2224
https://github.com/CliMA/Oceananigans.jl/issues/2226:43,Availability,checkpoint,checkpoint,43,"There is some issue when we pick up from a checkpoint and we start with an `AveragedTimeInterval`. If we, e.g., start with `AveragedTimeInterval(Xdays)` but the pick up time was not a multiple of `Xdays` then the first average does not carry on for the correct time interval. There may be more issues related to this. I just noticed this and thought I put it out there. [found with @glwagner]",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2226
https://github.com/CliMA/Oceananigans.jl/issues/2229:139,Integrability,message,message,139,CATKE closure doesn't work with `NonHydrostaticModel`.; Users who try to add that closure in `NonHydrostaticModel` should be warned with a message.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2229
https://github.com/CliMA/Oceananigans.jl/issues/2234:302,Availability,error,error,302,Right now we just call `findfirst`:. https://github.com/CliMA/Oceananigans.jl/blob/b7871d3fc8b53e8bfecb5395e80287ac9c12d0da/src/OutputReaders/field_time_series.jl#L174. which will return `nothing` index if it doesn't find a time in the file that's approximately equal to the requested one. Then we can error because you can't index with `nothing`. It'd be nice to throw a helpful error instead of letting `getindex` error. This error might also help users debug because we could display the times that are nearby to the requested one.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2234
https://github.com/CliMA/Oceananigans.jl/issues/2234:380,Availability,error,error,380,Right now we just call `findfirst`:. https://github.com/CliMA/Oceananigans.jl/blob/b7871d3fc8b53e8bfecb5395e80287ac9c12d0da/src/OutputReaders/field_time_series.jl#L174. which will return `nothing` index if it doesn't find a time in the file that's approximately equal to the requested one. Then we can error because you can't index with `nothing`. It'd be nice to throw a helpful error instead of letting `getindex` error. This error might also help users debug because we could display the times that are nearby to the requested one.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2234
https://github.com/CliMA/Oceananigans.jl/issues/2234:416,Availability,error,error,416,Right now we just call `findfirst`:. https://github.com/CliMA/Oceananigans.jl/blob/b7871d3fc8b53e8bfecb5395e80287ac9c12d0da/src/OutputReaders/field_time_series.jl#L174. which will return `nothing` index if it doesn't find a time in the file that's approximately equal to the requested one. Then we can error because you can't index with `nothing`. It'd be nice to throw a helpful error instead of letting `getindex` error. This error might also help users debug because we could display the times that are nearby to the requested one.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2234
https://github.com/CliMA/Oceananigans.jl/issues/2234:428,Availability,error,error,428,Right now we just call `findfirst`:. https://github.com/CliMA/Oceananigans.jl/blob/b7871d3fc8b53e8bfecb5395e80287ac9c12d0da/src/OutputReaders/field_time_series.jl#L174. which will return `nothing` index if it doesn't find a time in the file that's approximately equal to the requested one. Then we can error because you can't index with `nothing`. It'd be nice to throw a helpful error instead of letting `getindex` error. This error might also help users debug because we could display the times that are nearby to the requested one.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2234
https://github.com/CliMA/Oceananigans.jl/pull/2235:180,Testability,test,test,180,"Might be useful at the REPL for interactive stuff cause you can write. ```julia; julia> N² = compute!(α * ∂z(T) - β * ∂z(S)); ```. for example. If people like, I'll add docs and a test or two. I guess the equivalent one-liner right now is. ```julia; julia> N² = @compute Field(α * ∂z(T) - β * ∂z(S)); ```. and the equivalent two-liner is. ```julia; julia> N² = Field(α * ∂z(T) - β * ∂z(S)); julia> compute!(N²); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235
https://github.com/CliMA/Oceananigans.jl/issues/2236:40,Usability,simpl,simplify,40,"Now that most operators are 3D we could simplify the nomenclature for the difference and interpolation operators by getting rid of the `ᵃ`, no? I think it would make code more legible. For example something like this (from [Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/da1d9174480df4bacd05b0e050fa9f25f51ab337/src/TKEBudgetTerms.jl#L29-L33)). ```julia; @inline function turbulent_kinetic_energy_ccc(i, j, k, grid, u, v, w, U, V, W); return (ℑxᶜᵃᵃ(i, j, k, grid, ψ′², u, U) +; ℑyᵃᶜᵃ(i, j, k, grid, ψ′², v, V) +; ℑzᵃᵃᶜ(i, j, k, grid, ψ′², w, W)) / 2; end; ```. could become this, which I think is way easier on the eyes:. ```julia; @inline function turbulent_kinetic_energy_ccc(i, j, k, grid, u, v, w, U, V, W); return (ℑxᶜ(i, j, k, grid, ψ′², u, U) +; ℑyᶜ(i, j, k, grid, ψ′², v, V) +; ℑzᶜ(i, j, k, grid, ψ′², w, W)) / 2; end; ```. Double interpolators could go from `ℑxyᶠᶜᵃ` to `ℑxyᶠᶜ` or `ℑxᶠyᶜ`. Thoughts?. This was originally suggested by @simone-silvestri in #2214",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2236
https://github.com/CliMA/Oceananigans.jl/pull/2238:21,Deployability,update,update,21,This is a very minor update just to make the plotting command in the Ocean mixing and convection example a bit more general and self-contained. This makes it easier for people to copy-paste that snippet and have it work out of box (I do that frequently for example).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238
https://github.com/CliMA/Oceananigans.jl/issues/2239:356,Integrability,interface,interface,356,"@simone-silvestri brainstormed today about ways to clean up `TurbulenceClosures`. One idea that came up is to combine `IsotropicDiffusivity` and `HorizontallyCurvilinearAnisotropicDiffusivity` into a single `ScalarDiffusivity` (where isotropy in various directions is _implied_). We'll also simplify the ""anisotropic"" diffusivity in this process. The user interface could look something like. ```julia; three_dimensional_diffusivity = ScalarDiffusivity(ThreeDimensional(), ν=1); horizontal_diffusivity = ScalarDiffusivity(Horizontal(), ν=1); vertical_diffusivity = ScalarDiffusivity(Vertical(), ν=1); ```. so, no more `νh` and `νz`. The advantage is that we eliminate / share much more code. Arguably the API is a bit cleaner as well. (We can discuss aliases and defaults like `HorizontalScalarDiffusivity`, etc.). Under the hood we'll add the `Directionality` type to the type parameters of `ScalarDiffusivity`:. ```julia; struct ScalarDiffusivity{TimeDisc, Nu, Kappa, Directionality} <: AbstractScalarDiffusivity{TimeDisc, Dir}; ν :: Nu; κ :: Kappa. function IsotropicDiffusivity{TimeDisc}(dir::Dir, ν::Nu, κ::Ka) where {TimeDisc, Dir, Nu, Ka}; return new{TimeDisc, Nu, Ka, Dir}(ν, κ); end; end; ```. Then `abstract_isotropic_diffusivity.jl` becomes `abstract_scalar_diffusivity.jl`, and will implement the necessary abstractions for 3D isotropic scalar diffusivities, horizontally-isotropic diffusivities (a la MITgcm), and vertical diffusivities. . Consolidating code is an important precursor to a larger refactor that might. 1) support `AbstractOperation` viscosities and diffusivities at all locations on the grid; 2) eliminate `diffusivity_fields` and; 3) perhaps also involve fixing `TwoDimLeith` and implementing a biharmonic Leith.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239
https://github.com/CliMA/Oceananigans.jl/issues/2239:1510,Modifiability,refactor,refactor,1510,"@simone-silvestri brainstormed today about ways to clean up `TurbulenceClosures`. One idea that came up is to combine `IsotropicDiffusivity` and `HorizontallyCurvilinearAnisotropicDiffusivity` into a single `ScalarDiffusivity` (where isotropy in various directions is _implied_). We'll also simplify the ""anisotropic"" diffusivity in this process. The user interface could look something like. ```julia; three_dimensional_diffusivity = ScalarDiffusivity(ThreeDimensional(), ν=1); horizontal_diffusivity = ScalarDiffusivity(Horizontal(), ν=1); vertical_diffusivity = ScalarDiffusivity(Vertical(), ν=1); ```. so, no more `νh` and `νz`. The advantage is that we eliminate / share much more code. Arguably the API is a bit cleaner as well. (We can discuss aliases and defaults like `HorizontalScalarDiffusivity`, etc.). Under the hood we'll add the `Directionality` type to the type parameters of `ScalarDiffusivity`:. ```julia; struct ScalarDiffusivity{TimeDisc, Nu, Kappa, Directionality} <: AbstractScalarDiffusivity{TimeDisc, Dir}; ν :: Nu; κ :: Kappa. function IsotropicDiffusivity{TimeDisc}(dir::Dir, ν::Nu, κ::Ka) where {TimeDisc, Dir, Nu, Ka}; return new{TimeDisc, Nu, Ka, Dir}(ν, κ); end; end; ```. Then `abstract_isotropic_diffusivity.jl` becomes `abstract_scalar_diffusivity.jl`, and will implement the necessary abstractions for 3D isotropic scalar diffusivities, horizontally-isotropic diffusivities (a la MITgcm), and vertical diffusivities. . Consolidating code is an important precursor to a larger refactor that might. 1) support `AbstractOperation` viscosities and diffusivities at all locations on the grid; 2) eliminate `diffusivity_fields` and; 3) perhaps also involve fixing `TwoDimLeith` and implementing a biharmonic Leith.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239
https://github.com/CliMA/Oceananigans.jl/issues/2239:291,Usability,simpl,simplify,291,"@simone-silvestri brainstormed today about ways to clean up `TurbulenceClosures`. One idea that came up is to combine `IsotropicDiffusivity` and `HorizontallyCurvilinearAnisotropicDiffusivity` into a single `ScalarDiffusivity` (where isotropy in various directions is _implied_). We'll also simplify the ""anisotropic"" diffusivity in this process. The user interface could look something like. ```julia; three_dimensional_diffusivity = ScalarDiffusivity(ThreeDimensional(), ν=1); horizontal_diffusivity = ScalarDiffusivity(Horizontal(), ν=1); vertical_diffusivity = ScalarDiffusivity(Vertical(), ν=1); ```. so, no more `νh` and `νz`. The advantage is that we eliminate / share much more code. Arguably the API is a bit cleaner as well. (We can discuss aliases and defaults like `HorizontalScalarDiffusivity`, etc.). Under the hood we'll add the `Directionality` type to the type parameters of `ScalarDiffusivity`:. ```julia; struct ScalarDiffusivity{TimeDisc, Nu, Kappa, Directionality} <: AbstractScalarDiffusivity{TimeDisc, Dir}; ν :: Nu; κ :: Kappa. function IsotropicDiffusivity{TimeDisc}(dir::Dir, ν::Nu, κ::Ka) where {TimeDisc, Dir, Nu, Ka}; return new{TimeDisc, Nu, Ka, Dir}(ν, κ); end; end; ```. Then `abstract_isotropic_diffusivity.jl` becomes `abstract_scalar_diffusivity.jl`, and will implement the necessary abstractions for 3D isotropic scalar diffusivities, horizontally-isotropic diffusivities (a la MITgcm), and vertical diffusivities. . Consolidating code is an important precursor to a larger refactor that might. 1) support `AbstractOperation` viscosities and diffusivities at all locations on the grid; 2) eliminate `diffusivity_fields` and; 3) perhaps also involve fixing `TwoDimLeith` and implementing a biharmonic Leith.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239
https://github.com/CliMA/Oceananigans.jl/issues/2240:44,Performance,load,load,44,Related to #2179. If we don't then we can't load on CPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2240
https://github.com/CliMA/Oceananigans.jl/issues/2242:560,Availability,down,downside,560,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242
https://github.com/CliMA/Oceananigans.jl/issues/2242:436,Energy Efficiency,reduce,reduce,436,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242
https://github.com/CliMA/Oceananigans.jl/issues/2242:220,Integrability,wrap,wrapped,220,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242
https://github.com/CliMA/Oceananigans.jl/issues/2242:602,Security,expose,exposed,602,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242
https://github.com/CliMA/Oceananigans.jl/pull/2243:107,Deployability,deploy,deploying,107,The docs repo is running out of space. In an attempt to remedy that I'm trying here `forcepush = true` for deploying docs. https://juliadocs.github.io/Documenter.jl/stable/lib/public/#Documenter.deploydocs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2243
https://github.com/CliMA/Oceananigans.jl/pull/2243:195,Deployability,deploy,deploydocs,195,The docs repo is running out of space. In an attempt to remedy that I'm trying here `forcepush = true` for deploying docs. https://juliadocs.github.io/Documenter.jl/stable/lib/public/#Documenter.deploydocs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2243
https://github.com/CliMA/Oceananigans.jl/issues/2244:487,Performance,concurren,concurrent,487,"We currently calculate the barotropic mode inside the AB2 step:. https://github.com/CliMA/Oceananigans.jl/blob/e27988039e65e9244a84d241b70c2dcdeac93309/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L18-L22. I'm wondering if it makes more sense to calculate this inside `update_state!`. Our algorithm calculates `update_state!` at the _end_ of a time-step, which means that after calling `time_step!(model)` the model auxiliary and prognostic state are all concurrent, which is useful for output. cc @sandreza @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2244
https://github.com/CliMA/Oceananigans.jl/pull/2246:697,Energy Efficiency,reduce,reduced,697,"This PR adds a new property `indices` to `Field`. By default `indices = (:, :, :)`. Using `UnitRange` for a dimension's indices will ""window"" a field in that direction. This permits diagnostics to be ""windowed"" for selected indices; for example a surface field might be computed with `indices = (:, :, grid.Nz:grid.Nz)`. Another important feature is the extension of `FieldTimeSeries` to ""sliced"" fields. This means we can save just the surface velocity fields (rather than the 3D velocity fields), and in post-processing compute the surface vorticity. This PR is still very much WIP, but hopefully will be fully featured by the time it's merged, and we'll convert free surface displacements from reduced fields to windowed fields. Closes #2177; Closes #1080; Closes #1647",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2246
https://github.com/CliMA/Oceananigans.jl/pull/2247:1301,Integrability,depend,depend,1301,"Refractors the `IsotropicDiffusivity`, `AnisotropicDiffusivity` and `HorizontallyCurvilinearAnisotropicDiffusivity` so that only one `ScalarDiffusivity` is defined. with this PR, the following API changes are implemented; - `closure = IsotropicDiffusivity(ν = 1, κ = 1) -> closure = ScalarDiffusivity(ν = 1, κ = 1, direction=ThreeDimensional()) (default)`; - `closure = HorizontallyCurvilinearAnistropicDiffusivity(νh = 2, κh = 2, νh = 1, κh = 1) -> ; horizontal_closure = ScalarDiffusivity(ν = 2, κ = 2, direction=Horizontal()); ; vertical_closure = ScalarDiffusivity(ν = 1, κ = 1, direction=Vertical())`. For biharmonic diffusivity; - Bug fixes in `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` which is kept as the standard method for biharmonic diffusivity and renamed `ScalarBiharmonicDiffusivity` so now; `closure =HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity(ν = 1, κ = 1) -> closure = ScalarBiharmonicDiffusivity(ν = 1, κ = 1, direction=Horizontal()) (default)`; - Also for biharmonic we have a `ThreeDimensional`, `Horizontal` and `Vertical` mode; - Nuking of `AnisotropicBiharmonicDiffusivity`. Additionally; - Implementation of a `discrete` mode for viscosity and diffusivity functions (with `discrete_diffusivity = true`) to be able to have viscosity and diffusivity depend on grid metrics so that we can have; ```; using Oceananigans.Operators: Δx. νh(lx, ly, lz, i, j, k, grid, clock) = Δx(i, j, k, grid, lx, ly, lz)^4 / (3600*24); closure = ScalarDiffusivity(ν = νh, discrete_diffusivity = true); ```; - Implementation of `solid_node` and `solid_interface` for Bounded grids. Used in `Biharmonic` operators to enforce zero flux and zero laplacian boundary conditions. closes #2239; closes #2113",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247
https://github.com/CliMA/Oceananigans.jl/issues/2249:194,Availability,mask,masking,194,"Is this correct?. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/ImmersedBoundaries/mask_immersed_field.jl#L53. I'd expect it to use `solid_node` for masking scalars. Right?. For masking velocity fields for the purpose of enforcing impenetrable boundary conditions, it makes sense to me that we'd use `solid_interface`. But we should have a separate function for that. In reality, we only _need_ masking for the velocity field for our algorithm to work correctly. However, being able to mask scalars is sometimes useful for development purposes. @simone-silvestri can you shed some light?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249
https://github.com/CliMA/Oceananigans.jl/issues/2249:223,Availability,mask,masking,223,"Is this correct?. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/ImmersedBoundaries/mask_immersed_field.jl#L53. I'd expect it to use `solid_node` for masking scalars. Right?. For masking velocity fields for the purpose of enforcing impenetrable boundary conditions, it makes sense to me that we'd use `solid_interface`. But we should have a separate function for that. In reality, we only _need_ masking for the velocity field for our algorithm to work correctly. However, being able to mask scalars is sometimes useful for development purposes. @simone-silvestri can you shed some light?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249
https://github.com/CliMA/Oceananigans.jl/issues/2249:440,Availability,mask,masking,440,"Is this correct?. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/ImmersedBoundaries/mask_immersed_field.jl#L53. I'd expect it to use `solid_node` for masking scalars. Right?. For masking velocity fields for the purpose of enforcing impenetrable boundary conditions, it makes sense to me that we'd use `solid_interface`. But we should have a separate function for that. In reality, we only _need_ masking for the velocity field for our algorithm to work correctly. However, being able to mask scalars is sometimes useful for development purposes. @simone-silvestri can you shed some light?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249
https://github.com/CliMA/Oceananigans.jl/issues/2249:531,Availability,mask,mask,531,"Is this correct?. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/ImmersedBoundaries/mask_immersed_field.jl#L53. I'd expect it to use `solid_node` for masking scalars. Right?. For masking velocity fields for the purpose of enforcing impenetrable boundary conditions, it makes sense to me that we'd use `solid_interface`. But we should have a separate function for that. In reality, we only _need_ masking for the velocity field for our algorithm to work correctly. However, being able to mask scalars is sometimes useful for development purposes. @simone-silvestri can you shed some light?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249
https://github.com/CliMA/Oceananigans.jl/issues/2250:87,Availability,error,error,87,"Previously, I believe I was defining fields on immersed grids. When I try now I get an error. Am I doing something silly or has something changed?. ```; julia> using Oceananigans. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> h0, L = 0.5, 0.25; (0.5, 0.25). julia> grid = RectilinearGrid(size=(16, 8), y=(-1, 1), z=(-1, 0),; topology=(Flat, Periodic, Bounded), halo=(3,3)); 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> seamount2(x, y, z) = z < - 1 + h0*exp(-y^2/L^2); seamount2 (generic function with 1 method). julia> grid_with_seamount2 = ImmersedBoundaryGrid(grid, GridFittedBottom(seamount2)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Software/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; with immersed: GridFittedBottom{typeof(seamount2)}. julia> c2 = CenterField(grid_with_seamount2); Error showing value of type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Arra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250
https://github.com/CliMA/Oceananigans.jl/issues/2250:1382,Availability,Error,Error,1382,"unded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> seamount2(x, y, z) = z < - 1 + h0*exp(-y^2/L^2); seamount2 (generic function with 1 method). julia> grid_with_seamount2 = ImmersedBoundaryGrid(grid, GridFittedBottom(seamount2)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Software/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; with immersed: GridFittedBottom{typeof(seamount2)}. julia> c2 = CenterField(grid_with_seamount2); Error showing value of type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}:; ERROR: MethodError: no method matching seamount2(::Float64, ::F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250
https://github.com/CliMA/Oceananigans.jl/issues/2250:2409,Availability,ERROR,ERROR,2409,"type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}:; ERROR: MethodError: no method matching seamount2(::Float64, ::Float64); Closest candidates are:; seamount2(::Any, ::Any, ::Any) at REPL[6]:1; Stacktrace:; [1] is_immersed; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:38 [inlined]; [2] solid_node; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/immersed_grid_metrics.jl:35 [inlined]; [3] solid_interface; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/immersed_grid_metrics.jl:38 [inlined]; [4] get_condition; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/immersed_fields_reductions.jl:28 [inlined]; [5] getindex; @ ~/Software/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:109 [inlined]; [6] getindex; @ ./subarray.jl:276 [inlined]; [7] _getindex; @ ./abstractarray.jl:1214 [inlined]; [8] getindex; @ ./abstractarray.jl:1170 [inlined]; [9] map!(f::typeof(identity), dest::Array{Float64, 3}, A::SubArray{Float64, 3, Oceananigans.AbstractOperations.ConditionalOperati; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250
https://github.com/CliMA/Oceananigans.jl/issues/2250:908,Security,validat,validate,908,"Previously, I believe I was defining fields on immersed grids. When I try now I get an error. Am I doing something silly or has something changed?. ```; julia> using Oceananigans. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> h0, L = 0.5, 0.25; (0.5, 0.25). julia> grid = RectilinearGrid(size=(16, 8), y=(-1, 1), z=(-1, 0),; topology=(Flat, Periodic, Bounded), halo=(3,3)); 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> seamount2(x, y, z) = z < - 1 + h0*exp(-y^2/L^2); seamount2 (generic function with 1 method). julia> grid_with_seamount2 = ImmersedBoundaryGrid(grid, GridFittedBottom(seamount2)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Software/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; with immersed: GridFittedBottom{typeof(seamount2)}. julia> c2 = CenterField(grid_with_seamount2); Error showing value of type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Arra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250
https://github.com/CliMA/Oceananigans.jl/issues/2251:513,Usability,Clear,Clearly,513,"Following [Adroft et al. (1997)](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml), we are developing a **partial cell method** in the following branch: fjp/partial_cell_immersed_boundaries. Presently, we can build the mesh without any complaints, but nothing else. I thought a good first step would be to try and use `mask_immersed_field!` on a scalar field. When I try with the current set up, it doesn't complain, but it also doesn't modify the entries either. Clearly more work needs to be done. . I don't understand all of `mask_immersed_field.jl` but I wonder if we need to build a new `scalar_mask`. At present, it only works for grids that are `AbstractGridFittedBoundary`, but the new grid is not of that type. . Any advice on whether we need to create a new `scalar_mask` for dispatch? I tried something pretty simple but that had no effect so I suspect it's not being used,. ```; @inline function scalar_mask(i, j, k, grid, ::PartialCellBottom, LX, LY, LZ, value, field); return @inbounds ifelse(solid_interface(LX, LY, LZ, i, j, k, grid),; value,; field[i, j, k]); end; ```. Or maybe the problem should be solved by going into `mask_immersed_field.jl` and modifying `solid_interface`?. Any suggestions @simone-silvestri ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251
https://github.com/CliMA/Oceananigans.jl/issues/2251:870,Usability,simpl,simple,870,"Following [Adroft et al. (1997)](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml), we are developing a **partial cell method** in the following branch: fjp/partial_cell_immersed_boundaries. Presently, we can build the mesh without any complaints, but nothing else. I thought a good first step would be to try and use `mask_immersed_field!` on a scalar field. When I try with the current set up, it doesn't complain, but it also doesn't modify the entries either. Clearly more work needs to be done. . I don't understand all of `mask_immersed_field.jl` but I wonder if we need to build a new `scalar_mask`. At present, it only works for grids that are `AbstractGridFittedBoundary`, but the new grid is not of that type. . Any advice on whether we need to create a new `scalar_mask` for dispatch? I tried something pretty simple but that had no effect so I suspect it's not being used,. ```; @inline function scalar_mask(i, j, k, grid, ::PartialCellBottom, LX, LY, LZ, value, field); return @inbounds ifelse(solid_interface(LX, LY, LZ, i, j, k, grid),; value,; field[i, j, k]); end; ```. Or maybe the problem should be solved by going into `mask_immersed_field.jl` and modifying `solid_interface`?. Any suggestions @simone-silvestri ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251
https://github.com/CliMA/Oceananigans.jl/pull/2253:223,Energy Efficiency,Adapt,Adapt,223,todo. - [x] Implement the preconditioner for free surface Implicit solver; - [x] Allow for flux boundary conditions with `Array` type parameters; - [ ] Implement multi-region output writers (and eventually readers?); - [x] Adapt `AbstractOperations` to `MultiRegionFields`; - [x] Add more tests for implicit solvers; - [x] Benchmark results. Closes #1582 ; Closes #2255 ; closes #2005,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253
https://github.com/CliMA/Oceananigans.jl/pull/2253:223,Modifiability,Adapt,Adapt,223,todo. - [x] Implement the preconditioner for free surface Implicit solver; - [x] Allow for flux boundary conditions with `Array` type parameters; - [ ] Implement multi-region output writers (and eventually readers?); - [x] Adapt `AbstractOperations` to `MultiRegionFields`; - [x] Add more tests for implicit solvers; - [x] Benchmark results. Closes #1582 ; Closes #2255 ; closes #2005,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253
https://github.com/CliMA/Oceananigans.jl/pull/2253:289,Testability,test,tests,289,todo. - [x] Implement the preconditioner for free surface Implicit solver; - [x] Allow for flux boundary conditions with `Array` type parameters; - [ ] Implement multi-region output writers (and eventually readers?); - [x] Adapt `AbstractOperations` to `MultiRegionFields`; - [x] Add more tests for implicit solvers; - [x] Benchmark results. Closes #1582 ; Closes #2255 ; closes #2005,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253
https://github.com/CliMA/Oceananigans.jl/pull/2253:323,Testability,Benchmark,Benchmark,323,todo. - [x] Implement the preconditioner for free surface Implicit solver; - [x] Allow for flux boundary conditions with `Array` type parameters; - [ ] Implement multi-region output writers (and eventually readers?); - [x] Adapt `AbstractOperations` to `MultiRegionFields`; - [x] Add more tests for implicit solvers; - [x] Benchmark results. Closes #1582 ; Closes #2255 ; closes #2005,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253
https://github.com/CliMA/Oceananigans.jl/issues/2261:121,Usability,simpl,simplifies,121,"I'm just now reading about the new `ScalarDiffusivity` and trying to use it. I think it's a great idea and I love how it simplifies things, but the use of the word ""isotropy"" kinda threw me off a bit. To me setting a scalar diffusivity as `ScalarDiffusivity(..., isotropy=Horizontal())`, implies that the diffusivity is the same in the horizontal directions, but that you can also set a different diffusivity in the vertical direction. Which you can't in this instance of the constructor; you have to create a new one. There's an extra issue I think if you set `ScalarDiffusivity(..., isotropy=Vertical())`. Since by definition isotropy is [uniformity in all orientations](https://en.wikipedia.org/wiki/Isotropy#:~:text=Isotropy%20is%20uniformity%20in%20all,the%20prefix%20an%2C%20hence%20anisotropy.), I don't think it's accurate to say something is isotropic over one single direction. Maybe a better word would be ""directions""? Or directionality? (if that's even a word...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2261
https://github.com/CliMA/Oceananigans.jl/pull/2262:30,Usability,clear,clear,30,"I think the docs weren't 100% clear before on how to actually use different horizontal and vertical components in a single closure. I also couldn't figure out how to set `νx` different from `νy`, but I'm assuming that possible. So if anyone knows, I think we could also add that there.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262
https://github.com/CliMA/Oceananigans.jl/issues/2263:78,Integrability,interface,interface,78,"Right now the the function that calculates whether a face location is a solid interface looks like this:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Grids/grid_solid_nodes.jl#L42-L50. This means that it'll return `true` even if the face location is completely inside the immersed solid (i.e. the two adjacent centers are inside the solid, not just one). Is this by design? In my view it would make more sense to use `xor` there instead of `or`. That way it would return `false` if the `Face` is completely inside the immersed in the solid, and it would only return `true` in the actual edges of the immersed solid. This is relevant when implementing boundary conditions to the immersed solids. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263
https://github.com/CliMA/Oceananigans.jl/issues/2264:23,Modifiability,refactor,refactor,23,"The recent diffusivity refactor #2247 changed `ExplicitTimeDiscretization` -> `Explicit`. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L8-L27. We are importing these in http://github.com/CliMA/OceanTurbulenceParameterEstimation.jl and it seems a bit vague to import. ```Julia; using Oceananigans.TurbulenceClosures: Explicit; ```. Should we go back to bit more verbose names?. cc: @simone-silvestri, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2264
https://github.com/CliMA/Oceananigans.jl/issues/2265:751,Modifiability,refactor,refactor,751,"This is related to the discussion in https://github.com/CliMA/Oceananigans.jl/pull/2262. Instead of defining structs specifically to symbolize directions (`Vertical`, `ThreeDimensional`, `Horizontal`) to use with `ScalarDiffusivity`, is it possible/worth it to use arrays, similar to what `Average()` does?. In this way, instead of specifying a `ConstantDiffusivity` as . ```julia; horizontal_closure = ScalarDiffusivity(ν=1e-3, κ=2e-3, isotropy=Horizontal()); ```. a user would write. ```julia; horizontal_closure = ScalarDiffusivity(ν=1e-3, κ=2e-3, isotropy=(1,2)); ```. Seems to me like this would be more general and it would also decrease the amount of code used, but I'm not very familiar with that part of the code (especially since the recent refactor) so can't be sure. I thought it was worth posting about this though. @glwagner @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2265
https://github.com/CliMA/Oceananigans.jl/pull/2266:931,Integrability,depend,depending,931,"This PR is an attempt at unifying the directions used by `TurbulenceClosures` a bit, in addition to a few minor things. In summary, this PR. - Nukes the `Vertical` definition at `abstract_scalar_diffusivity_closure.jl` and uses the already-defined `ZDirection` instead. I think this decreases the amount of code but is also more accurate (since for rotated domains the `z` direction of the code isn't necessarily the ""physical"" vertical direction); - Renames `ThreeDimensional`, `Horizontal` to `XYZDirections` and `XYDirections` and moves their definition to `Grids`. This was done for consistency with `ZDirection` and also follows the same argument about rotated domains.; - Exports `XYZDirections`, `XYDirections` and `ZDirection` at the top level; - Makes minor improvements to documentation. I could also change the notation from `isotropy` to `dimensions`, according to https://github.com/CliMA/Oceananigans.jl/issues/2261, depending on how people feel. I haven't done that yet because there doesn't appear to be a consensus on what to do there as of writing this. Closes https://github.com/CliMA/Oceananigans.jl/issues/2254",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2266
https://github.com/CliMA/Oceananigans.jl/pull/2268:225,Availability,robust,robust,225,"This PR tweaks `initialize_simulation!` so that the schedules get called when `iteration == 0` --- in addition to running diagnostics, executing callbacks, and writing output. This is a tiny step in the direction of having a robust initialization procedure. I think we still need to work on the abstractions a bit though, since it'd be nice to initialize schedules / callbacks more explicitly rather than implicitly relying on `iteration == 0`. This change will affect `SpecifiedTimes` and `WallTimeInterval` the most, I think. TODO:. - [ ] Test for initialization of `SpecifiedTimes`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2268
https://github.com/CliMA/Oceananigans.jl/pull/2268:52,Energy Efficiency,schedul,schedules,52,"This PR tweaks `initialize_simulation!` so that the schedules get called when `iteration == 0` --- in addition to running diagnostics, executing callbacks, and writing output. This is a tiny step in the direction of having a robust initialization procedure. I think we still need to work on the abstractions a bit though, since it'd be nice to initialize schedules / callbacks more explicitly rather than implicitly relying on `iteration == 0`. This change will affect `SpecifiedTimes` and `WallTimeInterval` the most, I think. TODO:. - [ ] Test for initialization of `SpecifiedTimes`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2268
https://github.com/CliMA/Oceananigans.jl/pull/2268:355,Energy Efficiency,schedul,schedules,355,"This PR tweaks `initialize_simulation!` so that the schedules get called when `iteration == 0` --- in addition to running diagnostics, executing callbacks, and writing output. This is a tiny step in the direction of having a robust initialization procedure. I think we still need to work on the abstractions a bit though, since it'd be nice to initialize schedules / callbacks more explicitly rather than implicitly relying on `iteration == 0`. This change will affect `SpecifiedTimes` and `WallTimeInterval` the most, I think. TODO:. - [ ] Test for initialization of `SpecifiedTimes`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2268
https://github.com/CliMA/Oceananigans.jl/pull/2268:541,Testability,Test,Test,541,"This PR tweaks `initialize_simulation!` so that the schedules get called when `iteration == 0` --- in addition to running diagnostics, executing callbacks, and writing output. This is a tiny step in the direction of having a robust initialization procedure. I think we still need to work on the abstractions a bit though, since it'd be nice to initialize schedules / callbacks more explicitly rather than implicitly relying on `iteration == 0`. This change will affect `SpecifiedTimes` and `WallTimeInterval` the most, I think. TODO:. - [ ] Test for initialization of `SpecifiedTimes`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2268
https://github.com/CliMA/Oceananigans.jl/issues/2269:492,Availability,ERROR,ERROR,492,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269
https://github.com/CliMA/Oceananigans.jl/issues/2269:742,Availability,error,error,742,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269
https://github.com/CliMA/Oceananigans.jl/issues/2269:1235,Availability,error,error,1235,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269
https://github.com/CliMA/Oceananigans.jl/issues/2269:1241,Integrability,message,message,1241,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269
https://github.com/CliMA/Oceananigans.jl/issues/2269:499,Performance,Load,LoadError,499,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269
https://github.com/CliMA/Oceananigans.jl/issues/2269:728,Usability,user-friendly,user-friendly,728,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269
https://github.com/CliMA/Oceananigans.jl/issues/2271:699,Availability,down,downside,699,"A few ideas:. 1. Allow `grid` as a positional argument so we can write `WENO5(grid)` rather than `WENO5(grid=grid)`; 2. Emit a warning about ""stretched WENO"" in the model constructor rather than `WENO5`. It's misleading to throw a warning when using WENO5 on a uniform grid; we should only throw a warning if users specify `WENO5` with a stretched grid.; 3. Alternatively to 2, we can re-build WENO in model constructors with a `validate_advection` method. We already have `validate_momentum_advection` for hydrostatic models:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L127. The downside to 3 is that it's bad for testing, since it might _prevent_ us from using the ""uniform"" flavor of WENO on stretched grids. (@simone-silvestri is that true?) Also something that's not clear to me --- @simone-silvestri do coefficients like. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L30. become `Nothing` in regular directions, even with `WENO5(grid=grid)`? Or are they only `Nothing` for `WENO5()`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271
https://github.com/CliMA/Oceananigans.jl/issues/2271:734,Testability,test,testing,734,"A few ideas:. 1. Allow `grid` as a positional argument so we can write `WENO5(grid)` rather than `WENO5(grid=grid)`; 2. Emit a warning about ""stretched WENO"" in the model constructor rather than `WENO5`. It's misleading to throw a warning when using WENO5 on a uniform grid; we should only throw a warning if users specify `WENO5` with a stretched grid.; 3. Alternatively to 2, we can re-build WENO in model constructors with a `validate_advection` method. We already have `validate_momentum_advection` for hydrostatic models:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L127. The downside to 3 is that it's bad for testing, since it might _prevent_ us from using the ""uniform"" flavor of WENO on stretched grids. (@simone-silvestri is that true?) Also something that's not clear to me --- @simone-silvestri do coefficients like. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L30. become `Nothing` in regular directions, even with `WENO5(grid=grid)`? Or are they only `Nothing` for `WENO5()`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271
https://github.com/CliMA/Oceananigans.jl/issues/2271:891,Usability,clear,clear,891,"A few ideas:. 1. Allow `grid` as a positional argument so we can write `WENO5(grid)` rather than `WENO5(grid=grid)`; 2. Emit a warning about ""stretched WENO"" in the model constructor rather than `WENO5`. It's misleading to throw a warning when using WENO5 on a uniform grid; we should only throw a warning if users specify `WENO5` with a stretched grid.; 3. Alternatively to 2, we can re-build WENO in model constructors with a `validate_advection` method. We already have `validate_momentum_advection` for hydrostatic models:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L127. The downside to 3 is that it's bad for testing, since it might _prevent_ us from using the ""uniform"" flavor of WENO on stretched grids. (@simone-silvestri is that true?) Also something that's not clear to me --- @simone-silvestri do coefficients like. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L30. become `Nothing` in regular directions, even with `WENO5(grid=grid)`? Or are they only `Nothing` for `WENO5()`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271
https://github.com/CliMA/Oceananigans.jl/issues/2290:344,Security,Secur,Security-Token,344,"oposed / described by [Breivik et al., 2016](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500316X00042/1-s2.0-S1463500316000159/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAoaCXVzLWVhc3QtMSJGMEQCIEuzyjjMiYKjWncqy3fB9gow3kA5926WXv4VBHU9V0HoAiBgSB%2BFi9CNjS0smrtpCWSh2fziUgRWzaTpBid40ar%2FnSr6AwhjEAQaDDA1OTAwMzU0Njg2NSIMRVnsHhFNYBpkm%2B7%2BKtcDEI3fj7WLlfM53vSXM70Jkta7qu8fr%2BZ4CiPp4EQEEdZO6gUvY4SodH4tbdylMZ16%2B6i0LOoNoyjZ%2FVjIVIr%2BzT90aJhP4POuZeDrpUxWfNYUqCXOyJ%2Bl4Uz3BCrk0e4ciQXjvEtJzlNbQDfq48BbAPBlW6B4SZ8q5Tui7pe1OvlCCs299aJ8749qPcCrKO5zN5QGE0iDQ2PAN0c2L53i%2BjjNPA0EOYaa0HdQWwO0tF14tTe79EjPEgl%2BMv%2BtlDH3XbTE595%2FdFEfPieVxLQJxNVWwvBZn2docHqGUXgcMsjOQVus7E%2FLZymGWm5cdHIJeB1d5VhK27LB4laC%2FhKCYsRVY59KDzsKVDR0jp6Rz6Ot6MjCwTVKuDTt6Gz0lsC02z3Q52EEIwxsWwpFJytxblTwDDGU5vu0nC%2BXSaZAA4rt8uytZSBR%2BO5ePkeRpOR04IF45ZmZw6w8TTlQXDewatkd64cUrRc6FQw0krDJ4eP%2FCDJKSd1h02HjU7C7GH6Q26NhNyFNw6Arxd173SQ43s7JMYW%2BOqY5%2BPj791sOnT7e5unKOSlnygc9ByJ5nr1mjt8aEaX9kxW5ZcaWnRZ%2Fue3NGi3ZQZvmkfZXITWkG1JzW%2BQUXxBUMObG1JAGOqYBlOoU8BHgt%2FoqN5rPBE1L0boNzjsSZWd3Mvv%2FJL1puzzfMbVoxGXMWcCRTcGyUDKA5eKG261EWk8WXCHK77FpXfb67tIFjOPUqtQRYpPDw10p39jA2oX168yKgrQZe1OVbIrw4uM%2FzGI57WdgefB3HgcwUgAacmIOndn5YvNpMZIRU4ExzrHGrCb1%2BwKJjRNm4WjEnfczrQPDhzPx6kTK9RnxkpCWvA%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220222T190618Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYUWF4GJ7K%2F20220222%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=23dc65f5c0ed27e40381ce3eafb4d99c62faa368fa7ca21d3b635b3b05731127&hash=c2a51e264c7e095492ef97c3cb63571bfba4a5379b4090b7ad3b20ff588c2db6&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500316000159&tid=spdf-69dccd42-cfb6-4987-9af5-8ccdc6d81ccf&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=5306520250050e5302&rr=6e1a7da6df9c7d56) and [Li et al. 2017](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500317X00048/1-s2.0-S1463500317300471/mainext.pdf?X-Amz-Security-Token=IQoJb3JpZ2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290
https://github.com/CliMA/Oceananigans.jl/issues/2290:1726,Security,hash,hash,1726,"oposed / described by [Breivik et al., 2016](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500316X00042/1-s2.0-S1463500316000159/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAoaCXVzLWVhc3QtMSJGMEQCIEuzyjjMiYKjWncqy3fB9gow3kA5926WXv4VBHU9V0HoAiBgSB%2BFi9CNjS0smrtpCWSh2fziUgRWzaTpBid40ar%2FnSr6AwhjEAQaDDA1OTAwMzU0Njg2NSIMRVnsHhFNYBpkm%2B7%2BKtcDEI3fj7WLlfM53vSXM70Jkta7qu8fr%2BZ4CiPp4EQEEdZO6gUvY4SodH4tbdylMZ16%2B6i0LOoNoyjZ%2FVjIVIr%2BzT90aJhP4POuZeDrpUxWfNYUqCXOyJ%2Bl4Uz3BCrk0e4ciQXjvEtJzlNbQDfq48BbAPBlW6B4SZ8q5Tui7pe1OvlCCs299aJ8749qPcCrKO5zN5QGE0iDQ2PAN0c2L53i%2BjjNPA0EOYaa0HdQWwO0tF14tTe79EjPEgl%2BMv%2BtlDH3XbTE595%2FdFEfPieVxLQJxNVWwvBZn2docHqGUXgcMsjOQVus7E%2FLZymGWm5cdHIJeB1d5VhK27LB4laC%2FhKCYsRVY59KDzsKVDR0jp6Rz6Ot6MjCwTVKuDTt6Gz0lsC02z3Q52EEIwxsWwpFJytxblTwDDGU5vu0nC%2BXSaZAA4rt8uytZSBR%2BO5ePkeRpOR04IF45ZmZw6w8TTlQXDewatkd64cUrRc6FQw0krDJ4eP%2FCDJKSd1h02HjU7C7GH6Q26NhNyFNw6Arxd173SQ43s7JMYW%2BOqY5%2BPj791sOnT7e5unKOSlnygc9ByJ5nr1mjt8aEaX9kxW5ZcaWnRZ%2Fue3NGi3ZQZvmkfZXITWkG1JzW%2BQUXxBUMObG1JAGOqYBlOoU8BHgt%2FoqN5rPBE1L0boNzjsSZWd3Mvv%2FJL1puzzfMbVoxGXMWcCRTcGyUDKA5eKG261EWk8WXCHK77FpXfb67tIFjOPUqtQRYpPDw10p39jA2oX168yKgrQZe1OVbIrw4uM%2FzGI57WdgefB3HgcwUgAacmIOndn5YvNpMZIRU4ExzrHGrCb1%2BwKJjRNm4WjEnfczrQPDhzPx6kTK9RnxkpCWvA%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220222T190618Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYUWF4GJ7K%2F20220222%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=23dc65f5c0ed27e40381ce3eafb4d99c62faa368fa7ca21d3b635b3b05731127&hash=c2a51e264c7e095492ef97c3cb63571bfba4a5379b4090b7ad3b20ff588c2db6&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500316000159&tid=spdf-69dccd42-cfb6-4987-9af5-8ccdc6d81ccf&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=5306520250050e5302&rr=6e1a7da6df9c7d56) and [Li et al. 2017](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500317X00048/1-s2.0-S1463500317300471/mainext.pdf?X-Amz-Security-Token=IQoJb3JpZ2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290
https://github.com/CliMA/Oceananigans.jl/issues/2290:2167,Security,Secur,Security-Token,2167,rr=6e1a7da6df9c7d56) and [Li et al. 2017](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500317X00048/1-s2.0-S1463500317300471/mainext.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAsaCXVzLWVhc3QtMSJGMEQCIBRKxiRGfmCqFI08tnCQqlwbVGk%2Bm8YOAG57p4smh3cHAiAC%2B9pA%2FCQMsYbtGWN4kUfk%2FIAKtiQzgv56vUWJpK03NCr6AwhjEAQaDDA1OTAwMzU0Njg2NSIMtkIfmex2gMV%2FyYy6KtcD496P%2F695JO%2BGnHHg3hAcKNGkmiiEA8fjZyLcowzIG1pT5TS%2Ft%2BElYms%2FLx0gMtbZFbl3ks8ifVzTgoC0pM3zCN2TCTyxCPFUUB2j0PmnsyNtq9v5ljKcSf2eolUGpQlINrUrJ170CMAGYA7XjRWzC8YJCZBRF7iThfHpYOvqkjO5BJyW8p52vOlmz%2FRfy%2FSMbW0kVlgEef5PcIWTff3BSKQ5BA%2BdekJjdRrZDVaSwNIcQjE4l%2Ff38F%2Bp%2BlY75UZft0%2Fd1I18PyELQS5rWPmCIPNkmsePvN1rgPnhqldC5ozV0OO2Anr8oBoxmnmwNwnrfk5yUwJWc%2Fhsk4zmTD96nmzDgS3IOgCjh8b1TIhBEvYlZlCVkXouGc8M0%2BN7tCEZqvdjxKVkulq2BqwXW9bbYoPmp9ufV9A96mGmBWzqbJpRBLg%2FZHX5%2BDFDPoFc1vZ4gPCz9JSS8xyyayG1JtaZ6etf%2F%2FbmN2IcTbPh0lqf9B5O7DqisxWMCKadJvgsr5oVghbvkEd%2FjjFL7KrspUdfonTXuY5C5U2TiLkOIVlg2bFaEP9QemD8FVljVjKLrUr8K99rJnaPC1uQncZXj%2FL%2FF%2BKfi9k9bIQe0uhDrmwNpigQzgOdZy1GMJDS1JAGOqYB3PXXbyBFFFdkUJqOFawxA9rk4s0ZqMS4J8%2BpTJxrUG%2F3KL8SAYJh9PmjeekbuM1lz8q1TlsQNM50q4UiPr0Ld7Wt5PrqC01LwdIFgbhr1l1GltNfCH9vWLEasPpjc2O6MGHwNpmrCNVstzsTQ%2FbiELElpjrhNjLZUaIOPWHKUTVTcIBmQf%2B5AVSebzQWwEX2aaFc8HYk5XfmfFwJoKdlO%2F3oR%2FOsnQ%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220222T191639Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY34KZ3BVM%2F20220222%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=779b961e8385e6456d63980757c47e35f1c1dd69db925e240032b9055d9a2364&hash=23906dc815e1871c325b937eb48d6c480ea0ae6577d9267f9331fa4191fa7274&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500317300471&tid=spdf-3e1d0343-787e-407e-819c-dd650ee95cad&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=530652025f020b5652&rr=6e1a8cd34a467c44). This model assumes that the surface wave spectrum is self-similar according to the Phillips spectrum to produce a Stokes drift profile. We're ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290
https://github.com/CliMA/Oceananigans.jl/issues/2290:3563,Security,hash,hash,3563,rr=6e1a7da6df9c7d56) and [Li et al. 2017](https://pdf.sciencedirectassets.com/272136/1-s2.0-S1463500317X00048/1-s2.0-S1463500317300471/mainext.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAsaCXVzLWVhc3QtMSJGMEQCIBRKxiRGfmCqFI08tnCQqlwbVGk%2Bm8YOAG57p4smh3cHAiAC%2B9pA%2FCQMsYbtGWN4kUfk%2FIAKtiQzgv56vUWJpK03NCr6AwhjEAQaDDA1OTAwMzU0Njg2NSIMtkIfmex2gMV%2FyYy6KtcD496P%2F695JO%2BGnHHg3hAcKNGkmiiEA8fjZyLcowzIG1pT5TS%2Ft%2BElYms%2FLx0gMtbZFbl3ks8ifVzTgoC0pM3zCN2TCTyxCPFUUB2j0PmnsyNtq9v5ljKcSf2eolUGpQlINrUrJ170CMAGYA7XjRWzC8YJCZBRF7iThfHpYOvqkjO5BJyW8p52vOlmz%2FRfy%2FSMbW0kVlgEef5PcIWTff3BSKQ5BA%2BdekJjdRrZDVaSwNIcQjE4l%2Ff38F%2Bp%2BlY75UZft0%2Fd1I18PyELQS5rWPmCIPNkmsePvN1rgPnhqldC5ozV0OO2Anr8oBoxmnmwNwnrfk5yUwJWc%2Fhsk4zmTD96nmzDgS3IOgCjh8b1TIhBEvYlZlCVkXouGc8M0%2BN7tCEZqvdjxKVkulq2BqwXW9bbYoPmp9ufV9A96mGmBWzqbJpRBLg%2FZHX5%2BDFDPoFc1vZ4gPCz9JSS8xyyayG1JtaZ6etf%2F%2FbmN2IcTbPh0lqf9B5O7DqisxWMCKadJvgsr5oVghbvkEd%2FjjFL7KrspUdfonTXuY5C5U2TiLkOIVlg2bFaEP9QemD8FVljVjKLrUr8K99rJnaPC1uQncZXj%2FL%2FF%2BKfi9k9bIQe0uhDrmwNpigQzgOdZy1GMJDS1JAGOqYB3PXXbyBFFFdkUJqOFawxA9rk4s0ZqMS4J8%2BpTJxrUG%2F3KL8SAYJh9PmjeekbuM1lz8q1TlsQNM50q4UiPr0Ld7Wt5PrqC01LwdIFgbhr1l1GltNfCH9vWLEasPpjc2O6MGHwNpmrCNVstzsTQ%2FbiELElpjrhNjLZUaIOPWHKUTVTcIBmQf%2B5AVSebzQWwEX2aaFc8HYk5XfmfFwJoKdlO%2F3oR%2FOsnQ%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20220222T191639Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTY34KZ3BVM%2F20220222%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=779b961e8385e6456d63980757c47e35f1c1dd69db925e240032b9055d9a2364&hash=23906dc815e1871c325b937eb48d6c480ea0ae6577d9267f9331fa4191fa7274&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500317300471&tid=spdf-3e1d0343-787e-407e-819c-dd650ee95cad&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=530652025f020b5652&rr=6e1a8cd34a467c44). This model assumes that the surface wave spectrum is self-similar according to the Phillips spectrum to produce a Stokes drift profile. We're ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290
https://github.com/CliMA/Oceananigans.jl/issues/2290:4534,Usability,simpl,simple,4534,"z-Signature=779b961e8385e6456d63980757c47e35f1c1dd69db925e240032b9055d9a2364&hash=23906dc815e1871c325b937eb48d6c480ea0ae6577d9267f9331fa4191fa7274&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S1463500317300471&tid=spdf-3e1d0343-787e-407e-819c-dd650ee95cad&sid=14dd78682619684b691b33669d091ccbdc9egxrqa&type=client&ua=530652025f020b5652&rr=6e1a8cd34a467c44). This model assumes that the surface wave spectrum is self-similar according to the Phillips spectrum to produce a Stokes drift profile. We're about to do some epic modeling so hold onto your hats --- no, really. In the version of ""theory wave"" that does _not_ account for directional spreading, the Stokes drift profile takes the form. ![image](https://user-images.githubusercontent.com/15271942/155204195-dff6233d-a9b1-411b-a544-a9e106e2fad2.png). Note that we require the _vertical average of the Stokes shear_ for our finite volume model. This can be computed as the difference between the Stokes velocity at the top and bottom of a cell (let's take all the simple wins we can here). This model has two parameters: the wave number at the spectral peak, `k_p`, and the surface Stokes drift `u^S_Phil(0)`. Li et al propose. ![image](https://user-images.githubusercontent.com/15271942/155204117-b111eccb-f94c-4273-9262-7b3e194d6b84.png). and. ![image](https://user-images.githubusercontent.com/15271942/155204435-fe2b2215-ed24-40bf-ac38-cb2902e0e5d3.png). where V^S is the Stokes transport. One possibility is to use a scaling proposed by [Restrepo and McWilliams 1999] (https://journals.ametsoc.org/view/journals/phoc/29/10/1520-0485_1999_029_2523_twdoc_2.0.co_2.xml) (here T^S is Li et al's V^S):. <img width=""530"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155206371-f00fe258-688f-40b3-98c9-6abe83d6a03a.png"">. Note that other aspects of that paper are extremely misleading so read with caution... All of that closes one possible model for equilibrium waves. A second possibility is to ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290
https://github.com/CliMA/Oceananigans.jl/issues/2272:501,Deployability,update,update,501,"Recent calibration developments may have produced better defaults, e.g., here:; https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L108; and; https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/mixing_length.jl#L69-L85. Should we update these values?. (I'd like to add CATKE closure to the channel...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2272
https://github.com/CliMA/Oceananigans.jl/pull/2273:8,Deployability,update,updates,8,"This PR updates CATKE with an improved model for how the presence of shear modulates the mixing length and turbulent mixing. A few preliminary calibration results suggest that these changes are very promising, especially at coarse resolutions. A short summary is that, originally, CATKE was flexible enough to model both convection and shear-driven mixing --- just not at the same time (because TKE levels are much higher for shear-driven mixing). Adding a more explicit model for the modulation of the mixing length in the presence of shear allows CATKE to capture both convection and shear-driven regimes. We can update the default values for CATKE in this PR as well. This figure is a little out of context, but it shows agreement between LES (gray line) and the ""best parameters"" from a calibration run (blue line) at 8m resolution with five physical scenarios (from LESbrary's 4 day suite). The ""other line"" is the ""worst"" parameters in the calibration ensemble (so that one should be ignored). ![image](https://user-images.githubusercontent.com/15271942/155232297-9fa83269-0383-4f9e-a060-757b3632ce9d.png). Closes #2272",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273
https://github.com/CliMA/Oceananigans.jl/pull/2273:615,Deployability,update,update,615,"This PR updates CATKE with an improved model for how the presence of shear modulates the mixing length and turbulent mixing. A few preliminary calibration results suggest that these changes are very promising, especially at coarse resolutions. A short summary is that, originally, CATKE was flexible enough to model both convection and shear-driven mixing --- just not at the same time (because TKE levels are much higher for shear-driven mixing). Adding a more explicit model for the modulation of the mixing length in the presence of shear allows CATKE to capture both convection and shear-driven regimes. We can update the default values for CATKE in this PR as well. This figure is a little out of context, but it shows agreement between LES (gray line) and the ""best parameters"" from a calibration run (blue line) at 8m resolution with five physical scenarios (from LESbrary's 4 day suite). The ""other line"" is the ""worst"" parameters in the calibration ensemble (so that one should be ignored). ![image](https://user-images.githubusercontent.com/15271942/155232297-9fa83269-0383-4f9e-a060-757b3632ce9d.png). Closes #2272",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273
https://github.com/CliMA/Oceananigans.jl/pull/2273:291,Modifiability,flexible,flexible,291,"This PR updates CATKE with an improved model for how the presence of shear modulates the mixing length and turbulent mixing. A few preliminary calibration results suggest that these changes are very promising, especially at coarse resolutions. A short summary is that, originally, CATKE was flexible enough to model both convection and shear-driven mixing --- just not at the same time (because TKE levels are much higher for shear-driven mixing). Adding a more explicit model for the modulation of the mixing length in the presence of shear allows CATKE to capture both convection and shear-driven regimes. We can update the default values for CATKE in this PR as well. This figure is a little out of context, but it shows agreement between LES (gray line) and the ""best parameters"" from a calibration run (blue line) at 8m resolution with five physical scenarios (from LESbrary's 4 day suite). The ""other line"" is the ""worst"" parameters in the calibration ensemble (so that one should be ignored). ![image](https://user-images.githubusercontent.com/15271942/155232297-9fa83269-0383-4f9e-a060-757b3632ce9d.png). Closes #2272",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273
https://github.com/CliMA/Oceananigans.jl/pull/2275:239,Integrability,interface,interface,239,The main goal of this PR (done jointly with @whitleyv) is to add drag as an option to grid-fitted Immersed boundaries. This is draft for now since first we want to get something that is working properly without worrying to much about user-interface.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275
https://github.com/CliMA/Oceananigans.jl/pull/2284:8,Deployability,update,updates,8,This PR updates the baroclinic adjustment validations scripts. Closes #2291,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284
https://github.com/CliMA/Oceananigans.jl/pull/2284:42,Security,validat,validations,42,This PR updates the baroclinic adjustment validations scripts. Closes #2291,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284
https://github.com/CliMA/Oceananigans.jl/issues/2285:16,Modifiability,variab,variable,16,So here a local variable `area` is defined but `area` could be `Δx`. This is confusing... right?. https://github.com/CliMA/Oceananigans.jl/blob/4f1fe0fa7edd9489ba20875be64b69daa0a77b95/src/Operators/products_between_fields_and_grid_metrics.jl#L8. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2285
https://github.com/CliMA/Oceananigans.jl/issues/2291:776,Integrability,interface,interface,776,"`z_viscosity` is supposed to return the vertical diffusivity, or the coefficient `ν` that appears in the term `∂z ν ∂z u` --- _when that term exists for a given closure_. This means that. ```julia; julia> using Oceananigans. julia> using Oceananigans.TurbulenceClosures: z_viscosity. julia> horizontal_diffusivity = HorizontalScalarDiffusivity(ν=1, κ=1); ScalarDiffusivity{ExplicitTimeDiscretization, HorizontalFormulation}(ν=1.0, κ=1.0). julia> z_viscosity(horizontal_diffusivity, nothing); 1.0; ```. is wrong since `z_viscosity(horizontal_diffusivity, nothing) = 0`. I'm not sure if this affects functionality. `z_viscosity` is only used for vertically-implicit time-stepping. Regardless we should do the right thing here. We also need tests (eventually) for this ""internal interface"" for grabbing viscosities and diffusivities. (eg the functions `viscosity`, `diffusivity`, `z_viscosity`, `z_diffusivity`). It's a bit underdeveloped at the moment.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2291
https://github.com/CliMA/Oceananigans.jl/issues/2291:738,Testability,test,tests,738,"`z_viscosity` is supposed to return the vertical diffusivity, or the coefficient `ν` that appears in the term `∂z ν ∂z u` --- _when that term exists for a given closure_. This means that. ```julia; julia> using Oceananigans. julia> using Oceananigans.TurbulenceClosures: z_viscosity. julia> horizontal_diffusivity = HorizontalScalarDiffusivity(ν=1, κ=1); ScalarDiffusivity{ExplicitTimeDiscretization, HorizontalFormulation}(ν=1.0, κ=1.0). julia> z_viscosity(horizontal_diffusivity, nothing); 1.0; ```. is wrong since `z_viscosity(horizontal_diffusivity, nothing) = 0`. I'm not sure if this affects functionality. `z_viscosity` is only used for vertically-implicit time-stepping. Regardless we should do the right thing here. We also need tests (eventually) for this ""internal interface"" for grabbing viscosities and diffusivities. (eg the functions `viscosity`, `diffusivity`, `z_viscosity`, `z_diffusivity`). It's a bit underdeveloped at the moment.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2291
https://github.com/CliMA/Oceananigans.jl/issues/2292:225,Energy Efficiency,reduce,reduce,225,"Some time ago I told @simone-silvestri I wanted to show a ""simple 2D example"" in a tutorial, to which he responded. > It's actually harder to construct a 2D grid than a 3D grid. @simone-silvestri's point, I think, is that to reduce the dimension of a grid we have to pass `topology` with `Flat` elements. It's easier to construct a grid with the default topology `(Periodic, Periodic, Bounded)`. This has been haunting me ever since. I think one way we can solve this issue is to introduce convenience constructors like. ```julia; grid = ZRectilinearGrid(size=16, z=(0, 1), topology=Bounded); grid = XYRectilinearGrid(size=(64, 64), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic)); ```. These are relatively simple to implement since they're one-liners:. ```julia; XYRectilinearGrid(args...; topology=(Periodic, Periodic), kw...) = XYRectilinearGrid(args...; kw..., topology=tuple(topology[1:2]..., Flat)); ```. et cetera. We can also define the appropriate type aliases:. ```julia; const XYRectilinearGrid{FT, TX, TY} = RectilinearGrid{FT, TX, TY, Flat} where {FT, TX, TY}; ```. and change `show` (if we desire). Is this friendly / a good idea?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292
https://github.com/CliMA/Oceananigans.jl/issues/2292:59,Usability,simpl,simple,59,"Some time ago I told @simone-silvestri I wanted to show a ""simple 2D example"" in a tutorial, to which he responded. > It's actually harder to construct a 2D grid than a 3D grid. @simone-silvestri's point, I think, is that to reduce the dimension of a grid we have to pass `topology` with `Flat` elements. It's easier to construct a grid with the default topology `(Periodic, Periodic, Bounded)`. This has been haunting me ever since. I think one way we can solve this issue is to introduce convenience constructors like. ```julia; grid = ZRectilinearGrid(size=16, z=(0, 1), topology=Bounded); grid = XYRectilinearGrid(size=(64, 64), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic)); ```. These are relatively simple to implement since they're one-liners:. ```julia; XYRectilinearGrid(args...; topology=(Periodic, Periodic), kw...) = XYRectilinearGrid(args...; kw..., topology=tuple(topology[1:2]..., Flat)); ```. et cetera. We can also define the appropriate type aliases:. ```julia; const XYRectilinearGrid{FT, TX, TY} = RectilinearGrid{FT, TX, TY, Flat} where {FT, TX, TY}; ```. and change `show` (if we desire). Is this friendly / a good idea?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292
https://github.com/CliMA/Oceananigans.jl/issues/2292:711,Usability,simpl,simple,711,"Some time ago I told @simone-silvestri I wanted to show a ""simple 2D example"" in a tutorial, to which he responded. > It's actually harder to construct a 2D grid than a 3D grid. @simone-silvestri's point, I think, is that to reduce the dimension of a grid we have to pass `topology` with `Flat` elements. It's easier to construct a grid with the default topology `(Periodic, Periodic, Bounded)`. This has been haunting me ever since. I think one way we can solve this issue is to introduce convenience constructors like. ```julia; grid = ZRectilinearGrid(size=16, z=(0, 1), topology=Bounded); grid = XYRectilinearGrid(size=(64, 64), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic)); ```. These are relatively simple to implement since they're one-liners:. ```julia; XYRectilinearGrid(args...; topology=(Periodic, Periodic), kw...) = XYRectilinearGrid(args...; kw..., topology=tuple(topology[1:2]..., Flat)); ```. et cetera. We can also define the appropriate type aliases:. ```julia; const XYRectilinearGrid{FT, TX, TY} = RectilinearGrid{FT, TX, TY, Flat} where {FT, TX, TY}; ```. and change `show` (if we desire). Is this friendly / a good idea?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2292
https://github.com/CliMA/Oceananigans.jl/issues/2293:270,Availability,mask,masking,270,I got a little confused reading . https://github.com/CliMA/Oceananigans.jl/blob/4f1fe0fa7edd9489ba20875be64b69daa0a77b95/src/ImmersedBoundaries/immersed_fields_reductions.jl#L28. because I thought that `solid_interface` was defined for fluxes while `solid_node` was for masking. Can we clarify what the purpose of these two functions are? Do their names need to be changed?. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293
https://github.com/CliMA/Oceananigans.jl/pull/2295:170,Modifiability,parameteriz,parameterizations,170,"This PR eliminates `AbstractEddyDiffusivity` in favor of simply defining `viscosity` and `diffusivity` directly for the LES closures. It also converts the boundary layer parameterizations to subtype `AbstractScalarDiffusivity{TD, VerticalFormulation}`. This change eliminates much code duplication. I'm also removing the ""background"" diffusivities/viscosities from the LES closures. Closes #1277; Closes #1381. TODO:. - [x] Pass closures into `ivd_upper_diagonal` and implement `ivd_upper_diagonal` for closure tuples and filter out explicit closures before implicit solve; - [x] Change ""diffusivity extractors"" like `κᶠᶜᶜ` so they take `closure` as an argument.; - [x] Support `viscosity(closure::Tuple, K)` cc @tomchor ; - [x] Test `DiffusiveCFL` for closure tuples; - [x] We won't need `z_diffusivity` etc anymore?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295
https://github.com/CliMA/Oceananigans.jl/pull/2295:729,Testability,Test,Test,729,"This PR eliminates `AbstractEddyDiffusivity` in favor of simply defining `viscosity` and `diffusivity` directly for the LES closures. It also converts the boundary layer parameterizations to subtype `AbstractScalarDiffusivity{TD, VerticalFormulation}`. This change eliminates much code duplication. I'm also removing the ""background"" diffusivities/viscosities from the LES closures. Closes #1277; Closes #1381. TODO:. - [x] Pass closures into `ivd_upper_diagonal` and implement `ivd_upper_diagonal` for closure tuples and filter out explicit closures before implicit solve; - [x] Change ""diffusivity extractors"" like `κᶠᶜᶜ` so they take `closure` as an argument.; - [x] Support `viscosity(closure::Tuple, K)` cc @tomchor ; - [x] Test `DiffusiveCFL` for closure tuples; - [x] We won't need `z_diffusivity` etc anymore?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295
https://github.com/CliMA/Oceananigans.jl/pull/2295:57,Usability,simpl,simply,57,"This PR eliminates `AbstractEddyDiffusivity` in favor of simply defining `viscosity` and `diffusivity` directly for the LES closures. It also converts the boundary layer parameterizations to subtype `AbstractScalarDiffusivity{TD, VerticalFormulation}`. This change eliminates much code duplication. I'm also removing the ""background"" diffusivities/viscosities from the LES closures. Closes #1277; Closes #1381. TODO:. - [x] Pass closures into `ivd_upper_diagonal` and implement `ivd_upper_diagonal` for closure tuples and filter out explicit closures before implicit solve; - [x] Change ""diffusivity extractors"" like `κᶠᶜᶜ` so they take `closure` as an argument.; - [x] Support `viscosity(closure::Tuple, K)` cc @tomchor ; - [x] Test `DiffusiveCFL` for closure tuples; - [x] We won't need `z_diffusivity` etc anymore?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295
https://github.com/CliMA/Oceananigans.jl/pull/2298:260,Energy Efficiency,reduce,reduce,260,Simulation that produces the video below; https://user-images.githubusercontent.com/33547697/156404654-e5b37a58-d6d8-4ecb-b1df-a69eef4589ee.mp4. (actually this simulation uses monthly average climatology from 1993-2003 while this PR uses only the year 1992 to reduce the memory footprint on OceananigansArtifacts.jl). Future improvements:; - second order equation of state; - improve vertical mixing (CATKE); - switch to hybrid fluxes and relaxation for scalars; - possibly quadratic bottom drag?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2298
https://github.com/CliMA/Oceananigans.jl/issues/2300:232,Testability,test,tests,232,"Something to do with . https://github.com/CliMA/Oceananigans.jl/blob/b32394a9e70598a3728c4ed6acbcd03b0946fc32/src/Fields/interpolate.jl#L6-L10. ??. Discovered by @johnryantaylor, who may be able to provide more details. First step: tests...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2300
https://github.com/CliMA/Oceananigans.jl/pull/2304:186,Testability,test,tested,186,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.6, 0.7` to `0.6, 0.7, 0.8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2304
https://github.com/CliMA/Oceananigans.jl/pull/2304:292,Testability,test,tests,292,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.6, 0.7` to `0.6, 0.7, 0.8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2304
https://github.com/CliMA/Oceananigans.jl/pull/2305:179,Testability,test,tested,179,"This pull request changes the compat entry for the `CUDAKernels` package from `0.2, 0.3` to `0.2, 0.3, 0.4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2305
https://github.com/CliMA/Oceananigans.jl/pull/2305:285,Testability,test,tests,285,"This pull request changes the compat entry for the `CUDAKernels` package from `0.2, 0.3` to `0.2, 0.3, 0.4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2305
https://github.com/CliMA/Oceananigans.jl/pull/2306:219,Testability,test,test,219,"This creates a partial cell immersed boundary method, following [Adroft et al. (1997)](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). Things to be done still:. - [ ] test for tracer advection (done but needs to be added to tests); - [ ] test with momentum integrtion, both in rectilinear and lat lon grids (needs to be done)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306
https://github.com/CliMA/Oceananigans.jl/pull/2306:276,Testability,test,tests,276,"This creates a partial cell immersed boundary method, following [Adroft et al. (1997)](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). Things to be done still:. - [ ] test for tracer advection (done but needs to be added to tests); - [ ] test with momentum integrtion, both in rectilinear and lat lon grids (needs to be done)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306
https://github.com/CliMA/Oceananigans.jl/pull/2306:290,Testability,test,test,290,"This creates a partial cell immersed boundary method, following [Adroft et al. (1997)](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml). Things to be done still:. - [ ] test for tracer advection (done but needs to be added to tests); - [ ] test with momentum integrtion, both in rectilinear and lat lon grids (needs to be done)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2306
https://github.com/CliMA/Oceananigans.jl/issues/2308:390,Integrability,inject,injection,390,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308
https://github.com/CliMA/Oceananigans.jl/issues/2308:366,Modifiability,polymorphi,polymorphism,366,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308
https://github.com/CliMA/Oceananigans.jl/issues/2308:429,Performance,perform,performance,429,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308
https://github.com/CliMA/Oceananigans.jl/issues/2308:390,Security,inject,injection,390,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308
https://github.com/CliMA/Oceananigans.jl/issues/2309:1286,Deployability,deploy,deploydocs,1286,"Our suite of examples is fairly expensive; in recent runs the documentation build exceeds 90 minutes. If we're able to ""build"" the examples _first_, before calling `makedocs`:. https://github.com/CliMA/Oceananigans.jl/blob/8da72d122f887c1584d8c6f0bb5d4eea27e003d3/docs/make.jl#L155-L165. we can probably speed up the build. This is crucial now because we need to add new examples both for `HydrostaticFreeSurfaceModel` and for simulations in complex domains via `ImmersedBoundaryGrid`. We can also move some examples to the GPU and either speed them up, run them at higher resolution, or both. What I know now: we provide `.md` files to `makedocs`, which then expands code blocks and generates `.html`:. https://github.com/CliMA/Oceananigans.jl/blob/8da72d122f887c1584d8c6f0bb5d4eea27e003d3/docs/make.jl#L66. https://github.com/CliMA/Oceananigans.jl/blob/8da72d122f887c1584d8c6f0bb5d4eea27e003d3/docs/make.jl#L133. https://github.com/CliMA/Oceananigans.jl/blob/8da72d122f887c1584d8c6f0bb5d4eea27e003d3/docs/make.jl#L159. I think one solution is to generate the `.html` (by running code, which generates images and animations + links in the `html`) in separate buildkite jobs, and then somehow generate links to the pre-built `.html` in the ""primary"" `make.jl`call to `makedocs` before `deploydocs`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309
https://github.com/CliMA/Oceananigans.jl/pull/2312:66,Deployability,Install,Installation,66,"Based on the discussion with @iuryt on slack I realized that our ""Installation instructions"" session was a bit barebones. Here's attempt to re-write with a bit more explanation and ""hand-holding"", which I think will help users in general. Basically I think we need to touch on how to install Julia (both for personal computers and HPC systems), since that's often the hardest step, and also touch on running the simulations on HPC systems when you need GPUs (which basically means you have to deal with the job scheduler). This is only my first draft, but suggestions are welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312
https://github.com/CliMA/Oceananigans.jl/pull/2312:284,Deployability,install,install,284,"Based on the discussion with @iuryt on slack I realized that our ""Installation instructions"" session was a bit barebones. Here's attempt to re-write with a bit more explanation and ""hand-holding"", which I think will help users in general. Basically I think we need to touch on how to install Julia (both for personal computers and HPC systems), since that's often the hardest step, and also touch on running the simulations on HPC systems when you need GPUs (which basically means you have to deal with the job scheduler). This is only my first draft, but suggestions are welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312
https://github.com/CliMA/Oceananigans.jl/pull/2312:511,Energy Efficiency,schedul,scheduler,511,"Based on the discussion with @iuryt on slack I realized that our ""Installation instructions"" session was a bit barebones. Here's attempt to re-write with a bit more explanation and ""hand-holding"", which I think will help users in general. Basically I think we need to touch on how to install Julia (both for personal computers and HPC systems), since that's often the hardest step, and also touch on running the simulations on HPC systems when you need GPUs (which basically means you have to deal with the job scheduler). This is only my first draft, but suggestions are welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312
https://github.com/CliMA/Oceananigans.jl/pull/2313:187,Testability,test,tested,187,"This pull request changes the compat entry for the `NCDatasets` package from `^0.10, ^0.11` to `^0.10, ^0.11, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2313
https://github.com/CliMA/Oceananigans.jl/pull/2313:293,Testability,test,tests,293,"This pull request changes the compat entry for the `NCDatasets` package from `^0.10, ^0.11` to `^0.10, ^0.11, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2313
https://github.com/CliMA/Oceananigans.jl/pull/2314:187,Testability,test,tested,187,"This pull request changes the compat entry for the `NCDatasets` package from `^0.10, ^0.11` to `^0.10, ^0.11, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2314
https://github.com/CliMA/Oceananigans.jl/pull/2314:293,Testability,test,tests,293,"This pull request changes the compat entry for the `NCDatasets` package from `^0.10, ^0.11` to `^0.10, ^0.11, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2314
https://github.com/CliMA/Oceananigans.jl/pull/2315:187,Testability,test,tested,187,"This pull request changes the compat entry for the `NCDatasets` package from `^0.10, ^0.11` to `^0.10, ^0.11, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2315
https://github.com/CliMA/Oceananigans.jl/pull/2315:293,Testability,test,tests,293,"This pull request changes the compat entry for the `NCDatasets` package from `^0.10, ^0.11` to `^0.10, ^0.11, 0.12`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2315
https://github.com/CliMA/Oceananigans.jl/pull/2316:383,Availability,Error,Error,383,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316
https://github.com/CliMA/Oceananigans.jl/pull/2316:471,Availability,ERROR,ERROR,471,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316
https://github.com/CliMA/Oceananigans.jl/pull/2316:905,Availability,error,error,905,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316
https://github.com/CliMA/Oceananigans.jl/pull/2316:932,Availability,error,error,932,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316
https://github.com/CliMA/Oceananigans.jl/pull/2316:8,Deployability,update,updates,8,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316
https://github.com/CliMA/Oceananigans.jl/pull/2316:949,Testability,assert,assertscalar,949,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316
https://github.com/CliMA/Oceananigans.jl/pull/2317:191,Availability,down,download,191,"This PR is a first, explorational, attempt to introduce higher order (upwind and WENO) schemes in a Vector Invariant formulation (following chapter 7 of https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.705.7543&rep=rep1&type=pdf). To test them, this PR also revamps some test cases implemented by @sandreza in #1570 and new ones from the test set of Williamson et al 1992. Here a comparison between the 2nd order vector invariant scheme and the WENO vector invariant scheme on the Rossby-Haurwitz wave test case implemented in #1570 with an Implicit free surface formulation (`g = 900 ms⁻²`) and no dissipation. The video shows contours of vertical vorticity. https://user-images.githubusercontent.com/33547697/156962391-77527d5d-a059-450e-b3bb-a517237e485c.mp4. This is a first exploration. I am not completely convinced WENO interpolation can be used for vorticity onto curvilinear coordinates without a proper coordinate transform (although this is what we do for tracers...). Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). The same was happening when using uniform WENO on a stretched grid. It actually seems that a coordinate transformation should be applied and WENO weights should be different in case of a curvilinear grid (https://arxiv.org/pdf/1711.06212.pdf). . Applying WENO one dimension at a time instead of doing a full 2D/3D interpolation might also be incorrect for FV... (This might also impact how we do tracer advection with WENO on curvilinear grids)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317
https://github.com/CliMA/Oceananigans.jl/pull/2317:243,Testability,test,test,243,"This PR is a first, explorational, attempt to introduce higher order (upwind and WENO) schemes in a Vector Invariant formulation (following chapter 7 of https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.705.7543&rep=rep1&type=pdf). To test them, this PR also revamps some test cases implemented by @sandreza in #1570 and new ones from the test set of Williamson et al 1992. Here a comparison between the 2nd order vector invariant scheme and the WENO vector invariant scheme on the Rossby-Haurwitz wave test case implemented in #1570 with an Implicit free surface formulation (`g = 900 ms⁻²`) and no dissipation. The video shows contours of vertical vorticity. https://user-images.githubusercontent.com/33547697/156962391-77527d5d-a059-450e-b3bb-a517237e485c.mp4. This is a first exploration. I am not completely convinced WENO interpolation can be used for vorticity onto curvilinear coordinates without a proper coordinate transform (although this is what we do for tracers...). Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). The same was happening when using uniform WENO on a stretched grid. It actually seems that a coordinate transformation should be applied and WENO weights should be different in case of a curvilinear grid (https://arxiv.org/pdf/1711.06212.pdf). . Applying WENO one dimension at a time instead of doing a full 2D/3D interpolation might also be incorrect for FV... (This might also impact how we do tracer advection with WENO on curvilinear grids)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317
https://github.com/CliMA/Oceananigans.jl/pull/2317:280,Testability,test,test,280,"This PR is a first, explorational, attempt to introduce higher order (upwind and WENO) schemes in a Vector Invariant formulation (following chapter 7 of https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.705.7543&rep=rep1&type=pdf). To test them, this PR also revamps some test cases implemented by @sandreza in #1570 and new ones from the test set of Williamson et al 1992. Here a comparison between the 2nd order vector invariant scheme and the WENO vector invariant scheme on the Rossby-Haurwitz wave test case implemented in #1570 with an Implicit free surface formulation (`g = 900 ms⁻²`) and no dissipation. The video shows contours of vertical vorticity. https://user-images.githubusercontent.com/33547697/156962391-77527d5d-a059-450e-b3bb-a517237e485c.mp4. This is a first exploration. I am not completely convinced WENO interpolation can be used for vorticity onto curvilinear coordinates without a proper coordinate transform (although this is what we do for tracers...). Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). The same was happening when using uniform WENO on a stretched grid. It actually seems that a coordinate transformation should be applied and WENO weights should be different in case of a curvilinear grid (https://arxiv.org/pdf/1711.06212.pdf). . Applying WENO one dimension at a time instead of doing a full 2D/3D interpolation might also be incorrect for FV... (This might also impact how we do tracer advection with WENO on curvilinear grids)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317
https://github.com/CliMA/Oceananigans.jl/pull/2317:347,Testability,test,test,347,"This PR is a first, explorational, attempt to introduce higher order (upwind and WENO) schemes in a Vector Invariant formulation (following chapter 7 of https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.705.7543&rep=rep1&type=pdf). To test them, this PR also revamps some test cases implemented by @sandreza in #1570 and new ones from the test set of Williamson et al 1992. Here a comparison between the 2nd order vector invariant scheme and the WENO vector invariant scheme on the Rossby-Haurwitz wave test case implemented in #1570 with an Implicit free surface formulation (`g = 900 ms⁻²`) and no dissipation. The video shows contours of vertical vorticity. https://user-images.githubusercontent.com/33547697/156962391-77527d5d-a059-450e-b3bb-a517237e485c.mp4. This is a first exploration. I am not completely convinced WENO interpolation can be used for vorticity onto curvilinear coordinates without a proper coordinate transform (although this is what we do for tracers...). Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). The same was happening when using uniform WENO on a stretched grid. It actually seems that a coordinate transformation should be applied and WENO weights should be different in case of a curvilinear grid (https://arxiv.org/pdf/1711.06212.pdf). . Applying WENO one dimension at a time instead of doing a full 2D/3D interpolation might also be incorrect for FV... (This might also impact how we do tracer advection with WENO on curvilinear grids)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317
https://github.com/CliMA/Oceananigans.jl/pull/2317:511,Testability,test,test,511,"This PR is a first, explorational, attempt to introduce higher order (upwind and WENO) schemes in a Vector Invariant formulation (following chapter 7 of https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.705.7543&rep=rep1&type=pdf). To test them, this PR also revamps some test cases implemented by @sandreza in #1570 and new ones from the test set of Williamson et al 1992. Here a comparison between the 2nd order vector invariant scheme and the WENO vector invariant scheme on the Rossby-Haurwitz wave test case implemented in #1570 with an Implicit free surface formulation (`g = 900 ms⁻²`) and no dissipation. The video shows contours of vertical vorticity. https://user-images.githubusercontent.com/33547697/156962391-77527d5d-a059-450e-b3bb-a517237e485c.mp4. This is a first exploration. I am not completely convinced WENO interpolation can be used for vorticity onto curvilinear coordinates without a proper coordinate transform (although this is what we do for tracers...). Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). The same was happening when using uniform WENO on a stretched grid. It actually seems that a coordinate transformation should be applied and WENO weights should be different in case of a curvilinear grid (https://arxiv.org/pdf/1711.06212.pdf). . Applying WENO one dimension at a time instead of doing a full 2D/3D interpolation might also be incorrect for FV... (This might also impact how we do tracer advection with WENO on curvilinear grids)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317
https://github.com/CliMA/Oceananigans.jl/pull/2320:404,Deployability,integrat,integration,404,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320
https://github.com/CliMA/Oceananigans.jl/pull/2320:404,Integrability,integrat,integration,404,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320
https://github.com/CliMA/Oceananigans.jl/pull/2320:541,Integrability,depend,dependent,541,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320
https://github.com/CliMA/Oceananigans.jl/pull/2320:460,Performance,optimiz,optimizations,460,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320
https://github.com/CliMA/Oceananigans.jl/pull/2320:756,Testability,test,test,756,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320
https://github.com/CliMA/Oceananigans.jl/issues/2321:426,Availability,error,error,426,"Unfortunately I don't have an example of this on hand (and our tests don't catch it), but I've noticed occasional irregularities in output writing that are presumably due to rounding artifacts when aligning a time-step for `TimeInterval`. One common case is that I run a parameter sweep and one of the files is one iteration shorter than another. This is often at the end of a long run. I think the culprit might be round-off error when computing `align_time_step` or `schedule_aligned_Δt`. Maybe using `Base.TwicePrecision` for some of the calculations would solve the problem?. Here's some of the code involved:. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Simulations/run.jl#L43-L58. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L51. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L152",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321
https://github.com/CliMA/Oceananigans.jl/issues/2321:831,Energy Efficiency,schedul,schedules,831,"Unfortunately I don't have an example of this on hand (and our tests don't catch it), but I've noticed occasional irregularities in output writing that are presumably due to rounding artifacts when aligning a time-step for `TimeInterval`. One common case is that I run a parameter sweep and one of the files is one iteration shorter than another. This is often at the end of a long run. I think the culprit might be round-off error when computing `align_time_step` or `schedule_aligned_Δt`. Maybe using `Base.TwicePrecision` for some of the calculations would solve the problem?. Here's some of the code involved:. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Simulations/run.jl#L43-L58. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L51. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L152",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321
https://github.com/CliMA/Oceananigans.jl/issues/2321:946,Energy Efficiency,schedul,schedules,946,"Unfortunately I don't have an example of this on hand (and our tests don't catch it), but I've noticed occasional irregularities in output writing that are presumably due to rounding artifacts when aligning a time-step for `TimeInterval`. One common case is that I run a parameter sweep and one of the files is one iteration shorter than another. This is often at the end of a long run. I think the culprit might be round-off error when computing `align_time_step` or `schedule_aligned_Δt`. Maybe using `Base.TwicePrecision` for some of the calculations would solve the problem?. Here's some of the code involved:. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Simulations/run.jl#L43-L58. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L51. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L152",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321
https://github.com/CliMA/Oceananigans.jl/issues/2321:63,Testability,test,tests,63,"Unfortunately I don't have an example of this on hand (and our tests don't catch it), but I've noticed occasional irregularities in output writing that are presumably due to rounding artifacts when aligning a time-step for `TimeInterval`. One common case is that I run a parameter sweep and one of the files is one iteration shorter than another. This is often at the end of a long run. I think the culprit might be round-off error when computing `align_time_step` or `schedule_aligned_Δt`. Maybe using `Base.TwicePrecision` for some of the calculations would solve the problem?. Here's some of the code involved:. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Simulations/run.jl#L43-L58. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L51. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L152",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321
https://github.com/CliMA/Oceananigans.jl/pull/2324:9,Testability,test,tests,9,Timestep tests gave yet again become too long. (~3hrs on gpu); This PR attempts to split them. Closes #2325.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324
https://github.com/CliMA/Oceananigans.jl/pull/2329:62,Testability,test,tests,62,This PR attempts to enable Codecov code coverage reports from tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329
https://github.com/CliMA/Oceananigans.jl/issues/2330:383,Availability,down,downgrade,383,"Not sure someone already created this issue.; I know this is too new for having documentation yet, and I am only creating the issue to have it on the list.; I am trying to use CATKE vertical diffusivity for an experiment. Currently I am using Julia-1.6.5 and Oceananigans v0.72.0 it returned `UndefVarError: CATKEVerticalDiffusivity not defined`.; Am I calling it wrong? Or should I downgrade to v0.71.3 (@glwagner mentioned CATKE is available for this version).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330
https://github.com/CliMA/Oceananigans.jl/issues/2330:434,Availability,avail,available,434,"Not sure someone already created this issue.; I know this is too new for having documentation yet, and I am only creating the issue to have it on the list.; I am trying to use CATKE vertical diffusivity for an experiment. Currently I am using Julia-1.6.5 and Oceananigans v0.72.0 it returned `UndefVarError: CATKEVerticalDiffusivity not defined`.; Am I calling it wrong? Or should I downgrade to v0.71.3 (@glwagner mentioned CATKE is available for this version).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330
https://github.com/CliMA/Oceananigans.jl/pull/2335:241,Energy Efficiency,Reduce,Reduced,241,"changes in this PR. instead of doing individual halo filling for each fill, ex:; ```; fill_halo_regions(<:Tuple, args...); for field in fields ; fill_halo_regions!(field, args...); end; ```. we'll lump all the fields together in a kernel,; (Reduced Fields and Windowed Fields will have to be done separately). This PR also removes `architecture` from `fill_halo_regions!` signature",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335
https://github.com/CliMA/Oceananigans.jl/issues/2336:1065,Availability,error,error,1065,"ght?. I am trying to create an Oceananigans version for [iuryt/ocean_gyre_tank](https://github.com/iuryt/ocean_gyre_tank).; For the surface momentum flux I am using. ```; p = (; cᴰ = 2.5e-3, # dimensionless drag coefficient; ρₐ = 1.225, # kg m⁻³, average density of air at sea-level; ρₒ = 1026, # kg m⁻³, average density at the surface of the world ocean; L = 0.23meters,; H = 0.15meters,; Ny = 100,; Nx = 100,; Nz = 20,; ). radius(x,y) = sqrt(x^2 + y^2); U(x,y,L) = sin(π * radius(x,y) / L)*exp(1im*angle(x+y*1im)); Qᵘ(x,y,z,t,p) = radius(x,y)<p.L ? imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x,y,p.L) * abs(U(x,y,p.L))) : 0 # m² s⁻²; Qᵛ(x,y,z,t,p) = radius(x,y)<p.L ? - real(p.ρₐ / p.ρₒ * p.cᴰ * U(x,y,p.L) * abs(U(x,y,p.L))) : 0 # m² s⁻². u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ, parameters=p)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵛ, parameters=p)); ```. Which returns the error below when I try to run the simulation: ; <details>; <summary>Click to expand!</summary>; ; ```; ┌ Warning: Cannot serialize timeseries/u/serialized/boundary_conditions as it contains functions. Will replace with missing. Function boundary conditions must be restored manually.; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:65; ┌ Warning: Cannot serialize timeseries/v/serialized/boundary_conditions as it contains functions. Will replace with missing. Function boundary conditions must be restored manually.; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:65; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (36.847 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:2304,Availability,error,error,2304,"c/OutputWriters/output_writer_utils.jl:65; ┌ Warning: Cannot serialize timeseries/v/serialized/boundary_conditions as it contains functions. Will replace with missing. Function boundary conditions must be restored manually.; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:65; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (36.847 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; TaskFailedException. nested task error: TaskFailedException; ; nested task error: UndefKeywordError: keyword argument p not assigned; Stacktrace:; [1] Qᵘ(::Float64, ::Float64, ::Float64, ::NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}); @ ./In[3]:1 [inlined]; [2] overdub; @ ./In[3]:1 [inlined]; [3] overdub; @ ~/.julia/packages/Oceananigans/CuznF/src/BoundaryConditions/continuous_boundary_function.jl:122 [inlined]; [4] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, ::Int64, ::Int64, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:2346,Availability,error,error,2346,"c/OutputWriters/output_writer_utils.jl:65; ┌ Warning: Cannot serialize timeseries/v/serialized/boundary_conditions as it contains functions. Will replace with missing. Function boundary conditions must be restored manually.; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:65; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (36.847 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; TaskFailedException. nested task error: TaskFailedException; ; nested task error: UndefKeywordError: keyword argument p not assigned; Stacktrace:; [1] Qᵘ(::Float64, ::Float64, ::Float64, ::NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}); @ ./In[3]:1 [inlined]; [2] overdub; @ ./In[3]:1 [inlined]; [3] overdub; @ ~/.julia/packages/Oceananigans/CuznF/src/BoundaryConditions/continuous_boundary_function.jl:122 [inlined]; [4] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, ::Int64, ::Int64, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:61038,Availability,avail,available,61038,"tion{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}); @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/CuznF/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:155; [4] calculate_tendencies!; @ ~/.julia/packages/Oceananigans/CuznF/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:42 [inlined]; .; .; .; ```; </details>. Full code available at [OceanGyreTank.jl](https://github.com/iuryt/OceanGyreTank.jl/commit/5f132ac6b3ff0541d7f501a00d9560ec017651ea)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:2865,Deployability,Continuous,ContinuousBoundaryFunction,2865,"ons /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; TaskFailedException. nested task error: TaskFailedException; ; nested task error: UndefKeywordError: keyword argument p not assigned; Stacktrace:; [1] Qᵘ(::Float64, ::Float64, ::Float64, ::NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}); @ ./In[3]:1 [inlined]; [2] overdub; @ ./In[3]:1 [inlined]; [3] overdub; @ ~/.julia/packages/Oceananigans/CuznF/src/BoundaryConditions/continuous_boundary_function.jl:122 [inlined]; [4] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, ::Int64, ::Int64, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:4619,Deployability,Continuous,ContinuousBoundaryFunction,4619,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:5929,Deployability,Continuous,ContinuousBoundaryFunction,5929,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:12025,Deployability,Continuous,ContinuousBoundaryFunction,12025,"daryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Face, Center, Center}, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, Clock{Float64}, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:13313,Deployability,Continuous,ContinuousBoundaryFunction,13313,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:14623,Deployability,Continuous,ContinuousBoundaryFunction,14623,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:20288,Deployability,Continuous,ContinuousBoundaryFunction,20288,"daryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Face, Center, Center}, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, Clock{Float64}, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:21576,Deployability,Continuous,ContinuousBoundaryFunction,21576,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:22886,Deployability,Continuous,ContinuousBoundaryFunction,22886,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:28670,Deployability,Continuous,ContinuousBoundaryFunction,28670,"daryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Face, Center, Center}, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, Clock{Float64}, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:29958,Deployability,Continuous,ContinuousBoundaryFunction,29958,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:31268,Deployability,Continuous,ContinuousBoundaryFunction,31268,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:37018,Deployability,Continuous,ContinuousBoundaryFunction,37018,"daryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Face, Center, Center}, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, Clock{Float64}, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:38306,Deployability,Continuous,ContinuousBoundaryFunction,38306,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:39616,Deployability,Continuous,ContinuousBoundaryFunction,39616,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:49923,Deployability,Continuous,ContinuousBoundaryFunction,49923,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:51233,Deployability,Continuous,ContinuousBoundaryFunction,51233,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:55873,Deployability,Continuous,ContinuousBoundaryFunction,55873,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2336:57183,Deployability,Continuous,ContinuousBoundaryFunction,57183,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, 20, typeof(Qᵛ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336
https://github.com/CliMA/Oceananigans.jl/issues/2337:215,Integrability,depend,depend,215,"How to create field derived fields? For instance, if I want the model to calculate and save Richardson number fields. Also, I saw that the diffusivity can be a function of x,y,z,t, can I easily give a function that depend on the Richardson number or do I need to implement it as a Turbulence closure?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337
https://github.com/CliMA/Oceananigans.jl/issues/2340:352,Integrability,depend,dependencies,352,"Wondering if it'd be nicer to write. ```julia; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, velocities, tracers.b); ```. rather than the current syntax. ```julia; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); ```. I think we can document the fact that the ""dependencies"" (really, arguments to the kernel function) are computed. I'm actually not sure if it's so common to nest fields that require computation into a `KernelFunctionOperation`. It seems like that's maybe an edge case and most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". @tomchor you have used this the most, what do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340
https://github.com/CliMA/Oceananigans.jl/issues/2340:659,Integrability,depend,dependencies,659,"Wondering if it'd be nicer to write. ```julia; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, velocities, tracers.b); ```. rather than the current syntax. ```julia; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); ```. I think we can document the fact that the ""dependencies"" (really, arguments to the kernel function) are computed. I'm actually not sure if it's so common to nest fields that require computation into a `KernelFunctionOperation`. It seems like that's maybe an edge case and most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". @tomchor you have used this the most, what do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340
https://github.com/CliMA/Oceananigans.jl/issues/2340:724,Integrability,depend,dependencies,724,"Wondering if it'd be nicer to write. ```julia; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, velocities, tracers.b); ```. rather than the current syntax. ```julia; Ri_op = KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(velocities, tracers.b)); ```. I think we can document the fact that the ""dependencies"" (really, arguments to the kernel function) are computed. I'm actually not sure if it's so common to nest fields that require computation into a `KernelFunctionOperation`. It seems like that's maybe an edge case and most of the time we are just using ordinary numbers, fields, etc as ""computed dependencies"" and in that case it's silly to call them ""computed dependencies"". @tomchor you have used this the most, what do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340
https://github.com/CliMA/Oceananigans.jl/issues/2341:1027,Availability,ERROR,ERROR,1027,"This:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [-100.0, 0.0] regularly spaced with Δz=0.78125. julia> fake_model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: Nothing; ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing. julia> real_model = HydrostaticFreeSurfaceModel(; grid,; velocities = fake_model.velocities,; tracers = fake_model.tracers,; buoyancy = BuoyancyTracer()); ```. gives. ```julia; ERROR: MethodError: no method matching HydrostaticFreeSurfaceVelocityFields(::NamedTuple{(:u, :v, :w), ...; ```. I believe this is supported by `NonhydrostaticModel` so we should probably support it for the hydrostatic model too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2341
https://github.com/CliMA/Oceananigans.jl/issues/2342:810,Availability,ERROR,ERROR,810,"Eg for. ```julia; julia> κ; BinaryOperation at (Center, Center, Center); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; └── tree:; + at (Center, Center, Center);    ├── 1.0e-5;    └── / at (Center, Center, Center);       ├── 0.01;       └── + at (Center, Center, Center);          ├── 1;          └── * at (Center, Center, Center);             ├── 5;             └── ^ at (Center, Center, Center);                ├── 1×1×128 Field{Center, Center, Center} on RectilinearGrid on CPU;                └── 3; ```. we get. ```julia; julia> closure = ScalarDiffusivity(; κ); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=BinaryOperation at (Center, Center, Center)). julia> model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer()); ERROR: MethodError: no method matching tracer_diffusivities(::Tuple{Symbol}, ::BinaryOperation{Center, Center, Center, typeof(+); ```. It looks like `tracer_diffusivities` is being used to catch invalid diffusivity fields cause. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/TurbulenceClosures/turbulence_closure_utils.jl#L3. But it's kinda silly cause. ```julia; julia> closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). julia> model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer()); ```. works just fine. So we should either. 1. Include `AbstractArray` in objects supported by `tracer_diffusivities`, and throw a useful error as a fallback rather than going to `MethodError`; 2. Relax https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/TurbulenceClosures/turbulence_closure_utils.jl#L3 to a fallback so it works for any object",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2342
https://github.com/CliMA/Oceananigans.jl/issues/2342:1547,Availability,error,error,1547,"Eg for. ```julia; julia> κ; BinaryOperation at (Center, Center, Center); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; └── tree:; + at (Center, Center, Center);    ├── 1.0e-5;    └── / at (Center, Center, Center);       ├── 0.01;       └── + at (Center, Center, Center);          ├── 1;          └── * at (Center, Center, Center);             ├── 5;             └── ^ at (Center, Center, Center);                ├── 1×1×128 Field{Center, Center, Center} on RectilinearGrid on CPU;                └── 3; ```. we get. ```julia; julia> closure = ScalarDiffusivity(; κ); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=BinaryOperation at (Center, Center, Center)). julia> model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer()); ERROR: MethodError: no method matching tracer_diffusivities(::Tuple{Symbol}, ::BinaryOperation{Center, Center, Center, typeof(+); ```. It looks like `tracer_diffusivities` is being used to catch invalid diffusivity fields cause. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/TurbulenceClosures/turbulence_closure_utils.jl#L3. But it's kinda silly cause. ```julia; julia> closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). julia> model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer()); ```. works just fine. So we should either. 1. Include `AbstractArray` in objects supported by `tracer_diffusivities`, and throw a useful error as a fallback rather than going to `MethodError`; 2. Relax https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/TurbulenceClosures/turbulence_closure_utils.jl#L3 to a fallback so it works for any object",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2342
https://github.com/CliMA/Oceananigans.jl/issues/2347:27,Availability,error,error,27,"I am getting the following error from benchmark/distributed_nonhydrostatic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:167,Availability,error,error,167,"I am getting the following error from benchmark/distributed_nonhydrostatic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:1798,Availability,ERROR,ERROR,1798,"2.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:1805,Availability,ERROR,ERROR,1805,"2.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:1812,Performance,Load,LoadError,1812,"2.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:1823,Performance,Load,LoadError,1823,"2.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:38,Testability,benchmark,benchmark,38,"I am getting the following error from benchmark/distributed_nonhydrostatic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:231,Testability,test,tests,231,"I am getting the following error from benchmark/distributed_nonhydrostatic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:674,Testability,Benchmark,Benchmarking,674,"I am getting the following error from benchmark/distributed_nonhydrostatic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:1048,Testability,Benchmark,Benchmarking,1048,"tic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:1144,Testability,benchmark,benchmarking,1144,"get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/issues/2347:1223,Testability,Benchmark,Benchmarking,1223,"w water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347
https://github.com/CliMA/Oceananigans.jl/pull/2348:21,Security,validat,validation,21,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348
https://github.com/CliMA/Oceananigans.jl/pull/2348:49,Testability,test,tests,49,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348
https://github.com/CliMA/Oceananigans.jl/pull/2348:123,Testability,benchmark,benchmark,123,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348
https://github.com/CliMA/Oceananigans.jl/pull/2348:184,Testability,benchmark,benchmark,184,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348
https://github.com/CliMA/Oceananigans.jl/pull/2348:322,Usability,simpl,simple,322,"This PR adds another validation script for quick tests and such of distributed `NonhydrostaticModel`. We've been using the benchmark script, but that has additional features (and as a benchmark, is expensive to run). Hopefully these prove useful for fleshing out support for distributed cases. Right now I've just added a simple 2D turbulence script. TODO:; - [x] Add output to 2D turbulence script; - [ ] Add a 3D `NonhydrostaticModel` case; - [ ] Add `HydrostaticFreeSurfaceModel` case; - [ ] Add a script that runs into #2347 . cc @johnryantaylor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2348
https://github.com/CliMA/Oceananigans.jl/issues/2349:1425,Energy Efficiency,reduce,reduce,1425,"h`.; * Probably `MultiArch` should take a similar approach as the grid constructor; ie we can't distribute a grid in `Flat` directions, so `ranks` should be a 2-tuple for 2D topology, 1-element for 1D topology.; * We might want some functions for `arch` (and also `grid`, `model`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:14",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:1746,Energy Efficiency,Reduce,ReducedField,1746,"h`.; * Probably `MultiArch` should take a similar approach as the grid constructor; ie we can't distribute a grid in `Flat` directions, so `ranks` should be a 2-tuple for 2D topology, 1-element for 1D topology.; * We might want some functions for `arch` (and also `grid`, `model`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:14",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:1802,Energy Efficiency,reduce,reduce,1802,"l`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simula",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:1877,Energy Efficiency,Reduce,ReducedField,1877,"s eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:2088,Energy Efficiency,Reduce,ReducedField,2088,"em like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:1708,Modifiability,extend,extend,1708,"h`.; * Probably `MultiArch` should take a similar approach as the grid constructor; ie we can't distribute a grid in `Flat` directions, so `ranks` should be a 2-tuple for 2D topology, 1-element for 1D topology.; * We might want some functions for `arch` (and also `grid`, `model`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:14",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:2130,Performance,optimiz,optimize,2130,"em like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:2143,Performance,perform,performance,2143,"em like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:2222,Safety,avoid,avoids,2222,"le-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time step...; [ Info: ... simulation initialization complete (8.565 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (42.937 seconds).; [ Info: ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:1339,Testability,log,logs,1339,"h`.; * Probably `MultiArch` should take a similar approach as the grid constructor; ie we can't distribute a grid in `Flat` directions, so `ranks` should be a 2-tuple for 2D topology, 1-element for 1D topology.; * We might want some functions for `arch` (and also `grid`, `model`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:14",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:2197,Testability,log,logger,2197,"le-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time step...; [ Info: ... simulation initialization complete (8.565 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (42.937 seconds).; [ Info: ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:2237,Testability,log,logging,2237,"le-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.46e-01; [ Info: Rank 0: max|ζ|: 7.58e+01, max(e): 2.31e-01; [ Info: ... simulation initialization complete (9.536 seconds); [ Info: Executing initial time step...; [ Info: ... simulation initialization complete (8.565 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (42.937 seconds).; [ Info: ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2349:1926,Usability,clear,clearly,1926,"s eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:144; [ Info: Initializing simulation...; [ Info: Initializing simulation...; [ Info: Iteration: 0, time: 0 seconds; [ Info: Rank 1: max|ζ|: 7.80e+01, max(e): 2.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349
https://github.com/CliMA/Oceananigans.jl/issues/2350:609,Testability,test,test,609,"Launching. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(MPI.COMM_WORLD). # Setup model; topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), extent=(2π, 2π)); c = CenterField(grid). f(x, y, z) = rand(); set!(c, f); cmax = maximum(c); @info ""(function) rank $rank has max|c|: $cmax"". a = rand(size(c)...); set!(c, a); cmax = maximum(c); @info ""(array) rank $rank has max|c|: $cmax""; ```. in a file `test.jl` with. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl; ```. produces. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl [18:22:01]; [ Info: (function) rank 0 has max|c|: 0.0; [ Info: (function) rank 1 has max|c|: 0.0; [ Info: (array) rank 0 has max|c|: 0.9891116380008036; [ Info: (array) rank 1 has max|c|: 0.9963683297139798; ```. So `set!` works with `Array` but not functions. `set! for distributed model should be fixed and tested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2350
https://github.com/CliMA/Oceananigans.jl/issues/2350:680,Testability,test,test,680,"Launching. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(MPI.COMM_WORLD). # Setup model; topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), extent=(2π, 2π)); c = CenterField(grid). f(x, y, z) = rand(); set!(c, f); cmax = maximum(c); @info ""(function) rank $rank has max|c|: $cmax"". a = rand(size(c)...); set!(c, a); cmax = maximum(c); @info ""(array) rank $rank has max|c|: $cmax""; ```. in a file `test.jl` with. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl; ```. produces. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl [18:22:01]; [ Info: (function) rank 0 has max|c|: 0.0; [ Info: (function) rank 1 has max|c|: 0.0; [ Info: (array) rank 0 has max|c|: 0.9891116380008036; [ Info: (array) rank 1 has max|c|: 0.9963683297139798; ```. So `set!` works with `Array` but not functions. `set! for distributed model should be fixed and tested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2350
https://github.com/CliMA/Oceananigans.jl/issues/2350:760,Testability,test,test,760,"Launching. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(MPI.COMM_WORLD). # Setup model; topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), extent=(2π, 2π)); c = CenterField(grid). f(x, y, z) = rand(); set!(c, f); cmax = maximum(c); @info ""(function) rank $rank has max|c|: $cmax"". a = rand(size(c)...); set!(c, a); cmax = maximum(c); @info ""(array) rank $rank has max|c|: $cmax""; ```. in a file `test.jl` with. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl; ```. produces. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl [18:22:01]; [ Info: (function) rank 0 has max|c|: 0.0; [ Info: (function) rank 1 has max|c|: 0.0; [ Info: (array) rank 0 has max|c|: 0.9891116380008036; [ Info: (array) rank 1 has max|c|: 0.9963683297139798; ```. So `set!` works with `Array` but not functions. `set! for distributed model should be fixed and tested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2350
https://github.com/CliMA/Oceananigans.jl/issues/2350:1077,Testability,test,tested,1077,"Launching. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(MPI.COMM_WORLD). # Setup model; topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), extent=(2π, 2π)); c = CenterField(grid). f(x, y, z) = rand(); set!(c, f); cmax = maximum(c); @info ""(function) rank $rank has max|c|: $cmax"". a = rand(size(c)...); set!(c, a); cmax = maximum(c); @info ""(array) rank $rank has max|c|: $cmax""; ```. in a file `test.jl` with. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl; ```. produces. ```; $ JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project test.jl [18:22:01]; [ Info: (function) rank 0 has max|c|: 0.0; [ Info: (function) rank 1 has max|c|: 0.0; [ Info: (array) rank 0 has max|c|: 0.9891116380008036; [ Info: (array) rank 1 has max|c|: 0.9963683297139798; ```. So `set!` works with `Array` but not functions. `set! for distributed model should be fixed and tested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2350
https://github.com/CliMA/Oceananigans.jl/issues/2352:996,Availability,error,errors,996,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352
https://github.com/CliMA/Oceananigans.jl/issues/2352:759,Energy Efficiency,schedul,schedule,759,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352
https://github.com/CliMA/Oceananigans.jl/issues/2352:1088,Security,access,access,1088,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352
https://github.com/CliMA/Oceananigans.jl/issues/2352:1473,Usability,clear,clearly,1473,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352
https://github.com/CliMA/Oceananigans.jl/issues/2355:609,Availability,avail,available,609,"I was wondering if it would be advantageous to have a place dedicated to document the features that are still experimental. I think that'd make it easier for other people to contribute to those features and having them mature faster. The main motivation for me to ask this is that often users (myself included) will ask about a particular feature that's still under development (generally immersed solids or parallelism), and someone ends up describing the state of affairs at that point and pointing to a validation script and the user has to figure everything out from there. I realize all these things are available in issues and PRs, but it's hard to find the right ones and distill what's ""relevant"" information from there. I'm going through that this moment with `ImmersedBoundaryGrid`, which I'm trying to advance. I can work backwards from a given script to figure out how the implementation exists now and get a sense of to expand it, but it'd be way easier if I could read about what's implemented already, why that's the chosen implementation, bumps on the road, etc. Another motivation is that the code has grown so much lately that I sometimes see PRs/issues here about some features and I realize I simply don't recognize (and I'm fairly involved with Oceananigans' development). Some of those features might be useful for my research, or they may be things that I'd be interest in developing that I'm missing out on. Possible places to host that info would be a dedicated section of the docs possibly named ""Experimental features"", but maybe the easiest way would be allowing a wiki for that. I think discussions wouldn't be as organized. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355
https://github.com/CliMA/Oceananigans.jl/issues/2355:506,Security,validat,validation,506,"I was wondering if it would be advantageous to have a place dedicated to document the features that are still experimental. I think that'd make it easier for other people to contribute to those features and having them mature faster. The main motivation for me to ask this is that often users (myself included) will ask about a particular feature that's still under development (generally immersed solids or parallelism), and someone ends up describing the state of affairs at that point and pointing to a validation script and the user has to figure everything out from there. I realize all these things are available in issues and PRs, but it's hard to find the right ones and distill what's ""relevant"" information from there. I'm going through that this moment with `ImmersedBoundaryGrid`, which I'm trying to advance. I can work backwards from a given script to figure out how the implementation exists now and get a sense of to expand it, but it'd be way easier if I could read about what's implemented already, why that's the chosen implementation, bumps on the road, etc. Another motivation is that the code has grown so much lately that I sometimes see PRs/issues here about some features and I realize I simply don't recognize (and I'm fairly involved with Oceananigans' development). Some of those features might be useful for my research, or they may be things that I'd be interest in developing that I'm missing out on. Possible places to host that info would be a dedicated section of the docs possibly named ""Experimental features"", but maybe the easiest way would be allowing a wiki for that. I think discussions wouldn't be as organized. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355
https://github.com/CliMA/Oceananigans.jl/issues/2355:1213,Usability,simpl,simply,1213,"I was wondering if it would be advantageous to have a place dedicated to document the features that are still experimental. I think that'd make it easier for other people to contribute to those features and having them mature faster. The main motivation for me to ask this is that often users (myself included) will ask about a particular feature that's still under development (generally immersed solids or parallelism), and someone ends up describing the state of affairs at that point and pointing to a validation script and the user has to figure everything out from there. I realize all these things are available in issues and PRs, but it's hard to find the right ones and distill what's ""relevant"" information from there. I'm going through that this moment with `ImmersedBoundaryGrid`, which I'm trying to advance. I can work backwards from a given script to figure out how the implementation exists now and get a sense of to expand it, but it'd be way easier if I could read about what's implemented already, why that's the chosen implementation, bumps on the road, etc. Another motivation is that the code has grown so much lately that I sometimes see PRs/issues here about some features and I realize I simply don't recognize (and I'm fairly involved with Oceananigans' development). Some of those features might be useful for my research, or they may be things that I'd be interest in developing that I'm missing out on. Possible places to host that info would be a dedicated section of the docs possibly named ""Experimental features"", but maybe the easiest way would be allowing a wiki for that. I think discussions wouldn't be as organized. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355
https://github.com/CliMA/Oceananigans.jl/issues/2356:285,Usability,intuit,intuitive,285,I have recently realized that the current definition of `gravity_unit_vector` is a vector that's in the _opposite_ direction to gravity:. https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/BuoyancyModels/buoyancy.jl#L11-L13. This sounds counter-intuitive to me. I wonder if we can come up with a better name. Maybe `buoyancy_unit_vector`? It can't be something like `vertical_unit_vector` because then we'd potentially run into inconsistencies (see https://github.com/CliMA/Oceananigans.jl/pull/2266).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2356
https://github.com/CliMA/Oceananigans.jl/issues/2358:479,Availability,error,error,479,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358
https://github.com/CliMA/Oceananigans.jl/issues/2358:492,Availability,error,error,492,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358
https://github.com/CliMA/Oceananigans.jl/issues/2358:1549,Availability,error,error,1549,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358
https://github.com/CliMA/Oceananigans.jl/issues/2358:1598,Availability,error,error,1598,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358
https://github.com/CliMA/Oceananigans.jl/issues/2358:1236,Deployability,update,update,1236,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358
https://github.com/CliMA/Oceananigans.jl/issues/2358:599,Testability,test,test,599,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358
https://github.com/CliMA/Oceananigans.jl/issues/2358:1421,Testability,test,tests,1421,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358
https://github.com/CliMA/Oceananigans.jl/issues/2358:1504,Testability,test,tests,1504,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358
https://github.com/CliMA/Oceananigans.jl/issues/2359:317,Availability,error,error,317,"First of all, thank god this model runs on GPU. It is awesome how fast this is!!. I am trying to run the the model using the following function for `ScalarDiffusivity`:; ```; width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; ```; which returns the error below while running the model. ```; ┌ Warning: Cannot save Function property into closure/2/ν; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Warning: Cannot save Function property into closure/2/κ/b; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (27.506 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 4000, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 16, 50)}, KernelAbstractions.NDIteration.StaticSize{(1, 256, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359
https://github.com/CliMA/Oceananigans.jl/issues/2359:3704,Availability,down,download,3704,", NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359
https://github.com/CliMA/Oceananigans.jl/issues/2359:4220,Energy Efficiency,meter,meters,4220," NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). h = 50meters # mld; Hv = 150meters # virtual h (stratification) ; S = 2.8 # m/s; c=2750kilometers # center of the storm; l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velociti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359
https://github.com/CliMA/Oceananigans.jl/issues/2359:5277,Energy Efficiency,schedul,schedule,5277,"ple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). h = 50meters # mld; Hv = 150meters # virtual h (stratification) ; S = 2.8 # m/s; c=2750kilometers # center of the storm; l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359
https://github.com/CliMA/Oceananigans.jl/issues/2359:286,Modifiability,layers,layers,286,"First of all, thank god this model runs on GPU. It is awesome how fast this is!!. I am trying to run the the model using the following function for `ScalarDiffusivity`:; ```; width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; ```; which returns the error below while running the model. ```; ┌ Warning: Cannot save Function property into closure/2/ν; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Warning: Cannot save Function property into closure/2/κ/b; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (27.506 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 4000, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 16, 50)}, KernelAbstractions.NDIteration.StaticSize{(1, 256, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359
https://github.com/CliMA/Oceananigans.jl/issues/2359:4446,Modifiability,layers,layers,4446,"ple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). h = 50meters # mld; Hv = 150meters # virtual h (stratification) ; S = 2.8 # m/s; c=2750kilometers # center of the storm; l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359
https://github.com/CliMA/Oceananigans.jl/issues/2359:3723,Testability,log,log,3723,", NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359
https://github.com/CliMA/Oceananigans.jl/issues/2359:3788,Testability,log,log,3788,":v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). h = 50meters # mld; Hv ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359
https://github.com/CliMA/Oceananigans.jl/issues/2363:125,Availability,error,error,125,"Can we output the super long message that appears on the REPL when running the model to a text file so that the actual *key* error message will not be overwhelmed by the other irrelevant stuff? Something like the default option in MITgcm with the STDOUT/STDERR files. For those who run on a terminal, this is probably fine because they can scroll up (assuming they don't miss it!) but in VScode there's a limit on how much you can output.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363
https://github.com/CliMA/Oceananigans.jl/issues/2363:29,Integrability,message,message,29,"Can we output the super long message that appears on the REPL when running the model to a text file so that the actual *key* error message will not be overwhelmed by the other irrelevant stuff? Something like the default option in MITgcm with the STDOUT/STDERR files. For those who run on a terminal, this is probably fine because they can scroll up (assuming they don't miss it!) but in VScode there's a limit on how much you can output.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363
https://github.com/CliMA/Oceananigans.jl/issues/2363:131,Integrability,message,message,131,"Can we output the super long message that appears on the REPL when running the model to a text file so that the actual *key* error message will not be overwhelmed by the other irrelevant stuff? Something like the default option in MITgcm with the STDOUT/STDERR files. For those who run on a terminal, this is probably fine because they can scroll up (assuming they don't miss it!) but in VScode there's a limit on how much you can output.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363
https://github.com/CliMA/Oceananigans.jl/issues/2364:9045,Energy Efficiency,reduce,reduced,9045,"ns.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}}, typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.identity3), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64}, Tuple{Int64}}(Statistics.mean!, BinaryOperation at (Center, Center, Center); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; └── tree:; * at (Center, Center, Center);    ├── - at (Center, Center, Center);    │   ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;    │   └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;    └── - at (Center, Center, Center);       ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;       └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU, (1,)); ```. cc @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2364
https://github.com/CliMA/Oceananigans.jl/issues/2364:9255,Energy Efficiency,reduce,reduced,9255,"ns.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}}, typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.identity3), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64}, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64}, Tuple{Int64}}(Statistics.mean!, BinaryOperation at (Center, Center, Center); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; └── tree:; * at (Center, Center, Center);    ├── - at (Center, Center, Center);    │   ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;    │   └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;    └── - at (Center, Center, Center);       ├── 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU;       └── 1×1×1 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU, (1,)); ```. cc @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2364
https://github.com/CliMA/Oceananigans.jl/issues/2367:522,Availability,error,error,522,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/issues/2367:559,Availability,ERROR,ERROR,559,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/issues/2367:660,Availability,error,error,660,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/issues/2367:851,Availability,error,error,851,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/issues/2367:929,Availability,error,error,929,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/issues/2367:1916,Availability,avail,available,1916,"ndaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/blob/main/OceanGyreTank.ipynb",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/issues/2367:1599,Performance,cache,cache,1599,"ndaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/blob/main/OceanGyreTank.ipynb",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/issues/2367:1791,Performance,cache,cache,1791,"ndaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/blob/main/OceanGyreTank.ipynb",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/issues/2367:685,Security,access,access,685,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367
https://github.com/CliMA/Oceananigans.jl/pull/2370:8,Deployability,update,updates,8,"This PR updates the `show()` method for `LatitudeLongitudeGrid` to denote which of the directions is latitude and which is longitude. It also updates the docstring to match the latest syntax. ### Before this PR. ```julia; julia> using Oceananigans. julia> LatitudeLongitudeGrid(size = (10, 4, 5),; latitude = (-40, 40),; longitude = (-20, 20),; z = (-2000, 0),; topology = (Periodic, Bounded, Bounded),; halo = (2, 2, 2)); 10×4×5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 2×2×2 halo and with precomputed metrics; ├── Periodic λ ∈ [-20.0, 20.0) regularly spaced with Δλ=4.0; ├── Bounded φ ∈ [-40.0, 40.0] regularly spaced with Δφ=20.0; └── Bounded z ∈ [-2000.0, 0.0] regularly spaced with Δz=400.0; ```. ### After this PR. ```Julia; julia> using Oceananigans. julia> LatitudeLongitudeGrid(size = (10, 4, 5),; latitude = (-40, 40),; longitude = (-20, 20),; z = (-2000, 0),; topology = (Periodic, Bounded, Bounded),; halo = (2, 2, 2)); 10×4×5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 2×2×2 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-20.0, 20.0) regularly spaced with Δλ=4.0; ├── latitude: Bounded φ ∈ [-40.0, 40.0] regularly spaced with Δφ=20.0; └── z: Bounded z ∈ [-2000.0, 0.0] regularly spaced with Δz=400.0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2370
https://github.com/CliMA/Oceananigans.jl/pull/2370:142,Deployability,update,updates,142,"This PR updates the `show()` method for `LatitudeLongitudeGrid` to denote which of the directions is latitude and which is longitude. It also updates the docstring to match the latest syntax. ### Before this PR. ```julia; julia> using Oceananigans. julia> LatitudeLongitudeGrid(size = (10, 4, 5),; latitude = (-40, 40),; longitude = (-20, 20),; z = (-2000, 0),; topology = (Periodic, Bounded, Bounded),; halo = (2, 2, 2)); 10×4×5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 2×2×2 halo and with precomputed metrics; ├── Periodic λ ∈ [-20.0, 20.0) regularly spaced with Δλ=4.0; ├── Bounded φ ∈ [-40.0, 40.0] regularly spaced with Δφ=20.0; └── Bounded z ∈ [-2000.0, 0.0] regularly spaced with Δz=400.0; ```. ### After this PR. ```Julia; julia> using Oceananigans. julia> LatitudeLongitudeGrid(size = (10, 4, 5),; latitude = (-40, 40),; longitude = (-20, 20),; z = (-2000, 0),; topology = (Periodic, Bounded, Bounded),; halo = (2, 2, 2)); 10×4×5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 2×2×2 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-20.0, 20.0) regularly spaced with Δλ=4.0; ├── latitude: Bounded φ ∈ [-40.0, 40.0] regularly spaced with Δφ=20.0; └── z: Bounded z ∈ [-2000.0, 0.0] regularly spaced with Δz=400.0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2370
https://github.com/CliMA/Oceananigans.jl/pull/2374:8,Deployability,update,updates,8,"This PR updates the dissipation and surface TKE flux parameter for CATKE. These were _not_ updated in #2273, but they should have been. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2374
https://github.com/CliMA/Oceananigans.jl/pull/2374:91,Deployability,update,updated,91,"This PR updates the dissipation and surface TKE flux parameter for CATKE. These were _not_ updated in #2273, but they should have been. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2374
https://github.com/CliMA/Oceananigans.jl/pull/2375:223,Availability,checkpoint,checkpoint,223,"This PR removes some of the warnings that output writers throw when trying to save or serialize functions to disk. These warnings are outdated in a way because they are really aimed at users trying to restore models from a checkpoint. Previously, we used to require that an entire model could be deserialized from disk when restoring from a checkpoint. This created special headaches for models that involved user-defined functions. . But now we have a much better and simpler way for restoring models from a checkpoint. As a result we rarely care whether or not boundary conditions are serialized to disk if they are functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2375
https://github.com/CliMA/Oceananigans.jl/pull/2375:341,Availability,checkpoint,checkpoint,341,"This PR removes some of the warnings that output writers throw when trying to save or serialize functions to disk. These warnings are outdated in a way because they are really aimed at users trying to restore models from a checkpoint. Previously, we used to require that an entire model could be deserialized from disk when restoring from a checkpoint. This created special headaches for models that involved user-defined functions. . But now we have a much better and simpler way for restoring models from a checkpoint. As a result we rarely care whether or not boundary conditions are serialized to disk if they are functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2375
https://github.com/CliMA/Oceananigans.jl/pull/2375:509,Availability,checkpoint,checkpoint,509,"This PR removes some of the warnings that output writers throw when trying to save or serialize functions to disk. These warnings are outdated in a way because they are really aimed at users trying to restore models from a checkpoint. Previously, we used to require that an entire model could be deserialized from disk when restoring from a checkpoint. This created special headaches for models that involved user-defined functions. . But now we have a much better and simpler way for restoring models from a checkpoint. As a result we rarely care whether or not boundary conditions are serialized to disk if they are functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2375
https://github.com/CliMA/Oceananigans.jl/pull/2375:469,Usability,simpl,simpler,469,"This PR removes some of the warnings that output writers throw when trying to save or serialize functions to disk. These warnings are outdated in a way because they are really aimed at users trying to restore models from a checkpoint. Previously, we used to require that an entire model could be deserialized from disk when restoring from a checkpoint. This created special headaches for models that involved user-defined functions. . But now we have a much better and simpler way for restoring models from a checkpoint. As a result we rarely care whether or not boundary conditions are serialized to disk if they are functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2375
https://github.com/CliMA/Oceananigans.jl/pull/2377:281,Testability,test,test,281,This PR fixes a bug that crept in during #2295 that affects closure tuples with more than one vertically-implicit closure. The bug was an incorrect calculation of the diagonal coefficient of the tridiagonal matrix that's solved to effect an implicit time-step. This PR also adds a test to the good ol' `test_diffusion_cosine` for a tuple of two vertically-implicit `VerticalScalarDiffusivity`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2377
https://github.com/CliMA/Oceananigans.jl/pull/2388:405,Deployability,Update,Update,405,"This PR investigates the possibility of using a convex combination of high-order stencils to calculate horizontal divergence. The goal is to use a stencil for horizontal divergence that tames the omnipresent grid-scale noise in the vertical velocity field in large-scale hydrostatic models. TODO:. - [ ] Add `divergence` property to `HydrostaticFreeSurfaceModel` and pass stencil info into kernels; - [ ] Update implicit free surface to use the vertical integral of horizontal divergence, rather than vertical integrating the velocity fields separately; - [ ] Fuse `Advection` module into `Operators`? The module `Advection` just defines stencils after all...; - [ ] Implement `UpwindWENO4` and `CenteredWENO5` horizontal divergence stencils",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388
https://github.com/CliMA/Oceananigans.jl/pull/2388:510,Deployability,integrat,integrating,510,"This PR investigates the possibility of using a convex combination of high-order stencils to calculate horizontal divergence. The goal is to use a stencil for horizontal divergence that tames the omnipresent grid-scale noise in the vertical velocity field in large-scale hydrostatic models. TODO:. - [ ] Add `divergence` property to `HydrostaticFreeSurfaceModel` and pass stencil info into kernels; - [ ] Update implicit free surface to use the vertical integral of horizontal divergence, rather than vertical integrating the velocity fields separately; - [ ] Fuse `Advection` module into `Operators`? The module `Advection` just defines stencils after all...; - [ ] Implement `UpwindWENO4` and `CenteredWENO5` horizontal divergence stencils",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388
https://github.com/CliMA/Oceananigans.jl/pull/2388:510,Integrability,integrat,integrating,510,"This PR investigates the possibility of using a convex combination of high-order stencils to calculate horizontal divergence. The goal is to use a stencil for horizontal divergence that tames the omnipresent grid-scale noise in the vertical velocity field in large-scale hydrostatic models. TODO:. - [ ] Add `divergence` property to `HydrostaticFreeSurfaceModel` and pass stencil info into kernels; - [ ] Update implicit free surface to use the vertical integral of horizontal divergence, rather than vertical integrating the velocity fields separately; - [ ] Fuse `Advection` module into `Operators`? The module `Advection` just defines stencils after all...; - [ ] Implement `UpwindWENO4` and `CenteredWENO5` horizontal divergence stencils",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388
https://github.com/CliMA/Oceananigans.jl/pull/2389:683,Integrability,wrap,wrapped,683,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389
https://github.com/CliMA/Oceananigans.jl/pull/2389:727,Integrability,wrap,wrapper,727,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389
https://github.com/CliMA/Oceananigans.jl/pull/2389:1678,Security,Validat,Validation,1678,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389
https://github.com/CliMA/Oceananigans.jl/pull/2389:1665,Testability,Test,Tests,1665,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389
https://github.com/CliMA/Oceananigans.jl/pull/2389:1699,Usability,simpl,simple,1699,"This PR adds two features:. 1. The ability to specify multiple forcing functions with a tuple (eg #2136); 2. A new forcing function type `AdvectiveForcing` for adding advective terms as a forcing function. A few users want to model buoyant or sinking particles so we need a nice way to support this that doesn't require importing low-level Oceananigans kernel functions. This was discussed on Slack and in #2385 . Some notes:. * `AdvectiveForcing` can also model advection of momentum, but this will only work for `NonhydrostaticModel` at the moment (because the kernel functions for momentum advection have different names for nonhydrostatic vs hydrostatic); * ""forcing tuples"" are wrapped in a lightweight `MultipleForcings` wrapper; this is just an internal convenience. However it does mean that we can more easily support alternative ways to ""combine"" forcings (other than just adding them) in the future if need be. ### Example of multiple forcings. From #2136, in model constructors:. ```julia; forcing = (; u = (u_relaxation, u_sponge)); ```. ### Example of `AdvectiveForcing`. From the docstring:. ```julia; # Physical parameters; gravitational_acceleration = 9.81 # m s⁻²; ocean_density = 1026 # kg m⁻³; mean_particle_density = 2000 # kg m⁻³; mean_particle_radius = 1e-3 # m; ocean_molecular_kinematic_viscosity = 1.05e-6 # m² s⁻¹. # Terminal velocity of a sphere in viscous flow; Δb = gravitational_acceleration * (mean_particle_density - ocean_density) / ocean_density; ν = ocean_molecular_kinematic_viscosity; R = mean_particle_radius. w_Stokes = - 2/9 * Δb / ν * R^2. settling = AdvectiveForcing(WENO5(), w=w_Stokes); ```. Closes #2136 . TODO:; - [x] Tests; - [x] Validation case with simple sinking, reacting particle that combines `MultipleForcing` and `AdvectiveForcing`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389
https://github.com/CliMA/Oceananigans.jl/pull/2390:48,Availability,error,error,48,Running the example from #2389 it returned this error; `ERROR: LoadError: UndefVarError: div_Uc not defined`. Hope this suggestion makes sense.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390
https://github.com/CliMA/Oceananigans.jl/pull/2390:56,Availability,ERROR,ERROR,56,Running the example from #2389 it returned this error; `ERROR: LoadError: UndefVarError: div_Uc not defined`. Hope this suggestion makes sense.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390
https://github.com/CliMA/Oceananigans.jl/pull/2390:63,Performance,Load,LoadError,63,Running the example from #2389 it returned this error; `ERROR: LoadError: UndefVarError: div_Uc not defined`. Hope this suggestion makes sense.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390
https://github.com/CliMA/Oceananigans.jl/issues/2391:854,Availability,ERROR,ERROR,854,"The call to `Field()` doesn't appear to be working with just the `indices` keyword argument:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> Field(model.velocities.u; indices=(:,:,1)); ERROR: MethodError: no method matching Field(::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}; indices=(Col",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391
https://github.com/CliMA/Oceananigans.jl/issues/2391:2791,Availability,error,error,2791," Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}; indices=(Colon(), Colon(), 1)); Closest candidates are:; Field(::Field) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Fields/field.jl:160 got unsupported keyword argument ""indices""; Field(::Any, ::String, ::String, ::Any; grid, architecture, indices, boundary_conditions) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/OutputReaders/field_time_series.jl:150; Field(::Tuple, ::Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ, var""#s139""} where {FT, TX, TY, TZ, var""#s139""<:Oceananigans.Distributed.MultiArch}, ::Any, ::Any, ::Tuple, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Distributed/distributed_fields.jl:4 got unsupported keyword argument ""indices""; ...; Stacktrace:; [1] top-level scope; @ REPL[18]:1; ```. If I pass an abstract operation I get a different error:. ```julia; julia> Field(model.velocities.u^2; indices=(:,:,1)); ERROR: MethodError: no method matching offset_indices(::Type{Center}, ::Type{Bounded}, ::Int64, ::Int64, ::Int64); Closest candidates are:; offset_indices(::Any, ::Any, ::Any, ::Any, ::Colon) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:29; offset_indices(::Any, ::Any, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:16; offset_indices(::Any, ::Any, ::Any, ::Any, ::UnitRange) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:30; ...; Stacktrace:; [1] _broadcast_getindex_evalf(::typeof(Oceananigans.Grids.offset_indices), ::Type, ::Type, ::Int64, ::Int64, ::Int64); @ Base.Broadcast ./broadcast.jl:648; [2] _broadcast_getindex; @ ./broadcast.jl:621 [inlined]; [3] (::Base.Broadcast.var""#19#20""{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(Oceananigans.Grids.offset_indices), Tuple{Tuple{Dat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391
https://github.com/CliMA/Oceananigans.jl/issues/2391:2862,Availability,ERROR,ERROR,2862,"ditions.Flux, Nothing}}, Nothing}; indices=(Colon(), Colon(), 1)); Closest candidates are:; Field(::Field) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Fields/field.jl:160 got unsupported keyword argument ""indices""; Field(::Any, ::String, ::String, ::Any; grid, architecture, indices, boundary_conditions) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/OutputReaders/field_time_series.jl:150; Field(::Tuple, ::Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ, var""#s139""} where {FT, TX, TY, TZ, var""#s139""<:Oceananigans.Distributed.MultiArch}, ::Any, ::Any, ::Tuple, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Distributed/distributed_fields.jl:4 got unsupported keyword argument ""indices""; ...; Stacktrace:; [1] top-level scope; @ REPL[18]:1; ```. If I pass an abstract operation I get a different error:. ```julia; julia> Field(model.velocities.u^2; indices=(:,:,1)); ERROR: MethodError: no method matching offset_indices(::Type{Center}, ::Type{Bounded}, ::Int64, ::Int64, ::Int64); Closest candidates are:; offset_indices(::Any, ::Any, ::Any, ::Any, ::Colon) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:29; offset_indices(::Any, ::Any, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:16; offset_indices(::Any, ::Any, ::Any, ::Any, ::UnitRange) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:30; ...; Stacktrace:; [1] _broadcast_getindex_evalf(::typeof(Oceananigans.Grids.offset_indices), ::Type, ::Type, ::Int64, ::Int64, ::Int64); @ Base.Broadcast ./broadcast.jl:648; [2] _broadcast_getindex; @ ./broadcast.jl:621 [inlined]; [3] (::Base.Broadcast.var""#19#20""{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(Oceananigans.Grids.offset_indices), Tuple{Tuple{DataType, DataType, DataType}, Tuple{DataType, DataType, DataType}, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Tuple{Colon, Colon, Int64}}}})(k::Int64); @ Base.Broadcast ./broa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391
https://github.com/CliMA/Oceananigans.jl/issues/2395:928,Availability,Error,Errors,928,"Hi Oceananigans Community,. As discussed with @glwagner and @johnryantaylor, I post an issue about adding Lagrangian particles to a nonuniform grid in the z-direction. Hope the following minimum working example is mini enough and bug-free. Happy to learn and discuss. . Best,; Si Chen. <details open>; <summary>Minimum Working Example</summary>. ```; using Random; using Printf; using Plots. using Oceananigans; using Oceananigans.Units: minute, minutes, hour. Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. h(k) = (k - 1) / Nz. ζ₀(k) = 1 + (h(k) - 1) / refinement. Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, 32, Nz), ; x = (0, 64),; y = (0, 64),; #z = (-Lz, 0)) # Errors are gone for uniform grid ; z = z_faces). ############################ Lagrangian Particles; n_particles = 10;; x₀ = 60*rand(n_particles); ; y₀ = 60*rand(n_particles);; z₀ = -Lz*0.5*rand(n_particles); ; lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀, restitution=0); ############################. b_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)). model = NonhydrostaticModel(advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:b,),; coriolis = FPlane(f=1e-4),; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (b=b_bcs,),; particles=lagrangian_particles) ############################ Lagrangian Particles. bᵢ(x, y, z) = 1e-5 * z + 1e-9 * rand(). set!(model, b=bᵢ). simulation = Simulation(model, Δt=10.0, stop_time=20minutes). wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=1minute). simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). run!(simulation); ```; </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395
https://github.com/CliMA/Oceananigans.jl/issues/2395:249,Usability,learn,learn,249,"Hi Oceananigans Community,. As discussed with @glwagner and @johnryantaylor, I post an issue about adding Lagrangian particles to a nonuniform grid in the z-direction. Hope the following minimum working example is mini enough and bug-free. Happy to learn and discuss. . Best,; Si Chen. <details open>; <summary>Minimum Working Example</summary>. ```; using Random; using Printf; using Plots. using Oceananigans; using Oceananigans.Units: minute, minutes, hour. Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. h(k) = (k - 1) / Nz. ζ₀(k) = 1 + (h(k) - 1) / refinement. Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, 32, Nz), ; x = (0, 64),; y = (0, 64),; #z = (-Lz, 0)) # Errors are gone for uniform grid ; z = z_faces). ############################ Lagrangian Particles; n_particles = 10;; x₀ = 60*rand(n_particles); ; y₀ = 60*rand(n_particles);; z₀ = -Lz*0.5*rand(n_particles); ; lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀, restitution=0); ############################. b_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)). model = NonhydrostaticModel(advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:b,),; coriolis = FPlane(f=1e-4),; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (b=b_bcs,),; particles=lagrangian_particles) ############################ Lagrangian Particles. bᵢ(x, y, z) = 1e-5 * z + 1e-9 * rand(). set!(model, b=bᵢ). simulation = Simulation(model, Δt=10.0, stop_time=20minutes). wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=1minute). simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). run!(simulation); ```; </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395
https://github.com/CliMA/Oceananigans.jl/issues/2398:18,Availability,error,error,18,"I'm faced with an error when trying to `show()` a model with the `SmagorisnkyLilly()` closure:. ```julia; julia> grid = RectilinearGrid(CPU(), size=(1,1,1), extent=(1,1,1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> closure = SmagorinskyLilly(); SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model = NonhydrostaticModel(grid=grid; closure=SmagorinskyLilly()); Error showing value of type NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398
https://github.com/CliMA/Oceananigans.jl/issues/2398:586,Availability,Error,Error,586,"I'm faced with an error when trying to `show()` a model with the `SmagorisnkyLilly()` closure:. ```julia; julia> grid = RectilinearGrid(CPU(), size=(1,1,1), extent=(1,1,1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> closure = SmagorinskyLilly(); SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model = NonhydrostaticModel(grid=grid; closure=SmagorinskyLilly()); Error showing value of type NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398
https://github.com/CliMA/Oceananigans.jl/issues/2398:14830,Availability,ERROR,ERROR,14830,"pRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] closure_summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/TurbulenceClosures.jl:61 [inlined]; [8] show(io::IOContext{Base.TTY}, model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offse",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398
https://github.com/CliMA/Oceananigans.jl/issues/2398:46871,Availability,error,error,46871,"stdlib/v1.6/REPL/src/REPL.jl:229; [21] (::REPL.var""#do_respond#61""{Bool, Bool, REPL.var""#72#82""{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:798; [22] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [23] invokelatest; @ ./essentials.jl:706 [inlined]; [24] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [25] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [26] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:406; ```. Digging a bit deeper, it seems that even showing the closure itself throws this error, but only if it's attached to a model:. ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model.closure; Error showing value of type SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] show; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/sm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398
https://github.com/CliMA/Oceananigans.jl/issues/2398:47007,Availability,Error,Error,47007,"mpt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:798; [22] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [23] invokelatest; @ ./essentials.jl:706 [inlined]; [24] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [25] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [26] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:406; ```. Digging a bit deeper, it seems that even showing the closure itself throws this error, but only if it's attached to a model:. ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model.closure; Error showing value of type SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] show; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:195 [inlined]; [8] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, x::SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretiz",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398
https://github.com/CliMA/Oceananigans.jl/issues/2398:47148,Availability,ERROR,ERROR,47148,"L.jl:798; [22] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [23] invokelatest; @ ./essentials.jl:706 [inlined]; [24] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [25] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [26] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:406; ```. Digging a bit deeper, it seems that even showing the closure itself throws this error, but only if it's attached to a model:. ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model.closure; Error showing value of type SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] show; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:195 [inlined]; [8] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, x::SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}); @ Base.Multimedia ./multimedia.jl:47; [9] (::REPL.var""#38#39""{REPL.REPLDisplay{REPL.LineEditREPL},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398
https://github.com/CliMA/Oceananigans.jl/pull/2401:75,Availability,Error,Error,75,"Before this PR:. ```julia; julia> using Oceananigans. julia> NamedTuple(); Error showing value of type NamedTuple{(), Tuple{}}:; ERROR: ArgumentError: collection must be non-empty; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> NamedTuple(); NamedTuple(); ```. you'd think this stuff would be easy. Closes #2398",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2401
https://github.com/CliMA/Oceananigans.jl/pull/2401:129,Availability,ERROR,ERROR,129,"Before this PR:. ```julia; julia> using Oceananigans. julia> NamedTuple(); Error showing value of type NamedTuple{(), Tuple{}}:; ERROR: ArgumentError: collection must be non-empty; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> NamedTuple(); NamedTuple(); ```. you'd think this stuff would be easy. Closes #2398",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2401
https://github.com/CliMA/Oceananigans.jl/pull/2402:455,Availability,down,downwards,455,"@tomchor and @whitleyv this PR adds a script that we can use to _estimate_ the relative effect of bottom drag vs form drag in buoyancy-stratified simulations over hilly bathymetry. This script only produces an estimate, because the bottom drag is implemented in a flat bottom setup, while form drag requires bathymetry. I'd hypothesis that we get more drag when there are both hills and bottom drag, because 1) greater shear at the bottom and 2) stronger downwards mixing of momentum due to strong turbulence. We could use #2275 to extend the results obtained here to cases with both drag and hills. I think it'll also be interesting if more accurate bathymetry representations like the one in #2306 lead to a reduction in form drag (cc @francispoulin). Possibly the spurious form drag is a nice metric to use to judge developments in our representation of bathymetry... I'll run these simulations at high resolution and report some results, hopefully soon. Side note: it's annoying that we don't serialized the immersed boundary so I might try to fix that here too...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402
https://github.com/CliMA/Oceananigans.jl/pull/2402:532,Modifiability,extend,extend,532,"@tomchor and @whitleyv this PR adds a script that we can use to _estimate_ the relative effect of bottom drag vs form drag in buoyancy-stratified simulations over hilly bathymetry. This script only produces an estimate, because the bottom drag is implemented in a flat bottom setup, while form drag requires bathymetry. I'd hypothesis that we get more drag when there are both hills and bottom drag, because 1) greater shear at the bottom and 2) stronger downwards mixing of momentum due to strong turbulence. We could use #2275 to extend the results obtained here to cases with both drag and hills. I think it'll also be interesting if more accurate bathymetry representations like the one in #2306 lead to a reduction in form drag (cc @francispoulin). Possibly the spurious form drag is a nice metric to use to judge developments in our representation of bathymetry... I'll run these simulations at high resolution and report some results, hopefully soon. Side note: it's annoying that we don't serialized the immersed boundary so I might try to fix that here too...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402
https://github.com/CliMA/Oceananigans.jl/issues/2403:38,Deployability,update,updated,38,"@glwagner and @simone-silvestri : . I updated the Overleaf document to include what form of viscosity we should be using. In summary, following [Gent (1993) ](https://www.cgd.ucar.edu/staff/gent/swe.pdf), I think the should choose the viscosity for `ShallowWaterModel` to be. ν/h ∇⋅ ( h ∇ 𝐯 ) . The reasons he states are as follows:. - h ∇ 𝐯 is a parameterization of the turbulent flux and therefore should be proportional to the depth.; - This ensures that the diffusion of momentum is in the form of the divergence of a stress tensor (Schar and Smith 1993); - It has a negative definite effect on the KE budget if the viscous boundary condition is either no slip or free slip. Of course a problem occurs where h=0 but I guess we just don't apply viscosity where there is no fluid. If we wanted to generalize this to biharmonic viscosity, I would guess the following, . ν/h ∇² ( h ∇² 𝐯) . but this is something that should be done later, of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403
https://github.com/CliMA/Oceananigans.jl/issues/2403:347,Modifiability,parameteriz,parameterization,347,"@glwagner and @simone-silvestri : . I updated the Overleaf document to include what form of viscosity we should be using. In summary, following [Gent (1993) ](https://www.cgd.ucar.edu/staff/gent/swe.pdf), I think the should choose the viscosity for `ShallowWaterModel` to be. ν/h ∇⋅ ( h ∇ 𝐯 ) . The reasons he states are as follows:. - h ∇ 𝐯 is a parameterization of the turbulent flux and therefore should be proportional to the depth.; - This ensures that the diffusion of momentum is in the form of the divergence of a stress tensor (Schar and Smith 1993); - It has a negative definite effect on the KE budget if the viscous boundary condition is either no slip or free slip. Of course a problem occurs where h=0 but I guess we just don't apply viscosity where there is no fluid. If we wanted to generalize this to biharmonic viscosity, I would guess the following, . ν/h ∇² ( h ∇² 𝐯) . but this is something that should be done later, of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403
https://github.com/CliMA/Oceananigans.jl/issues/2405:1850,Energy Efficiency,meter,meters,1850,"6.8*z/1e5+1027.56. # decay function for fronts; @inline decay(z) = (tanh((z+500)/300)+1)/2. @inline front(x, y, z, cy) = tanh((y-cy)/12kilometers); @inline D(x, y, z) = bg(z) + 0.8*decay(z)*front(x, y, z, 0)/4; @inline B(x, y, z) = -(g/ρₒ)*D(x, y, z). # setting the initial conditions; set!(model; b=B); ```. ## The problem. After 1 timestep it starts to present weird patters at the surface.; I am pretty sure I am messing up with something here, can you help me to figure this out?. ![image](https://user-images.githubusercontent.com/5797727/161127315-8230c1fb-9207-45ed-9fe8-f65b157a905a.png). ## Full code:; ```julia; using Oceananigans; using Oceananigans.Units. # define the size and max depth of the simulation; const Ny = 100; const Nz = 48 # number of points in z; const H = 1000 # maximum depth. # create the grid of the model; grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(-(Ny/2)kilometers, (Ny/2)kilometers),; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). # define the turbulence closure of the model; horizontal_closure = ScalarDiffusivity(ν=1, κ=1); vertical_closure = ScalarDiffusivity(ν=1e-5, κ=1e-5). coriolis = FPlane(latitude=60). #--------------- Instantiate Model. # create the model; model = NonhydrostaticModel(grid = grid,; advection = WENO5(),; timestepper = :RungeKutta3,; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers = (:b),; buoyancy = BuoyancyTracer()). #--------------- Initial Conditions. const g = 9.82 # gravity; const ρₒ = 1026 # reference density. # background density profile based on Argo data; @inline bg(z) = 0.25*tanh(0.0027*(-653.3-z))-6.8*z/1e5+1027.56. # decay function for fronts; @inline decay(z) = (tanh((z+500)/300)+1)/2. @inline front(x, y, z, cy) = tanh((y-cy)/12kilometers); @inline D(x, y, z) = bg(z) + 0.8*decay(z)*front(x, y, z, 0)/4; @inline B(x, y, z) = -(g/ρₒ)*D(x, y, z). # setting the initial conditions; set!(model; b=B). #--------------- Simulation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2405
https://github.com/CliMA/Oceananigans.jl/issues/2405:3330,Energy Efficiency,schedul,schedule,3330,"m/5797727/161127315-8230c1fb-9207-45ed-9fe8-f65b157a905a.png). ## Full code:; ```julia; using Oceananigans; using Oceananigans.Units. # define the size and max depth of the simulation; const Ny = 100; const Nz = 48 # number of points in z; const H = 1000 # maximum depth. # create the grid of the model; grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(-(Ny/2)kilometers, (Ny/2)kilometers),; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). # define the turbulence closure of the model; horizontal_closure = ScalarDiffusivity(ν=1, κ=1); vertical_closure = ScalarDiffusivity(ν=1e-5, κ=1e-5). coriolis = FPlane(latitude=60). #--------------- Instantiate Model. # create the model; model = NonhydrostaticModel(grid = grid,; advection = WENO5(),; timestepper = :RungeKutta3,; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers = (:b),; buoyancy = BuoyancyTracer()). #--------------- Initial Conditions. const g = 9.82 # gravity; const ρₒ = 1026 # reference density. # background density profile based on Argo data; @inline bg(z) = 0.25*tanh(0.0027*(-653.3-z))-6.8*z/1e5+1027.56. # decay function for fronts; @inline decay(z) = (tanh((z+500)/300)+1)/2. @inline front(x, y, z, cy) = tanh((y-cy)/12kilometers); @inline D(x, y, z) = bg(z) + 0.8*decay(z)*front(x, y, z, 0)/4; @inline B(x, y, z) = -(g/ρₒ)*D(x, y, z). # setting the initial conditions; set!(model; b=B). #--------------- Simulation. simulation = Simulation(model, Δt = 10seconds, stop_time = 10minutes). wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=6minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(5)). # merge light and h to the outputs; outputs = merge(model.velocities, model.tracers) # make a NamedTuple with all outputs. # writing the output; simulation.output_writers[:fields] =; NetCDFOutputWriter(model, outputs, filepath = ""data/output.nc"",; schedule=IterationInterval(1)). # run the simulation; run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2405
https://github.com/CliMA/Oceananigans.jl/issues/2405:313,Modifiability,evolve,evolves,313,"Hi all,. I am having some weird patterns for buoyancy at the surface that blows up the model, even that I am not applying any forcing there. ## The context. I am currently trying to setup a front simulation to couple with the NP model being developed in #2385 .; The idea is to start with an unbalaced front that evolves in time until it reaches its balance. I expect that front will probably radiate some internal waves, but geostrophically adjust after some time. ## The initial conditions. I am starting the simulation with a single buoyant front that adds to an initial buoyancy profile. ![image](https://user-images.githubusercontent.com/5797727/161123119-976a92ef-0a7f-4bc9-823a-0da0b4852623.png). ```julia; const g = 9.82 # gravity; const ρₒ = 1026 # reference density. # background density profile based on Argo data; @inline bg(z) = 0.25*tanh(0.0027*(-653.3-z))-6.8*z/1e5+1027.56. # decay function for fronts; @inline decay(z) = (tanh((z+500)/300)+1)/2. @inline front(x, y, z, cy) = tanh((y-cy)/12kilometers); @inline D(x, y, z) = bg(z) + 0.8*decay(z)*front(x, y, z, 0)/4; @inline B(x, y, z) = -(g/ρₒ)*D(x, y, z). # setting the initial conditions; set!(model; b=B); ```. ## The problem. After 1 timestep it starts to present weird patters at the surface.; I am pretty sure I am messing up with something here, can you help me to figure this out?. ![image](https://user-images.githubusercontent.com/5797727/161127315-8230c1fb-9207-45ed-9fe8-f65b157a905a.png). ## Full code:; ```julia; using Oceananigans; using Oceananigans.Units. # define the size and max depth of the simulation; const Ny = 100; const Nz = 48 # number of points in z; const H = 1000 # maximum depth. # create the grid of the model; grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(-(Ny/2)kilometers, (Ny/2)kilometers),; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). # define the turbulence closure of the model; horizontal_closure = ScalarDiffusivity(ν=1, κ=1); vertical",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2405
https://github.com/CliMA/Oceananigans.jl/pull/2412:1494,Energy Efficiency,reduce,reduces,1494," 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:7019,Integrability,interface,interface,7019,"────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; ## Possible future improvements. In this PR I also attempted to explore an alternative formulation of the FFT-based preconditioner:. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H Δt) - ∇ʰ H ⋅ ∇ʰ η★ / H,; ```. where `η★` is the current solution in the conjugate gradient iteration. However, this caused the iteration to diverge. Perhaps it would be better to use `ηⁿ`, but I'm not sure. On the right side, `H` is no longer constant but instead is the actual depth `H(x, y)`. I also tried using `H̄` in the denominators above, but this apparently made no difference. # Other changes / improvements. To support this development, this PR implements some improvements to `PreconditionedConjugateGradientSolver`. Previously we would specify the argument `precondition!`, which was supposed to be a function that computed `P * r`, where `P` is often called the ""preconditioner"". Now we specify `preconditioner`, which must define a method. ```julia; precondition!(z, preconditioner, r, args...); ```. This API is more convenient for preconditioners that require some data storage or precomputation and thus must be objects of their own (rather than functions). - In the conjugate gradient loop, we launch broadcasts with `parent(a) .= parent(b)` rather than using Oceananigans internal broadcasting `a .= b`. This is a bit faster and saves some memory allocation.; - The default preconditioner for `PCGImplicitFreeSurface` is now `nothing`.; - We now always precompute and store `GridFittedBottom`, since it's rarely / never desired to compute on the fly and ""only supporting arrays"" simplifies our code.; - The interface for `PreconditionedConjugateGradientSolver` now resembles the interface to `cg` with properties `maxiter`, `abstol`, and `reltol`; - The default `reltol` for the `PCGImplicitFreeSurfaceSolver` is `max(1e-7, 10 * eps(eltype(grid)))`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:7091,Integrability,interface,interface,7091,"────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; ## Possible future improvements. In this PR I also attempted to explore an alternative formulation of the FFT-based preconditioner:. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H Δt) - ∇ʰ H ⋅ ∇ʰ η★ / H,; ```. where `η★` is the current solution in the conjugate gradient iteration. However, this caused the iteration to diverge. Perhaps it would be better to use `ηⁿ`, but I'm not sure. On the right side, `H` is no longer constant but instead is the actual depth `H(x, y)`. I also tried using `H̄` in the denominators above, but this apparently made no difference. # Other changes / improvements. To support this development, this PR implements some improvements to `PreconditionedConjugateGradientSolver`. Previously we would specify the argument `precondition!`, which was supposed to be a function that computed `P * r`, where `P` is often called the ""preconditioner"". Now we specify `preconditioner`, which must define a method. ```julia; precondition!(z, preconditioner, r, args...); ```. This API is more convenient for preconditioners that require some data storage or precomputation and thus must be objects of their own (rather than functions). - In the conjugate gradient loop, we launch broadcasts with `parent(a) .= parent(b)` rather than using Oceananigans internal broadcasting `a .= b`. This is a bit faster and saves some memory allocation.; - The default preconditioner for `PCGImplicitFreeSurface` is now `nothing`.; - We now always precompute and store `GridFittedBottom`, since it's rarely / never desired to compute on the fly and ""only supporting arrays"" simplifies our code.; - The interface for `PreconditionedConjugateGradientSolver` now resembles the interface to `cg` with properties `maxiter`, `abstol`, and `reltol`; - The default `reltol` for the `PCGImplicitFreeSurfaceSolver` is `max(1e-7, 10 * eps(eltype(grid)))`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:436,Modifiability,variab,variable,436,"This PR implements an FFT-based preconditioner for `PCGImplicitFreeSurfaceSolver` on immersed boundary `RectilinearGrid`. Note that we have a direct FFT solver for _non-immersed_ `RectilinearGrid`. # Premise. The premise of the FFT-based preconditioner is to use the non-immersed FFT-based algorithm for implicit free surface solves on rectilinear grids as a _preconditioner_ for a conjugate gradient iterative solver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:1257,Security,validat,validation,1257," FFT-based algorithm for implicit free surface solves on rectilinear grids as a _preconditioner_ for a conjugate gradient iterative solver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater effici",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:1402,Security,validat,validation,1402,"olver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditione",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:1323,Testability,test,test,1323,"tilinear grids as a _preconditioner_ for a conjugate gradient iterative solver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:1446,Testability,benchmark,benchmarking,1446,"olver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditione",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:2426,Testability,benchmark,benchmarks,2426,"undaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:2675,Testability,Benchmark,Benchmarks,2675,"hly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 6.635 ms │ 7.733 ms │ 13.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:2796,Testability,benchmark,benchmarks,2796,"nditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner for the matrix solver (only valid on CPU now) converges in even fewer iterations, typically 3-4 for this problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 6.635 ms │ 7.733 ms │ 13.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 20.311 ms │ 21.363 ms │ 23.938 ms │ 36.792 ms │ 5.19 MiB │ 8279 │ 10 │; │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:2874,Testability,benchmark,benchmarks,2874," problem. However, due to the greater efficiency of _applying_ the FFT preconditioner versus the ILU prconditioner (ie, FFTs verus matrix multiply), _and_ the greater efficiency of the LHS computation for `PCGImplicitFreeSurfaceSolver` versus `MatrixIterativeSolver`, the ""PCG"" solver with FFT preconditioner is faster (benchmarks below). ; * Both the ""matrix"" and ""non-matrix"" solvers use conjugate gradient iteration --- the difference is in how they compute the left-hand-side (ie the linear left-side operator above, and the preconditioners that are supported). ## Benchmarks. Note that ""PCGImplicitFreeSurface"" below means ""PCGImplicitFreeSurface with FFT based preconditioner"". These benchmarks have a problem size 256 x 128 x 1. ### CPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 6.635 ms │ 7.733 ms │ 13.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 20.311 ms │ 21.363 ms │ 23.938 ms │ 36.792 ms │ 5.19 MiB │ 8279 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 30.756 ms │ 32.076 ms │ 31.916 ms │ 32.815 ms │ 5.19 MiB │ 8276 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:4160,Testability,benchmark,benchmarks,4160,3.564 ms │ 33.224 ms │ 3.07 MiB │ 5626 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 9.578 ms │ 11.644 ms │ 11.541 ms │ 13.400 ms │ 4.55 MiB │ 8023 │ 10 │; │ CPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 13.193 ms │ 14.087 ms │ 14.329 ms │ 17.618 ms │ 5.34 MiB │ 9656 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 20.311 ms │ 21.363 ms │ 23.938 ms │ 36.792 ms │ 5.19 MiB │ 8279 │ 10 │; │ CPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 30.756 ms │ 32.076 ms │ 31.916 ms │ 32.815 ms │ 5.19 MiB │ 8276 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```. ### GPU; ```; Hydrostatic model benchmarks; ┌───────────────┬─────────────────┬───────────────────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼───────────────────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ GPU │ RectilinearGrid │ ExplicitFreeSurface │ 1.455 ms │ 1.632 ms │ 1.786 ms │ 3.695 ms │ 1.07 MiB │ 3495 │ 10 │; │ GPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 2.277 ms │ 2.315 ms │ 2.472 ms │ 3.774 ms │ 1.56 MiB │ 5257 │ 10 │; │ GPU │ RectilinearGrid │ PCGImplicitFreeSurface │ 3.285 ms │ 3.347 ms │ 3.543 ms │ 5.177 ms │ 1.70 MiB │ 7742 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceOrd2 │ 6.804 ms │ 6.924 ms │ 7.050 ms │ 8.149 ms │ 1.74 MiB │ 14313 │ 10 │; │ GPU │ RectilinearGrid │ MatrixImplicitFreeSurfaceSparsePreconditioner │ 6.323 ms │ 6.400 ms │ 6.639 ms │ 7.688 ms │ 1.68 MiB │ 12378 │ 10 │; └───────────────┴─────────────────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/pull/2412:6991,Usability,simpl,simplifies,6991,"────┴───────────────────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; ## Possible future improvements. In this PR I also attempted to explore an alternative formulation of the FFT-based preconditioner:. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H Δt) - ∇ʰ H ⋅ ∇ʰ η★ / H,; ```. where `η★` is the current solution in the conjugate gradient iteration. However, this caused the iteration to diverge. Perhaps it would be better to use `ηⁿ`, but I'm not sure. On the right side, `H` is no longer constant but instead is the actual depth `H(x, y)`. I also tried using `H̄` in the denominators above, but this apparently made no difference. # Other changes / improvements. To support this development, this PR implements some improvements to `PreconditionedConjugateGradientSolver`. Previously we would specify the argument `precondition!`, which was supposed to be a function that computed `P * r`, where `P` is often called the ""preconditioner"". Now we specify `preconditioner`, which must define a method. ```julia; precondition!(z, preconditioner, r, args...); ```. This API is more convenient for preconditioners that require some data storage or precomputation and thus must be objects of their own (rather than functions). - In the conjugate gradient loop, we launch broadcasts with `parent(a) .= parent(b)` rather than using Oceananigans internal broadcasting `a .= b`. This is a bit faster and saves some memory allocation.; - The default preconditioner for `PCGImplicitFreeSurface` is now `nothing`.; - We now always precompute and store `GridFittedBottom`, since it's rarely / never desired to compute on the fly and ""only supporting arrays"" simplifies our code.; - The interface for `PreconditionedConjugateGradientSolver` now resembles the interface to `cg` with properties `maxiter`, `abstol`, and `reltol`; - The default `reltol` for the `PCGImplicitFreeSurfaceSolver` is `max(1e-7, 10 * eps(eltype(grid)))`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412
https://github.com/CliMA/Oceananigans.jl/issues/2415:950,Availability,ERROR,ERROR,950,"For example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> b = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> f = 1; 1. julia> vz_op = @at (Face, Center, Center) - ∂x(b) / f; ERROR: LoadError: MethodError: no method matching var""@at""(::LineNumberNode, ::Module, ::Expr); Closest candidates are:; var""@at""(::LineNumberNode, ::Module, ::Any, ::Any) at /Users/gregorywagner/Projects/Oceananigans.jl/src/AbstractOperations/at.jl:42; in expression starting at REPL[16]:1; ```. Found with @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415
https://github.com/CliMA/Oceananigans.jl/issues/2415:957,Performance,Load,LoadError,957,"For example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> b = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> f = 1; 1. julia> vz_op = @at (Face, Center, Center) - ∂x(b) / f; ERROR: LoadError: MethodError: no method matching var""@at""(::LineNumberNode, ::Module, ::Expr); Closest candidates are:; var""@at""(::LineNumberNode, ::Module, ::Any, ::Any) at /Users/gregorywagner/Projects/Oceananigans.jl/src/AbstractOperations/at.jl:42; in expression starting at REPL[16]:1; ```. Found with @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415
https://github.com/CliMA/Oceananigans.jl/pull/2416:270,Testability,test,tests,270,- [x] Changes `mode` and `force` to overwrite existing; - [x] Change `prefix` to something clearer (maybe `filename`); - [x] Separate keyword `filepath` in `NetcdfOutputWriter` into `dir` and `filename` (or whatever is replacing `prefix`); - [x] Maybe add a couple more tests for `NetcdfWriter`. Closes https://github.com/CliMA/Oceananigans.jl/issues/884; Closes https://github.com/CliMA/Oceananigans.jl/issues/2427,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416
https://github.com/CliMA/Oceananigans.jl/pull/2416:91,Usability,clear,clearer,91,- [x] Changes `mode` and `force` to overwrite existing; - [x] Change `prefix` to something clearer (maybe `filename`); - [x] Separate keyword `filepath` in `NetcdfOutputWriter` into `dir` and `filename` (or whatever is replacing `prefix`); - [x] Maybe add a couple more tests for `NetcdfWriter`. Closes https://github.com/CliMA/Oceananigans.jl/issues/884; Closes https://github.com/CliMA/Oceananigans.jl/issues/2427,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416
https://github.com/CliMA/Oceananigans.jl/pull/2417:182,Availability,down,downgrades,182,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417
https://github.com/CliMA/Oceananigans.jl/pull/2417:36,Deployability,update,updated,36,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417
https://github.com/CliMA/Oceananigans.jl/pull/2417:367,Deployability,update,update,367,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417
https://github.com/CliMA/Oceananigans.jl/pull/2417:1,Testability,benchmark,benchmarks,1,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417
https://github.com/CliMA/Oceananigans.jl/pull/2417:78,Testability,benchmark,benchmarking,78,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417
https://github.com/CliMA/Oceananigans.jl/pull/2417:153,Testability,benchmark,benchmarks,153,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417
https://github.com/CliMA/Oceananigans.jl/pull/2417:277,Testability,benchmark,benchmarks,277,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417
https://github.com/CliMA/Oceananigans.jl/pull/2417:323,Testability,benchmark,benchmarks,323,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417
https://github.com/CliMA/Oceananigans.jl/issues/2418:606,Integrability,interface,interface,606,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418
https://github.com/CliMA/Oceananigans.jl/issues/2418:1826,Integrability,interface,interface,1826,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418
https://github.com/CliMA/Oceananigans.jl/issues/2418:83,Modifiability,refactor,refactoring,83,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418
https://github.com/CliMA/Oceananigans.jl/issues/2418:539,Modifiability,refactor,refactor,539,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418
https://github.com/CliMA/Oceananigans.jl/issues/2418:429,Performance,optimiz,optimized,429,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418
https://github.com/CliMA/Oceananigans.jl/issues/2418:1070,Testability,log,logic,1070,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418
https://github.com/CliMA/Oceananigans.jl/pull/2419:8,Deployability,update,updates,8,"This PR updates `FieldTimeSeries` to be slightly ""backward compatible"" and capable of loading data from Oceananigans versions that did not have `Field.indices`, or which serialized stretched GPU grids with `CuArray`s. We might have to constantly maintain this... but hopefully eventually structures will be more stable, and eventually we can just delete the stuff added here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2419
https://github.com/CliMA/Oceananigans.jl/pull/2419:86,Performance,load,loading,86,"This PR updates `FieldTimeSeries` to be slightly ""backward compatible"" and capable of loading data from Oceananigans versions that did not have `Field.indices`, or which serialized stretched GPU grids with `CuArray`s. We might have to constantly maintain this... but hopefully eventually structures will be more stable, and eventually we can just delete the stuff added here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2419
https://github.com/CliMA/Oceananigans.jl/pull/2420:16,Security,validat,validation,16,"This PR splits `validation/bickley_jet.jl` into two scripts (one for the ""immersed bickley jet"" and one for the ""ordinary"" bickley jet) and somewhat improves the script for the ordinary bickley jet. @simone-silvestri I left the ""immersed bickley jet"" unchanged so you can continue to use it as is.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2420
https://github.com/CliMA/Oceananigans.jl/issues/2422:277,Energy Efficiency,energy,energy,277,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:416,Energy Efficiency,energy,energy,416,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:759,Energy Efficiency,sustainab,sustainable,759,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:1218,Integrability,interface,interface,1218," that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:2397,Integrability,interface,interface,2397,"is works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structure that we currently have in `diffusivity_fields`. . I also think we need an interface for extracting mixing coefficients / diffusivities (rather than requiring that users spelunk into the model properties to find the information they want). We have a prototype with `viscosity` and `diffusivity` functions but it hasn't been used much and isn't really tested. So that would have to be expanded upon as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:240,Modifiability,variab,variables,240,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:333,Modifiability,evolve,evolved,333,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:868,Modifiability,variab,variables,868,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:895,Modifiability,variab,variables,895,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:1298,Modifiability,variab,variable,1298," that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:2018,Security,access,accessing,2018,"is works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structure that we currently have in `diffusivity_fields`. . I also think we need an interface for extracting mixing coefficients / diffusivities (rather than requiring that users spelunk into the model properties to find the information they want). We have a prototype with `viscosity` and `diffusivity` functions but it hasn't been used much and isn't really tested. So that would have to be expanded upon as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:1873,Testability,log,logical,1873,"is works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structure that we currently have in `diffusivity_fields`. . I also think we need an interface for extracting mixing coefficients / diffusivities (rather than requiring that users spelunk into the model properties to find the information they want). We have a prototype with `viscosity` and `diffusivity` functions but it hasn't been used much and isn't really tested. So that would have to be expanded upon as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/issues/2422:2673,Testability,test,tested,2673,"is works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come with an API for accessing the data. Right now we have `fields(model)`. We could divide this into two functions: `prognostic_fields(model)` and `diagnostic_fields(model)`, and then also `fields(model)` which combines the two. One decision there is whether to ""flatten"" the lists, or to maintain the hierarchical structure that we currently have in `diffusivity_fields`. . I also think we need an interface for extracting mixing coefficients / diffusivities (rather than requiring that users spelunk into the model properties to find the information they want). We have a prototype with `viscosity` and `diffusivity` functions but it hasn't been used much and isn't really tested. So that would have to be expanded upon as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422
https://github.com/CliMA/Oceananigans.jl/pull/2423:1637,Availability,error,error,1637,"Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01 | 7.889e-03 | 8.798e-03 |; ```. (https://github.com/CliMA/OceananigansArtifacts.jl/pull/14). Everything is preliminary because we still need to upgrade to LESbrary 2.0 (with Stokes drift and more cases).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423
https://github.com/CliMA/Oceananigans.jl/pull/2423:1749,Availability,error,error,1749,"Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01 | 7.889e-03 | 8.798e-03 |; ```. (https://github.com/CliMA/OceananigansArtifacts.jl/pull/14). Everything is preliminary because we still need to upgrade to LESbrary 2.0 (with Stokes drift and more cases).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423
https://github.com/CliMA/Oceananigans.jl/pull/2423:2146,Deployability,upgrade,upgrade,2146,"Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01 | 7.889e-03 | 8.798e-03 |; ```. (https://github.com/CliMA/OceananigansArtifacts.jl/pull/14). Everything is preliminary because we still need to upgrade to LESbrary 2.0 (with Stokes drift and more cases).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423
https://github.com/CliMA/Oceananigans.jl/pull/2423:31,Modifiability,enhance,enhancements,31,"This draft PR introduces a few enhancements to `RiBasedVerticalDiffusivity`. `RiBasedVerticalDiffusivity` imposes viscosities and diffusivities of the form. ```; ν₀ * tapering(Ri, Ri_c, Ri_d); ```. where `Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423
https://github.com/CliMA/Oceananigans.jl/pull/2423:677,Testability,test,tested,677,"This draft PR introduces a few enhancements to `RiBasedVerticalDiffusivity`. `RiBasedVerticalDiffusivity` imposes viscosities and diffusivities of the form. ```; ν₀ * tapering(Ri, Ri_c, Ri_d); ```. where `Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423
https://github.com/CliMA/Oceananigans.jl/issues/2424:476,Availability,ERROR,ERROR,476,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424
https://github.com/CliMA/Oceananigans.jl/issues/2424:769,Availability,Error,Error,769,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424
https://github.com/CliMA/Oceananigans.jl/issues/2424:1938,Availability,ERROR,ERROR,1938,"nhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424
https://github.com/CliMA/Oceananigans.jl/issues/2424:275,Energy Efficiency,schedul,schedule,275,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424
https://github.com/CliMA/Oceananigans.jl/issues/2424:507,Security,access,access,507,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424
https://github.com/CliMA/Oceananigans.jl/issues/2424:1969,Security,access,access,1969,"nhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424
https://github.com/CliMA/Oceananigans.jl/issues/2424:333,Testability,test,test,333,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424
https://github.com/CliMA/Oceananigans.jl/issues/2424:393,Testability,test,test,393,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424
https://github.com/CliMA/Oceananigans.jl/pull/2425:168,Testability,test,test,168,"However, we don't support reducing across the 4th dimension (yet). I think we should merge this now since it resolves #2424, but we should also raise an issue to add a test or two. Closes #2424",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2425
https://github.com/CliMA/Oceananigans.jl/pull/2426:8,Modifiability,extend,extends,8,"This PR extends the capability of the ""implicit diffusion solver"" to handle an ""additional linear term"". This feature is then used to treat the TKE dissipation term semi-implicitly in attempt to alleviate CATKE's time-step restrictions. I use quotes because it's not exactly a ""diffusion solver"" anymore. So a little name shuffling might be in order if this turns out to work well. Thanks to @yairchn for help in formulating this potential solution for CATKE's inclination toward instability.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426
https://github.com/CliMA/Oceananigans.jl/issues/2427:54,Availability,error,errors,54,"I just realized that the output writers docs page has errors relating to the purging of `FieldSlicer()`: https://clima.github.io/OceananigansDocumentation/stable/model_setup/output_writers/#Examples. ![image](https://user-images.githubusercontent.com/13205162/162648339-b7b30179-a9cc-4c05-ab34-9833e7603044.png). Now that `FieldSlicer()` doesn't exist anymore, part of that section may be out of date and needs to be re-written.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2427
https://github.com/CliMA/Oceananigans.jl/issues/2430:157,Availability,error,error,157,"I think I am encountering a bug using `ValueBoundaryCondition`s with `ImmersedBoundaryGrid`s. `FluxBoundaryCondition`s do not trigger this, and based on the error message it looks like it has to do with how the halos are treated (in `src/BoundaryConditions/fill_halo_regions.jl`)? See a MWE below. I am running the latest version of `Oceananigans` (0.73.8). ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; using Oceananigans.Units; using Printf. Nx = 60; Nz = 18; Lx = 1200kilometers; Lz = 1800meters; Δt = 30minutes; taux = -0.5 # [Pa]; ρ₀ = 1026 # [kg m⁻³]. stop_time = 1years; save_interval = 1days; wind_time_ramp = 5days; lateral_diffusive_time = 1days; αT = 2e-4; taux = taux/ρ₀. buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=αT, haline_contraction=0.0)); momentum_advection = WENO5(); tracer_advection = WENO5(); tracers = (:T, :S). grid = RectilinearGrid(size = (Nx, Nx, Nz),; x = (0, Lx),; y = (0, Lx),; z = (-Lz, 0),; halo = (3, 3, 3),; topology = (Bounded, Bounded, Bounded)). free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver). # Rough topography.; ht = 100meters; Lt = 500kilometers; kt = 2π/Lt; topography(x, y) = ht*cos.(kt*x).*cos.(kt*y) .- Lz; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(topography)). coriolis = BetaPlane(latitude=45); κh = grid.Δxᶜᵃᵃ^2 / lateral_diffusive_time; νh = κh. κz = 0; νz = κz; horizontal_closure = HorizontalScalarDiffusivity(ν=νh, κ=κh); vertical_closure = VerticalScalarDiffusivity(ν=νz, κ=κz); closure = (vertical_closure, horizontal_closure). wind_stress(x, y, t) = - taux * cos(2π * y / (2Lx)) * tanh(t/wind_time_ramp); no_slip = ValueBoundaryCondition(0); no_flux = FluxBoundaryCondition(0). # No bottom drag (free-slip at the bottom).; boundary_conditions = (;; u = FieldBoundaryConditions(top=FluxBoundaryCondition(wind_stress), south=no_slip, north=no_slip),; v = FieldBoundaryConditions(east=no_slip, west=n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430
https://github.com/CliMA/Oceananigans.jl/issues/2430:3325,Energy Efficiency,schedul,schedule,3325,"2π * y / (2Lx)) * tanh(t/wind_time_ramp); no_slip = ValueBoundaryCondition(0); no_flux = FluxBoundaryCondition(0). # No bottom drag (free-slip at the bottom).; boundary_conditions = (;; u = FieldBoundaryConditions(top=FluxBoundaryCondition(wind_stress), south=no_slip, north=no_slip),; v = FieldBoundaryConditions(east=no_slip, west=no_slip),; T = FieldBoundaryConditions(top=no_flux, bottom=no_flux, east=no_flux, west=no_flux, south=no_flux, north=no_flux); ). model = HydrostaticFreeSurfaceModel(; grid, coriolis, closure = closure, boundary_conditions,; momentum_advection = momentum_advection,; tracer_advection = tracer_advection,; tracers = tracers, buoyancy = buoyancy, free_surface = free_surface). # Flat linear stratification as initial condition.; Tsurf, Tbot = 25, 2; Tz = (Tsurf - Tbot)/Lz; Tprof(x, y, z) = Tsurf + Tz*z; Sprof(x, y, z) = 35; set!(model, T=Tprof, S=Sprof). simulation = Simulation(model, Δt=Δt, stop_time=stop_time); mutable struct Progress; interval_start_time :: Float64; end. function (p::Progress)(sim); wall_time = (time_ns() - p.interval_start_time) * 1e-9. @info @sprintf(""Time: %s, iteration: %d, max(v): %.2e m s⁻¹, wall time: %s"",; prettytime(sim.model.clock.time),; sim.model.clock.iteration,; maximum(sim.model.velocities.v),; prettytime(wall_time)). p.interval_start_time = time_ns(). return nothing; end; simulation.callbacks[:progress] = Callback(Progress(time_ns()), IterationInterval(20)). output = Dict(""v"" => model.velocities.v, ""T"" => model.tracers.T); simulation.output_writers[:surface_slice_writer] = NetCDFOutputWriter(model, output,; filepath = joinpath(@__DIR__, ""baroclinic_gyre_surface_slice.nc""),; schedule = TimeInterval(save_interval),; mode = ""c"", indices=(:, :, grid.Nz)). simulation.output_writers[:vertical_slice_writer] = NetCDFOutputWriter(model, output,; filepath = joinpath(@__DIR__, ""baroclinic_gyre_vertical_slice.nc""),; schedule = TimeInterval(save_interval),; mode = ""c"", indices=(:, Int(grid.Nx/2), :)). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430
https://github.com/CliMA/Oceananigans.jl/issues/2430:3560,Energy Efficiency,schedul,schedule,3560,"2π * y / (2Lx)) * tanh(t/wind_time_ramp); no_slip = ValueBoundaryCondition(0); no_flux = FluxBoundaryCondition(0). # No bottom drag (free-slip at the bottom).; boundary_conditions = (;; u = FieldBoundaryConditions(top=FluxBoundaryCondition(wind_stress), south=no_slip, north=no_slip),; v = FieldBoundaryConditions(east=no_slip, west=no_slip),; T = FieldBoundaryConditions(top=no_flux, bottom=no_flux, east=no_flux, west=no_flux, south=no_flux, north=no_flux); ). model = HydrostaticFreeSurfaceModel(; grid, coriolis, closure = closure, boundary_conditions,; momentum_advection = momentum_advection,; tracer_advection = tracer_advection,; tracers = tracers, buoyancy = buoyancy, free_surface = free_surface). # Flat linear stratification as initial condition.; Tsurf, Tbot = 25, 2; Tz = (Tsurf - Tbot)/Lz; Tprof(x, y, z) = Tsurf + Tz*z; Sprof(x, y, z) = 35; set!(model, T=Tprof, S=Sprof). simulation = Simulation(model, Δt=Δt, stop_time=stop_time); mutable struct Progress; interval_start_time :: Float64; end. function (p::Progress)(sim); wall_time = (time_ns() - p.interval_start_time) * 1e-9. @info @sprintf(""Time: %s, iteration: %d, max(v): %.2e m s⁻¹, wall time: %s"",; prettytime(sim.model.clock.time),; sim.model.clock.iteration,; maximum(sim.model.velocities.v),; prettytime(wall_time)). p.interval_start_time = time_ns(). return nothing; end; simulation.callbacks[:progress] = Callback(Progress(time_ns()), IterationInterval(20)). output = Dict(""v"" => model.velocities.v, ""T"" => model.tracers.T); simulation.output_writers[:surface_slice_writer] = NetCDFOutputWriter(model, output,; filepath = joinpath(@__DIR__, ""baroclinic_gyre_surface_slice.nc""),; schedule = TimeInterval(save_interval),; mode = ""c"", indices=(:, :, grid.Nz)). simulation.output_writers[:vertical_slice_writer] = NetCDFOutputWriter(model, output,; filepath = joinpath(@__DIR__, ""baroclinic_gyre_vertical_slice.nc""),; schedule = TimeInterval(save_interval),; mode = ""c"", indices=(:, Int(grid.Nx/2), :)). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430
https://github.com/CliMA/Oceananigans.jl/issues/2430:163,Integrability,message,message,163,"I think I am encountering a bug using `ValueBoundaryCondition`s with `ImmersedBoundaryGrid`s. `FluxBoundaryCondition`s do not trigger this, and based on the error message it looks like it has to do with how the halos are treated (in `src/BoundaryConditions/fill_halo_regions.jl`)? See a MWE below. I am running the latest version of `Oceananigans` (0.73.8). ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; using Oceananigans.Units; using Printf. Nx = 60; Nz = 18; Lx = 1200kilometers; Lz = 1800meters; Δt = 30minutes; taux = -0.5 # [Pa]; ρ₀ = 1026 # [kg m⁻³]. stop_time = 1years; save_interval = 1days; wind_time_ramp = 5days; lateral_diffusive_time = 1days; αT = 2e-4; taux = taux/ρ₀. buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=αT, haline_contraction=0.0)); momentum_advection = WENO5(); tracer_advection = WENO5(); tracers = (:T, :S). grid = RectilinearGrid(size = (Nx, Nx, Nz),; x = (0, Lx),; y = (0, Lx),; z = (-Lz, 0),; halo = (3, 3, 3),; topology = (Bounded, Bounded, Bounded)). free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver). # Rough topography.; ht = 100meters; Lt = 500kilometers; kt = 2π/Lt; topography(x, y) = ht*cos.(kt*x).*cos.(kt*y) .- Lz; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(topography)). coriolis = BetaPlane(latitude=45); κh = grid.Δxᶜᵃᵃ^2 / lateral_diffusive_time; νh = κh. κz = 0; νz = κz; horizontal_closure = HorizontalScalarDiffusivity(ν=νh, κ=κh); vertical_closure = VerticalScalarDiffusivity(ν=νz, κ=κz); closure = (vertical_closure, horizontal_closure). wind_stress(x, y, t) = - taux * cos(2π * y / (2Lx)) * tanh(t/wind_time_ramp); no_slip = ValueBoundaryCondition(0); no_flux = FluxBoundaryCondition(0). # No bottom drag (free-slip at the bottom).; boundary_conditions = (;; u = FieldBoundaryConditions(top=FluxBoundaryCondition(wind_stress), south=no_slip, north=no_slip),; v = FieldBoundaryConditions(east=no_slip, west=n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430
https://github.com/CliMA/Oceananigans.jl/pull/2431:1603,Availability,down,downside,1603,"r for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which is motivated more by internal considerations). But it's tradeoffs all the way down so good to discuss. I also did a little clean up and changed the internal function `TurbulenceClosures.DiffusivityFields` to `TurbulenceClosures.diffusivity_fields`. The code is inconsistent about the use of TitleCase (is it a constructor / struct? is it a function?) and there's a bit of clean up to do... Resolves #2422",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2431:2079,Availability,down,down,2079,"r for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which is motivated more by internal considerations). But it's tradeoffs all the way down so good to discuss. I also did a little clean up and changed the internal function `TurbulenceClosures.DiffusivityFields` to `TurbulenceClosures.diffusivity_fields`. The code is inconsistent about the use of TitleCase (is it a constructor / struct? is it a function?) and there's a bit of clean up to do... Resolves #2422",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2431:777,Energy Efficiency,energy,energy,777,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2431:618,Integrability,interface,interface,618,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2431:1744,Integrability,interface,interface,1744,"r for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which is motivated more by internal considerations). But it's tradeoffs all the way down so good to discuss. I also did a little clean up and changed the internal function `TurbulenceClosures.DiffusivityFields` to `TurbulenceClosures.diffusivity_fields`. The code is inconsistent about the use of TitleCase (is it a constructor / struct? is it a function?) and there's a bit of clean up to do... Resolves #2422",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2431:40,Modifiability,parameteriz,parameterization,40,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2431:714,Modifiability,parameteriz,parameterization,714,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2431:784,Modifiability,variab,variable,784,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2431:1112,Modifiability,parameteriz,parameterization,1112,"ttps://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which is motivated more by internal considerations). But it's tradeoffs all the way down so good t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431
https://github.com/CliMA/Oceananigans.jl/pull/2432:99,Testability,Benchmark,Benchmark,99,This PR tries to make the script a bit easier to run based on my experiences with it. For example `Benchmark` and `@gpu_sync` aren't needed in this case and we can delete it. So far I've only been able to run this with one core (see https://github.com/CliMA/Oceananigans.jl/issues/2433). Closes https://github.com/CliMA/Oceananigans.jl/issues/2433,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432
https://github.com/CliMA/Oceananigans.jl/issues/2433:734,Availability,error,error,734,"This is related to https://github.com/CliMA/Oceananigans.jl/pull/2432. I'm trying to run the [`distributed_nonhydrostatic_model_mpi.jl` benchmark](https://github.com/CliMA/Oceananigans.jl/blob/9eb055064e68f6a725cebcf9973a3ebf1cbad16b/benchmark/distributed_nonhydrostatic_model_mpi.jl) but I'm running into problems. It seems to be something silly but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433
https://github.com/CliMA/Oceananigans.jl/issues/2433:1201,Availability,ERROR,ERROR,1201,"but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, P",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433
https://github.com/CliMA/Oceananigans.jl/issues/2433:1208,Availability,ERROR,ERROR,1208,"but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, P",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433
https://github.com/CliMA/Oceananigans.jl/issues/2433:10176,Availability,error,error,10176,"tations.Permutation{(2, 1, 3), 3}, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}, Vector{ComplexF64}}}); @ Oceananigans.Distributed /glade/work/tomasc/.julia/packages/Oceananigans/9ZFqp/src/Distributed/distributed_fft_based_poisson_solver.jl:65; [10] solve_for_pressure!(pressure::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, MultiArch{CPU, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{HaloCommunication, Oceananigans.Distributed.HaloCommunicationRanks{Int64, Int64}}, BoundaryCondition{HaloCommunication, Oceananigans.Distributed.HaloCommunicationRanks{Int64, Int64}}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, solver::Base.Broadcast ./broadcast.jl:495; ```; ... and the error continues. Am I missing something obvious here? Is this script expected to work?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433
https://github.com/CliMA/Oceananigans.jl/issues/2433:1215,Performance,Load,LoadError,1215,"but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, P",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433
https://github.com/CliMA/Oceananigans.jl/issues/2433:1226,Performance,Load,LoadError,1226,"but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, P",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433
https://github.com/CliMA/Oceananigans.jl/issues/2433:136,Testability,benchmark,benchmark,136,"This is related to https://github.com/CliMA/Oceananigans.jl/pull/2432. I'm trying to run the [`distributed_nonhydrostatic_model_mpi.jl` benchmark](https://github.com/CliMA/Oceananigans.jl/blob/9eb055064e68f6a725cebcf9973a3ebf1cbad16b/benchmark/distributed_nonhydrostatic_model_mpi.jl) but I'm running into problems. It seems to be something silly but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433
https://github.com/CliMA/Oceananigans.jl/issues/2433:234,Testability,benchmark,benchmark,234,"This is related to https://github.com/CliMA/Oceananigans.jl/pull/2432. I'm trying to run the [`distributed_nonhydrostatic_model_mpi.jl` benchmark](https://github.com/CliMA/Oceananigans.jl/blob/9eb055064e68f6a725cebcf9973a3ebf1cbad16b/benchmark/distributed_nonhydrostatic_model_mpi.jl) but I'm running into problems. It seems to be something silly but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433
https://github.com/CliMA/Oceananigans.jl/pull/2437:727,Deployability,Continuous,ContinuousBoundaryFunction,727,"This PR will implement support boundary conditions on immersed boundaries. The design is to add a new function to the tendency kernel function for each field that represents the contribution to the viscous / diffusive flux divergence in boundary-adjacent cells due to the user-defined immersed boundary condition. This PR will support `Flux` boundary conditions for sure. If it turns out to be simple, this PR will also support `Value` / `Gradient` boundary conditions for `ScalarDiffusivity`. There may be some challenges when `ScalarDiffusivity` is embedded in a closure tuple (ie the case we get for wall-resolved LES). Hopefully the solution to that is not too complicated. Another problem to solve is how to ""regularize"" `ContinuousBoundaryFunction`. Immersed boundary conditions are 3D, so function of `i, j, k`. Thus we need a slightly different interface for them. `discrete_form=true` will also have a different signature (`i, j, k, grid, ...` rather than `i, j, grid, ...`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437
https://github.com/CliMA/Oceananigans.jl/pull/2437:853,Integrability,interface,interface,853,"This PR will implement support boundary conditions on immersed boundaries. The design is to add a new function to the tendency kernel function for each field that represents the contribution to the viscous / diffusive flux divergence in boundary-adjacent cells due to the user-defined immersed boundary condition. This PR will support `Flux` boundary conditions for sure. If it turns out to be simple, this PR will also support `Value` / `Gradient` boundary conditions for `ScalarDiffusivity`. There may be some challenges when `ScalarDiffusivity` is embedded in a closure tuple (ie the case we get for wall-resolved LES). Hopefully the solution to that is not too complicated. Another problem to solve is how to ""regularize"" `ContinuousBoundaryFunction`. Immersed boundary conditions are 3D, so function of `i, j, k`. Thus we need a slightly different interface for them. `discrete_form=true` will also have a different signature (`i, j, k, grid, ...` rather than `i, j, grid, ...`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437
https://github.com/CliMA/Oceananigans.jl/pull/2437:394,Usability,simpl,simple,394,"This PR will implement support boundary conditions on immersed boundaries. The design is to add a new function to the tendency kernel function for each field that represents the contribution to the viscous / diffusive flux divergence in boundary-adjacent cells due to the user-defined immersed boundary condition. This PR will support `Flux` boundary conditions for sure. If it turns out to be simple, this PR will also support `Value` / `Gradient` boundary conditions for `ScalarDiffusivity`. There may be some challenges when `ScalarDiffusivity` is embedded in a closure tuple (ie the case we get for wall-resolved LES). Hopefully the solution to that is not too complicated. Another problem to solve is how to ""regularize"" `ContinuousBoundaryFunction`. Immersed boundary conditions are 3D, so function of `i, j, k`. Thus we need a slightly different interface for them. `discrete_form=true` will also have a different signature (`i, j, k, grid, ...` rather than `i, j, grid, ...`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437
https://github.com/CliMA/Oceananigans.jl/pull/2439:22,Testability,test,tested,22,"This solves #2438 . I tested with the following code and it is working. ```julia; using Oceananigans; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); b = CenterField(grid); location(b); ```. Returns:; ```julia; (Center, Center, Center); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2439
https://github.com/CliMA/Oceananigans.jl/pull/2440:487,Availability,error,error,487,"This allows us to implement ""divergence damping"" for large scale ocean models via `ScalarDiffusivity`:. ```julia; using Oceananigans.TurbulenceClosures: HorizontalDivergenceFormulation; divergence_damping = ScalarDiffusivity(HorizontalDivergenceFormulation(), ν=1); ```. We probably also want vorticity damping. There also might be other names, for vorticity damping the coefficient is often referred to as the ""rotational viscosity"". A few other things:. * Possibly one should throw an error if users specify kappa, since this closure has no tracer diffusion.; * I added an abstract type for the formulations; * Should we use flux=0 fallbacks? We have a substantial amount of code devoted to emitting zero fluxes for many cases (eg zero tracer flux in this case).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440
https://github.com/CliMA/Oceananigans.jl/pull/2441:8,Deployability,update,updates,8,"This PR updates `fill_halo_regions!` to pass location information into the kernels. We need location information to correctly assess distances across the wall (eg `Δx`, `Δy`, `Δz`) when filling halos for `ValueBoundaryCondition` and `GradientBoundaryCondition`. After this PR we should be able to use `ValueBoundaryCondition` and `GradientBoundaryCondition` on curvilinear grids and immersed boundary grids. Resolves #2430; Resolves #2369 ; Resolves #1730. There might be a few other issues on this...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441
https://github.com/CliMA/Oceananigans.jl/issues/2445:188,Availability,error,error,188,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:457,Availability,error,error,457,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:480,Availability,ERROR,ERROR,480,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:487,Availability,ERROR,ERROR,487,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:14828,Availability,error,error,14828,"λx, :λy, :λz), Tuple{Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}}}, PencilArrays.ManyPencilArray{ComplexF64, 3, 3, Tuple{PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.NoPermutation, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(2, 1, 3), 3}, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}, Vector{ComplexF64}}}); @ Oceananigans.Distributed ~/.julia/packages/Oceananigans/nqpMM/src/Distributed/distributed_fft_based_poisson_solver.jl:65; ```; ... the error continues. Also, this part of the distributed tests is currently passing 1.6: https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/test/test_distributed_models.jl#L469-L473. But fails on Julia 1.7 with the same error that I get (part of the reason why https://github.com/CliMA/Oceananigans.jl/pull/2307 isn't ready): https://buildkite.com/clima/oceananigans/builds/6202#6f169fce-d4b4-43e6-947e-fade1e4c7ad3/19-1203. At first I thought this was a limitation of `PencilArrays.jl`, which is why I created https://github.com/jipolanco/PencilArrays.jl/issues/49. But from the answer I got there that doesn't seem to be the case. I don't fully understand [the answer](https://github.com/jipolanco/PencilArrays.jl/issues/49#issuecomment-1100907232), but it makes me think that something might be up with our distributed architecture implementation and it'd be nice to get some other eyes here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:15079,Availability,error,error,15079,"λx, :λy, :λz), Tuple{Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}}}, PencilArrays.ManyPencilArray{ComplexF64, 3, 3, Tuple{PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.NoPermutation, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(2, 1, 3), 3}, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}, Vector{ComplexF64}}}); @ Oceananigans.Distributed ~/.julia/packages/Oceananigans/nqpMM/src/Distributed/distributed_fft_based_poisson_solver.jl:65; ```; ... the error continues. Also, this part of the distributed tests is currently passing 1.6: https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/test/test_distributed_models.jl#L469-L473. But fails on Julia 1.7 with the same error that I get (part of the reason why https://github.com/CliMA/Oceananigans.jl/pull/2307 isn't ready): https://buildkite.com/clima/oceananigans/builds/6202#6f169fce-d4b4-43e6-947e-fade1e4c7ad3/19-1203. At first I thought this was a limitation of `PencilArrays.jl`, which is why I created https://github.com/jipolanco/PencilArrays.jl/issues/49. But from the answer I got there that doesn't seem to be the case. I don't fully understand [the answer](https://github.com/jipolanco/PencilArrays.jl/issues/49#issuecomment-1100907232), but it makes me think that something might be up with our distributed architecture implementation and it'd be nice to get some other eyes here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:194,Integrability,depend,depending,194,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:494,Performance,Load,LoadError,494,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:505,Performance,Load,LoadError,505,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:123,Testability,benchmark,benchmark,123,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:14880,Testability,test,tests,14880,"λx, :λy, :λz), Tuple{Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}}}, PencilArrays.ManyPencilArray{ComplexF64, 3, 3, Tuple{PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.NoPermutation, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(2, 1, 3), 3}, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}, Vector{ComplexF64}}}); @ Oceananigans.Distributed ~/.julia/packages/Oceananigans/nqpMM/src/Distributed/distributed_fft_based_poisson_solver.jl:65; ```; ... the error continues. Also, this part of the distributed tests is currently passing 1.6: https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/test/test_distributed_models.jl#L469-L473. But fails on Julia 1.7 with the same error that I get (part of the reason why https://github.com/CliMA/Oceananigans.jl/pull/2307 isn't ready): https://buildkite.com/clima/oceananigans/builds/6202#6f169fce-d4b4-43e6-947e-fade1e4c7ad3/19-1203. At first I thought this was a limitation of `PencilArrays.jl`, which is why I created https://github.com/jipolanco/PencilArrays.jl/issues/49. But from the answer I got there that doesn't seem to be the case. I don't fully understand [the answer](https://github.com/jipolanco/PencilArrays.jl/issues/49#issuecomment-1100907232), but it makes me think that something might be up with our distributed architecture implementation and it'd be nice to get some other eyes here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2445:14999,Testability,test,test,14999,"λx, :λy, :λz), Tuple{Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}}}, PencilArrays.ManyPencilArray{ComplexF64, 3, 3, Tuple{PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.NoPermutation, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(2, 1, 3), 3}, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}, Vector{ComplexF64}}}); @ Oceananigans.Distributed ~/.julia/packages/Oceananigans/nqpMM/src/Distributed/distributed_fft_based_poisson_solver.jl:65; ```; ... the error continues. Also, this part of the distributed tests is currently passing 1.6: https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/test/test_distributed_models.jl#L469-L473. But fails on Julia 1.7 with the same error that I get (part of the reason why https://github.com/CliMA/Oceananigans.jl/pull/2307 isn't ready): https://buildkite.com/clima/oceananigans/builds/6202#6f169fce-d4b4-43e6-947e-fade1e4c7ad3/19-1203. At first I thought this was a limitation of `PencilArrays.jl`, which is why I created https://github.com/jipolanco/PencilArrays.jl/issues/49. But from the answer I got there that doesn't seem to be the case. I don't fully understand [the answer](https://github.com/jipolanco/PencilArrays.jl/issues/49#issuecomment-1100907232), but it makes me think that something might be up with our distributed architecture implementation and it'd be nice to get some other eyes here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445
https://github.com/CliMA/Oceananigans.jl/issues/2450:673,Integrability,interface,interfaces,673,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450
https://github.com/CliMA/Oceananigans.jl/issues/2450:778,Integrability,interface,interfaces,778,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450
https://github.com/CliMA/Oceananigans.jl/issues/2450:987,Integrability,interface,interfaces,987,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450
https://github.com/CliMA/Oceananigans.jl/issues/2450:1424,Integrability,interface,interfaces,1424,"be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that shear production and buoyancy flux include the _total_ contribution, not just the contribution from CATKE diffusion (@simone-silvestri this is especially important if we want to pair CATKE with a mass flux scheme). Does anyone else have any suggestion or things on their wishlist?. cc @adelinehillier @sandreza @na",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450
https://github.com/CliMA/Oceananigans.jl/issues/2450:1719,Integrability,depend,dependent,1719," stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that shear production and buoyancy flux include the _total_ contribution, not just the contribution from CATKE diffusion (@simone-silvestri this is especially important if we want to pair CATKE with a mass flux scheme). Does anyone else have any suggestion or things on their wishlist?. cc @adelinehillier @sandreza @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450
https://github.com/CliMA/Oceananigans.jl/issues/2450:260,Security,validat,validation,260,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450
https://github.com/CliMA/Oceananigans.jl/issues/2450:56,Usability,feedback,feedback,56,"I'm opening this issue to have a discussion and solicit feedback on a few proposed improvements to CATKEVerticalDiffusivity. The most crucial improvement was to implement semi-implicit time-stepping for the dissipation term in the TKE equation, in #2426 . In `validation/windy_convection.jl`, the time-step had to be 30 seconds for CATKE stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450
https://github.com/CliMA/Oceananigans.jl/issues/2450:1609,Usability,simpl,simpler,1609," stability before this PR. After that PR, a time-step of 10 minutes was stable. For models ~ 1 deg resolution we need to be able to take 20 minute time-steps, so this change was necessary if CATKE were to be used in a global simulation. Another change being implemented in #2449 is to calculate the CATKE diffusivities at vertical cell interfaces, rather than cell centers. This is natural because the diffusivity is _used_ at vertical cell interfaces (for horizontal momentum components and tracers), and also because many of the quantities involved in calculating the CATKE diffusivity (buoyancy frequency, shear) are also located at vertical cell interfaces. I think there's a few other developments that may be needed:. - Revision of the ""convective adjustment"" part of CATKE. We haven't yet succeeded in formulating a version of CATKE that's more accurate when ""convective adjustment"" is included (I use quotes, because its a dynamic convective adjustment rather than the typical static-diffusivity convective adjustment); - Should we consider also calculating TKE at vertical cell interfaces? This makes sense if we think of TKE as ""mostly"" vertical velocity variance. If we do this, we may need to change the boundary conditions that we use for TKE.; - A cheaper / simpler stability function. We currently use a tanh-based stability function (the stability function is an Ri-dependent coefficient that decreases mixing coefficients when Ri increases). We might use a piecewise linear function (cheaper) or perhaps an exponential (an exponential stability function improved Ri-based results in #2423); - CATKE's TKE equation needs to be generalized so that shear production and buoyancy flux include the _total_ contribution, not just the contribution from CATKE diffusion (@simone-silvestri this is especially important if we want to pair CATKE with a mass flux scheme). Does anyone else have any suggestion or things on their wishlist?. cc @adelinehillier @sandreza @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2450
https://github.com/CliMA/Oceananigans.jl/issues/2452:11,Testability,benchmark,benchmark,11,"We need to benchmark various flavors of `ImmersedBoundaryGrid` including. * `GridFittedBoundary` for immersed boundaries that are both function-based (computed on the fly) and array-based (precomputed); * `GridFittedBottom` for the same (I think for _this_ case, precomputation is always wise. That's not the case for `GridFittedBoundary` though. The benchmarks will hopefully show this.); * Various immersed boundary conditions implemented in #2437 . These should be implemented for both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2452
https://github.com/CliMA/Oceananigans.jl/issues/2452:351,Testability,benchmark,benchmarks,351,"We need to benchmark various flavors of `ImmersedBoundaryGrid` including. * `GridFittedBoundary` for immersed boundaries that are both function-based (computed on the fly) and array-based (precomputed); * `GridFittedBottom` for the same (I think for _this_ case, precomputation is always wise. That's not the case for `GridFittedBoundary` though. The benchmarks will hopefully show this.); * Various immersed boundary conditions implemented in #2437 . These should be implemented for both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2452
https://github.com/CliMA/Oceananigans.jl/issues/2453:124,Security,validat,validation,124,"At high enough ~~vertical~~ vertical + horizontal resolution, it seems that the `zonally_averaged_baroclinic_adjustment.jl` validation test blows up with `IsopycnalSkewSymmetricDiffusivity`; specifically:. ```julia; gerdes_koberle_willebrand_tapering = FluxTapering(1e-2); gent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = 1000,; κ_symmetric = 900,; slope_limiter = gerdes_koberle_willebrand_tapering); ```. For example, with 50m vertical resolution (Nz=20, Lz=1000m, 20km horizontal resolution) we find. https://user-images.githubusercontent.com/15271942/164360760-ef03fc9d-e07a-4b50-9e80-bd79997cfa1d.mp4. while at 25m resolution (same extent, horizontal resolution, time-step) we find. https://user-images.githubusercontent.com/15271942/164360772-e39a08e4-eb5e-48e4-bfc4-cde1e241ec0f.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2453
https://github.com/CliMA/Oceananigans.jl/issues/2453:135,Testability,test,test,135,"At high enough ~~vertical~~ vertical + horizontal resolution, it seems that the `zonally_averaged_baroclinic_adjustment.jl` validation test blows up with `IsopycnalSkewSymmetricDiffusivity`; specifically:. ```julia; gerdes_koberle_willebrand_tapering = FluxTapering(1e-2); gent_mcwilliams_diffusivity = IsopycnalSkewSymmetricDiffusivity(κ_skew = 1000,; κ_symmetric = 900,; slope_limiter = gerdes_koberle_willebrand_tapering); ```. For example, with 50m vertical resolution (Nz=20, Lz=1000m, 20km horizontal resolution) we find. https://user-images.githubusercontent.com/15271942/164360760-ef03fc9d-e07a-4b50-9e80-bd79997cfa1d.mp4. while at 25m resolution (same extent, horizontal resolution, time-step) we find. https://user-images.githubusercontent.com/15271942/164360772-e39a08e4-eb5e-48e4-bfc4-cde1e241ec0f.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2453
https://github.com/CliMA/Oceananigans.jl/issues/2454:89,Security,expose,exposed,89,"We need to overhaul the way we specify advection schemes, whose current limitations were exposed when ""WENO vector invariant"" was implemented. I propose that we implement a hierarchical specification system using a new object called `AdvectionScheme` that specifies. 1. The ""form"" of the advection operator for momentum and tracers (either `VectorInvariant` or `FluxForm` for momentum, always `FluxForm` for tracers); 2. For `FluxForm`, the reconstruction scheme for the advected component ; 3. For `VectorInvariant`, the stencil for _computing_ vorticity, as well as the method for _reconstructing_ vorticity at the momentum locations; 4. For `VectorInvariant` with WENO reconstruction, the type of the smoothness stencil (vorticity or velocity); 5. The method for reconstruction velocities in mass conservation (continuity) as well as tracer advection. We also may want to specify how we reconstruction _advecting_ velocities for flux form momentum advection (right now we use centered advection with an accuracy one order lower than the accuracy of the advected component reconstruction --- ie with `UpwindBiasedFifthOrder()` we reconstruct advecting components with a centered fourth order scheme). Finally, we need to allow different schemes for every tracer. This modular design will allow more detailed specification of an advection scheme and also us to remove the option for WENO reconstruction for vector invariant more easily, which @simone-silvestri pointed out is experimental. We also would like to explore alternative discretization for the continuity equation. For this we need a ""mass"" reconstruction scheme, and the advecting scheme for tracers needs to reconstruct `advected_velocity` in a way that's consistent with the mass reconstruction. Here's a sketch of what these new types might look like:. ```julia; """""" Specifies a reconstruction scheme for fluxes of the form u * c,; where u is the `advecting_velocity` and c is the `advected_quantity` """"""; struct FluxFormAdvection; adv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2454
https://github.com/CliMA/Oceananigans.jl/issues/2457:777,Usability,clear,clear,777,"### Discussed in https://github.com/CliMA/Oceananigans.jl/discussions/2455. <div type='discussions-op-text'>. <sup>Originally posted by **iuryt** April 21, 2022</sup>; Hi,. I couldn't find an example from the docs that uses a regular array, converts to `CudaArray` and them use it as an initial condition for a GPU run. Do you guys have any example of that that could share? Maybe would be good to consider putting an example like this on the docs.</div>. I think we should add examples on the docs for setting initial conditions with Arrays using CPU and GPU.; https://clima.github.io/OceananigansDocumentation/stable/model_setup/setting_initial_conditions/#Setting-initial-conditions. I know that for CPU it should be straight forward, but I think it is important to make it clear. Also, it might not be like this for GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2457
https://github.com/CliMA/Oceananigans.jl/pull/2461:8,Deployability,update,updates,8,"This PR updates CATKE parameters, which was needed after the semi-implicit time-stepping for the TKE equation was introduced in #2426. This PR is all @adelinehillier's work!. The results were generated by training with a 2 minute time-step (previously we had to use time-steps as small as 1 second during training), and are pretty promising:. ![image](https://user-images.githubusercontent.com/15271942/164771409-22f836fc-6ccb-4432-b97b-74de87dbb825.png). The next step is to calibrate and test CATKE at different vertical resolutions. But this is a good start.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461
https://github.com/CliMA/Oceananigans.jl/pull/2461:490,Testability,test,test,490,"This PR updates CATKE parameters, which was needed after the semi-implicit time-stepping for the TKE equation was introduced in #2426. This PR is all @adelinehillier's work!. The results were generated by training with a 2 minute time-step (previously we had to use time-steps as small as 1 second during training), and are pretty promising:. ![image](https://user-images.githubusercontent.com/15271942/164771409-22f836fc-6ccb-4432-b97b-74de87dbb825.png). The next step is to calibrate and test CATKE at different vertical resolutions. But this is a good start.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461
https://github.com/CliMA/Oceananigans.jl/issues/2462:172,Safety,detect,detected,172,"This has a few benefits:. 1. Users know when `set!` has been invoked, and how long it takes to run (if we emit timing data as well); 2. Incorrect initial conditions may be detected. In a way this would look like just a single output of @christophernhill 's ""state checker"" idea, so we might be able to combine code for those utilities (which could also pave the way for default logging in `run!`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2462
https://github.com/CliMA/Oceananigans.jl/issues/2462:378,Testability,log,logging,378,"This has a few benefits:. 1. Users know when `set!` has been invoked, and how long it takes to run (if we emit timing data as well); 2. Incorrect initial conditions may be detected. In a way this would look like just a single output of @christophernhill 's ""state checker"" idea, so we might be able to combine code for those utilities (which could also pave the way for default logging in `run!`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2462
https://github.com/CliMA/Oceananigans.jl/pull/2463:997,Availability,down,download,997,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463
https://github.com/CliMA/Oceananigans.jl/pull/2463:466,Deployability,update,update,466,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463
https://github.com/CliMA/Oceananigans.jl/pull/2463:1218,Performance,load,loaded,1218,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463
https://github.com/CliMA/Oceananigans.jl/pull/2463:48,Security,validat,validation,48,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463
https://github.com/CliMA/Oceananigans.jl/pull/2463:589,Security,validat,validation,589,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463
https://github.com/CliMA/Oceananigans.jl/issues/2470:399,Deployability,update,update,399,"I opened a wiki for Oceananigans:. https://github.com/CliMA/Oceananigans.jl/wiki. I think we should use the wiki to host practical information and tips for using Oceananigans on various hardware (laptops, CPUs, GPUs), clusters / high-performance computing system (HPCs), and more. Using the wiki this way will allow us to focus the docs on code and numerics, and alleviate the need to submit PRs to update details about using clusters. We need to provide an introduction to Oceananigans ""knowledge base"" (where to find useful information in the documentation, wiki, Github Discussions, and Github Issues) in the README, the docs, and the wiki.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2470
https://github.com/CliMA/Oceananigans.jl/issues/2470:234,Performance,perform,performance,234,"I opened a wiki for Oceananigans:. https://github.com/CliMA/Oceananigans.jl/wiki. I think we should use the wiki to host practical information and tips for using Oceananigans on various hardware (laptops, CPUs, GPUs), clusters / high-performance computing system (HPCs), and more. Using the wiki this way will allow us to focus the docs on code and numerics, and alleviate the need to submit PRs to update details about using clusters. We need to provide an introduction to Oceananigans ""knowledge base"" (where to find useful information in the documentation, wiki, Github Discussions, and Github Issues) in the README, the docs, and the wiki.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2470
https://github.com/CliMA/Oceananigans.jl/pull/2474:8,Deployability,update,updates,8,"This PR updates the docs to provide stronger links to the [new wiki](https://github.com/CliMA/Oceananigans.jl/wiki). There's a few more updates I'd like to make, and perhaps we can completely migrate ""using GPUs"" and ""installation instructions"" over to the new wiki? @tomchor and @navidcy are the docs aficionados so let's see what they think. ~I'd also like to resolve #2471 .~. Closes #2471",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2474
https://github.com/CliMA/Oceananigans.jl/pull/2474:136,Deployability,update,updates,136,"This PR updates the docs to provide stronger links to the [new wiki](https://github.com/CliMA/Oceananigans.jl/wiki). There's a few more updates I'd like to make, and perhaps we can completely migrate ""using GPUs"" and ""installation instructions"" over to the new wiki? @tomchor and @navidcy are the docs aficionados so let's see what they think. ~I'd also like to resolve #2471 .~. Closes #2471",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2474
https://github.com/CliMA/Oceananigans.jl/pull/2474:218,Deployability,install,installation,218,"This PR updates the docs to provide stronger links to the [new wiki](https://github.com/CliMA/Oceananigans.jl/wiki). There's a few more updates I'd like to make, and perhaps we can completely migrate ""using GPUs"" and ""installation instructions"" over to the new wiki? @tomchor and @navidcy are the docs aficionados so let's see what they think. ~I'd also like to resolve #2471 .~. Closes #2471",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2474
https://github.com/CliMA/Oceananigans.jl/issues/2475:636,Deployability,integrat,integrating,636,"We use `∂xᶠᶜᶜ(i, j, k, grid, η)` to represent the x-component of the barotropic pressure gradient, for example:. https://github.com/CliMA/Oceananigans.jl/blob/be040379ec20d77a8968ba3c0dff71aeed1b2a38/src/Models/HydrostaticFreeSurfaceModels/barotropic_pressure_correction.jl#L49-L50. which also appears in the left-side operator for the implicit free surface solver:. https://github.com/CliMA/Oceananigans.jl/blob/be040379ec20d77a8968ba3c0dff71aeed1b2a38/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L141-L142. But a finite volume discretization of x-component of the barotropic pressure gradient term (ie integrating over cell areas, then using Gauss' theorem to transform the volume integral into a surface integral) would look like. <img width=""308"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165198034-1a4fb702-2abc-4ea8-a028-dae750fdeee3.png"">. where I've canceled some `dz`, but don't seem to be able to cancel `dy`. Are we making some latent approximation here that we may not need to make?. @simone-silvestri @christophernhill ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475
https://github.com/CliMA/Oceananigans.jl/issues/2475:636,Integrability,integrat,integrating,636,"We use `∂xᶠᶜᶜ(i, j, k, grid, η)` to represent the x-component of the barotropic pressure gradient, for example:. https://github.com/CliMA/Oceananigans.jl/blob/be040379ec20d77a8968ba3c0dff71aeed1b2a38/src/Models/HydrostaticFreeSurfaceModels/barotropic_pressure_correction.jl#L49-L50. which also appears in the left-side operator for the implicit free surface solver:. https://github.com/CliMA/Oceananigans.jl/blob/be040379ec20d77a8968ba3c0dff71aeed1b2a38/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L141-L142. But a finite volume discretization of x-component of the barotropic pressure gradient term (ie integrating over cell areas, then using Gauss' theorem to transform the volume integral into a surface integral) would look like. <img width=""308"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165198034-1a4fb702-2abc-4ea8-a028-dae750fdeee3.png"">. where I've canceled some `dz`, but don't seem to be able to cancel `dy`. Are we making some latent approximation here that we may not need to make?. @simone-silvestri @christophernhill ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475
https://github.com/CliMA/Oceananigans.jl/pull/2477:1064,Integrability,depend,dependency,1064,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477
https://github.com/CliMA/Oceananigans.jl/pull/2477:1294,Modifiability,Refactor,Refactor,1294,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477
https://github.com/CliMA/Oceananigans.jl/pull/2477:840,Performance,perform,performance,840,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477
https://github.com/CliMA/Oceananigans.jl/pull/2477:1203,Performance,perform,performance,1203,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477
https://github.com/CliMA/Oceananigans.jl/pull/2477:949,Safety,avoid,avoided,949,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477
https://github.com/CliMA/Oceananigans.jl/pull/2477:981,Safety,avoid,avoiding,981,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477
https://github.com/CliMA/Oceananigans.jl/issues/2479:110,Availability,error,error,110,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:192,Availability,error,error,192,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:364,Availability,error,error,364,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:661,Availability,ERROR,ERROR,661,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:673,Availability,error,error,673,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:864,Availability,error,error,864,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:1284,Availability,error,error,1284,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:1475,Availability,error,error,1475,"ed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:1553,Availability,error,error,1553,"ed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:370,Integrability,message,message,370,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:961,Integrability,synchroniz,synchronize,961,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:1080,Integrability,synchroniz,synchronize,1080,"ncountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{V",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:1268,Performance,Load,LoadError,1268,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:2223,Performance,cache,cache,2223,"ed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:2415,Performance,cache,cache,2415,"ed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:698,Security,access,access,698,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:1309,Security,access,access,1309,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2479:14,Testability,test,tests,14,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479
https://github.com/CliMA/Oceananigans.jl/issues/2480:523,Availability,error,errored,523,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:985,Availability,ERROR,ERROR,985,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:1084,Availability,error,error,1084,"o Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d127",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:1111,Availability,error,error,1111,"try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4279,Availability,ERROR,ERROR,4279,"quire(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4430,Availability,error,error,4430,"ng.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4457,Availability,error,error,4457,"scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:37",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:5764,Availability,ERROR,ERROR,5764,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:5922,Availability,error,error,5922,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:5949,Availability,error,error,5949,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:42,Deployability,install,installing,42,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:193,Deployability,install,installation,193,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:455,Integrability,depend,dependencies,455,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:510,Integrability,depend,dependencies,510,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:3022,Integrability,wrap,wrappers,3022,"rom: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:1023,Modifiability,config,configured,1023,"ical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:598,Performance,load,load,598,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:992,Performance,Load,LoadError,992,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:1453,Performance,load,loading,1453,"ependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:1713,Performance,Load,LoadError,1713,", like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:1745,Performance,load,load,1745,", like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:1978,Performance,load,loaded,1978,"e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPIC",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:3147,Performance,load,loading,3147,"ean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ non",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:3246,Performance,load,loading,3246,"ile), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packag",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:3302,Performance,load,loading,3302,"b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:3362,Performance,load,loading,3362,"e), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:3428,Performance,load,loading,3428,"a/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bool); @ Base.Libc.Libdl ./libdl.jl:117; [2] dlopen(s::String, flags::UInt32); @ Base.Libc.Libdl ./libdl.jl:117; [3] macro expansion; @ ~/.julia/packages/JLLWrappers/QpMQW/src/products/library_generators.jl:54 [inlined]; [4] __init__(); @ MPICH_jll ~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] er",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:3981,Performance,load,loading,3981,"~/.julia/packages/MPICH_jll/dhUyI/src/wrappers/aarch64-apple-darwin-libgfortran5.jl:32; [5] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:768; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:854; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1097; [8] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4286,Performance,Load,LoadError,4286,"quire(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4599,Performance,load,loading,4599," MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.jul",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4674,Performance,load,loading,4674,"ulia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in express",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4731,Performance,load,loading,4731,"Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4791,Performance,load,loading,4791,"Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:4857,Performance,load,loading,4857,"h::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:5386,Performance,load,loading,5386,"ed/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:6091,Performance,load,loading,6091,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:6166,Performance,load,loading,6166,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:6223,Performance,load,loading,6223,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:6283,Performance,load,loading,6283,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:6349,Performance,load,loading,6349,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/issues/2480:368,Testability,log,log,368,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480
https://github.com/CliMA/Oceananigans.jl/pull/2481:8,Modifiability,refactor,refactors,8,"This PR refactors the calculation of `isopycnal_rotation_components` to _actually_ use the ""Cox stencil"" described by [Griffies et al 1998](https://journals.ametsoc.org/view/journals/phoc/28/5/1520-0485_1998_028_0805_idiazc_2.0.co_2.xml). ~~It looks to me like MITgcm uses this so-called anti-Cox stencil.~~ It looks like MITgcm uses the Cox stencil. For example, when calculating the ""Gradient of Sigma at rVel points"" --- which appears in `isopycnal_rotation_tensor_xz_ccf` --- MITgcm uses. https://github.com/MITgcm/MITgcm/blob/9bcb4977016b9cc234328aa357b105d227417e43/pkg/gmredi/gmredi_calc_tensor.F#L712. which reconstructs the x-component of the density gradient by _averaging the gradient_ (with a four point average). On the other hand, we use. https://github.com/CliMA/Oceananigans.jl/blob/001ec56debf0447103d9b75c81de4036a8d6a94a/src/TurbulenceClosures/isopycnal_rotation_tensor_components.jl#L68. which instead computes the _gradient of the average_ (first by averaging with 4 points, then calculating the gradient of that). ~~But Griffies 1998 describers the Cox87 discretization as~~ EDIT: we were confused by Griffies' notation. NOW, this PR changes all the buoyancy gradient calculations so they are similar to MITgcm (average of the gradient) --- the ""actually-Cox stencil"". We'll see what that does.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481
https://github.com/CliMA/Oceananigans.jl/pull/2484:52,Deployability,update,update,52,Captures immersed boundary condition API #2437 docs update #2474,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2484
https://github.com/CliMA/Oceananigans.jl/pull/2487:166,Integrability,depend,depends,166,"This PR adds the capability for treating the ""33"" component of the symmetric isoneutral diffusive flux implicitly. cc @sandreza would be great if you test this. This depends on #2481",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2487
https://github.com/CliMA/Oceananigans.jl/pull/2487:150,Testability,test,test,150,"This PR adds the capability for treating the ""33"" component of the symmetric isoneutral diffusive flux implicitly. cc @sandreza would be great if you test this. This depends on #2481",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2487
https://github.com/CliMA/Oceananigans.jl/pull/2488:181,Deployability,update,update,181,"According to https://pkgdocs.julialang.org/v1/compatibility/, `MPICH_jll = ""4.0.1""` means `[4.0.1 - 5.0.0)` and it's not what we wanted!. (And indeed, when I called `using Pkg; Pkg.update()` MPICH_jll got updated to 4.0.2.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488
https://github.com/CliMA/Oceananigans.jl/pull/2488:205,Deployability,update,updated,205,"According to https://pkgdocs.julialang.org/v1/compatibility/, `MPICH_jll = ""4.0.1""` means `[4.0.1 - 5.0.0)` and it's not what we wanted!. (And indeed, when I called `using Pkg; Pkg.update()` MPICH_jll got updated to 4.0.2.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488
https://github.com/CliMA/Oceananigans.jl/issues/2492:1097,Availability,down,downside,1097,"This really depends where we want to take this abstraction. One possibility is to develop ""four-dimensional fields"". This is sort of what the design reflects now (ie we subtype `AbstractField`, etc). Another possibility is to ditch that and cement `Fields` as 3 dimensional and less, and commit the `FieldTimeSeries` abstraction to look like a 1D vector of 3D fields. It seems like a subtle distinction, but is has some important consequences. For example, what should. ```julia; first(fts::FieldTimeSeries); ```. return? If `FieldTimeSeries` is 4D then this is either `parent(fts)[1, 1, 1, 1]` or `fts.data[1, 1, 1 ,1]`. But if `FieldTimeSeries` is 1D this is `fts[1]` --- the first _Field_. I think it's nice to have `first(fts)` and `last(fts)` return fields --- we use stuff like that _a lot_, but right now we are forced to write stuff like. ```julia; Nt = length(fts.times); fts[Nt]; ```. kind of annoying. Right now the API is hybrid; ie we have `getindex(fts, i)` _and_ `getindex(fts, i, j, k, n)`. But we use the ""vector"" abstraction more than the ""4D field mode"" a lot more I think. One downside is that this might preclude defining a `∂t` abstract operation. I don't think this impacts support for reductions, but I have to think about that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2492
https://github.com/CliMA/Oceananigans.jl/issues/2492:12,Integrability,depend,depends,12,"This really depends where we want to take this abstraction. One possibility is to develop ""four-dimensional fields"". This is sort of what the design reflects now (ie we subtype `AbstractField`, etc). Another possibility is to ditch that and cement `Fields` as 3 dimensional and less, and commit the `FieldTimeSeries` abstraction to look like a 1D vector of 3D fields. It seems like a subtle distinction, but is has some important consequences. For example, what should. ```julia; first(fts::FieldTimeSeries); ```. return? If `FieldTimeSeries` is 4D then this is either `parent(fts)[1, 1, 1, 1]` or `fts.data[1, 1, 1 ,1]`. But if `FieldTimeSeries` is 1D this is `fts[1]` --- the first _Field_. I think it's nice to have `first(fts)` and `last(fts)` return fields --- we use stuff like that _a lot_, but right now we are forced to write stuff like. ```julia; Nt = length(fts.times); fts[Nt]; ```. kind of annoying. Right now the API is hybrid; ie we have `getindex(fts, i)` _and_ `getindex(fts, i, j, k, n)`. But we use the ""vector"" abstraction more than the ""4D field mode"" a lot more I think. One downside is that this might preclude defining a `∂t` abstract operation. I don't think this impacts support for reductions, but I have to think about that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2492
https://github.com/CliMA/Oceananigans.jl/issues/2493:305,Deployability,update,updated,305,"Hello,; My [fork](https://github.com/matinraayai/Oceananigans.jl) of Oceananigans.jl is in the process of adding AMDGPU support for the code base. I've added a new architecture called ROCMGPU, and changed the name of the GPU architecture to CUDAGPU. ; Some of the operations are ported, and the tests are updated to use ROCMGPU as well. @christophernhill and I are in the process of running each test suite to see what other operations need to be tweaked for AMDGPU.; 1. I would like to push this work on a branch on the main codebase, called amdgpu for it to get more attention.; 2. Any help on getting the tests working would be much appreciated.; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493
https://github.com/CliMA/Oceananigans.jl/issues/2493:295,Testability,test,tests,295,"Hello,; My [fork](https://github.com/matinraayai/Oceananigans.jl) of Oceananigans.jl is in the process of adding AMDGPU support for the code base. I've added a new architecture called ROCMGPU, and changed the name of the GPU architecture to CUDAGPU. ; Some of the operations are ported, and the tests are updated to use ROCMGPU as well. @christophernhill and I are in the process of running each test suite to see what other operations need to be tweaked for AMDGPU.; 1. I would like to push this work on a branch on the main codebase, called amdgpu for it to get more attention.; 2. Any help on getting the tests working would be much appreciated.; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493
https://github.com/CliMA/Oceananigans.jl/issues/2493:396,Testability,test,test,396,"Hello,; My [fork](https://github.com/matinraayai/Oceananigans.jl) of Oceananigans.jl is in the process of adding AMDGPU support for the code base. I've added a new architecture called ROCMGPU, and changed the name of the GPU architecture to CUDAGPU. ; Some of the operations are ported, and the tests are updated to use ROCMGPU as well. @christophernhill and I are in the process of running each test suite to see what other operations need to be tweaked for AMDGPU.; 1. I would like to push this work on a branch on the main codebase, called amdgpu for it to get more attention.; 2. Any help on getting the tests working would be much appreciated.; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493
https://github.com/CliMA/Oceananigans.jl/issues/2493:608,Testability,test,tests,608,"Hello,; My [fork](https://github.com/matinraayai/Oceananigans.jl) of Oceananigans.jl is in the process of adding AMDGPU support for the code base. I've added a new architecture called ROCMGPU, and changed the name of the GPU architecture to CUDAGPU. ; Some of the operations are ported, and the tests are updated to use ROCMGPU as well. @christophernhill and I are in the process of running each test suite to see what other operations need to be tweaked for AMDGPU.; 1. I would like to push this work on a branch on the main codebase, called amdgpu for it to get more attention.; 2. Any help on getting the tests working would be much appreciated.; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493
https://github.com/CliMA/Oceananigans.jl/pull/2496:54,Deployability,install,installing,54,This PR supersedes #2488. I have added a remark about installing/using Oceananigans with Julia v1.7 + Apple M1 chips at https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2496
https://github.com/CliMA/Oceananigans.jl/pull/2496:166,Deployability,Install,Installation-and-getting-started-with-Oceananigans,166,This PR supersedes #2488. I have added a remark about installing/using Oceananigans with Julia v1.7 + Apple M1 chips at https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2496
https://github.com/CliMA/Oceananigans.jl/issues/2497:746,Availability,error,error,746,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/issues/2497:759,Availability,ERROR,ERROR,759,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/issues/2497:42813,Availability,error,error,42813,"(:slice1,), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{UnitRange{Int64}, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32, N} where N}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/MVUJA/src/OutputWriters/netcdf_output_writer.jl:324; [14] top-level scope; @ ~/Dropbox/tests/new_project/tilted.jl:24; [15] include(fname::String); @ Base.MainInclude ./client.jl:444; [16] top-level scope; @ REPL[2]:1; ```. Am I missing something or is this a bug?. PS: I had to exclude a big chunk of the error because the output was too long and github wouldn't let me post it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/issues/2497:504,Energy Efficiency,schedul,schedule,504,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/issues/2497:655,Energy Efficiency,schedul,schedule,655,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/issues/2497:42150,Energy Efficiency,schedul,schedule,42150,"(:slice1,), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{UnitRange{Int64}, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32, N} where N}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/MVUJA/src/OutputWriters/netcdf_output_writer.jl:324; [14] top-level scope; @ ~/Dropbox/tests/new_project/tilted.jl:24; [15] include(fname::String); @ Base.MainInclude ./client.jl:444; [16] top-level scope; @ REPL[2]:1; ```. Am I missing something or is this a bug?. PS: I had to exclude a big chunk of the error because the output was too long and github wouldn't let me post it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/issues/2497:766,Performance,Load,LoadError,766,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/issues/2497:801,Security,access,access,801,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/issues/2497:42594,Testability,test,tests,42594,"(:slice1,), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{UnitRange{Int64}, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32, N} where N}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/MVUJA/src/OutputWriters/netcdf_output_writer.jl:324; [14] top-level scope; @ ~/Dropbox/tests/new_project/tilted.jl:24; [15] include(fname::String); @ Base.MainInclude ./client.jl:444; [16] top-level scope; @ REPL[2]:1; ```. Am I missing something or is this a bug?. PS: I had to exclude a big chunk of the error because the output was too long and github wouldn't let me post it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497
https://github.com/CliMA/Oceananigans.jl/pull/2499:986,Availability,error,error,986,"This PR cherry-picks a commit from #2253 . Before this PR:. ```julia; julia> grid = RectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [-7.51279e-18, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [-7.51279e-18, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z; ```. after:. ```julia; julia> grid = RectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [0.0, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z; ```. Basically, this PR computes the location of the _first halo point_ more accurate, which in turn means that the location of the _right interior boundary_ is computed more accurately, without round-off error (which pollutes `main` at the moment). I think our method could be slightly improved. Here we first truncate to `Float32`, and then expand to `BigFloat` for subsequent arithmetic. The truncation is important, but also means that the _input_ is limited to single-precision accurate. Is that inevitable, or is there another way to achieve this outcome that doesn't lose precision?. PS we may need to do something similar with precision / round-off error for `align_time_step`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499
https://github.com/CliMA/Oceananigans.jl/pull/2499:1438,Availability,error,error,1438,"This PR cherry-picks a commit from #2253 . Before this PR:. ```julia; julia> grid = RectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [-7.51279e-18, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [-7.51279e-18, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z; ```. after:. ```julia; julia> grid = RectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [0.0, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z; ```. Basically, this PR computes the location of the _first halo point_ more accurate, which in turn means that the location of the _right interior boundary_ is computed more accurately, without round-off error (which pollutes `main` at the moment). I think our method could be slightly improved. Here we first truncate to `Float32`, and then expand to `BigFloat` for subsequent arithmetic. The truncation is important, but also means that the _input_ is limited to single-precision accurate. Is that inevitable, or is there another way to achieve this outcome that doesn't lose precision?. PS we may need to do something similar with precision / round-off error for `align_time_step`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499
https://github.com/CliMA/Oceananigans.jl/issues/2501:397,Testability,test,tests,397,"with @glwagner we introduced broadcasts across fields and `OffsetArrays` that include halos, so that. ```; field1 = CenterField(grid); field2 = CenterField(grid). set!(field1, (x, y, z) -> x). data = field1.data. field2 .= data; ```; or alternatively; ```; set!(field2, data); ```; will set not only the interior of the field, but also the halos, without the need of `fill_halo_regions!`. We need tests to make sure this feature does not break somewhere...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2501
https://github.com/CliMA/Oceananigans.jl/pull/2502:8,Deployability,update,updates,8,"This PR updates PencilFFTs to 0.13.4, and fixes the DistributedFFTBasedPoissonSolver. Previously we were attempting to ""partition"" the eigenvalues manually, which produce an inconsistency between the layout of the spectral-space pressure and the eigenvalues. This PR uses `PencilFFTs.localgrid` to partition the eigenvalues instead, and furthermore correctly identifies `last(solver.storage)` (not `solver.storage[2]`) with the _outcome_ of the in-place spectral transform of pressure. Thanks @jlpolanco especially for patiently enduring my utter inability to read documentation. I believe this should resolve #2347 but we'll need to test that directly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502
https://github.com/CliMA/Oceananigans.jl/pull/2502:634,Testability,test,test,634,"This PR updates PencilFFTs to 0.13.4, and fixes the DistributedFFTBasedPoissonSolver. Previously we were attempting to ""partition"" the eigenvalues manually, which produce an inconsistency between the layout of the spectral-space pressure and the eigenvalues. This PR uses `PencilFFTs.localgrid` to partition the eigenvalues instead, and furthermore correctly identifies `last(solver.storage)` (not `solver.storage[2]`) with the _outcome_ of the in-place spectral transform of pressure. Thanks @jlpolanco especially for patiently enduring my utter inability to read documentation. I believe this should resolve #2347 but we'll need to test that directly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502
https://github.com/CliMA/Oceananigans.jl/pull/2506:31,Security,validat,validation,31,"Just so that we could run this validation test with latest Oceananigans. - fix Coriolis, Simulation setting and 2-D initial free-surface in; single face test: surface_gravity_waves_on_face.jl; - fix single face animation: animate_face.jl; - remove ""animate.jl"" (was identical to ""animate_face.jl""); - fix Simulation setting in full cubed test (but more to fix there).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2506
https://github.com/CliMA/Oceananigans.jl/pull/2506:42,Testability,test,test,42,"Just so that we could run this validation test with latest Oceananigans. - fix Coriolis, Simulation setting and 2-D initial free-surface in; single face test: surface_gravity_waves_on_face.jl; - fix single face animation: animate_face.jl; - remove ""animate.jl"" (was identical to ""animate_face.jl""); - fix Simulation setting in full cubed test (but more to fix there).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2506
https://github.com/CliMA/Oceananigans.jl/pull/2506:153,Testability,test,test,153,"Just so that we could run this validation test with latest Oceananigans. - fix Coriolis, Simulation setting and 2-D initial free-surface in; single face test: surface_gravity_waves_on_face.jl; - fix single face animation: animate_face.jl; - remove ""animate.jl"" (was identical to ""animate_face.jl""); - fix Simulation setting in full cubed test (but more to fix there).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2506
https://github.com/CliMA/Oceananigans.jl/pull/2506:338,Testability,test,test,338,"Just so that we could run this validation test with latest Oceananigans. - fix Coriolis, Simulation setting and 2-D initial free-surface in; single face test: surface_gravity_waves_on_face.jl; - fix single face animation: animate_face.jl; - remove ""animate.jl"" (was identical to ""animate_face.jl""); - fix Simulation setting in full cubed test (but more to fix there).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2506
https://github.com/CliMA/Oceananigans.jl/issues/2507:860,Modifiability,layers,layers,860,"Hi all,. I'd be very keen to implement a multi-layer version of the shallow water model. For example, here's the 2-layer version:. <img width=""1002"" alt=""Screen Shot 2022-05-03 at 10 15 14 am"" src=""https://user-images.githubusercontent.com/29700296/166345681-77f90009-2f8b-4db5-8ddd-3808eca11c09.png"">. My ultimate ambition is to solve this set of equations that include a diapycnal term `S_int`:. <img width=""998"" alt=""Screen Shot 2022-05-03 at 10 17 48 am"" src=""https://user-images.githubusercontent.com/29700296/166345823-4ed83b3f-d160-4fea-93d4-2d29100452a8.png"">. where `Q_net` is a prescribed heat forcing at the surface. So, from what I understand and from what I discussed with @navidcy, if we have a multi-layer shallow water model like eqs. 56 above then I can implement the set of eqs with the diapycnal terms added forcing to each individual fluid layers. Does this sound right?. Is enhancing the `ShallowWaterModel` to have multiple layers feasible?. cc @francispoulin, @glwagner, @navidcy, @AndyHoggANU, @rmholmes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507
https://github.com/CliMA/Oceananigans.jl/issues/2507:946,Modifiability,layers,layers,946,"Hi all,. I'd be very keen to implement a multi-layer version of the shallow water model. For example, here's the 2-layer version:. <img width=""1002"" alt=""Screen Shot 2022-05-03 at 10 15 14 am"" src=""https://user-images.githubusercontent.com/29700296/166345681-77f90009-2f8b-4db5-8ddd-3808eca11c09.png"">. My ultimate ambition is to solve this set of equations that include a diapycnal term `S_int`:. <img width=""998"" alt=""Screen Shot 2022-05-03 at 10 17 48 am"" src=""https://user-images.githubusercontent.com/29700296/166345823-4ed83b3f-d160-4fea-93d4-2d29100452a8.png"">. where `Q_net` is a prescribed heat forcing at the surface. So, from what I understand and from what I discussed with @navidcy, if we have a multi-layer shallow water model like eqs. 56 above then I can implement the set of eqs with the diapycnal terms added forcing to each individual fluid layers. Does this sound right?. Is enhancing the `ShallowWaterModel` to have multiple layers feasible?. cc @francispoulin, @glwagner, @navidcy, @AndyHoggANU, @rmholmes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507
https://github.com/CliMA/Oceananigans.jl/pull/2508:337,Safety,avoid,avoid,337,"This PR fixes the behavior seen in https://github.com/CliMA/Oceananigans.jl/issues/2497. Basically due to the behavior of `construct_output()` and the default values for `indices` in the output writer constructors, whenever we pass a `Field` that is already sliced, we re-slice it when constructing the outputs. I'm not sure how to best avoid this behavior (I'm inclined to change the default value of `indices` in the output writers, but I'm taking suggestions), so I'm starting by simply adding a test that should fail without this fix. Closes https://github.com/CliMA/Oceananigans.jl/issues/2497",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508
https://github.com/CliMA/Oceananigans.jl/pull/2508:499,Testability,test,test,499,"This PR fixes the behavior seen in https://github.com/CliMA/Oceananigans.jl/issues/2497. Basically due to the behavior of `construct_output()` and the default values for `indices` in the output writer constructors, whenever we pass a `Field` that is already sliced, we re-slice it when constructing the outputs. I'm not sure how to best avoid this behavior (I'm inclined to change the default value of `indices` in the output writers, but I'm taking suggestions), so I'm starting by simply adding a test that should fail without this fix. Closes https://github.com/CliMA/Oceananigans.jl/issues/2497",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508
https://github.com/CliMA/Oceananigans.jl/pull/2508:483,Usability,simpl,simply,483,"This PR fixes the behavior seen in https://github.com/CliMA/Oceananigans.jl/issues/2497. Basically due to the behavior of `construct_output()` and the default values for `indices` in the output writer constructors, whenever we pass a `Field` that is already sliced, we re-slice it when constructing the outputs. I'm not sure how to best avoid this behavior (I'm inclined to change the default value of `indices` in the output writers, but I'm taking suggestions), so I'm starting by simply adding a test that should fail without this fix. Closes https://github.com/CliMA/Oceananigans.jl/issues/2497",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508
https://github.com/CliMA/Oceananigans.jl/issues/2509:0,Energy Efficiency,Efficient,Efficiently,0,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509
https://github.com/CliMA/Oceananigans.jl/issues/2509:92,Integrability,message,messages,92,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509
https://github.com/CliMA/Oceananigans.jl/issues/2509:191,Integrability,message,message,191,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509
https://github.com/CliMA/Oceananigans.jl/issues/2509:298,Integrability,message,message,298,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509
https://github.com/CliMA/Oceananigans.jl/issues/2509:337,Integrability,message,message,337,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509
https://github.com/CliMA/Oceananigans.jl/issues/2509:171,Modifiability,variab,variables,171,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509
https://github.com/CliMA/Oceananigans.jl/issues/2509:238,Modifiability,variab,variables,238,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509
https://github.com/CliMA/Oceananigans.jl/issues/2509:278,Modifiability,variab,variables,278,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509
https://github.com/CliMA/Oceananigans.jl/pull/2511:173,Testability,test,tested,173,"This pull request changes the compat entry for the `GPUArrays` package from `= 8.3.1` to `= 8.3.1, 8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2511
https://github.com/CliMA/Oceananigans.jl/pull/2511:279,Testability,test,tests,279,"This pull request changes the compat entry for the `GPUArrays` package from `= 8.3.1` to `= 8.3.1, 8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2511
https://github.com/CliMA/Oceananigans.jl/issues/2512:1248,Availability,down,down,1248,". In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I thi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512
https://github.com/CliMA/Oceananigans.jl/issues/2512:473,Integrability,interface,interfaces,473,"There's been a bunch of interest in using Oceananigans for physical-biogeochemical interaction studies --- problems where systems of reacting tracers that represent either oceanic biological systems, chemical reactions and cycles, or both interact with turbulence and fluid dynamics simulated by Oceananigans. In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we mi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512
https://github.com/CliMA/Oceananigans.jl/issues/2512:2175,Integrability,interface,interface,2175,"d complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also think it will yield a cleaner and more interpretable user API: biogeochemistry models are sometimes complicated, so it's helpful to disentangle their specification from the specification of more ""vanilla"" forcing terms, like sponge layers, etc. We may want special time-stepping methods for some types of biogeochemistry in the future. I also think we can build an interface for `biogeochemistry` that uses similar or identical syntax to `Forcing` (like requiring functions of `x, y, z, t, fields` --- etc) because this will allow directly transferring code for biogeochemistry models that's first implemented as a system of forcing functions (a very common ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512
https://github.com/CliMA/Oceananigans.jl/issues/2512:2818,Integrability,interface,interface,2818,"or example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also think it will yield a cleaner and more interpretable user API: biogeochemistry models are sometimes complicated, so it's helpful to disentangle their specification from the specification of more ""vanilla"" forcing terms, like sponge layers, etc. We may want special time-stepping methods for some types of biogeochemistry in the future. I also think we can build an interface for `biogeochemistry` that uses similar or identical syntax to `Forcing` (like requiring functions of `x, y, z, t, fields` --- etc) because this will allow directly transferring code for biogeochemistry models that's first implemented as a system of forcing functions (a very common and useful development paradigm). What do others think about this? @iuryt @johnryantaylor @rafferrari @simone-silvestri @christophernhill @jm-c @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512
https://github.com/CliMA/Oceananigans.jl/issues/2512:2685,Modifiability,layers,layers,2685,"or example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also think it will yield a cleaner and more interpretable user API: biogeochemistry models are sometimes complicated, so it's helpful to disentangle their specification from the specification of more ""vanilla"" forcing terms, like sponge layers, etc. We may want special time-stepping methods for some types of biogeochemistry in the future. I also think we can build an interface for `biogeochemistry` that uses similar or identical syntax to `Forcing` (like requiring functions of `x, y, z, t, fields` --- etc) because this will allow directly transferring code for biogeochemistry models that's first implemented as a system of forcing functions (a very common and useful development paradigm). What do others think about this? @iuryt @johnryantaylor @rafferrari @simone-silvestri @christophernhill @jm-c @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512
https://github.com/CliMA/Oceananigans.jl/issues/2512:1454,Security,access,accessible,1454,"e a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512
https://github.com/CliMA/Oceananigans.jl/issues/2512:628,Testability,test,testing,628,"There's been a bunch of interest in using Oceananigans for physical-biogeochemical interaction studies --- problems where systems of reacting tracers that represent either oceanic biological systems, chemical reactions and cycles, or both interact with turbulence and fluid dynamics simulated by Oceananigans. In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we mi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512
https://github.com/CliMA/Oceananigans.jl/issues/2512:1309,Testability,test,tests,1309,". In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I thi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512
https://github.com/CliMA/Oceananigans.jl/pull/2513:337,Testability,test,tests,337,"This PR permutes the dimensions of the _temporary array_ that's used by the `DistributedFFTBasedPoissonSolver` (and `PencilFFTs`) compared to Oceananigans data layout to look like (z, x, y). This permits ""pencil"" decompositions in x, y via PencilFFTs, which cannot partition along the first dimension. This PR should probably expand the tests to cover these cases, which weren't tested previously because it wasn't supported. Co-developed with @johnryantaylor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2513
https://github.com/CliMA/Oceananigans.jl/pull/2513:379,Testability,test,tested,379,"This PR permutes the dimensions of the _temporary array_ that's used by the `DistributedFFTBasedPoissonSolver` (and `PencilFFTs`) compared to Oceananigans data layout to look like (z, x, y). This permits ""pencil"" decompositions in x, y via PencilFFTs, which cannot partition along the first dimension. This PR should probably expand the tests to cover these cases, which weren't tested previously because it wasn't supported. Co-developed with @johnryantaylor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2513
https://github.com/CliMA/Oceananigans.jl/pull/2517:400,Availability,down,downstream,400,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517
https://github.com/CliMA/Oceananigans.jl/pull/2517:338,Deployability,release,release,338,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517
https://github.com/CliMA/Oceananigans.jl/pull/2517:424,Integrability,depend,depend,424,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517
https://github.com/CliMA/Oceananigans.jl/pull/2517:49,Testability,Benchmark,BenchmarkTools,49,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517
https://github.com/CliMA/Oceananigans.jl/pull/2517:151,Testability,test,tested,151,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517
https://github.com/CliMA/Oceananigans.jl/pull/2517:257,Testability,test,tests,257,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517
https://github.com/CliMA/Oceananigans.jl/pull/2517:443,Testability,test,tests,443,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517
https://github.com/CliMA/Oceananigans.jl/pull/2519:400,Availability,down,downstream,400,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2519
https://github.com/CliMA/Oceananigans.jl/pull/2519:338,Deployability,release,release,338,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2519
https://github.com/CliMA/Oceananigans.jl/pull/2519:424,Integrability,depend,depend,424,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2519
https://github.com/CliMA/Oceananigans.jl/pull/2519:49,Testability,Benchmark,BenchmarkTools,49,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2519
https://github.com/CliMA/Oceananigans.jl/pull/2519:151,Testability,test,tested,151,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2519
https://github.com/CliMA/Oceananigans.jl/pull/2519:257,Testability,test,tests,257,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2519
https://github.com/CliMA/Oceananigans.jl/pull/2519:443,Testability,test,tests,443,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2519
https://github.com/CliMA/Oceananigans.jl/pull/2520:173,Testability,test,tested,173,"This pull request changes the compat entry for the `GPUArrays` package from `= 8.3.1` to `= 8.3.1, 8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2520
https://github.com/CliMA/Oceananigans.jl/pull/2520:279,Testability,test,tests,279,"This pull request changes the compat entry for the `GPUArrays` package from `= 8.3.1` to `= 8.3.1, 8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2520
https://github.com/CliMA/Oceananigans.jl/pull/2521:13,Testability,test,tests,13,"This PR adds tests for ""sliced"" `compute!(field)`, when `field.indices != (:, :, :)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2521
https://github.com/CliMA/Oceananigans.jl/pull/2523:187,Energy Efficiency,Adapt,Adapt,187,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:1026,Energy Efficiency,Allocate,Allocate,1026,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:254,Integrability,wrap,wrap,254,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:609,Integrability,wrap,wrapping,609,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:187,Modifiability,Adapt,Adapt,187,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:307,Modifiability,extend,extend,307,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:781,Performance,perform,perform,781,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:968,Performance,perform,perform,968,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:1074,Performance,perform,perform,1074,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2523:366,Security,Expose,Expose,366,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523
https://github.com/CliMA/Oceananigans.jl/pull/2524:79,Deployability,update,updated,79,this PR fixes a bug in the `OutputWriters` for which the output fields are not updated when writing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2524
https://github.com/CliMA/Oceananigans.jl/issues/2526:202,Deployability,pipeline,pipeline,202,"with the development of multi GPU we have to expand our test capabilities to include this functionality. ; We should introduce a new Agent that can handle single-node and multi-node multi GPU to our CI pipeline. . @christophernhill @glwagner @navidcy, any candidates in mind?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2526
https://github.com/CliMA/Oceananigans.jl/issues/2526:56,Testability,test,test,56,"with the development of multi GPU we have to expand our test capabilities to include this functionality. ; We should introduce a new Agent that can handle single-node and multi-node multi GPU to our CI pipeline. . @christophernhill @glwagner @navidcy, any candidates in mind?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2526
https://github.com/CliMA/Oceananigans.jl/issues/2528:298,Modifiability,variab,variable,298,"In the equation of state for TEOS10 the function plugged in for depth has a different sign than what is assumed in the seawater polynomial package. https://github.com/CliMA/Oceananigans.jl/blob/main/src/BuoyancyModels/nonlinear_equation_of_state.jl#L27. In the SeawaterPolynomials package, the 'Z' variable must be positive. Thus one (or both) packages must be changed to have the right sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2528
https://github.com/CliMA/Oceananigans.jl/pull/2529:126,Deployability,update,update,126,This won't pass tests until https://github.com/CliMA/SeawaterPolynomials.jl/pull/20 is merged and registered. We also need to update `Manifest.toml`. Closes #2528. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2529
https://github.com/CliMA/Oceananigans.jl/pull/2529:16,Testability,test,tests,16,This won't pass tests until https://github.com/CliMA/SeawaterPolynomials.jl/pull/20 is merged and registered. We also need to update `Manifest.toml`. Closes #2528. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2529
https://github.com/CliMA/Oceananigans.jl/issues/2530:117,Deployability,update,update,117,"### Discussed in https://github.com/CliMA/Oceananigans.jl/discussions/2527. Probably, there are some bugs related to update in CUDA from 3.3.6 to 3.9. <div type='discussions-op-text'>. <sup>Originally posted by **parfenyev** May 6, 2022</sup>; Hello,. I am trying to create model using GPU to play around. Below is my code:; ```; using Oceananigans, Statistics, Printf, Oceananigans.Units. grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)). # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); v_forcing(x, y, z, t) = -0.01*cos(5*x). # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); ```; It works when I change GPU to CPU in the `RectilinearGrid`, but fails in the current state:; ```; InvalidIRError: compiling kernel gpu__fill_south_and_north_halo!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:48073,Deployability,Continuous,ContinuousForcing,48073,"geLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(u_forcing), Tuple{}, Tuple{}, Tuple{}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, Nothing, typeof(v_forcing), Tuple{}, Tuple{}, Tuple{}}, typeof(Oceananigans.Forcings.zeroforcing)}}, UpwindBiasedFifthOrder, Oceananigans.Solvers.FFTBasedPoissonSolver{RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU}, NamedTuple{(:λx, :λy, :λz), Tuple{CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, NamedTuple{(:forwa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:48191,Deployability,Continuous,ContinuousForcing,48191,"pRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(u_forcing), Tuple{}, Tuple{}, Tuple{}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, Nothing, typeof(v_forcing), Tuple{}, Tuple{}, Tuple{}}, typeof(Oceananigans.Forcings.zeroforcing)}}, UpwindBiasedFifthOrder, Oceananigans.Solvers.FFTBasedPoissonSolver{RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU}, NamedTuple{(:λx, :λy, :λz), Tuple{CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, NamedTuple{(:forward, :backward), Tuple{Tuple{Oceananigans.Solvers.DiscreteTransform{CUDA.CUFFT.cCuFFTPlan{ComplexF64, -1, true, 3}, Oceana",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:14972,Integrability,depend,dependencies,14972,"le{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:291; [13] macro expansion; @ C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:102 [inlined]; [14] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!)})(::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels C:\Users\parfe\.julia\packages\CUDAKernels\4VLF4\src\CUDAKernels.jl:272; [15] launch!(::GPU, ::RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_south_and_north_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; depende",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:15953,Integrability,depend,dependencies,15953,"y}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels C:\Users\parfe\.julia\packages\CUDAKernels\4VLF4\src\CUDAKernels.jl:272; [15] launch!(::GPU, ::RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU}, ::Symbol, ::typeof(Oceananigans.BoundaryConditions._fill_south_and_north_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; dependencies::CUDAKernels.CudaEvent, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils C:\Users\parfe\.julia\packages\Oceananigans\B958I\src\Utils\kernel_launching.jl:95; [16] fill_south_and_north_halo!(::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, ::Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:10033,Performance,cache,cache,10033,"RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}}); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:74; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:324; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\cache.jl:90; [11] cufunction(f::typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:10238,Performance,cache,cache,10238,"loat64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}}); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:74; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:324; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\cache.jl:90; [11] cufunction(f::typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryC",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:55878,Performance,load,loading,55878,"yCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, tracers::Nothing, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.NonhydrostaticModels C:\Users\parfe\.julia\packages\Oceananigans\B958I\src\Models\NonhydrostaticModels\nonhydrostatic_model.jl:204; [28] top-level scope; @ In[23]:1; [29] eval; @ .\boot.jl:373 [inlined]; [30] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1196; ```; What is wrong here?</div>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:6979,Security,validat,validation,6979," Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}}, RectilinearGrid{Float64, Bounded, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}, args::LLVM.Module); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\validation.jl:124; [2] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:386 [inlined]; [3] macro expansion; @ C:\Users\parfe\.julia\packages\TimerOutputs\8mHel\src\TimerOutput.jl:252 [inlined]; [4] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:384 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:332; [7] #260; @ C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:325 [inlined]; [8] JuliaContext(f::CUDA.var""#260#261""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/issues/2530:7380,Security,validat,validate,7380,"Len{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}}}}, args::LLVM.Module); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\validation.jl:124; [2] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:386 [inlined]; [3] macro expansion; @ C:\Users\parfe\.julia\packages\TimerOutputs\8mHel\src\TimerOutput.jl:252 [inlined]; [4] macro expansion; @ C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\driver.jl:384 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler C:\Users\parfe\.julia\packages\GPUCompiler\1FdJy\src\utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:332; [7] #260; @ C:\Users\parfe\.julia\packages\CUDA\Uurn4\src\compiler\execution.jl:325 [inlined]; [8] JuliaContext(f::CUDA.var""#260#261""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.BoundaryConditions.gpu__fill_south_and_north_halo!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530
https://github.com/CliMA/Oceananigans.jl/pull/2532:139,Testability,test,test,139,Might not be enough so let's check. I think maybe `GridFittedBottom` and `GridFittedBoundary` need to know about `Flat` too?. Should add a test too. @simone-silvestri ; @raphaelouillon. Closes #2479,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2532
https://github.com/CliMA/Oceananigans.jl/issues/2533:350,Security,hash,hashing,350,`Nz=1` is probably broken for `DistributedFFTPoissonSolver` right now:. https://github.com/CliMA/Oceananigans.jl/blob/a94d27afcd5c2c26f2a6cbd65a54acc4394f592f/src/Distributed/distributed_fft_based_poisson_solver.jl#L49-L50. We want to support this case to make implementing a distributed FFT-based implicit free surface solver straightforward. We're hashing it out on https://github.com/jipolanco/PencilFFTs.jl/issues/43.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2533
https://github.com/CliMA/Oceananigans.jl/issues/2534:526,Performance,load,loaded,526,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534
https://github.com/CliMA/Oceananigans.jl/issues/2534:1292,Performance,load,loaded,1292,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534
https://github.com/CliMA/Oceananigans.jl/issues/2534:1441,Safety,detect,detect,1441,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534
https://github.com/CliMA/Oceananigans.jl/issues/2534:267,Security,validat,validation,267,"Occasionally you'll find user scripts peppered with things like. ```julia; Q = arch_array(arch, Q); ```. which changes `Q` to CuArray if needed and vice versa. Or, more recently:. https://github.com/CliMA/Oceananigans.jl/blob/5cc9653584370e7cbbd828583d4129628eb20fd0/validation/multi_region/multi_region_near_global_quarter_degree.jl#L117. on a multi-region grid, which ""partitions"" a global array onto difference devices. That last pattern is also needed for distributed problems in which global-size data is either built or loaded from disk. I propose we implement one utility for all these cases called something like `on_grid(obj, grid)` (note I'm reversing the argument intputs relative to `arch_array`; I think that's what we want, but it's something to discuss carefully. It's also a problem that `multi_region_object_from_array` and `arch_array` have different syntax). Usually one can write generic code for CPU/GPU --- except when building boundary conditions in terms of arrays, where we _do not_ want to automatically convert from CPU to GPU. In that case users need to write. ```julia; Q = on_grid(Q, grid); ```. since `grid` has `grid.architecture`, this will change to CPU or GPU as needed. For distributed problems we also want. ```julia; Q = on_grid(Q, grid); ```. if `Q` is loaded from file, for example. If `Q` has the size of global data, we will partition it into a local version (since the grid is also local). We can ""detect"" whether `Q` has a local size (though there are some subtleties re: dimensionality...) and handle that case. We can also transfer to correct architecture. For multi-region problems we write. ```julia; Q = on_grid(Q, grid); ```. which will return a `MultiRegionObject` with `Q` appropriately partitioned. I think this will help users write generic code that can run on any grid + architecture. Other names are definitely welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534
https://github.com/CliMA/Oceananigans.jl/issues/2535:13,Availability,error,error,13,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:118,Availability,checkpoint,checkpoint,118,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:163,Availability,checkpoint,checkpoint,163,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:241,Availability,error,error,241,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:254,Availability,ERROR,ERROR,254,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:405,Availability,checkpoint,checkpointed,405,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:475,Availability,checkpoint,checkpoint,475,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:1002,Availability,error,error,1002,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:1424,Availability,error,error,1424,"first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then out",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:1452,Availability,error,error,1452,"first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then out",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:1284,Deployability,toggle,toggle,1284,"first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then out",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:2700,Deployability,toggle,toggle,2700,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:627,Integrability,wrap,wrap,627,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:1902,Modifiability,refactor,refactoring,1902,"tead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:2279,Modifiability,variab,variable,2279,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:2430,Modifiability,variab,variable,2430,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:261,Performance,Load,LoadError,261,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:2678,Safety,avoid,avoids,2678,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:589,Usability,simpl,simplest,589,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:1177,Usability,usab,usability,1177," file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different wa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/issues/2535:2549,Usability,usab,usability,2549,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535
https://github.com/CliMA/Oceananigans.jl/pull/2536:563,Deployability,configurat,configurations,563,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:982,Deployability,configurat,configurations,982,"and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)` processes in (x, z).; 6. Transform in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:1056,Deployability,configurat,configuration,1056,"and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)` processes in (x, z).; 6. Transform in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:146,Integrability,depend,depend,146,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:563,Modifiability,config,configurations,563,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:982,Modifiability,config,configurations,982,"and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)` processes in (x, z).; 6. Transform in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:1056,Modifiability,config,configuration,1056,"and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)` processes in (x, z).; 6. Transform in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:2477,Modifiability,config,configured,2477,"=======================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)` processes in (x, z).; 6. Transform in y. At this point the three in-place forward transforms are complete, and we; solve the Poisson equation by updating `last(storage)`.; Then the process is reversed to obtain `first(storage)` in physical; space and with the layout (z, x, y). Restrictions; ============. The algorithm for two-dimensional decompositions requires that `Nz = size(global_grid, 3)` is larger; than either `Rx = ranks[1]` or `Ry = ranks[2]`, where `ranks` are configured when building `MultiArch`.; If `Nz` does not satisfy this condition, we can only support a one-dimensional decomposition. Algorithm for one-dimensional decompositions; ============================================. This algorithm requires a one-dimensional decomposition with _either_ `Rx = 1`; _or_ `Ry = 1`, and is important to support two-dimensional transforms. For one-dimensional decompositions, we place the decomposed direction _last_.; If the number of ranks is `Rh = max(Rx, Ry)`, this algorithm requires that; _both_ `Nx > Rh` _and_ `Ny > Rh`. It remains somewhat of a mystery why this; succeeds (ie, why the last transform is correctly decomposed).; """"""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:298,Testability,log,logic,298,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2536:340,Usability,learn,learned,340,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536
https://github.com/CliMA/Oceananigans.jl/pull/2537:275,Availability,checkpoint,checkpoint,275,"This PR ""enhances"" `JLD2OutputWriter` so it first _checks_ whether an iteration number exists in the file it's about to save to. If the iteration number does exist, it emits warning, but does not fail. Previously, it would fail. This helps when restoring a simulation from a checkpoint when output is saved at higher frequency than the simulation is checkpointed. TODO: probably test makes sense.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537
https://github.com/CliMA/Oceananigans.jl/pull/2537:350,Availability,checkpoint,checkpointed,350,"This PR ""enhances"" `JLD2OutputWriter` so it first _checks_ whether an iteration number exists in the file it's about to save to. If the iteration number does exist, it emits warning, but does not fail. Previously, it would fail. This helps when restoring a simulation from a checkpoint when output is saved at higher frequency than the simulation is checkpointed. TODO: probably test makes sense.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537
https://github.com/CliMA/Oceananigans.jl/pull/2537:9,Modifiability,enhance,enhances,9,"This PR ""enhances"" `JLD2OutputWriter` so it first _checks_ whether an iteration number exists in the file it's about to save to. If the iteration number does exist, it emits warning, but does not fail. Previously, it would fail. This helps when restoring a simulation from a checkpoint when output is saved at higher frequency than the simulation is checkpointed. TODO: probably test makes sense.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537
https://github.com/CliMA/Oceananigans.jl/pull/2537:379,Testability,test,test,379,"This PR ""enhances"" `JLD2OutputWriter` so it first _checks_ whether an iteration number exists in the file it's about to save to. If the iteration number does exist, it emits warning, but does not fail. Previously, it would fail. This helps when restoring a simulation from a checkpoint when output is saved at higher frequency than the simulation is checkpointed. TODO: probably test makes sense.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537
https://github.com/CliMA/Oceananigans.jl/pull/2538:824,Energy Efficiency,efficient,efficient,824,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538
https://github.com/CliMA/Oceananigans.jl/pull/2538:1052,Energy Efficiency,reduce,reduces,1052,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538
https://github.com/CliMA/Oceananigans.jl/pull/2538:1342,Energy Efficiency,efficient,efficient,1342,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538
https://github.com/CliMA/Oceananigans.jl/pull/2538:464,Performance,optimiz,optimization,464,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538
https://github.com/CliMA/Oceananigans.jl/pull/2538:938,Performance,perform,performance,938,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538
https://github.com/CliMA/Oceananigans.jl/pull/2538:407,Safety,avoid,avoid,407,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538
https://github.com/CliMA/Oceananigans.jl/pull/2538:1168,Testability,test,test,1168,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538
https://github.com/CliMA/Oceananigans.jl/pull/2538:1402,Testability,test,tests,1402,"This PR builds off #2536 and implements a distributed Poisson solver that users horizontal FFTs and a vertical tridiagonal solve, with more help from @jipolanco. When distributed in (x, y), this kind of solver is more expensive than a pure FFT-based solver, because it requires 4 additional transpositions + communication. For problems that are only distributed in x _or_ y (eg, slab decomposition), we can avoid the additional transpositions. ~~Implementing that optimization is TODO for this PR.~~. Some of the details are discussed on https://github.com/jipolanco/PencilFFTs.jl/issues/44. Future work, which would require abstracting the implementation of hydrostatic pressure in `NonhydrostaticModel` (and, for friendliness, forbidding the use of VerticallyImplicitTimeDiscretization), could in principle support a more efficient version of this solver with pencil decomposition in (y, z) or (x, z). This memory layout would increase performance for very large problems that require a 2D domain decomposition, since decomposing in (y, z) or (x, z) reduces the number of transposes needed by 4 over (x, y). This feature is easy to code, but might take some time to test. We've already noticed on #1910 that lumping hydrostatic and nonhydrostatic pressure produces different (perhaps lower quality) solutions. TODO:; - [x] Implement a more efficient algorithm for 1D ""slab"" decompositions; - [x] Add tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538
https://github.com/CliMA/Oceananigans.jl/pull/2539:401,Availability,down,downstream,401,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539
https://github.com/CliMA/Oceananigans.jl/pull/2539:339,Deployability,release,release,339,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539
https://github.com/CliMA/Oceananigans.jl/pull/2539:425,Integrability,depend,depend,425,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539
https://github.com/CliMA/Oceananigans.jl/pull/2539:152,Testability,test,tested,152,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539
https://github.com/CliMA/Oceananigans.jl/pull/2539:258,Testability,test,tests,258,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539
https://github.com/CliMA/Oceananigans.jl/pull/2539:444,Testability,test,tests,444,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539
https://github.com/CliMA/Oceananigans.jl/pull/2540:579,Deployability,pipeline,pipeline,579,"PR for discussion of changes to main. There are some things that can go in soon, others may require more work. . Note . - Julia AMD GPU stack (AMDGPU.jl, KernelAbstractions.jl) needs 1.7 Julia at least.; - Currently AMDGPU.jl works against ROCM 4.2. More recent ROCM 5 has LLVM that is ahead of Julia 1.7, so that breaks things! ; - people who are working on relevant Julia support include @jpsamaroo @vchuravy @luraess and @matinraayai .... What fun! . A buildkite test is here ( https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/.buildkite/pipeline.yml#L496 ) which gives some clues on what is needed to run something on MI50.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540
https://github.com/CliMA/Oceananigans.jl/pull/2540:466,Testability,test,test,466,"PR for discussion of changes to main. There are some things that can go in soon, others may require more work. . Note . - Julia AMD GPU stack (AMDGPU.jl, KernelAbstractions.jl) needs 1.7 Julia at least.; - Currently AMDGPU.jl works against ROCM 4.2. More recent ROCM 5 has LLVM that is ahead of Julia 1.7, so that breaks things! ; - people who are working on relevant Julia support include @jpsamaroo @vchuravy @luraess and @matinraayai .... What fun! . A buildkite test is here ( https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/.buildkite/pipeline.yml#L496 ) which gives some clues on what is needed to run something on MI50.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540
https://github.com/CliMA/Oceananigans.jl/issues/2541:414,Availability,error,error,414,"I was trying use `NetCDFOutputWriter` to write some data using the syntax that is used in the example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/) and tried the following:. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filename = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. That did not work. The error was `keyword argument filepath not assigned`. . I checked `help` it said I should be using `filepath` instead of `'filename`. Hence I tried the following, which did work. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filepath = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. I am using juliav1.6 and `NCDatasets v0.12.4`, which seems to be the latest version. . Does anyone have any suggestions as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2541
https://github.com/CliMA/Oceananigans.jl/issues/2541:355,Energy Efficiency,schedul,schedule,355,"I was trying use `NetCDFOutputWriter` to write some data using the syntax that is used in the example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/) and tried the following:. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filename = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. That did not work. The error was `keyword argument filepath not assigned`. . I checked `help` it said I should be using `filepath` instead of `'filename`. Hence I tried the following, which did work. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filepath = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. I am using juliav1.6 and `NCDatasets v0.12.4`, which seems to be the latest version. . Does anyone have any suggestions as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2541
https://github.com/CliMA/Oceananigans.jl/issues/2541:716,Energy Efficiency,schedul,schedule,716,"I was trying use `NetCDFOutputWriter` to write some data using the syntax that is used in the example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/) and tried the following:. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filename = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. That did not work. The error was `keyword argument filepath not assigned`. . I checked `help` it said I should be using `filepath` instead of `'filename`. Hence I tried the following, which did work. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filepath = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. I am using juliav1.6 and `NCDatasets v0.12.4`, which seems to be the latest version. . Does anyone have any suggestions as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2541
https://github.com/CliMA/Oceananigans.jl/issues/2542:238,Availability,error,error,238,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:293,Availability,ERROR,ERROR,293,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:409,Availability,error,error,409,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:436,Availability,error,error,436,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:278,Deployability,update,updated,278,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:685,Integrability,interface,interfaces,685,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:966,Integrability,interface,interfaces,966,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:1032,Integrability,interface,interfaces,1032,"arotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Ocean",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:300,Performance,Load,LoadError,300,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:311,Performance,Load,LoadError,311,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:105,Security,validat,validation,105,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:1922,Security,validat,validation,1922,"e, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; [11] include(fname::String); @ Base.MainInclude ./client.jl:444; [12] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:2033,Security,validat,validation,2033,"e, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; [11] include(fname::String); @ Base.MainInclude ./client.jl:444; [12] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:2209,Security,validat,validation,2209,"e, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; [11] include(fname::String); @ Base.MainInclude ./client.jl:444; [12] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:2325,Security,validat,validation,2325,"e, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; [11] include(fname::String); @ Base.MainInclude ./client.jl:444; [12] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2542:2450,Security,validat,validation,2450,"e, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; [11] include(fname::String); @ Base.MainInclude ./client.jl:444; [12] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/barotropic_gyre.jl:139; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542
https://github.com/CliMA/Oceananigans.jl/issues/2543:192,Availability,error,error,192,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543
https://github.com/CliMA/Oceananigans.jl/issues/2543:204,Availability,ERROR,ERROR,204,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543
https://github.com/CliMA/Oceananigans.jl/issues/2543:211,Performance,Load,LoadError,211,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543
https://github.com/CliMA/Oceananigans.jl/issues/2543:112,Security,validat,validation,112,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543
https://github.com/CliMA/Oceananigans.jl/issues/2543:1237,Security,validat,validation,1237,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543
https://github.com/CliMA/Oceananigans.jl/issues/2543:1363,Security,validat,validation,1363,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543
https://github.com/CliMA/Oceananigans.jl/pull/2544:173,Testability,test,tested,173,"This pull request changes the compat entry for the `PencilArrays` package from `0.16` to `0.16, 0.17`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2544
https://github.com/CliMA/Oceananigans.jl/pull/2544:279,Testability,test,tests,279,"This pull request changes the compat entry for the `PencilArrays` package from `0.16` to `0.16, 0.17`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2544
https://github.com/CliMA/Oceananigans.jl/pull/2546:173,Testability,test,tested,173,"This pull request changes the compat entry for the `PencilArrays` package from `0.16` to `0.16, 0.17`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2546
https://github.com/CliMA/Oceananigans.jl/pull/2546:279,Testability,test,tests,279,"This pull request changes the compat entry for the `PencilArrays` package from `0.16` to `0.16, 0.17`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2546
https://github.com/CliMA/Oceananigans.jl/pull/2547:204,Performance,perform,performance,204,This fixes a bug in `MultiRegion` for which `copyto!` is by default asynchronous. This is not a problem until very large meshes (which unfortunately is what we want with multi GPU) ; I still have to test performance... and maybe we also want another solution,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2547
https://github.com/CliMA/Oceananigans.jl/pull/2547:199,Testability,test,test,199,This fixes a bug in `MultiRegion` for which `copyto!` is by default asynchronous. This is not a problem until very large meshes (which unfortunately is what we want with multi GPU) ; I still have to test performance... and maybe we also want another solution,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2547
https://github.com/CliMA/Oceananigans.jl/issues/2548:818,Availability,error,error,818,"At the moment this is possible:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = 1:1:10, y=1:1:10,; z = 1:1:10, ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 5.0) variably spaced with min(Δx)=1.0, max(Δx)=1.0; ├── Periodic y ∈ [1.0, 5.0) variably spaced with min(Δy)=1.0, max(Δy)=1.0; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> grid.Nz; 4. julia> length(grid.zᵃᵃᶜ); 10; ```; Meaning, you can pass a certain size to the constructor, say `Nx`, and also pass an array for that direction (to ""stretch it"") that has a different size than `Nx`. I haven't investigated the consequences of this, but this feels like it could cause problems. Should we throw a warning/error in these cases?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548
https://github.com/CliMA/Oceananigans.jl/issues/2548:284,Modifiability,variab,variably,284,"At the moment this is possible:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = 1:1:10, y=1:1:10,; z = 1:1:10, ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 5.0) variably spaced with min(Δx)=1.0, max(Δx)=1.0; ├── Periodic y ∈ [1.0, 5.0) variably spaced with min(Δy)=1.0, max(Δy)=1.0; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> grid.Nz; 4. julia> length(grid.zᵃᵃᶜ); 10; ```; Meaning, you can pass a certain size to the constructor, say `Nx`, and also pass an array for that direction (to ""stretch it"") that has a different size than `Nx`. I haven't investigated the consequences of this, but this feels like it could cause problems. Should we throw a warning/error in these cases?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548
https://github.com/CliMA/Oceananigans.jl/issues/2548:359,Modifiability,variab,variably,359,"At the moment this is possible:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = 1:1:10, y=1:1:10,; z = 1:1:10, ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 5.0) variably spaced with min(Δx)=1.0, max(Δx)=1.0; ├── Periodic y ∈ [1.0, 5.0) variably spaced with min(Δy)=1.0, max(Δy)=1.0; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> grid.Nz; 4. julia> length(grid.zᵃᵃᶜ); 10; ```; Meaning, you can pass a certain size to the constructor, say `Nx`, and also pass an array for that direction (to ""stretch it"") that has a different size than `Nx`. I haven't investigated the consequences of this, but this feels like it could cause problems. Should we throw a warning/error in these cases?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548
https://github.com/CliMA/Oceananigans.jl/issues/2548:433,Modifiability,variab,variably,433,"At the moment this is possible:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = 1:1:10, y=1:1:10,; z = 1:1:10, ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 5.0) variably spaced with min(Δx)=1.0, max(Δx)=1.0; ├── Periodic y ∈ [1.0, 5.0) variably spaced with min(Δy)=1.0, max(Δy)=1.0; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> grid.Nz; 4. julia> length(grid.zᵃᵃᶜ); 10; ```; Meaning, you can pass a certain size to the constructor, say `Nx`, and also pass an array for that direction (to ""stretch it"") that has a different size than `Nx`. I haven't investigated the consequences of this, but this feels like it could cause problems. Should we throw a warning/error in these cases?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548
https://github.com/CliMA/Oceananigans.jl/pull/2549:1252,Availability,ERROR,ERROR,1252,"regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid=grid),; ); ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:197; ERROR: MethodError: no method matching return_metrics(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}); Closest candidates are:; return_metrics(::LatitudeLongitudeGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:215; return_metrics(::RectilinearGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:216; Stacktrace:; [1] compute_stretched_weno_coefficients(grid::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549
https://github.com/CliMA/Oceananigans.jl/pull/2549:1154,Safety,risk,risk,1154,"> grid_base = RectilinearGrid(size=(4, 4, 4),; x = (0, 1), y=(0, 1),; z = (0, 1),; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid=grid),; ); ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:197; ERROR: MethodError: no method matching return_metrics(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}); Closest candidates are:; return_metrics(::LatitudeLongitudeGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:215; return_metrics(::RectilinearGrid) at /home/tomas/re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549
https://github.com/CliMA/Oceananigans.jl/pull/2549:1127,Security,validat,validated,1127,"> grid_base = RectilinearGrid(size=(4, 4, 4),; x = (0, 1), y=(0, 1),; z = (0, 1),; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid=grid),; ); ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:197; ERROR: MethodError: no method matching return_metrics(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}); Closest candidates are:; return_metrics(::LatitudeLongitudeGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:215; return_metrics(::RectilinearGrid) at /home/tomas/re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549
https://github.com/CliMA/Oceananigans.jl/pull/2550:1247,Availability,ERROR,ERROR,1247,"ectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 0.210526] variably spaced with min(Δz)=0.0526316, max(Δz)=0.0526316. julia> grid.zᵃᵃᶜ; 10-element OffsetArray(::Vector{Float64}, -2:7) with eltype Float64 with indices -2:7:; -0.13157894736842105; -0.07894736842105263; -0.02631578947368421; 0.02631578947368421; 0.07894736842105263; 0.13157894736842105; 0.18421052631578946; 0.23684210526315788; 0.2894736842105263; 0.3421052631578947. julia> collect(grid.xᶜᵃᵃ); 10-element Vector{Float64}:; -0.625; -0.375; -0.125; 0.125; 0.375; 0.625; 0.875; 1.125; 1.375; 1.625; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 6 threads. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); ERROR: ArgumentError: `length(z)` must be equal to size passed to `size` argument.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::LinRange{Float64}, dir::Symbol, size_dir::Int64, FT::Type); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:108; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}, FT::Type, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:284; [4] RectilinearGrid(architecture::CPU, FT::Type; size::Tuple{Int64, Int64, Int64}, x::Tuple{Int64,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550
https://github.com/CliMA/Oceananigans.jl/pull/2550:2606,Availability,error,error,2606,"94736842105263; 0.13157894736842105; 0.18421052631578946; 0.23684210526315788; 0.2894736842105263; 0.3421052631578947. julia> collect(grid.xᶜᵃᵃ); 10-element Vector{Float64}:; -0.625; -0.375; -0.125; 0.125; 0.375; 0.625; 0.875; 1.125; 1.375; 1.625; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 6 threads. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); ERROR: ArgumentError: `length(z)` must be equal to size passed to `size` argument.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::LinRange{Float64}, dir::Symbol, size_dir::Int64, FT::Type); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:108; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}, FT::Type, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:284; [4] RectilinearGrid(architecture::CPU, FT::Type; size::Tuple{Int64, Int64, Int64}, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}, halo::Tuple{Int64, Int64, Int64}, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:259; [5] top-level scope; @ REPL[2]:1; [6] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```. I decided to throw an error instead of a warning because I don't think we want the user be able to proceed in a situation like this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550
https://github.com/CliMA/Oceananigans.jl/pull/2550:459,Modifiability,variab,variably,459,"Closes https://github.com/CliMA/Oceananigans.jl/issues/2548. Before this PR:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 0.210526] variably spaced with min(Δz)=0.0526316, max(Δz)=0.0526316. julia> grid.zᵃᵃᶜ; 10-element OffsetArray(::Vector{Float64}, -2:7) with eltype Float64 with indices -2:7:; -0.13157894736842105; -0.07894736842105263; -0.02631578947368421; 0.02631578947368421; 0.07894736842105263; 0.13157894736842105; 0.18421052631578946; 0.23684210526315788; 0.2894736842105263; 0.3421052631578947. julia> collect(grid.xᶜᵃᵃ); 10-element Vector{Float64}:; -0.625; -0.375; -0.125; 0.125; 0.375; 0.625; 0.875; 1.125; 1.375; 1.625; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 6 threads. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); ERROR: ArgumentError: `length(z)` must be equal to size passed to `size` argument.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::LinRange{Float64}, dir::Symbol, size_dir::Int64, FT::Type); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:108; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}, FT::Type, extent::Nothing, x::Tuple{Int64, I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550
https://github.com/CliMA/Oceananigans.jl/issues/2558:14,Availability,error,error,14,"I'm facing an error that I'm not able to pinpoint. Running the following example on a CPU works, but I get an error on GPUs:. ```julia; using Oceananigans; using CUDA. arch = has_cuda_gpu() ? GPU() : CPU(). grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent=(1, 1, 1)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). noflux = FluxBoundaryCondition(0); b_bcs = FieldBoundaryConditions(immersed=noflux). model = NonhydrostaticModel(grid = grid,; buoyancy = BuoyancyTracer(),; tracers = :b,; boundary_conditions = (b=b_bcs,),; ). simulation = Simulation(model, Δt=1, stop_iteration=100); run!(simulation); ```. The error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gc!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gc!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, Val{1}, CenteredSecondOrder, Nothing, ImmersedBoundaryCondition{Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558
https://github.com/CliMA/Oceananigans.jl/issues/2558:110,Availability,error,error,110,"I'm facing an error that I'm not able to pinpoint. Running the following example on a CPU works, but I get an error on GPUs:. ```julia; using Oceananigans; using CUDA. arch = has_cuda_gpu() ? GPU() : CPU(). grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent=(1, 1, 1)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). noflux = FluxBoundaryCondition(0); b_bcs = FieldBoundaryConditions(immersed=noflux). model = NonhydrostaticModel(grid = grid,; buoyancy = BuoyancyTracer(),; tracers = :b,; boundary_conditions = (b=b_bcs,),; ). simulation = Simulation(model, Δt=1, stop_iteration=100); run!(simulation); ```. The error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gc!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gc!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, Val{1}, CenteredSecondOrder, Nothing, ImmersedBoundaryCondition{Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558
https://github.com/CliMA/Oceananigans.jl/issues/2558:666,Availability,error,error,666,"I'm facing an error that I'm not able to pinpoint. Running the following example on a CPU works, but I get an error on GPUs:. ```julia; using Oceananigans; using CUDA. arch = has_cuda_gpu() ? GPU() : CPU(). grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent=(1, 1, 1)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). noflux = FluxBoundaryCondition(0); b_bcs = FieldBoundaryConditions(immersed=noflux). model = NonhydrostaticModel(grid = grid,; buoyancy = BuoyancyTracer(),; tracers = :b,; boundary_conditions = (b=b_bcs,),; ). simulation = Simulation(model, Δt=1, stop_iteration=100); run!(simulation); ```. The error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gc!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gc!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, Val{1}, CenteredSecondOrder, Nothing, ImmersedBoundaryCondition{Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558
https://github.com/CliMA/Oceananigans.jl/issues/2558:679,Availability,ERROR,ERROR,679,"I'm facing an error that I'm not able to pinpoint. Running the following example on a CPU works, but I get an error on GPUs:. ```julia; using Oceananigans; using CUDA. arch = has_cuda_gpu() ? GPU() : CPU(). grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent=(1, 1, 1)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). noflux = FluxBoundaryCondition(0); b_bcs = FieldBoundaryConditions(immersed=noflux). model = NonhydrostaticModel(grid = grid,; buoyancy = BuoyancyTracer(),; tracers = :b,; boundary_conditions = (b=b_bcs,),; ). simulation = Simulation(model, Δt=1, stop_iteration=100); run!(simulation); ```. The error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gc!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gc!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, Val{1}, CenteredSecondOrder, Nothing, ImmersedBoundaryCondition{Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558
https://github.com/CliMA/Oceananigans.jl/issues/2558:31367,Availability,error,error,31367,"loat64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations /glade/work/tomasc/.julia/packages/Oceananigans/rtj1r/src/Simulations/run.jl:88; [24] top-level scope; @ /glade/scratch/tomasc/twake2/simulations/mwe_ibm.jl:28; [25] include(fname::String); @ Base.MainInclude ./client.jl:444; [26] top-level scope; @ REPL[1]:1; in expression starting at /glade/scratch/tomasc/twake2/simulations/mwe_ibm.jl:28; ```. (I deleted part of the error because it was too long...). This seems to be different from the other errors I've seen posted on issues here recently. Any ideas? It seems to be coming from the BC on `b`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558
https://github.com/CliMA/Oceananigans.jl/issues/2558:31444,Availability,error,errors,31444,"loat64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations /glade/work/tomasc/.julia/packages/Oceananigans/rtj1r/src/Simulations/run.jl:88; [24] top-level scope; @ /glade/scratch/tomasc/twake2/simulations/mwe_ibm.jl:28; [25] include(fname::String); @ Base.MainInclude ./client.jl:444; [26] top-level scope; @ REPL[1]:1; in expression starting at /glade/scratch/tomasc/twake2/simulations/mwe_ibm.jl:28; ```. (I deleted part of the error because it was too long...). This seems to be different from the other errors I've seen posted on issues here recently. Any ideas? It seems to be coming from the BC on `b`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558
https://github.com/CliMA/Oceananigans.jl/issues/2558:686,Performance,Load,LoadError,686,"I'm facing an error that I'm not able to pinpoint. Running the following example on a CPU works, but I get an error on GPUs:. ```julia; using Oceananigans; using CUDA. arch = has_cuda_gpu() ? GPU() : CPU(). grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent=(1, 1, 1)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). noflux = FluxBoundaryCondition(0); b_bcs = FieldBoundaryConditions(immersed=noflux). model = NonhydrostaticModel(grid = grid,; buoyancy = BuoyancyTracer(),; tracers = :b,; boundary_conditions = (b=b_bcs,),; ). simulation = Simulation(model, Δt=1, stop_iteration=100); run!(simulation); ```. The error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gc!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gc!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, Val{1}, CenteredSecondOrder, Nothing, ImmersedBoundaryCondition{Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558
https://github.com/CliMA/Oceananigans.jl/issues/2563:15,Availability,error,error,15,"I'm getting an error while running the following example on a GPU, it runs correctly on CPU though. It has a problem with the immersed boundary conditions, but the same BC on the normal boundary doesn't throw the error.; ```; using CUDA; using Oceananigans. arch = has_cuda_gpu() ? GPU() : CPU(); topo = [Flat, Periodic, Bounded] ; underlying_grid = RectilinearGrid(arch, size = (1,1), ; extent = (1, 1),; topology = topo). @inline slope(x, y) = -2.0*y; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). z₀ = 1e-2 # Charnock roughness; κ = 0.4 # Von Karman constant; @inline Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2; const dz = 0.1. @inline bottom_drag_v(x, y, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); @inline bottom_drag_v(x, y, z, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); v_drag_bc = FluxBoundaryCondition(bottom_drag_v, field_dependencies=(:v, :w), parameters=Cᴰ(dz)); v_bcs = FieldBoundaryConditions(bottom=v_drag_bc, immersed=v_drag_bc). boundary_conditions = (; v = v_bcs,). model = NonhydrostaticModel(grid = immersed_grid, ; boundary_conditions = boundary_conditions). simulation = Simulation(model, Δt = 0.1, stop_time = 1.0); run!(simulation); ```; Error, truncated stack trace for length:. ```; GPU compilation of kernel gpu_calculate_Gv!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gv!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:213,Availability,error,error,213,"I'm getting an error while running the following example on a GPU, it runs correctly on CPU though. It has a problem with the immersed boundary conditions, but the same BC on the normal boundary doesn't throw the error.; ```; using CUDA; using Oceananigans. arch = has_cuda_gpu() ? GPU() : CPU(); topo = [Flat, Periodic, Bounded] ; underlying_grid = RectilinearGrid(arch, size = (1,1), ; extent = (1, 1),; topology = topo). @inline slope(x, y) = -2.0*y; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). z₀ = 1e-2 # Charnock roughness; κ = 0.4 # Von Karman constant; @inline Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2; const dz = 0.1. @inline bottom_drag_v(x, y, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); @inline bottom_drag_v(x, y, z, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); v_drag_bc = FluxBoundaryCondition(bottom_drag_v, field_dependencies=(:v, :w), parameters=Cᴰ(dz)); v_bcs = FieldBoundaryConditions(bottom=v_drag_bc, immersed=v_drag_bc). boundary_conditions = (; v = v_bcs,). model = NonhydrostaticModel(grid = immersed_grid, ; boundary_conditions = boundary_conditions). simulation = Simulation(model, Δt = 0.1, stop_time = 1.0); run!(simulation); ```; Error, truncated stack trace for length:. ```; GPU compilation of kernel gpu_calculate_Gv!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gv!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:1183,Availability,Error,Error,1183,"dary doesn't throw the error.; ```; using CUDA; using Oceananigans. arch = has_cuda_gpu() ? GPU() : CPU(); topo = [Flat, Periodic, Bounded] ; underlying_grid = RectilinearGrid(arch, size = (1,1), ; extent = (1, 1),; topology = topo). @inline slope(x, y) = -2.0*y; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). z₀ = 1e-2 # Charnock roughness; κ = 0.4 # Von Karman constant; @inline Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2; const dz = 0.1. @inline bottom_drag_v(x, y, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); @inline bottom_drag_v(x, y, z, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); v_drag_bc = FluxBoundaryCondition(bottom_drag_v, field_dependencies=(:v, :w), parameters=Cᴰ(dz)); v_bcs = FieldBoundaryConditions(bottom=v_drag_bc, immersed=v_drag_bc). boundary_conditions = (; v = v_bcs,). model = NonhydrostaticModel(grid = immersed_grid, ; boundary_conditions = boundary_conditions). simulation = Simulation(model, Δt = 0.1, stop_time = 1.0); run!(simulation); ```; Error, truncated stack trace for length:. ```; GPU compilation of kernel gpu_calculate_Gv!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gv!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:29865,Availability,error,error,29865,"ryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/IBMCode/Oceananigans.jl/src/Simulations/run.jl:88; [24] top-level scope; @ REPL[18]:1; [25] top-level scope; @ ~/.julia/packages/CUDA/qAl31/src/initialization.jl:52; ```; @tomchor has also seen the same error. Looking at past issues, I wondered if this related to #2558 at all?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:2577,Deployability,Continuous,ContinuousBoundaryFunction,2577,"ing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, CenteredSecondOrder, Nothing, Nothing, Nothing, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:2927,Deployability,Continuous,ContinuousBoundaryFunction,2927,"unded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, CenteredSecondOrder, Nothing, Nothing, Nothing, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:3296,Deployability,Continuous,ContinuousBoundaryFunction,3296,"FittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, CenteredSecondOrder, Nothing, Nothing, Nothing, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:3645,Deployability,Continuous,ContinuousBoundaryFunction,3645,"eof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, Nothing, NamedTuple{(:u, :v, :w), Tuple{typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:4937,Deployability,Continuous,ContinuousBoundaryFunction,4937,"e{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, Nothing, NamedTuple{(:u, :v, :w), Tuple{typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 11 to your kernel function is of type ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:5287,Deployability,Continuous,ContinuousBoundaryFunction,5287,"ays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, Nothing, NamedTuple{(:u, :v, :w), Tuple{typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 11 to your kernel function is of type ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, which is not isbits:; .west is of type BoundaryCond",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:5656,Deployability,Continuous,ContinuousBoundaryFunction,5656,"e{Float64, Int64, Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 11 to your kernel function is of type ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, which is not isbits:; .west is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:6005,Deployability,Continuous,ContinuousBoundaryFunction,6005,"eof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, which is not isbits:; .west is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:6395,Deployability,Continuous,ContinuousBoundaryFunction,6395,"ol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, which is not isbits:; .west is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .east is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symb",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:6732,Deployability,Continuous,ContinuousBoundaryFunction,6732,"om_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, which is not isbits:; .west is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .east is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Sym",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:7280,Deployability,Continuous,ContinuousBoundaryFunction,7280,"daryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .east is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .bottom is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:7618,Deployability,Continuous,ContinuousBoundaryFunction,7618,"ᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .east is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .bottom is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Sym",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:8169,Deployability,Continuous,ContinuousBoundaryFunction,8169,"Condition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .bottom is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .top is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:8505,Deployability,Continuous,ContinuousBoundaryFunction,8505,"ᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .bottom is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .top is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:9051,Deployability,Continuous,ContinuousBoundaryFunction,9051,"oundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .top is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits. Stacktrace:; ...; [23] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:9388,Deployability,Continuous,ContinuousBoundaryFunction,9388,"ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .top is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits. Stacktrace:; ...; [23] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:16275,Deployability,Continuous,ContinuousBoundaryFunction,16275,"Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:16716,Deployability,Continuous,ContinuousBoundaryFunction,16716,"e.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:17066,Deployability,Continuous,ContinuousBoundaryFunction,17066,"Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:17435,Deployability,Continuous,ContinuousBoundaryFunction,17435,"nigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:17784,Deployability,Continuous,ContinuousBoundaryFunction,17784,"eof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/issues/2563:619,Testability,log,log,619,"I'm getting an error while running the following example on a GPU, it runs correctly on CPU though. It has a problem with the immersed boundary conditions, but the same BC on the normal boundary doesn't throw the error.; ```; using CUDA; using Oceananigans. arch = has_cuda_gpu() ? GPU() : CPU(); topo = [Flat, Periodic, Bounded] ; underlying_grid = RectilinearGrid(arch, size = (1,1), ; extent = (1, 1),; topology = topo). @inline slope(x, y) = -2.0*y; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). z₀ = 1e-2 # Charnock roughness; κ = 0.4 # Von Karman constant; @inline Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2; const dz = 0.1. @inline bottom_drag_v(x, y, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); @inline bottom_drag_v(x, y, z, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); v_drag_bc = FluxBoundaryCondition(bottom_drag_v, field_dependencies=(:v, :w), parameters=Cᴰ(dz)); v_bcs = FieldBoundaryConditions(bottom=v_drag_bc, immersed=v_drag_bc). boundary_conditions = (; v = v_bcs,). model = NonhydrostaticModel(grid = immersed_grid, ; boundary_conditions = boundary_conditions). simulation = Simulation(model, Δt = 0.1, stop_time = 1.0); run!(simulation); ```; Error, truncated stack trace for length:. ```; GPU compilation of kernel gpu_calculate_Gv!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gv!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563
https://github.com/CliMA/Oceananigans.jl/pull/2572:159,Testability,test,test,159,Just realized I left a bug... the solution was initialized with random numbers and as such was not converging some times. This finally solves the issue of the test not passing (hopefully),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2572
https://github.com/CliMA/Oceananigans.jl/issues/2575:32,Usability,learn,learned,32,"Thanks to @simone-silvestri , I learned today that we cannot compute the divergence on a `LatitudeLongitudeGrid` using the simple formula of. $$; \zeta = \partial_x(v) - \partial_y(u); $$. Instead, we should use `VerticalVorticityField`. . Since this function exists, do we also want to create a [`HorizontalDivergenceField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/vertical_vorticity_field.jl), which computes the equivalent of the following but correctly on all grids?. $$; \delta = \partial_x(u) - \partial_y(v); $$. I for one expect that I would use this almost as often.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575
https://github.com/CliMA/Oceananigans.jl/issues/2575:123,Usability,simpl,simple,123,"Thanks to @simone-silvestri , I learned today that we cannot compute the divergence on a `LatitudeLongitudeGrid` using the simple formula of. $$; \zeta = \partial_x(v) - \partial_y(u); $$. Instead, we should use `VerticalVorticityField`. . Since this function exists, do we also want to create a [`HorizontalDivergenceField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/vertical_vorticity_field.jl), which computes the equivalent of the following but correctly on all grids?. $$; \delta = \partial_x(u) - \partial_y(v); $$. I for one expect that I would use this almost as often.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575
https://github.com/CliMA/Oceananigans.jl/pull/2576:199,Integrability,message,messages,199,"This PR builds on @navidcy's excellent work to convert all the examples to Makie. I tried to unify the coding style in the examples as best I could. Also, there was a bit too much logging / plotting messages in the examples, which polluted the docs. TODO:. - [x] We should use `Axis3` in the baroclinic adjustment animation.; - [x] The stretched grid is not displayed in the tilted bottom boundary layer (we could also get rid of this, because we already visualize a similar stretched grid in another example); - [x] Remove logging noise from shallow water bickley jet, horizontal convection, and tilted bottom boundary layer examples",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576
https://github.com/CliMA/Oceananigans.jl/pull/2576:180,Testability,log,logging,180,"This PR builds on @navidcy's excellent work to convert all the examples to Makie. I tried to unify the coding style in the examples as best I could. Also, there was a bit too much logging / plotting messages in the examples, which polluted the docs. TODO:. - [x] We should use `Axis3` in the baroclinic adjustment animation.; - [x] The stretched grid is not displayed in the tilted bottom boundary layer (we could also get rid of this, because we already visualize a similar stretched grid in another example); - [x] Remove logging noise from shallow water bickley jet, horizontal convection, and tilted bottom boundary layer examples",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576
https://github.com/CliMA/Oceananigans.jl/pull/2576:524,Testability,log,logging,524,"This PR builds on @navidcy's excellent work to convert all the examples to Makie. I tried to unify the coding style in the examples as best I could. Also, there was a bit too much logging / plotting messages in the examples, which polluted the docs. TODO:. - [x] We should use `Axis3` in the baroclinic adjustment animation.; - [x] The stretched grid is not displayed in the tilted bottom boundary layer (we could also get rid of this, because we already visualize a similar stretched grid in another example); - [x] Remove logging noise from shallow water bickley jet, horizontal convection, and tilted bottom boundary layer examples",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576
https://github.com/CliMA/Oceananigans.jl/pull/2578:179,Testability,test,tested,179,"This pull request changes the compat entry for the `DocStringExtensions` package from `^0.8` to `^0.8, 0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2578
https://github.com/CliMA/Oceananigans.jl/pull/2578:285,Testability,test,tests,285,"This pull request changes the compat entry for the `DocStringExtensions` package from `^0.8` to `^0.8, 0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2578
https://github.com/CliMA/Oceananigans.jl/issues/2581:1108,Energy Efficiency,schedul,schedule,1108,"nigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. grid_base = RectilinearGrid(CPU(), size=(24, 24, 6), extent=(500, 500, 100)); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(-50)); @info grid. model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,); @info """" model; v_i(x, y, z,) = 0.1 + 1e-2*randn(); set!(model, v=v_i). simulation = Simulation(model, Δt=10seconds, stop_time=0.5day,). using Oceananigans.AbstractOperations: @at; using Oceananigans.Grids: Center, Face. ccc_scratch = Field{Center, Center, Center}(model.grid); u, v, w = model.velocities. u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data). outputs = (; u1, v1,); overwrite_existing = true. simname = ""mwe.nc""; simulation.output_writers[:hr1_writer] =; NetCDFOutputWriter(model, outputs,; filename = ""data/hr1.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). xz_average(F) = Field(Average(F, dims=(1,3))); outputs_avg = map(xz_average, outputs). simulation.output_writers[:avg_writer] =; NetCDFOutputWriter(model, outputs_avg,; filename = ""data/avg.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). run!(simulation); ```. The output for `hr1_writer` appears to be fine, but when I open the outputs for `ave_writer` I get that both outputs are always _exactly_ the same, and they have the value that the xz-average of `u1` should:. ![Screenshot_20220526_114754](https://user-images.githubusercontent.com/13205162/170556118-5e7cfb5b-6491-4e1e-919c-2ea9d5db5211.png). The two left pictures are `u1` and `v1` from `avg_writer`. The figure on the right is the xy-average computed separately. In other words: in this example the xz-average of `u1` gets computed correctly, but the xz-average of `v1` gets assigned the value of the xz-average of `u1`. A couple of notes:. - Us",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581
https://github.com/CliMA/Oceananigans.jl/issues/2581:1391,Energy Efficiency,schedul,schedule,1391,"taticModel(grid = grid, timestepper = :RungeKutta3,); @info """" model; v_i(x, y, z,) = 0.1 + 1e-2*randn(); set!(model, v=v_i). simulation = Simulation(model, Δt=10seconds, stop_time=0.5day,). using Oceananigans.AbstractOperations: @at; using Oceananigans.Grids: Center, Face. ccc_scratch = Field{Center, Center, Center}(model.grid); u, v, w = model.velocities. u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data). outputs = (; u1, v1,); overwrite_existing = true. simname = ""mwe.nc""; simulation.output_writers[:hr1_writer] =; NetCDFOutputWriter(model, outputs,; filename = ""data/hr1.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). xz_average(F) = Field(Average(F, dims=(1,3))); outputs_avg = map(xz_average, outputs). simulation.output_writers[:avg_writer] =; NetCDFOutputWriter(model, outputs_avg,; filename = ""data/avg.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). run!(simulation); ```. The output for `hr1_writer` appears to be fine, but when I open the outputs for `ave_writer` I get that both outputs are always _exactly_ the same, and they have the value that the xz-average of `u1` should:. ![Screenshot_20220526_114754](https://user-images.githubusercontent.com/13205162/170556118-5e7cfb5b-6491-4e1e-919c-2ea9d5db5211.png). The two left pictures are `u1` and `v1` from `avg_writer`. The figure on the right is the xy-average computed separately. In other words: in this example the xz-average of `u1` gets computed correctly, but the xz-average of `v1` gets assigned the value of the xz-average of `u1`. A couple of notes:. - Using a regular grid instead of an immersed grid solves the issue (although I can't do that since that's the point of my whole simulation); - Removing the scratch space specification solves the issue, but I also can't do that since I'm severely constrained in memory and this reduces m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581
https://github.com/CliMA/Oceananigans.jl/issues/2581:2414,Energy Efficiency,reduce,reduces,2414,"op_time=0.5day,). using Oceananigans.AbstractOperations: @at; using Oceananigans.Grids: Center, Face. ccc_scratch = Field{Center, Center, Center}(model.grid); u, v, w = model.velocities. u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data). outputs = (; u1, v1,); overwrite_existing = true. simname = ""mwe.nc""; simulation.output_writers[:hr1_writer] =; NetCDFOutputWriter(model, outputs,; filename = ""data/hr1.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). xz_average(F) = Field(Average(F, dims=(1,3))); outputs_avg = map(xz_average, outputs). simulation.output_writers[:avg_writer] =; NetCDFOutputWriter(model, outputs_avg,; filename = ""data/avg.$(simname)"",; schedule = TimeInterval(15minutes),; overwrite_existing = overwrite_existing). run!(simulation); ```. The output for `hr1_writer` appears to be fine, but when I open the outputs for `ave_writer` I get that both outputs are always _exactly_ the same, and they have the value that the xz-average of `u1` should:. ![Screenshot_20220526_114754](https://user-images.githubusercontent.com/13205162/170556118-5e7cfb5b-6491-4e1e-919c-2ea9d5db5211.png). The two left pictures are `u1` and `v1` from `avg_writer`. The figure on the right is the xy-average computed separately. In other words: in this example the xz-average of `u1` gets computed correctly, but the xz-average of `v1` gets assigned the value of the xz-average of `u1`. A couple of notes:. - Using a regular grid instead of an immersed grid solves the issue (although I can't do that since that's the point of my whole simulation); - Removing the scratch space specification solves the issue, but I also can't do that since I'm severely constrained in memory and this reduces my memory footprint in about 50% (maybe after https://github.com/CliMA/Oceananigans.jl/pull/2523 is merged). I've got no idea what's causing this, so any help is appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581
https://github.com/CliMA/Oceananigans.jl/pull/2582:32,Testability,test,test,32,Resolves #2581. Maybe we should test this?. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582
https://github.com/CliMA/Oceananigans.jl/issues/2586:471,Availability,error,error,471,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586
https://github.com/CliMA/Oceananigans.jl/issues/2586:803,Availability,ERROR,ERROR,803,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586
https://github.com/CliMA/Oceananigans.jl/issues/2586:843,Availability,error,error,843,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586
https://github.com/CliMA/Oceananigans.jl/issues/2586:81,Integrability,depend,depends,81,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586
https://github.com/CliMA/Oceananigans.jl/issues/2586:563,Integrability,depend,depend,563,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586
https://github.com/CliMA/Oceananigans.jl/issues/2586:36,Usability,learn,learn,36,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586
https://github.com/CliMA/Oceananigans.jl/issues/2588:11,Security,validat,validation,11,"This input validation:. https://github.com/CliMA/Oceananigans.jl/blob/d14b6d222dc06fb520635902563af98ed2699246/src/Grids/input_validation.jl#L108. breaks the ""naive"" construction of grid domain that's used in `FieldTimeSeries`:. https://github.com/CliMA/Oceananigans.jl/blob/d14b6d222dc06fb520635902563af98ed2699246/src/OutputReaders/field_time_series.jl#L143. There, an `OffsetArray` with correct indexing (but incorrect size, according to the new restrictions on grid construction) is used to build a grid for `FieldTimeSeries` (when deserialization fails; typically this is because data was created with an old version of Oceananigans or a different Julia version).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2588
https://github.com/CliMA/Oceananigans.jl/issues/2591:1130,Availability,error,error,1130,"anigans.BoundaryConditions, Oceananigans.Grids, Oceananigans.AbstractOperations; using Oceananigans.TurbulenceClosures; using Oceananigans.Advection: CenteredFourthOrder; using Oceananigans.Utils: TimeInterval; using CUDA. # # Making grid; Nx = 32; Ny = 32; Nz = 30; Δy = 250.0; Δx = 250.0; Δz = 2.5; Lx = Δx*Nx; Ly = Δy*Ny; Lz = Δz*Nz; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = (0, Lz)). kappaH = 5e5 # [m4/s]; kappaV = 5e-5 # [m2/s]; vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = HorizontalScalarBiharmonicDiffusivity(κ=kappaH, ν=kappaH); closures = (vertical_closure, horizontal_closure). model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; closure = closures,; ); ; # Running; Δt = 60.; simulation = Simulation(model, Δt=Δt, stop_iteration=0); simulation.stop_iteration += 1; run!(simulation). ```. and get the following error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 30)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 30)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, CenteredFourthOrder, FPlane{Float64}, Nothi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2591
https://github.com/CliMA/Oceananigans.jl/issues/2591:1143,Availability,ERROR,ERROR,1143,"bstractOperations; using Oceananigans.TurbulenceClosures; using Oceananigans.Advection: CenteredFourthOrder; using Oceananigans.Utils: TimeInterval; using CUDA. # # Making grid; Nx = 32; Ny = 32; Nz = 30; Δy = 250.0; Δx = 250.0; Δz = 2.5; Lx = Δx*Nx; Ly = Δy*Ny; Lz = Δz*Nz; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = (0, Lz)). kappaH = 5e5 # [m4/s]; kappaV = 5e-5 # [m2/s]; vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = HorizontalScalarBiharmonicDiffusivity(κ=kappaH, ν=kappaH); closures = (vertical_closure, horizontal_closure). model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; closure = closures,; ); ; # Running; Δt = 60.; simulation = Simulation(model, Δt=Δt, stop_iteration=0); simulation.stop_iteration += 1; run!(simulation). ```. and get the following error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 30)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 30)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, CenteredFourthOrder, FPlane{Float64}, Nothing, Tuple{ScalarBiharmonicDiffusivity{Oceananigans.TurbulenceCl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2591
https://github.com/CliMA/Oceananigans.jl/issues/2591:1150,Performance,Load,LoadError,1150,"bstractOperations; using Oceananigans.TurbulenceClosures; using Oceananigans.Advection: CenteredFourthOrder; using Oceananigans.Utils: TimeInterval; using CUDA. # # Making grid; Nx = 32; Ny = 32; Nz = 30; Δy = 250.0; Δx = 250.0; Δz = 2.5; Lx = Δx*Nx; Ly = Δy*Ny; Lz = Δz*Nz; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = (0, Lz)). kappaH = 5e5 # [m4/s]; kappaV = 5e-5 # [m2/s]; vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = HorizontalScalarBiharmonicDiffusivity(κ=kappaH, ν=kappaH); closures = (vertical_closure, horizontal_closure). model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; closure = closures,; ); ; # Running; Δt = 60.; simulation = Simulation(model, Δt=Δt, stop_iteration=0); simulation.stop_iteration += 1; run!(simulation). ```. and get the following error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 30)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 30)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, CenteredFourthOrder, FPlane{Float64}, Nothing, Tuple{ScalarBiharmonicDiffusivity{Oceananigans.TurbulenceCl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2591
https://github.com/CliMA/Oceananigans.jl/pull/2593:0,Deployability,Update,Updates,0,Updates the 0.25 degree simulation to our best numerical schemes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2593
https://github.com/CliMA/Oceananigans.jl/issues/2595:8,Availability,redundant,redundant,8,Is this redundant? If there is no CUDA-enabled GPU then how could a `grid` on GPU be provided as constructor argument?. https://github.com/CliMA/Oceananigans.jl/blob/d675d8b9f7359219941fa81ce098eb51b7c5ac8f/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L125-L127,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595
https://github.com/CliMA/Oceananigans.jl/issues/2595:8,Safety,redund,redundant,8,Is this redundant? If there is no CUDA-enabled GPU then how could a `grid` on GPU be provided as constructor argument?. https://github.com/CliMA/Oceananigans.jl/blob/d675d8b9f7359219941fa81ce098eb51b7c5ac8f/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L125-L127,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595
https://github.com/CliMA/Oceananigans.jl/pull/2597:1511,Availability,error,errors,1511,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2597:1387,Energy Efficiency,reduce,reduces,1387,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2597:1459,Energy Efficiency,reduce,reduces,1459,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2597:1637,Energy Efficiency,reduce,reduces,1637,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2597:551,Performance,perform,performant,551,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2597:637,Performance,perform,performance,637,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2597:417,Usability,simpl,simplify,417,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2597:534,Usability,simpl,simpler,534,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2597:672,Usability,simpl,simplifies,672,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597
https://github.com/CliMA/Oceananigans.jl/pull/2599:13,Modifiability,enhance,enhancements,13,Some phrasal enhancements in the docs/physics section. The page `physics/boundary_conditions.md` wasn't included in the `make.jl`? Is this markdown file deprecated and we should delete it altogether?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2599
https://github.com/CliMA/Oceananigans.jl/pull/2600:8,Modifiability,enhance,enhances,8,This PR enhances the `ShallowWaterModel` to allow for multiple fluid layers. The equations are summarized in [this overleaf doc](https://www.overleaf.com/read/mtyjxnnrjpqv). Closes #2507.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600
https://github.com/CliMA/Oceananigans.jl/pull/2600:69,Modifiability,layers,layers,69,This PR enhances the `ShallowWaterModel` to allow for multiple fluid layers. The equations are summarized in [this overleaf doc](https://www.overleaf.com/read/mtyjxnnrjpqv). Closes #2507.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600
https://github.com/CliMA/Oceananigans.jl/pull/2603:15,Modifiability,Refactor,Refactoring,15,"In this PR:; - Refactoring of advection to have three different reconstruction schemes: `Centered`, `UpwindBiased` and `WENO`; - advection schemes can be constructed with an `order` keyword argument which goes up to 12 for `Centered` and 11 for upwind schemes; - Reimplementation of boundary treatment: reconstruction method `_symmetric_`, `_left_biased_` and `_right_biased` have their own boundary treatment which entails checking the points for each method differently; - advection scheme have a `boundary_scheme` field which will is used to reconstruct values near the boundary. Boundary schemes use the same method as the _parent_ scheme but with a lower order:; For example, when using a WENO 9th order, closing in near the boundaries the order will be progressively decreased to 7th, 5th, 3rd and finally 1st. It also solves various bugs associated with advection and immersed boundary.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603
https://github.com/CliMA/Oceananigans.jl/pull/2605:92,Deployability,update,updated,92,cc @christophernhill creating a PR to merge this branch into our fork of main (which I just updated with the main upstream).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2605
https://github.com/CliMA/Oceananigans.jl/issues/2606:194,Availability,error,error,194,"This is a minimum working example that shows how we (@writingindy and I) have tried to use closure in the `VectorInvariantFormulation` of the `ShallowWaterModel` but get a `TaskFailedException` error, copied below. @simone-silvestri , do you have any idea as to how this can be fixed?. ```; using Oceananigans; using Oceananigans.Models.ShallowWaterModels: VectorInvariantFormulation; using Oceananigans.Advection: VelocityStencil, VorticityStencil; using Oceananigans.TurbulenceClosures. grid = RectilinearGrid(size = (16, 16), x = (0, 1), y = (0, 1), ; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(grid = grid,; momentum_advection = WENO5(vector_invariant = VelocityStencil()),; tracers = (:A),; closure = HorizontalScalarBiharmonicDiffusivity(κ=1e-6),; gravitational_acceleration = 1.0,; formulation = VectorInvariantFormulation(); ). set!(model, h=1); simulation = Simulation(model, Δt = 0.001, stop_time = 10.0). run!(simulation); ```. Error: ; ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching getindex(::Nothing, ::Int64); Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] diffusive_flux_x(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606
https://github.com/CliMA/Oceananigans.jl/issues/2606:962,Availability,Error,Error,962,"This is a minimum working example that shows how we (@writingindy and I) have tried to use closure in the `VectorInvariantFormulation` of the `ShallowWaterModel` but get a `TaskFailedException` error, copied below. @simone-silvestri , do you have any idea as to how this can be fixed?. ```; using Oceananigans; using Oceananigans.Models.ShallowWaterModels: VectorInvariantFormulation; using Oceananigans.Advection: VelocityStencil, VorticityStencil; using Oceananigans.TurbulenceClosures. grid = RectilinearGrid(size = (16, 16), x = (0, 1), y = (0, 1), ; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(grid = grid,; momentum_advection = WENO5(vector_invariant = VelocityStencil()),; tracers = (:A),; closure = HorizontalScalarBiharmonicDiffusivity(κ=1e-6),; gravitational_acceleration = 1.0,; formulation = VectorInvariantFormulation(); ). set!(model, h=1); simulation = Simulation(model, Δt = 0.001, stop_time = 10.0). run!(simulation); ```. Error: ; ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching getindex(::Nothing, ::Int64); Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] diffusive_flux_x(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606
https://github.com/CliMA/Oceananigans.jl/issues/2606:976,Availability,ERROR,ERROR,976,"This is a minimum working example that shows how we (@writingindy and I) have tried to use closure in the `VectorInvariantFormulation` of the `ShallowWaterModel` but get a `TaskFailedException` error, copied below. @simone-silvestri , do you have any idea as to how this can be fixed?. ```; using Oceananigans; using Oceananigans.Models.ShallowWaterModels: VectorInvariantFormulation; using Oceananigans.Advection: VelocityStencil, VorticityStencil; using Oceananigans.TurbulenceClosures. grid = RectilinearGrid(size = (16, 16), x = (0, 1), y = (0, 1), ; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(grid = grid,; momentum_advection = WENO5(vector_invariant = VelocityStencil()),; tracers = (:A),; closure = HorizontalScalarBiharmonicDiffusivity(κ=1e-6),; gravitational_acceleration = 1.0,; formulation = VectorInvariantFormulation(); ). set!(model, h=1); simulation = Simulation(model, Δt = 0.001, stop_time = 10.0). run!(simulation); ```. Error: ; ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching getindex(::Nothing, ::Int64); Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] diffusive_flux_x(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606
https://github.com/CliMA/Oceananigans.jl/issues/2606:1027,Availability,error,error,1027,"This is a minimum working example that shows how we (@writingindy and I) have tried to use closure in the `VectorInvariantFormulation` of the `ShallowWaterModel` but get a `TaskFailedException` error, copied below. @simone-silvestri , do you have any idea as to how this can be fixed?. ```; using Oceananigans; using Oceananigans.Models.ShallowWaterModels: VectorInvariantFormulation; using Oceananigans.Advection: VelocityStencil, VorticityStencil; using Oceananigans.TurbulenceClosures. grid = RectilinearGrid(size = (16, 16), x = (0, 1), y = (0, 1), ; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(grid = grid,; momentum_advection = WENO5(vector_invariant = VelocityStencil()),; tracers = (:A),; closure = HorizontalScalarBiharmonicDiffusivity(κ=1e-6),; gravitational_acceleration = 1.0,; formulation = VectorInvariantFormulation(); ). set!(model, h=1); simulation = Simulation(model, Δt = 0.001, stop_time = 10.0). run!(simulation); ```. Error: ; ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching getindex(::Nothing, ::Int64); Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] diffusive_flux_x(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606
https://github.com/CliMA/Oceananigans.jl/issues/2606:983,Performance,Load,LoadError,983,"This is a minimum working example that shows how we (@writingindy and I) have tried to use closure in the `VectorInvariantFormulation` of the `ShallowWaterModel` but get a `TaskFailedException` error, copied below. @simone-silvestri , do you have any idea as to how this can be fixed?. ```; using Oceananigans; using Oceananigans.Models.ShallowWaterModels: VectorInvariantFormulation; using Oceananigans.Advection: VelocityStencil, VorticityStencil; using Oceananigans.TurbulenceClosures. grid = RectilinearGrid(size = (16, 16), x = (0, 1), y = (0, 1), ; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(grid = grid,; momentum_advection = WENO5(vector_invariant = VelocityStencil()),; tracers = (:A),; closure = HorizontalScalarBiharmonicDiffusivity(κ=1e-6),; gravitational_acceleration = 1.0,; formulation = VectorInvariantFormulation(); ). set!(model, h=1); simulation = Simulation(model, Δt = 0.001, stop_time = 10.0). run!(simulation); ```. Error: ; ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching getindex(::Nothing, ::Int64); Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] diffusive_flux_x(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606
https://github.com/CliMA/Oceananigans.jl/issues/2608:168,Energy Efficiency,schedul,schedule,168,It currently leaves something to be desired:. ```julia; help?> SpecifiedTimes; search: SpecifiedTimes. struct SpecifiedTimes <: AbstractSchedule. Callable TimeInterval schedule for periodic output or diagnostic evaluation according to model.clock.time.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2608
https://github.com/CliMA/Oceananigans.jl/issues/2609:465,Usability,simpl,simply,465,"This question is a bit of a detour from the Ocean, but might occur in the oceanographic context sometime, maybe?. With @writingindy, we have put together a one-layer shallow water magnetohydrodynamic model as presented in [Gilman 2000](https://iopscience.iop.org/article/10.1086/317291/meta). You can see the results of a simulation in the animation below and find the code [here](https://github.com/writingindy/SWMHD/blob/main/sw_mhd_adjustment.jl). To do this we simply needed to add a tracer for the magnetic potential and add a Lorentz force. Luckily, Oceananigans makes it easy to do both! In our formulation, we wrote the Lorentz force as Jacobian, which means that it tends to be noisy and needs dissipation for numerical stability. The Lorentz force can also be written in in terms of advection, but the advection is by a tracer field, which leads to the following question:. Can we use advection schemes in the forcing functions?. https://user-images.githubusercontent.com/8239041/173368598-90b26027-63ab-4fcd-91e9-76618ae002bc.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2609
https://github.com/CliMA/Oceananigans.jl/pull/2611:177,Testability,test,tested,177,"This pull request changes the compat entry for the `PencilFFTs` package from `^0.13.5` to `^0.13.5, 0.14`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2611
https://github.com/CliMA/Oceananigans.jl/pull/2611:283,Testability,test,tests,283,"This pull request changes the compat entry for the `PencilFFTs` package from `^0.13.5` to `^0.13.5, 0.14`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2611
https://github.com/CliMA/Oceananigans.jl/pull/2616:20,Availability,mask,masking,20,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:85,Availability,mask,masked,85,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:149,Availability,mask,masked,149,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:274,Availability,mask,masked,274,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:544,Availability,mask,masking,544,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:688,Availability,mask,masking,688,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:926,Availability,mask,masking,926,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:1071,Availability,mask,masking,1071,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:1201,Availability,mask,masking,1201,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:1257,Availability,mask,masks,1257,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2616:866,Deployability,Update,Updated,866,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616
https://github.com/CliMA/Oceananigans.jl/pull/2621:76,Availability,avail,available,76,Enhances docstring for the `ImplicitFreeSurface` constructor to include the available solver methods. Closes #2620,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2621
https://github.com/CliMA/Oceananigans.jl/pull/2621:0,Modifiability,Enhance,Enhances,0,Enhances docstring for the `ImplicitFreeSurface` constructor to include the available solver methods. Closes #2620,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2621
https://github.com/CliMA/Oceananigans.jl/issues/2625:11,Testability,test,tests,11,Why in the tests for the implicit free surface we use a grid with `Ny = 1` and not `Flat` y?. https://github.com/CliMA/Oceananigans.jl/blob/27f7d044619b4159154a5940443be1d3d843aa5b/test/test_implicit_free_surface_solver.jl#L84-L86. cc @elise-palethorpe,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2625
https://github.com/CliMA/Oceananigans.jl/issues/2625:181,Testability,test,test,181,Why in the tests for the implicit free surface we use a grid with `Ny = 1` and not `Flat` y?. https://github.com/CliMA/Oceananigans.jl/blob/27f7d044619b4159154a5940443be1d3d843aa5b/test/test_implicit_free_surface_solver.jl#L84-L86. cc @elise-palethorpe,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2625
https://github.com/CliMA/Oceananigans.jl/pull/2629:226,Energy Efficiency,allocate,allocated,226,"This PR associates the GPU architecture with a specific device. This helps make the device that a model / grid is located on more explicit, so we don't have to ""infer"" the device based on where a particular piece of memory is allocated. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2629
https://github.com/CliMA/Oceananigans.jl/issues/2631:313,Deployability,update,update,313,"The typical example for this should be a linear bottom drag, e.g., for `u` a condition `- μ u`. Additionally, the `FieldBoundaryConditions` [docstring](https://github.com/CliMA/Oceananigans.jl/blob/42b2130b0945956632624a17b4d2d28631e1eee4/src/BoundaryConditions/field_boundary_conditions.jl#L103-L128) needs some update to include the `immersed` kwarg. cc @txs156, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2631
https://github.com/CliMA/Oceananigans.jl/issues/2638:197,Testability,test,test,197,Is there a reason that `test_matrix_poisson_solver.jl` defines its own function for computing the laplacian:. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/test/test_matrix_poisson_solver.jl#L8-L15. instead of using the one in `utils_for_runtests.jl`. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/test/utils_for_runtests.jl#L60-L77. I can only note an extra `fill_halo_regions!(ϕ)` line. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2638
https://github.com/CliMA/Oceananigans.jl/issues/2638:380,Testability,test,test,380,Is there a reason that `test_matrix_poisson_solver.jl` defines its own function for computing the laplacian:. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/test/test_matrix_poisson_solver.jl#L8-L15. instead of using the one in `utils_for_runtests.jl`. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/test/utils_for_runtests.jl#L60-L77. I can only note an extra `fill_halo_regions!(ϕ)` line. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2638
https://github.com/CliMA/Oceananigans.jl/pull/2639:8,Deployability,update,updates,8,"This PR updates several sections of the Docs to add clarity. In particular:. - Physics/Boussinesq approximation; - Numerical Implementation/Elliptic Solvers/Implicit free surface pressure operator; - Numerical Implementation/Pressure decomposition; - Numerical Implementation/Time-stepping; - `HydrostaticFreeSurfaceModel` docstrings . Also, closes #2653 and closes #2656.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639
https://github.com/CliMA/Oceananigans.jl/pull/2642:20,Modifiability,refactor,refactor,20,This PR sets out to refactor advection along the lines proposed in #2454; A final form for the new advection scheme is still to be decided though,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2642
https://github.com/CliMA/Oceananigans.jl/pull/2645:753,Deployability,update,updated,753,"following the suggestions provided in [On the Form of the Viscous Term for Two Dimensional Navier-Stokes Flows](https://academic.oup.com/qjmam/article/67/2/205/1909952), the viscous term is implemented as the divergence of the thickness weighted symmetric stress tensor; $$\boldsymbol{d} = h^{-1} \nabla \cdot (h \nu \boldsymbol{t})$$ where $$\boldsymbol{t} = \nabla \boldsymbol{u} + ( \nabla \boldsymbol{u})^T - \xi \boldsymbol{I} (\nabla \cdot \boldsymbol{u})$$. In case of a `ConservativeFormulation` the division by h in front of the term is dropped.; A new scalar diffusivity tailored to the shallow water model is added `ShallowWaterScalarDiffusivity` where $$\nu_e = h \nu$$ and the velocities are added as a field to the shallow water model and updated each time step in case of a conservative formulation. with @francispoulin . closes #2403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645
https://github.com/CliMA/Oceananigans.jl/pull/2646:342,Deployability,Update,Updates,342,"This PR:; - The Langmuir example currently claims that the buoyancy flux in the 2021 paper is `2.307e-9 # m² s⁻³, surface buoyancy flux` and sets up the buoyancy flux accordingly. But the paper actually sets up a flux of `2.307e-8` so I changed that (I think it was a typo). @glwagner can you please confirm that I'm not missing anything?. - Updates the CPU -> GPU functionality done via grid constructor instead via model in the Ocean wind mixing example. Docs should render here: It should render here: https://clima.github.io/OceananigansDocumentation/previews/PR2646",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2646
https://github.com/CliMA/Oceananigans.jl/issues/2647:141,Testability,test,testing,141,"the `inertial_oscillations_work_with_rotation_in_different_axis` (in `test_dynamics.jl`) takes about 1.5 hours to complete on a GPU, despite testing only slanted coriolis force. It would be probably better to skip it or design a slimmer version of the test...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2647
https://github.com/CliMA/Oceananigans.jl/issues/2647:252,Testability,test,test,252,"the `inertial_oscillations_work_with_rotation_in_different_axis` (in `test_dynamics.jl`) takes about 1.5 hours to complete on a GPU, despite testing only slanted coriolis force. It would be probably better to skip it or design a slimmer version of the test...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2647
https://github.com/CliMA/Oceananigans.jl/pull/2652:536,Performance,optimiz,optimize,536,"This PR adds grid spacings to NetCDF out, which is a step closer to solving https://github.com/CliMA/Oceananigans.jl/issues/1334. EDIT:. The goal here is to add grid metrics to NetCDF output. The are two main avenues to follow:. 1. We can follow Oceananigans nomenclature and conventions, which would make the output play more nicely with Oceananigans itself (and more generally in the Julia environment).; 2. We can follow standard community conventions, which would mean the output won't follow Oceananigans naming etc., but it would optimize its readability by other software. I think we should follow option 2, since if a user wants to work with the output in Oceananigans/Julia, then using JLD2 output is probably the right choice anyway. Given that most people in the community use Python, `xarray` and `xgcm` to analyze model output, I think we should optimize the output to work with that ecosystem out of the box. Based on the discussion in https://github.com/CliMA/Oceananigans.jl/issues/1334, it seems the preferred conventions to use are the [SGRID conventions](https://sgrid.github.io/sgrid/). For the more technical aspects, I'm planning on starting with `RectilinearGrids` and `LatLonGrids` in this PR since these are more straightforward. And then we can expand from there. I also think this should be presented to the user as an opt-in flag in `NetCDFWriter` constructor, as opposed to being included in every NetCDF output by default.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652
https://github.com/CliMA/Oceananigans.jl/pull/2652:859,Performance,optimiz,optimize,859,"This PR adds grid spacings to NetCDF out, which is a step closer to solving https://github.com/CliMA/Oceananigans.jl/issues/1334. EDIT:. The goal here is to add grid metrics to NetCDF output. The are two main avenues to follow:. 1. We can follow Oceananigans nomenclature and conventions, which would make the output play more nicely with Oceananigans itself (and more generally in the Julia environment).; 2. We can follow standard community conventions, which would mean the output won't follow Oceananigans naming etc., but it would optimize its readability by other software. I think we should follow option 2, since if a user wants to work with the output in Oceananigans/Julia, then using JLD2 output is probably the right choice anyway. Given that most people in the community use Python, `xarray` and `xgcm` to analyze model output, I think we should optimize the output to work with that ecosystem out of the box. Based on the discussion in https://github.com/CliMA/Oceananigans.jl/issues/1334, it seems the preferred conventions to use are the [SGRID conventions](https://sgrid.github.io/sgrid/). For the more technical aspects, I'm planning on starting with `RectilinearGrids` and `LatLonGrids` in this PR since these are more straightforward. And then we can expand from there. I also think this should be presented to the user as an opt-in flag in `NetCDFWriter` constructor, as opposed to being included in every NetCDF output by default.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652
https://github.com/CliMA/Oceananigans.jl/issues/2655:122,Integrability,depend,depending,122,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/ep/pcg-with-multigrid/validation/elliptic_solvers/testing_preconditioner.jl)). When the initial guess is all 0s the precondition! method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here ](https://www.netlib.org/templates/templates.pdf)so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2655
https://github.com/CliMA/Oceananigans.jl/issues/2655:270,Security,validat,validation,270,"I was having a play with preconditioning the CG solver with multigrid and found that I get considerably different results depending on whether I zero the initial guess to the preconditioner (see [here](https://github.com/CliMA/Oceananigans.jl/blob/ep/pcg-with-multigrid/validation/elliptic_solvers/testing_preconditioner.jl)). When the initial guess is all 0s the precondition! method is called ~1/3 of the number to times it is called if the given initial guess is used. My understanding is that the initial guess is not specified by the algorithm in fig 2.5 [here ](https://www.netlib.org/templates/templates.pdf)so am not sure whether this is a ""correct"" answer here but would like to know why the zeroing gives such a different result. Could it be because solving for a residual equation the answer should be close to all 0s so it is actually a good initial guess?. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2655
https://github.com/CliMA/Oceananigans.jl/pull/2658:126,Energy Efficiency,adapt,adaptation,126,revamp of lagrangian particles to make sure that they work on a `LatitudeLongitudeGrid` and on an `ImmersedBoundaryGrid` (and adaptation to all the new changes to Oceananigans). closes #2397 ; closes #2395,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2658
https://github.com/CliMA/Oceananigans.jl/pull/2658:126,Modifiability,adapt,adaptation,126,revamp of lagrangian particles to make sure that they work on a `LatitudeLongitudeGrid` and on an `ImmersedBoundaryGrid` (and adaptation to all the new changes to Oceananigans). closes #2397 ; closes #2395,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2658
https://github.com/CliMA/Oceananigans.jl/issues/2659:2133,Availability,ERROR,ERROR,2133,"d over dims = (1, 2) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 4); ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: mean! over dims (1, 2) of 4×4×4 Field{Face, Center, Center} on RectilinearGrid on CPU; └── status: time=0.0. julia> fcc_scratch = Field{Face, Center, Center}(model.grid); 4×4×4 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 10×10×10 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> Field(Average(u, dims=(1,2)), data=fcc_scratch.data); ERROR: ArgumentError: Cannot construct field at (Nothing, Nothing, Center) with size(data)=(10, 10, 10). `data` must have size (1, 1, 10).; Stacktrace:; [1] validate_field_data(loc::Tuple{DataType, DataType, DataType}, data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{Colon, Colon, Colon}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:43; [2] #apply_regionally!#27; @ ~/repos/Oceananigans.jl/src/Utils/multi_region_transformation.jl:96 [inlined]; [3] apply_regionally!; @ ~/repos/Oceananigans.jl/src/Utils/multi_region_transformation.jl:94 [inlined",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2659
https://github.com/CliMA/Oceananigans.jl/issues/2659:1175,Energy Efficiency,reduce,reduced,1175," Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid=grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> u, v, w = model.velocities; NamedTuple with 3 Fields on 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 4×4×4 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── v: 4×4×4 Field{Center, Face, Center} on RectilinearGrid on CPU; └── w: 4×4×5 Field{Center, Center, Face} on RectilinearGrid on CPU. julia> Field(Average(u, dims=(1,2))); 1×1×4 Field{Nothing, Nothing, Center} reduced over dims = (1, 2) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 4); ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: mean! over dims (1, 2) of 4×4×4 Field{Face, Center, Center} on RectilinearGrid on CPU; └── status: time=0.0. julia> fcc_scratch = Field{Face, Center, Center}(model.grid); 4×4×4 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 10×10×10 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> Field(Average(u, dims=(1,2)), data=fcc_scratch.data); ERROR: ArgumentError: Cannot construct fie",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2659
https://github.com/CliMA/Oceananigans.jl/issues/2660:1636,Availability,error,error,1636,"= 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; #; k = collect(1:Nz); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimension",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660
https://github.com/CliMA/Oceananigans.jl/issues/2660:1650,Availability,ERROR,ERROR,1650,"); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660
https://github.com/CliMA/Oceananigans.jl/issues/2660:1657,Performance,Load,LoadError,1657,"); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660
https://github.com/CliMA/Oceananigans.jl/issues/2660:8164,Security,validat,validation,8164,"ys.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, SmallSlopeIsopycnalTensor{Int64}}, VerticalScalarDiffusivity{ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}}}, BoundaryCondition{Flux, Nothing}, Buoyancy{SeawaterBuoyancy{Float64, SeawaterPolynomials.BoussinesqEquationOfState{TEOS10SeawaterPolynomial{Float64}, Int64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:T, :S), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, Tuple{NamedTuple{(:νₑ,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, Nothing}, typeof(Oceananigans.Forcings.zeroforcing), NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/XyxTy/src/validation.jl:139. ```. Note that the equivalent code works fine on CPU. Any ideas? Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660
https://github.com/CliMA/Oceananigans.jl/pull/2662:536,Availability,error,error,536,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662
https://github.com/CliMA/Oceananigans.jl/pull/2662:626,Deployability,update,updated,626,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662
https://github.com/CliMA/Oceananigans.jl/pull/2662:865,Deployability,update,updated,865,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662
https://github.com/CliMA/Oceananigans.jl/pull/2662:992,Deployability,update,updated,992,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662
https://github.com/CliMA/Oceananigans.jl/pull/2662:877,Testability,test,tests,877,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662
https://github.com/CliMA/Oceananigans.jl/pull/2662:917,Testability,test,tests,917,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662
https://github.com/CliMA/Oceananigans.jl/issues/2663:172,Availability,error,error,172,"This issue appears on v1.8.0-rc1 so I understand if it is not a priority.; Oceananigans version: So far reproduced in v0.76.6 and v0.76.5; To reproduce, in the REPL:; *The error does not prevent the fields from been created* but it is a pain to do interactive work with it.; ```julia; pkg> activate --temp; pkg> add NetCDF_jll@400.802.103, Oceananigans ; #NCDatasets latest release does not work with v1.8.0-rc1; julia> using Oceananigans; julia> grid = RectilinearGrid(CPU(),size = (10, 10),; x = (0, 100), y = (0, 100),; topology = (Periodic, Periodic, Flat), halo = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663
https://github.com/CliMA/Oceananigans.jl/issues/2663:639,Availability,Error,Error,639,"This issue appears on v1.8.0-rc1 so I understand if it is not a priority.; Oceananigans version: So far reproduced in v0.76.6 and v0.76.5; To reproduce, in the REPL:; *The error does not prevent the fields from been created* but it is a pain to do interactive work with it.; ```julia; pkg> activate --temp; pkg> add NetCDF_jll@400.802.103, Oceananigans ; #NCDatasets latest release does not work with v1.8.0-rc1; julia> using Oceananigans; julia> grid = RectilinearGrid(CPU(),size = (10, 10),; x = (0, 100), y = (0, 100),; topology = (Periodic, Periodic, Flat), halo = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663
https://github.com/CliMA/Oceananigans.jl/issues/2663:1704,Availability,ERROR,ERROR,1704,"o = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.add_sum), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.mul_prod), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::Union{typeof(Base._extrema_rf), typeof(max), typeof(min)}, ::Bool, ::AbstractArray) where T at reducedim.jl:84; ...; Stacktrace:; [1] initialize_reduced_field!; ```; I'm trying to figure out why would this fail in v1.8.0-rc1 but not on v1.7 but no luck so far.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663
https://github.com/CliMA/Oceananigans.jl/issues/2663:374,Deployability,release,release,374,"This issue appears on v1.8.0-rc1 so I understand if it is not a priority.; Oceananigans version: So far reproduced in v0.76.6 and v0.76.5; To reproduce, in the REPL:; *The error does not prevent the fields from been created* but it is a pain to do interactive work with it.; ```julia; pkg> activate --temp; pkg> add NetCDF_jll@400.802.103, Oceananigans ; #NCDatasets latest release does not work with v1.8.0-rc1; julia> using Oceananigans; julia> grid = RectilinearGrid(CPU(),size = (10, 10),; x = (0, 100), y = (0, 100),; topology = (Periodic, Periodic, Flat), halo = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663
https://github.com/CliMA/Oceananigans.jl/issues/2663:2132,Energy Efficiency,reduce,reducedim,2132,"o = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.add_sum), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.mul_prod), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::Union{typeof(Base._extrema_rf), typeof(max), typeof(min)}, ::Bool, ::AbstractArray) where T at reducedim.jl:84; ...; Stacktrace:; [1] initialize_reduced_field!; ```; I'm trying to figure out why would this fail in v1.8.0-rc1 but not on v1.7 but no luck so far.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663
https://github.com/CliMA/Oceananigans.jl/issues/2663:2248,Energy Efficiency,reduce,reducedim,2248,"o = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.add_sum), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.mul_prod), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::Union{typeof(Base._extrema_rf), typeof(max), typeof(min)}, ::Bool, ::AbstractArray) where T at reducedim.jl:84; ...; Stacktrace:; [1] initialize_reduced_field!; ```; I'm trying to figure out why would this fail in v1.8.0-rc1 but not on v1.7 but no luck so far.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663
https://github.com/CliMA/Oceananigans.jl/issues/2663:2400,Energy Efficiency,reduce,reducedim,2400,"o = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.add_sum), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.mul_prod), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::Union{typeof(Base._extrema_rf), typeof(max), typeof(min)}, ::Bool, ::AbstractArray) where T at reducedim.jl:84; ...; Stacktrace:; [1] initialize_reduced_field!; ```; I'm trying to figure out why would this fail in v1.8.0-rc1 but not on v1.7 but no luck so far.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663
https://github.com/CliMA/Oceananigans.jl/issues/2668:722,Availability,down,down,722,"The `precondition!` defined for `DiagonallyDominantPreconditioner` takes the arguments:. ```julia; P_r, ::DiagonallyDominantInversePreconditioner, r, ∫ᶻ_Axᶠᶜᶜ, ∫ᶻ_Ayᶜᶠᶜ, ...; ```. https://github.com/CliMA/Oceananigans.jl/blob/2edd2b1fa321725ad4e7891d3442ca9dd0657d98/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L243. however, the _fourth_ argument to `precondition` is supposed to be the free surface displacement (ie, the solution to the implicit step equation) as in. https://github.com/CliMA/Oceananigans.jl/blob/2edd2b1fa321725ad4e7891d3442ca9dd0657d98/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L191. as I recall this preconditioner has never worked properly (ie it slows down convergence rather than speeding it up). Is this the reason?. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2668
https://github.com/CliMA/Oceananigans.jl/issues/2671:2055,Energy Efficiency,schedul,schedule,2055,"rModel(; grid=grid,; gravitational_acceleration=9.81,; coriolis=FPlane(f=1),; ). #SMOOTH RANDOM FUNCTION; using Random; Random.seed!(17). n = 16; m = 16; len = n * m * 4. global alea; alea = rand(-1:1, (n, m, 4)). function rand_smth(x::Float64, y::Float64); X = x / 1000000; Y = y / 1000000; val = 0; for i in 1:n; for j in 1:m; ar = alea[i,j,1]; br = alea[i,j,2]; cr = alea[i,j,3]; dr = alea[i,j,4]; val += ar * cos(i * x) * cos(j * y); val += br * cos(i * x) * sin(j * y); val += cr * sin(i * x) * cos(j * y); val += dr * sin(i * x) * sin(j * y); end; end; return val; end; #End of smooth random function. H = 1kilometer # unperturbed layer depth. h₀(x, y, t) = H + rand_smth(x,y). set!(model, h=h₀). uh, vh, h = model.solution. simulation = Simulation(model, Δt=0.002, stop_iteration=10000). using Oceananigans.OutputWriters: JLD2OutputWriter, IterationInterval. simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.solution,; filename = ""simkm1.jld2"",; schedule=IterationInterval(4),; overwrite_existing = true). run!(simulation). using JLD2. file = jldopen(simulation.output_writers[:fields].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). xh, yh, zh = nodes(h). using Plots. @info ""Making a neat movie of height..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; h_snapshot = file[""timeseries/h/$iteration""][:, :, 1]. h_lim = 1.5meter; h_levels = range(H - h_lim, stop = H + h_lim, length=40). kwargs = (xlabel=""x"", ylabel=""y"", aspectratio=1, linewidth=0, colorbar=true,; xlims=(-model.grid.Lx/2, model.grid.Lx/2), ylims=(-model.grid.Ly/2, model.grid.Ly/2)). h_plot = contourf(xh, yh, clamp.(h_snapshot', H - h_lim, H + h_lim);; color = :balance,; levels = h_levels,; clims = (H - h_lim, H + h_lim),; kwargs...). plot(h_plot, title=""Height"", layout=(1), size=(600, 500)); end. mp4(anim, ""simkm1.mp4"", fps = 64) # hide. ```; **Initial random height func",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2671
https://github.com/CliMA/Oceananigans.jl/issues/2671:674,Testability,test,testing,674,"Hi,; I have been working with a shallow water model simulation that consists simply of a stochastic height field as the initial condition. It's been working well on a 2pi by 2pi domain without using the Units module. . However, once I tried to scale this same simulation to a 2000km by 2000km domain, I encountered some issues. Specifically, it seems the simulation becomes static. The output I'm viewing is just the height field animation. I also apologize if the initial condition code is confusing and added an image of the initial height function. I scaled the initial height function to match the domain so that should not be a source of bugs, theoretically. I've been testing and trying to fix this issue but am not sure what to do. . Thanks for any help or advice!. **Code:**; ```; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; using Oceananigans.Units. #Parameters; Nx, Ny = 128, 128; Lx = 1000kilometer; Ly = 1000kilometer. grid = RectilinearGrid(size = (Nx, Ny),; x=(-Lx, Lx), y=(-Lx, Ly),; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(; grid=grid,; gravitational_acceleration=9.81,; coriolis=FPlane(f=1),; ). #SMOOTH RANDOM FUNCTION; using Random; Random.seed!(17). n = 16; m = 16; len = n * m * 4. global alea; alea = rand(-1:1, (n, m, 4)). function rand_smth(x::Float64, y::Float64); X = x / 1000000; Y = y / 1000000; val = 0; for i in 1:n; for j in 1:m; ar = alea[i,j,1]; br = alea[i,j,2]; cr = alea[i,j,3]; dr = alea[i,j,4]; val += ar * cos(i * x) * cos(j * y); val += br * cos(i * x) * sin(j * y); val += cr * sin(i * x) * cos(j * y); val += dr * sin(i * x) * sin(j * y); end; end; return val; end; #End of smooth random function. H = 1kilometer # unperturbed layer depth. h₀(x, y, t) = H + rand_smth(x,y). set!(model, h=h₀). uh, vh, h = model.solution. simulation = Simulation(model, Δt=0.002, stop_iteration=10000). using Oceananigans.OutputWriters: JLD2OutputWriter, IterationInterval. simulation.output_writers[:fields] =; JLD2OutputWriter(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2671
https://github.com/CliMA/Oceananigans.jl/issues/2671:77,Usability,simpl,simply,77,"Hi,; I have been working with a shallow water model simulation that consists simply of a stochastic height field as the initial condition. It's been working well on a 2pi by 2pi domain without using the Units module. . However, once I tried to scale this same simulation to a 2000km by 2000km domain, I encountered some issues. Specifically, it seems the simulation becomes static. The output I'm viewing is just the height field animation. I also apologize if the initial condition code is confusing and added an image of the initial height function. I scaled the initial height function to match the domain so that should not be a source of bugs, theoretically. I've been testing and trying to fix this issue but am not sure what to do. . Thanks for any help or advice!. **Code:**; ```; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; using Oceananigans.Units. #Parameters; Nx, Ny = 128, 128; Lx = 1000kilometer; Ly = 1000kilometer. grid = RectilinearGrid(size = (Nx, Ny),; x=(-Lx, Lx), y=(-Lx, Ly),; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(; grid=grid,; gravitational_acceleration=9.81,; coriolis=FPlane(f=1),; ). #SMOOTH RANDOM FUNCTION; using Random; Random.seed!(17). n = 16; m = 16; len = n * m * 4. global alea; alea = rand(-1:1, (n, m, 4)). function rand_smth(x::Float64, y::Float64); X = x / 1000000; Y = y / 1000000; val = 0; for i in 1:n; for j in 1:m; ar = alea[i,j,1]; br = alea[i,j,2]; cr = alea[i,j,3]; dr = alea[i,j,4]; val += ar * cos(i * x) * cos(j * y); val += br * cos(i * x) * sin(j * y); val += cr * sin(i * x) * cos(j * y); val += dr * sin(i * x) * sin(j * y); end; end; return val; end; #End of smooth random function. H = 1kilometer # unperturbed layer depth. h₀(x, y, t) = H + rand_smth(x,y). set!(model, h=h₀). uh, vh, h = model.solution. simulation = Simulation(model, Δt=0.002, stop_iteration=10000). using Oceananigans.OutputWriters: JLD2OutputWriter, IterationInterval. simulation.output_writers[:fields] =; JLD2OutputWriter(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2671
https://github.com/CliMA/Oceananigans.jl/issues/2676:33,Availability,error,error,33,I got an incremental compilation error/warning here. https://github.com/CliMA/Oceananigans.jl/blob/b6dd1fa9b1d740f7d8cb4be116a24cbba0042f86/src/Architectures.jl#L23,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2676
https://github.com/CliMA/Oceananigans.jl/issues/2681:129,Availability,down,down,129,"Hi all,. I've come across a strange issue with Lagrangian particles where if they're near the top of the domain they always jump down by Δz after the first intermediate time step. I have tracked this down to the boundary condition enforcement where there is an off by one error choosing the maximum allowed position. The error would also have occurred in the x and y directions too. I will pull request this fix: https://github.com/jagoosw/Oceananigans.jl/tree/particle_tracking. I realized @simone-silvestri is working on an overhaul of Lagrangian particle tracking but it seems to not be fixed in that branch either. Hope this helps!. MWE:; ```; using Oceananigans. grid = RectilinearGrid(size=(2,2,2), extent=(2,2,2)); particles = LagrangianParticles(x=[0.5], y=[0.5], z=[-0.5]); model = NonhydrostaticModel(; grid, timestepper=:RungeKutta3, particles=particles); set!(model, u=0, v=0, w=0); sim = Simulation(model, Δt=1, stop_time=1); printz(sim)=println(sim.model.particles.properties.z); sim.callbacks[:z] = Callback(printz); run!(sim); ```; Result:; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (429.036 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (22.760 seconds).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-1.5]; ```; Results with fix; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (10.887 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.866 ms).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-0.5]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2681
https://github.com/CliMA/Oceananigans.jl/issues/2681:200,Availability,down,down,200,"Hi all,. I've come across a strange issue with Lagrangian particles where if they're near the top of the domain they always jump down by Δz after the first intermediate time step. I have tracked this down to the boundary condition enforcement where there is an off by one error choosing the maximum allowed position. The error would also have occurred in the x and y directions too. I will pull request this fix: https://github.com/jagoosw/Oceananigans.jl/tree/particle_tracking. I realized @simone-silvestri is working on an overhaul of Lagrangian particle tracking but it seems to not be fixed in that branch either. Hope this helps!. MWE:; ```; using Oceananigans. grid = RectilinearGrid(size=(2,2,2), extent=(2,2,2)); particles = LagrangianParticles(x=[0.5], y=[0.5], z=[-0.5]); model = NonhydrostaticModel(; grid, timestepper=:RungeKutta3, particles=particles); set!(model, u=0, v=0, w=0); sim = Simulation(model, Δt=1, stop_time=1); printz(sim)=println(sim.model.particles.properties.z); sim.callbacks[:z] = Callback(printz); run!(sim); ```; Result:; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (429.036 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (22.760 seconds).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-1.5]; ```; Results with fix; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (10.887 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.866 ms).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-0.5]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2681
https://github.com/CliMA/Oceananigans.jl/issues/2681:272,Availability,error,error,272,"Hi all,. I've come across a strange issue with Lagrangian particles where if they're near the top of the domain they always jump down by Δz after the first intermediate time step. I have tracked this down to the boundary condition enforcement where there is an off by one error choosing the maximum allowed position. The error would also have occurred in the x and y directions too. I will pull request this fix: https://github.com/jagoosw/Oceananigans.jl/tree/particle_tracking. I realized @simone-silvestri is working on an overhaul of Lagrangian particle tracking but it seems to not be fixed in that branch either. Hope this helps!. MWE:; ```; using Oceananigans. grid = RectilinearGrid(size=(2,2,2), extent=(2,2,2)); particles = LagrangianParticles(x=[0.5], y=[0.5], z=[-0.5]); model = NonhydrostaticModel(; grid, timestepper=:RungeKutta3, particles=particles); set!(model, u=0, v=0, w=0); sim = Simulation(model, Δt=1, stop_time=1); printz(sim)=println(sim.model.particles.properties.z); sim.callbacks[:z] = Callback(printz); run!(sim); ```; Result:; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (429.036 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (22.760 seconds).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-1.5]; ```; Results with fix; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (10.887 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.866 ms).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-0.5]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2681
https://github.com/CliMA/Oceananigans.jl/issues/2681:321,Availability,error,error,321,"Hi all,. I've come across a strange issue with Lagrangian particles where if they're near the top of the domain they always jump down by Δz after the first intermediate time step. I have tracked this down to the boundary condition enforcement where there is an off by one error choosing the maximum allowed position. The error would also have occurred in the x and y directions too. I will pull request this fix: https://github.com/jagoosw/Oceananigans.jl/tree/particle_tracking. I realized @simone-silvestri is working on an overhaul of Lagrangian particle tracking but it seems to not be fixed in that branch either. Hope this helps!. MWE:; ```; using Oceananigans. grid = RectilinearGrid(size=(2,2,2), extent=(2,2,2)); particles = LagrangianParticles(x=[0.5], y=[0.5], z=[-0.5]); model = NonhydrostaticModel(; grid, timestepper=:RungeKutta3, particles=particles); set!(model, u=0, v=0, w=0); sim = Simulation(model, Δt=1, stop_time=1); printz(sim)=println(sim.model.particles.properties.z); sim.callbacks[:z] = Callback(printz); run!(sim); ```; Result:; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (429.036 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (22.760 seconds).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-1.5]; ```; Results with fix; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (10.887 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.866 ms).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-0.5]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2681
https://github.com/CliMA/Oceananigans.jl/issues/2684:43,Availability,error,error,43,"Right now if we do this, we get an obscure error from `calc_correct_velocity_u` (which is already a confusing name --- what's the ""incorrect"" velocity?). ```julia; nested task error: BoundsError: attempt to access 608-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -3:604) with eltype Float64 with indices -3:604 at index [-58]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] calc_correct_velocity_u; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:104 [inlined]; [5] update_particle_position!; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:72 [inlined]; ```. This probably has to be checked in model constructors, since `LagrangianParticles` doesn't know about `grid`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2684
https://github.com/CliMA/Oceananigans.jl/issues/2684:176,Availability,error,error,176,"Right now if we do this, we get an obscure error from `calc_correct_velocity_u` (which is already a confusing name --- what's the ""incorrect"" velocity?). ```julia; nested task error: BoundsError: attempt to access 608-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -3:604) with eltype Float64 with indices -3:604 at index [-58]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] calc_correct_velocity_u; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:104 [inlined]; [5] update_particle_position!; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:72 [inlined]; ```. This probably has to be checked in model constructors, since `LagrangianParticles` doesn't know about `grid`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2684
https://github.com/CliMA/Oceananigans.jl/issues/2684:207,Security,access,access,207,"Right now if we do this, we get an obscure error from `calc_correct_velocity_u` (which is already a confusing name --- what's the ""incorrect"" velocity?). ```julia; nested task error: BoundsError: attempt to access 608-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -3:604) with eltype Float64 with indices -3:604 at index [-58]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] calc_correct_velocity_u; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:104 [inlined]; [5] update_particle_position!; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:72 [inlined]; ```. This probably has to be checked in model constructors, since `LagrangianParticles` doesn't know about `grid`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2684
https://github.com/CliMA/Oceananigans.jl/issues/2690:162,Security,validat,validation,162,"At least, this is not the current syntax for discrete diffusion function:. https://github.com/CliMA/Oceananigans.jl/blob/2234f02afdb83815ffd1134033b25c09477ddeac/validation/near_global_lat_lon/near_global_quarter_degree.jl#L131. There are also some formatting irregularities here:. https://github.com/CliMA/Oceananigans.jl/blob/2234f02afdb83815ffd1134033b25c09477ddeac/src/TurbulenceClosures/discrete_diffusion_function.jl#L57-L67",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690
https://github.com/CliMA/Oceananigans.jl/issues/2700:360,Availability,error,error,360,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:387,Availability,error,error,387,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:1673,Availability,error,error,1673,"ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:9573,Availability,error,errors,9573,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:9792,Availability,error,error,9792,"19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:9800,Availability,error,error,9800,"_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:16766,Availability,error,errors,16766,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:16985,Availability,error,error,16985,"19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:16993,Availability,error,error,16993,"_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:19182,Availability,error,errors,19182,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:19401,Availability,error,error,19401,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:19409,Availability,error,error,19409,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:19597,Availability,error,error,19597,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:607,Energy Efficiency,reduce,reduce,607,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:815,Energy Efficiency,reduce,reduce-gpu-params,815,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:366,Integrability,message,messages,366,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:393,Integrability,message,message,393,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:948,Integrability,depend,depend,948,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:19603,Integrability,message,message,19603,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:1568,Performance,Load,LoadError,1568,"duce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4_14TwicePrecisionIS4_ES10_IS4_E5Int64EES3_IS4_Li1ES9_IS4_S10_IS4_ES10_IS4_ES11_EES3_IS4_Li1ES5_IS4_Li1ELi1EEEvE22UpwindBiasedFifthOrder6FPlaneIS4_Ev17ScalarDiffusivityI26ExplicitTimeDiscretization27ThreeDimensionalFormulation3___10NamedTupleI57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_5TupleIS17_S17_S17_S17_S17_S17_S17_S17_S17_S17_S17_EEE17BoundaryConditionI4FluxvE8BuoyancyI14BuoyancyTracer10ZDirectionES18_I23__velocities___tracers_S19_IS18_I12__u___v___w_S19_I9ZeroFieldIS11_Li3EES25_IS11_Li3EES25_IS11_Li3EEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS25_IS11_L",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:9558,Safety,abort,aborted,9558,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:16751,Safety,abort,aborted,16751,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2700:19167,Safety,abort,aborted,19167,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700
https://github.com/CliMA/Oceananigans.jl/issues/2709:523,Availability,ERROR,ERROR,523,"Using Julia 1.7.3 and Oceananigans 0.77.1, this code:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(1, 1, 2), extent=(1, 1, 1)); buoyancy_bottom_bc = GradientBoundaryCondition(1e-5); buoyancy_bcs = FieldBoundaryConditions(bottom=buoyancy_bottom_bc); model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=BuoyancyTracer(),; boundary_conditions=(; b=buoyancy_bcs)); simulation = Simulation(model; Δt=1, stop_iteration=2); run!(simulation); ```. produces:. ```julia; julia> include(""simple_model.jl""); ERROR: LoadError: InvalidIRError: compiling kernel #gpu__fill_bottom_and_top_halo!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, NTuple{4, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Float64}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}, Tuple{Center, Center, Center}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, In",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2709
https://github.com/CliMA/Oceananigans.jl/issues/2709:530,Performance,Load,LoadError,530,"Using Julia 1.7.3 and Oceananigans 0.77.1, this code:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(1, 1, 2), extent=(1, 1, 1)); buoyancy_bottom_bc = GradientBoundaryCondition(1e-5); buoyancy_bcs = FieldBoundaryConditions(bottom=buoyancy_bottom_bc); model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=BuoyancyTracer(),; boundary_conditions=(; b=buoyancy_bcs)); simulation = Simulation(model; Δt=1, stop_iteration=2); run!(simulation); ```. produces:. ```julia; julia> include(""simple_model.jl""); ERROR: LoadError: InvalidIRError: compiling kernel #gpu__fill_bottom_and_top_halo!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, NTuple{4, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Float64}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}, Tuple{Center, Center, Center}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, In",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2709
https://github.com/CliMA/Oceananigans.jl/issues/2709:2832,Testability,test,tests,2832,"on.StaticSize{(1, 1)}, Nothing, Nothing}}, NTuple{4, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Float64}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}, Tuple{Center, Center, Center}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}, NamedTuple{(:u, :v, :w, :b), NTuple{4, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to _fill_bottom_halo!(i, j, grid, c, bc::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryConditions.Gradient}}, loc, args...) in Oceananigans.BoundaryConditions at /home/greg/.julia/packages/Oceananigans/W63bs/src/BoundaryConditions/fill_halo_regions_value_gradient.jl:73); ```. probably affects `ValueBoundaryCondition` too. We should probably have regression tests for these boundary conditions, as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2709
https://github.com/CliMA/Oceananigans.jl/issues/2711:818,Availability,error,error,818,"When I run the following MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lz = 50; grid_base = RectilinearGrid(size=(50, 50, 6), x=(-2000, 2000), y=(-1500, 2500), z=(0, Lz)). bathymetry(x, y) = Lz/2 * exp(-(x/500)^2 - (y/500)^2); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). const cᴰᶻ = 3e-3; @inline τˣᶻ_drag(x, y, z, t, u, v, w) = -cᴰᶻ * u * √(u^2 + v^2); τˣᶻ_BC = FluxBoundaryCondition(τˣᶻ_drag, field_dependencies = (:u, :v, :w)). u_bcs = FieldBoundaryConditions(immersed=ImmersedBoundaryCondition(bottom = τˣᶻ_BC)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u=u_bcs)). simulation = Simulation(model, Δt=1, stop_iteration=10); run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException; ; nested task error: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:831,Availability,ERROR,ERROR,831,"When I run the following MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lz = 50; grid_base = RectilinearGrid(size=(50, 50, 6), x=(-2000, 2000), y=(-1500, 2500), z=(0, Lz)). bathymetry(x, y) = Lz/2 * exp(-(x/500)^2 - (y/500)^2); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). const cᴰᶻ = 3e-3; @inline τˣᶻ_drag(x, y, z, t, u, v, w) = -cᴰᶻ * u * √(u^2 + v^2); τˣᶻ_BC = FluxBoundaryCondition(τˣᶻ_drag, field_dependencies = (:u, :v, :w)). u_bcs = FieldBoundaryConditions(immersed=ImmersedBoundaryCondition(bottom = τˣᶻ_BC)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u=u_bcs)). simulation = Simulation(model, Δt=1, stop_iteration=10); run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException; ; nested task error: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:882,Availability,error,error,882,"following MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lz = 50; grid_base = RectilinearGrid(size=(50, 50, 6), x=(-2000, 2000), y=(-1500, 2500), z=(0, Lz)). bathymetry(x, y) = Lz/2 * exp(-(x/500)^2 - (y/500)^2); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). const cᴰᶻ = 3e-3; @inline τˣᶻ_drag(x, y, z, t, u, v, w) = -cᴰᶻ * u * √(u^2 + v^2); τˣᶻ_BC = FluxBoundaryCondition(τˣᶻ_drag, field_dependencies = (:u, :v, :w)). u_bcs = FieldBoundaryConditions(immersed=ImmersedBoundaryCondition(bottom = τˣᶻ_BC)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u=u_bcs)). simulation = Simulation(model, Δt=1, stop_iteration=10); run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException; ; nested task error: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:924,Availability,error,error,924,"following MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lz = 50; grid_base = RectilinearGrid(size=(50, 50, 6), x=(-2000, 2000), y=(-1500, 2500), z=(0, Lz)). bathymetry(x, y) = Lz/2 * exp(-(x/500)^2 - (y/500)^2); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). const cᴰᶻ = 3e-3; @inline τˣᶻ_drag(x, y, z, t, u, v, w) = -cᴰᶻ * u * √(u^2 + v^2); τˣᶻ_BC = FluxBoundaryCondition(τˣᶻ_drag, field_dependencies = (:u, :v, :w)). u_bcs = FieldBoundaryConditions(immersed=ImmersedBoundaryCondition(bottom = τˣᶻ_BC)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u=u_bcs)). simulation = Simulation(model, Δt=1, stop_iteration=10); run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException; ; nested task error: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:3044,Deployability,Continuous,ContinuousBoundaryFunction,3044,"se.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:12095,Deployability,Continuous,ContinuousBoundaryFunction,12095,"s/Oceananigans/x1XyN/src/Utils/user_function_arguments.jl:22 [inlined]; [6] overdub; @ ~/.julia/packages/Oceananigans/x1XyN/src/BoundaryConditions/continuous_boundary_function.jl:161 [inlined]; [7] bottom_ib_flux(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, ::Tuple{Face, Center, Center}, ::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:13794,Deployability,Continuous,ContinuousBoundaryFunction,13794,"se.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Nothing, ::Nothing, ::Nothing, ::Clock{Float64}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:15655,Deployability,Continuous,ContinuousBoundaryFunction,15655,"se.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:25065,Deployability,Continuous,ContinuousBoundaryFunction,25065,"se.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:28234,Deployability,Continuous,ContinuousBoundaryFunction,28234,"fsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, ::ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, ::Nothing, ::Nothing, ::Clock{Float64}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.Im",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:29995,Deployability,Continuous,ContinuousBoundaryFunction,29995,"se.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:40216,Deployability,Continuous,ContinuousBoundaryFunction,40216,".Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:41923,Deployability,Continuous,ContinuousBoundaryFunction,41923,"se.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:57195,Deployability,Continuous,ContinuousBoundaryFunction,57195,".Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, ; ```. I'm not very familiar with hydrostatic models. Is this a bug o",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/issues/2711:838,Performance,Load,LoadError,838,"When I run the following MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lz = 50; grid_base = RectilinearGrid(size=(50, 50, 6), x=(-2000, 2000), y=(-1500, 2500), z=(0, Lz)). bathymetry(x, y) = Lz/2 * exp(-(x/500)^2 - (y/500)^2); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). const cᴰᶻ = 3e-3; @inline τˣᶻ_drag(x, y, z, t, u, v, w) = -cᴰᶻ * u * √(u^2 + v^2); τˣᶻ_BC = FluxBoundaryCondition(τˣᶻ_drag, field_dependencies = (:u, :v, :w)). u_bcs = FieldBoundaryConditions(immersed=ImmersedBoundaryCondition(bottom = τˣᶻ_BC)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u=u_bcs)). simulation = Simulation(model, Δt=1, stop_iteration=10); run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException; ; nested task error: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711
https://github.com/CliMA/Oceananigans.jl/pull/2715:175,Deployability,install,install,175,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:134,Integrability,depend,dependencies,134,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:535,Integrability,depend,dependencies,535,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:28,Performance,load,loaded,28,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:463,Performance,load,loading,463,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:552,Performance,load,loaded,552,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:610,Performance,load,loaded,610,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:238,Testability,test,tests,238,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:394,Testability,test,test,394,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/pull/2715:681,Testability,test,testing,681,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715
https://github.com/CliMA/Oceananigans.jl/issues/2717:337,Availability,error,error,337,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:364,Availability,ERROR,ERROR,364,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:6252,Availability,error,error,6252,"ctor{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, zweno::Bool, vector_invariant::Nothing, bounds::Nothing); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/weno_reconstruction.jl:133; [38] top-level scope; @ ~/repos/convddvs/simulations/mwe.jl:12; [39] include(fname::String); @ Base.MainInclude ./client.jl:444; [40] top-level scope; @ REPL[2]:1; [41] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ```. Some useful notes:. - When I increase the halo to 4 on the `z` direction the error disappears. Interestingly this code runs even with `halo=(1,1,4)`. (Is the WENO order decreasing as you approach the boundary? Should we throw a warning about this?); - This behavior is the same if decrease the WENO order and the halo size in the `z` direction, as expected.; - When I run the same code with the stretched grid (e.g. with `z=(0,1)`) the error disappears, which seems to point to a bug. If this isn't a bug and is instead expected behavior, maybe a more useful error would be helpful here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:6611,Availability,error,error,6611,"ctor{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, zweno::Bool, vector_invariant::Nothing, bounds::Nothing); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/weno_reconstruction.jl:133; [38] top-level scope; @ ~/repos/convddvs/simulations/mwe.jl:12; [39] include(fname::String); @ Base.MainInclude ./client.jl:444; [40] top-level scope; @ REPL[2]:1; [41] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ```. Some useful notes:. - When I increase the halo to 4 on the `z` direction the error disappears. Interestingly this code runs even with `halo=(1,1,4)`. (Is the WENO order decreasing as you approach the boundary? Should we throw a warning about this?); - This behavior is the same if decrease the WENO order and the halo size in the `z` direction, as expected.; - When I run the same code with the stretched grid (e.g. with `z=(0,1)`) the error disappears, which seems to point to a bug. If this isn't a bug and is instead expected behavior, maybe a more useful error would be helpful here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:6734,Availability,error,error,6734,"ctor{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, zweno::Bool, vector_invariant::Nothing, bounds::Nothing); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/weno_reconstruction.jl:133; [38] top-level scope; @ ~/repos/convddvs/simulations/mwe.jl:12; [39] include(fname::String); @ Base.MainInclude ./client.jl:444; [40] top-level scope; @ REPL[2]:1; [41] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ```. Some useful notes:. - When I increase the halo to 4 on the `z` direction the error disappears. Interestingly this code runs even with `halo=(1,1,4)`. (Is the WENO order decreasing as you approach the boundary? Should we throw a warning about this?); - This behavior is the same if decrease the WENO order and the halo size in the `z` direction, as expected.; - When I run the same code with the stretched grid (e.g. with `z=(0,1)`) the error disappears, which seems to point to a bug. If this isn't a bug and is instead expected behavior, maybe a more useful error would be helpful here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:846,Energy Efficiency,reduce,reduce,846,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:891,Energy Efficiency,reduce,reduce,891,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1287,Energy Efficiency,reduce,reduce,1287,"advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1321,Energy Efficiency,reduce,reduce,1321,"7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceana",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1368,Energy Efficiency,reduce,reduce,1368,"LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1416,Energy Efficiency,reduce,reduce,1416,"ment OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.Offse",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1460,Energy Efficiency,reduce,reduce,1460,"ith eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1510,Energy Efficiency,reduce,reduce,1510,"]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1555,Energy Efficiency,reduce,reduce,1555,"etArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1600,Energy Efficiency,reduce,reduce,1600,"}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64});",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1640,Energy Efficiency,reduce,reduce,1640,"rray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:1830,Energy Efficiency,reduce,reduce,1830,"ppingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:2207,Energy Efficiency,reduce,reduce,2207,"ase.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:2613,Energy Efficiency,reduce,reduce,2613,"nlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:3015,Energy Efficiency,reduce,reduce,3015,", OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}})(acc::Float64, x::Int64); @ Base ./reduce.jl:105; [20] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRang",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:3431,Energy Efficiency,reduce,reduce,3431,", Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:62; [21] foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:3824,Energy Efficiency,reduce,reduce,3824,"tor{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:3858,Energy Efficiency,reduce,reduce,3858,"setArrays.OffsetVector{Float64, Vector{Float64}}, Int64}, Base.BottomRF{typeof(Base.add_sum)}}}, nt::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:48; [22] mapfoldl_impl(f::typeof(identity), op::typeof(Base.add_sum), nt::Base._InitialValue, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.jul",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:4315,Energy Efficiency,reduce,reduce,4315,".OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataT",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:4350,Energy Efficiency,reduce,reduce,4350,"64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::Rectilinea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:4394,Energy Efficiency,reduce,reduce,4394,"tor{Float64}}, Int64}}); @ Base ./reduce.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:4433,Energy Efficiency,reduce,reduce,4433,"e.jl:44; [23] mapfoldl(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:4477,Energy Efficiency,reduce,reduce,4477,"tion, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:4516,Energy Efficiency,reduce,reduce,4516,"s.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; init::Base._InitialValue); @ Base ./reduce.jl:160; [24] mapfoldl; @ ./reduce.jl:160 [inlined]; [25] mapreduce(f::Function, op::Function, itr::Base.Generator{Base.Iterators.Filter{Oceananigans.Advection.var""#19#23""{Int64}, UnitRange{Int64}}, Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Nothing, Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64}}; kw::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Base ./reduce.jl:287; [26] mapreduce; @ ./reduce.jl:287 [inlined]; [27] #sum#221; @ ./reduce.jl:501 [inlined]; [28] sum; @ ./reduce.jl:501 [inlined]; [29] #sum#222; @ ./reduce.jl:528 [inlined]; [30] sum; @ ./reduce.jl:528 [inlined]; [31] #stencil_coefficients#17; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:61 [inlined]; [32] create_reconstruction_coefficients(FT::Type, r::Int64, cpu_coord::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:371,Performance,Load,LoadError,371,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2717:406,Security,access,access,406,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717
https://github.com/CliMA/Oceananigans.jl/issues/2719:1478,Energy Efficiency,schedul,schedules,1478,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719
https://github.com/CliMA/Oceananigans.jl/issues/2719:782,Modifiability,sandbox,sandbox,782,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719
https://github.com/CliMA/Oceananigans.jl/issues/2719:1052,Modifiability,sandbox,sandbox,1052,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719
https://github.com/CliMA/Oceananigans.jl/issues/2719:1266,Modifiability,sandbox,sandbox,1266,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719
https://github.com/CliMA/Oceananigans.jl/issues/2719:782,Testability,sandbox,sandbox,782,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719
https://github.com/CliMA/Oceananigans.jl/issues/2719:1052,Testability,sandbox,sandbox,1052,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719
https://github.com/CliMA/Oceananigans.jl/issues/2719:1266,Testability,sandbox,sandbox,1266,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719
https://github.com/CliMA/Oceananigans.jl/pull/2723:869,Availability,down,down,869,"There is a test for immersed boundary inside `test_implicit_free_surface.jl` but it seems to be *trivially passing* (see, e.g., the [log](https://buildkite.com/clima/oceananigans/builds/8449#0182eb0d-74d3-440e-92a7-eb0ffecfb042/25-734) from tests run on `main`). One problem was that `set_simple_divergent_velocity!` function defined at; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/test/test_implicit_free_surface_solver.jl#L17-L35; was setting a non-zero `u` velocity in the center of the domain at `k = 1`, but that was inside the immersed boundary. I changed the [`set_simple_divergent_velocity!`](https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/test/test_implicit_free_surface_solver.jl#L17-L46) function to address that. However, still there is an issue... I managed to pinpoint it down to the step:. https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:1937,Energy Efficiency,reduce,reduced,1937,"ans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: 128×1×1 Field{Center, Face, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU. julia> ∫ᶻQ.u .= 0; ∫ᶻQ.v .= 0;; ```. I call. ```Julia; julia> sum!(∫ᶻQ.u, Ax * model.velocities.u);; ```. Now, when I print out `∫ᶻQ.u` I see that all its elements are supposedly 0:. ```; julia> ∫ᶻQ.u; 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 135×7×1 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, 1:1) with eltype Float64 with indices -2:132×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But this returns the right answer; ```; julia> maximum(∫ᶻQ.u.data); 8.0; ```. The velocity set by `set_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:2038,Energy Efficiency,reduce,reduced,2038,"ans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: 128×1×1 Field{Center, Face, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU. julia> ∫ᶻQ.u .= 0; ∫ᶻQ.v .= 0;; ```. I call. ```Julia; julia> sum!(∫ᶻQ.u, Ax * model.velocities.u);; ```. Now, when I print out `∫ᶻQ.u` I see that all its elements are supposedly 0:. ```; julia> ∫ᶻQ.u; 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 135×7×1 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, 1:1) with eltype Float64 with indices -2:132×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But this returns the right answer; ```; julia> maximum(∫ᶻQ.u.data); 8.0; ```. The velocity set by `set_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:2334,Energy Efficiency,reduce,reduced,2334," 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: 128×1×1 Field{Center, Face, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU. julia> ∫ᶻQ.u .= 0; ∫ᶻQ.v .= 0;; ```. I call. ```Julia; julia> sum!(∫ᶻQ.u, Ax * model.velocities.u);; ```. Now, when I print out `∫ᶻQ.u` I see that all its elements are supposedly 0:. ```; julia> ∫ᶻQ.u; 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 135×7×1 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, 1:1) with eltype Float64 with indices -2:132×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0; ```. But this returns the right answer; ```; julia> maximum(∫ᶻQ.u.data); 8.0; ```. The velocity set by `set_simple_divergent_velocity!` is 0.1 and `Δz = 80` so that's correct!. Hm.... Here's a MWE now to demonstrate that somewhere something is not passed on. ```Julia; using Oceananigans. using Statistics; using Oceananigans.Units; using Oceananigans.Architectures: device_event; using Oceananigans.TimeSteppers: update_state!; using LinearAlgebra: norm. using Oceananigans.Models.HydrostaticFreeSurfaceModels:; ImplicitFreeSurface,; FreeSurface,; PCGImplicitFreeSurfaceSolver,; implicit_free_surface_step!. function set_simple_divergent_velocity!(model); # Create a divergent velocity; grid = model.grid. u, v, w = model.veloci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:11,Testability,test,test,11,"There is a test for immersed boundary inside `test_implicit_free_surface.jl` but it seems to be *trivially passing* (see, e.g., the [log](https://buildkite.com/clima/oceananigans/builds/8449#0182eb0d-74d3-440e-92a7-eb0ffecfb042/25-734) from tests run on `main`). One problem was that `set_simple_divergent_velocity!` function defined at; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/test/test_implicit_free_surface_solver.jl#L17-L35; was setting a non-zero `u` velocity in the center of the domain at `k = 1`, but that was inside the immersed boundary. I changed the [`set_simple_divergent_velocity!`](https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/test/test_implicit_free_surface_solver.jl#L17-L46) function to address that. However, still there is an issue... I managed to pinpoint it down to the step:. https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:133,Testability,log,log,133,"There is a test for immersed boundary inside `test_implicit_free_surface.jl` but it seems to be *trivially passing* (see, e.g., the [log](https://buildkite.com/clima/oceananigans/builds/8449#0182eb0d-74d3-440e-92a7-eb0ffecfb042/25-734) from tests run on `main`). One problem was that `set_simple_divergent_velocity!` function defined at; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/test/test_implicit_free_surface_solver.jl#L17-L35; was setting a non-zero `u` velocity in the center of the domain at `k = 1`, but that was inside the immersed boundary. I changed the [`set_simple_divergent_velocity!`](https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/test/test_implicit_free_surface_solver.jl#L17-L46) function to address that. However, still there is an issue... I managed to pinpoint it down to the step:. https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:241,Testability,test,tests,241,"There is a test for immersed boundary inside `test_implicit_free_surface.jl` but it seems to be *trivially passing* (see, e.g., the [log](https://buildkite.com/clima/oceananigans/builds/8449#0182eb0d-74d3-440e-92a7-eb0ffecfb042/25-734) from tests run on `main`). One problem was that `set_simple_divergent_velocity!` function defined at; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/test/test_implicit_free_surface_solver.jl#L17-L35; was setting a non-zero `u` velocity in the center of the domain at `k = 1`, but that was inside the immersed boundary. I changed the [`set_simple_divergent_velocity!`](https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/test/test_implicit_free_surface_solver.jl#L17-L46) function to address that. However, still there is an issue... I managed to pinpoint it down to the step:. https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:425,Testability,test,test,425,"There is a test for immersed boundary inside `test_implicit_free_surface.jl` but it seems to be *trivially passing* (see, e.g., the [log](https://buildkite.com/clima/oceananigans/builds/8449#0182eb0d-74d3-440e-92a7-eb0ffecfb042/25-734) from tests run on `main`). One problem was that `set_simple_divergent_velocity!` function defined at; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/test/test_implicit_free_surface_solver.jl#L17-L35; was setting a non-zero `u` velocity in the center of the domain at `k = 1`, but that was inside the immersed boundary. I changed the [`set_simple_divergent_velocity!`](https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/test/test_implicit_free_surface_solver.jl#L17-L46) function to address that. However, still there is an issue... I managed to pinpoint it down to the step:. https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:731,Testability,test,test,731,"There is a test for immersed boundary inside `test_implicit_free_surface.jl` but it seems to be *trivially passing* (see, e.g., the [log](https://buildkite.com/clima/oceananigans/builds/8449#0182eb0d-74d3-440e-92a7-eb0ffecfb042/25-734) from tests run on `main`). One problem was that `set_simple_divergent_velocity!` function defined at; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/test/test_implicit_free_surface_solver.jl#L17-L35; was setting a non-zero `u` velocity in the center of the domain at `k = 1`, but that was inside the immersed boundary. I changed the [`set_simple_divergent_velocity!`](https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/test/test_implicit_free_surface_solver.jl#L17-L46) function to address that. However, still there is an issue... I managed to pinpoint it down to the step:. https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:4840,Testability,test,test,4840,"dBoundaryGrid && begin; while grid.immersed_boundary.bottom_height[imid, jmid] > grid.underlying_grid.zᵃᵃᶜ[k_index]; k_index += 1; end; end. k_index = k_index + 1 ≤ grid.Nz ? k_index + 1 : k_index; ; u[imid, jmid, k_index] = 0.1. update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-500kilometers, 500kilometers),; y = (0, 1),; z = (-400, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = 50kilometers; bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface). set_simple_divergent_velocity!(model). @show model.velocities.u. events = ((device_event(arch), device_event(arch)), (device_event(arch), device_event(arch))). Δt = 900.0; implicit_free_surface_step!(model.free_surface, model, Δt, 1.5, events). η = model.free_surface.η; @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; ```. gives. ```Julia; julia> @show model.velocities.u; model.velocities.u = 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; [ Info: implicit free surface solver test, norm(η): 0.0, maximum(abs, η): 0.0; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:5522,Testability,test,test,5522,"dBoundaryGrid && begin; while grid.immersed_boundary.bottom_height[imid, jmid] > grid.underlying_grid.zᵃᵃᶜ[k_index]; k_index += 1; end; end. k_index = k_index + 1 ≤ grid.Nz ? k_index + 1 : k_index; ; u[imid, jmid, k_index] = 0.1. update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-500kilometers, 500kilometers),; y = (0, 1),; z = (-400, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = 50kilometers; bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface). set_simple_divergent_velocity!(model). @show model.velocities.u. events = ((device_event(arch), device_event(arch)), (device_event(arch), device_event(arch))). Δt = 900.0; implicit_free_surface_step!(model.free_surface, model, Δt, 1.5, events). η = model.free_surface.η; @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; ```. gives. ```Julia; julia> @show model.velocities.u; model.velocities.u = 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; [ Info: implicit free surface solver test, norm(η): 0.0, maximum(abs, η): 0.0; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2723:5624,Testability,test,test,5624,"dBoundaryGrid && begin; while grid.immersed_boundary.bottom_height[imid, jmid] > grid.underlying_grid.zᵃᵃᶜ[k_index]; k_index += 1; end; end. k_index = k_index + 1 ≤ grid.Nz ? k_index + 1 : k_index; ; u[imid, jmid, k_index] = 0.1. update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-500kilometers, 500kilometers),; y = (0, 1),; z = (-400, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = 50kilometers; bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface). set_simple_divergent_velocity!(model). @show model.velocities.u. events = ((device_event(arch), device_event(arch)), (device_event(arch), device_event(arch))). Δt = 900.0; implicit_free_surface_step!(model.free_surface, model, Δt, 1.5, events). η = model.free_surface.η; @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; ```. gives. ```Julia; julia> @show model.velocities.u; model.velocities.u = 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; [ Info: implicit free surface solver test, norm(η): 0.0, maximum(abs, η): 0.0; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723
https://github.com/CliMA/Oceananigans.jl/pull/2724:425,Deployability,integrat,integration,425,"Hi all, . I am currently working on a biogeochemistry modelling environment with @johnryantaylor using Oceananigans, and as part of this have have up with a scheme to have ""active"" particles that interact with tracers. How I currently have this set up: when the particle dynamics are run, the particles can increase/decrease the concentration of tracers in the cells surrounding them, but this only allows for explicit Euler integration. A better way todo this seems to be to have the particles uptake/exudation of tracers contribute to their tendencies during the time stepping as I have implemented here. I'm unsure if this is implemented in the best way throughout but I'm fairly satisfied that I have it working as desired. . Hope everyone is happy with this?. --------. To summaries what I have changed:. - Particle setup: particles can get a parameter called `active_properties` which is a tuple of named tuples of particle properties and tracers (e.g. `((property=:t, tracer=:x),).`) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. - `calculate_particle_tendency_contributions!` added after each `calculate_tendencies!` call: function goes through each particle, finds its 8 nearest cells, and adds the relevant fraction of each particle property (divided by the cell volume) to the tracer tendencies so it can be integrated by the time stepper (like tracer forcing)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724
https://github.com/CliMA/Oceananigans.jl/pull/2724:1173,Deployability,integrat,integrate,1173,"Hi all, . I am currently working on a biogeochemistry modelling environment with @johnryantaylor using Oceananigans, and as part of this have have up with a scheme to have ""active"" particles that interact with tracers. How I currently have this set up: when the particle dynamics are run, the particles can increase/decrease the concentration of tracers in the cells surrounding them, but this only allows for explicit Euler integration. A better way todo this seems to be to have the particles uptake/exudation of tracers contribute to their tendencies during the time stepping as I have implemented here. I'm unsure if this is implemented in the best way throughout but I'm fairly satisfied that I have it working as desired. . Hope everyone is happy with this?. --------. To summaries what I have changed:. - Particle setup: particles can get a parameter called `active_properties` which is a tuple of named tuples of particle properties and tracers (e.g. `((property=:t, tracer=:x),).`) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. - `calculate_particle_tendency_contributions!` added after each `calculate_tendencies!` call: function goes through each particle, finds its 8 nearest cells, and adds the relevant fraction of each particle property (divided by the cell volume) to the tracer tendencies so it can be integrated by the time stepper (like tracer forcing)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724
https://github.com/CliMA/Oceananigans.jl/pull/2724:1502,Deployability,integrat,integrated,1502,"Hi all, . I am currently working on a biogeochemistry modelling environment with @johnryantaylor using Oceananigans, and as part of this have have up with a scheme to have ""active"" particles that interact with tracers. How I currently have this set up: when the particle dynamics are run, the particles can increase/decrease the concentration of tracers in the cells surrounding them, but this only allows for explicit Euler integration. A better way todo this seems to be to have the particles uptake/exudation of tracers contribute to their tendencies during the time stepping as I have implemented here. I'm unsure if this is implemented in the best way throughout but I'm fairly satisfied that I have it working as desired. . Hope everyone is happy with this?. --------. To summaries what I have changed:. - Particle setup: particles can get a parameter called `active_properties` which is a tuple of named tuples of particle properties and tracers (e.g. `((property=:t, tracer=:x),).`) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. - `calculate_particle_tendency_contributions!` added after each `calculate_tendencies!` call: function goes through each particle, finds its 8 nearest cells, and adds the relevant fraction of each particle property (divided by the cell volume) to the tracer tendencies so it can be integrated by the time stepper (like tracer forcing)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724
https://github.com/CliMA/Oceananigans.jl/pull/2724:425,Integrability,integrat,integration,425,"Hi all, . I am currently working on a biogeochemistry modelling environment with @johnryantaylor using Oceananigans, and as part of this have have up with a scheme to have ""active"" particles that interact with tracers. How I currently have this set up: when the particle dynamics are run, the particles can increase/decrease the concentration of tracers in the cells surrounding them, but this only allows for explicit Euler integration. A better way todo this seems to be to have the particles uptake/exudation of tracers contribute to their tendencies during the time stepping as I have implemented here. I'm unsure if this is implemented in the best way throughout but I'm fairly satisfied that I have it working as desired. . Hope everyone is happy with this?. --------. To summaries what I have changed:. - Particle setup: particles can get a parameter called `active_properties` which is a tuple of named tuples of particle properties and tracers (e.g. `((property=:t, tracer=:x),).`) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. - `calculate_particle_tendency_contributions!` added after each `calculate_tendencies!` call: function goes through each particle, finds its 8 nearest cells, and adds the relevant fraction of each particle property (divided by the cell volume) to the tracer tendencies so it can be integrated by the time stepper (like tracer forcing)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724
https://github.com/CliMA/Oceananigans.jl/pull/2724:1173,Integrability,integrat,integrate,1173,"Hi all, . I am currently working on a biogeochemistry modelling environment with @johnryantaylor using Oceananigans, and as part of this have have up with a scheme to have ""active"" particles that interact with tracers. How I currently have this set up: when the particle dynamics are run, the particles can increase/decrease the concentration of tracers in the cells surrounding them, but this only allows for explicit Euler integration. A better way todo this seems to be to have the particles uptake/exudation of tracers contribute to their tendencies during the time stepping as I have implemented here. I'm unsure if this is implemented in the best way throughout but I'm fairly satisfied that I have it working as desired. . Hope everyone is happy with this?. --------. To summaries what I have changed:. - Particle setup: particles can get a parameter called `active_properties` which is a tuple of named tuples of particle properties and tracers (e.g. `((property=:t, tracer=:x),).`) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. - `calculate_particle_tendency_contributions!` added after each `calculate_tendencies!` call: function goes through each particle, finds its 8 nearest cells, and adds the relevant fraction of each particle property (divided by the cell volume) to the tracer tendencies so it can be integrated by the time stepper (like tracer forcing)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724
https://github.com/CliMA/Oceananigans.jl/pull/2724:1502,Integrability,integrat,integrated,1502,"Hi all, . I am currently working on a biogeochemistry modelling environment with @johnryantaylor using Oceananigans, and as part of this have have up with a scheme to have ""active"" particles that interact with tracers. How I currently have this set up: when the particle dynamics are run, the particles can increase/decrease the concentration of tracers in the cells surrounding them, but this only allows for explicit Euler integration. A better way todo this seems to be to have the particles uptake/exudation of tracers contribute to their tendencies during the time stepping as I have implemented here. I'm unsure if this is implemented in the best way throughout but I'm fairly satisfied that I have it working as desired. . Hope everyone is happy with this?. --------. To summaries what I have changed:. - Particle setup: particles can get a parameter called `active_properties` which is a tuple of named tuples of particle properties and tracers (e.g. `((property=:t, tracer=:x),).`) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. - `calculate_particle_tendency_contributions!` added after each `calculate_tendencies!` call: function goes through each particle, finds its 8 nearest cells, and adds the relevant fraction of each particle property (divided by the cell volume) to the tracer tendencies so it can be integrated by the time stepper (like tracer forcing)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724
https://github.com/CliMA/Oceananigans.jl/issues/2725:152,Testability,test,test,152,"Here's what we currently do:; https://github.com/CliMA/Oceananigans.jl/blob/b6dd1fa9b1d740f7d8cb4be116a24cbba0042f86/src/Fields/field.jl#L500. Here's a test script:. ```Julia; using Oceananigans; using BenchmarkTools; using LinearAlgebra. Nx, Ny, Nz = 128, 128, 16. grid = RectilinearGrid(size=(Nx, Ny, Nz), x=(-4, 4), y=(-4, 4), z=(-4, 0), topology=(Bounded, Bounded, Bounded)). a = CenterField(grid); b = CenterField(grid). ε(x, y, z) = randn(). set!(a, ε); set!(b, ε). true_dot(a, b) = sum(interior(a) .* interior(b)). dot_current(a::Field, b::Field) = mapreduce((x, y) -> x * y, +, interior(a), interior(b)). function dot_faster(a, b); s = zero(eltype(a.grid)). @inbounds @simd for I ∈ CartesianIndices(a); s += a[I] * b[I]; end. return s; end; ```. I get. ```julia. julia> isapprox(dot_current(a, b), true_dot(a, b)); true. julia> isapprox(dot_faster(a, b), true_dot(a, b)); true. julia> @btime true_dot($a, $b);; 149.667 μs (29 allocations: 2.00 MiB). julia> @btime dot_current($a, $b);; 1.289 ms (34 allocations: 2.00 MiB). julia> @btime dot_faster($a, $b);; 74.041 μs (0 allocations: 0 bytes); ```. So we can get a ~15x speedup with zero allocations. With only this change, running a `HydrostaticFreeSurfaceModel` simulation with a PGC free surface solver gave a ~20% speedup on the CPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725
https://github.com/CliMA/Oceananigans.jl/issues/2725:202,Testability,Benchmark,BenchmarkTools,202,"Here's what we currently do:; https://github.com/CliMA/Oceananigans.jl/blob/b6dd1fa9b1d740f7d8cb4be116a24cbba0042f86/src/Fields/field.jl#L500. Here's a test script:. ```Julia; using Oceananigans; using BenchmarkTools; using LinearAlgebra. Nx, Ny, Nz = 128, 128, 16. grid = RectilinearGrid(size=(Nx, Ny, Nz), x=(-4, 4), y=(-4, 4), z=(-4, 0), topology=(Bounded, Bounded, Bounded)). a = CenterField(grid); b = CenterField(grid). ε(x, y, z) = randn(). set!(a, ε); set!(b, ε). true_dot(a, b) = sum(interior(a) .* interior(b)). dot_current(a::Field, b::Field) = mapreduce((x, y) -> x * y, +, interior(a), interior(b)). function dot_faster(a, b); s = zero(eltype(a.grid)). @inbounds @simd for I ∈ CartesianIndices(a); s += a[I] * b[I]; end. return s; end; ```. I get. ```julia. julia> isapprox(dot_current(a, b), true_dot(a, b)); true. julia> isapprox(dot_faster(a, b), true_dot(a, b)); true. julia> @btime true_dot($a, $b);; 149.667 μs (29 allocations: 2.00 MiB). julia> @btime dot_current($a, $b);; 1.289 ms (34 allocations: 2.00 MiB). julia> @btime dot_faster($a, $b);; 74.041 μs (0 allocations: 0 bytes); ```. So we can get a ~15x speedup with zero allocations. With only this change, running a `HydrostaticFreeSurfaceModel` simulation with a PGC free surface solver gave a ~20% speedup on the CPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725
https://github.com/CliMA/Oceananigans.jl/issues/2727:221,Availability,error,errors,221,Seems like when we call. ```Julia; julia> maximum(f); ```; where `f::Field` then this is called:; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Fields/field.jl#L600-L618. This errors on the GPU. Why not simply:. ```julia; import Base: maximum. maximum(f::Field) = maximum(parent(f.data)); ```; ?. cc @taimoorsohail,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727
https://github.com/CliMA/Oceananigans.jl/issues/2727:248,Usability,simpl,simply,248,Seems like when we call. ```Julia; julia> maximum(f); ```; where `f::Field` then this is called:; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Fields/field.jl#L600-L618. This errors on the GPU. Why not simply:. ```julia; import Base: maximum. maximum(f::Field) = maximum(parent(f.data)); ```; ?. cc @taimoorsohail,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727
https://github.com/CliMA/Oceananigans.jl/issues/2728:998,Performance,perform,perform,998,"Working with @elise-palethorpe we see that the preconditioned conjugate gradient solver is much slower than expected. See #2654. In particular, benchmarks on solving the Poisson equation on a doubly bounded domain on the [ep/pcg-with-multigrid](https://github.com/CliMA/Oceananigans.jl/tree/ep/pcg-with-multigrid) branch give:. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. We'd expect the PCG to perform similarly to MG and MG-preconditioned PGC to perform better. There is definitely some issue with memory allocations but, possibly, something else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728
https://github.com/CliMA/Oceananigans.jl/issues/2728:1051,Performance,perform,perform,1051,"Working with @elise-palethorpe we see that the preconditioned conjugate gradient solver is much slower than expected. See #2654. In particular, benchmarks on solving the Poisson equation on a doubly bounded domain on the [ep/pcg-with-multigrid](https://github.com/CliMA/Oceananigans.jl/tree/ep/pcg-with-multigrid) branch give:. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. We'd expect the PCG to perform similarly to MG and MG-preconditioned PGC to perform better. There is definitely some issue with memory allocations but, possibly, something else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728
https://github.com/CliMA/Oceananigans.jl/issues/2728:354,Security,validat,validation,354,"Working with @elise-palethorpe we see that the preconditioned conjugate gradient solver is much slower than expected. See #2654. In particular, benchmarks on solving the Poisson equation on a doubly bounded domain on the [ep/pcg-with-multigrid](https://github.com/CliMA/Oceananigans.jl/tree/ep/pcg-with-multigrid) branch give:. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. We'd expect the PCG to perform similarly to MG and MG-preconditioned PGC to perform better. There is definitely some issue with memory allocations but, possibly, something else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728
https://github.com/CliMA/Oceananigans.jl/issues/2728:144,Testability,benchmark,benchmarks,144,"Working with @elise-palethorpe we see that the preconditioned conjugate gradient solver is much slower than expected. See #2654. In particular, benchmarks on solving the Poisson equation on a doubly bounded domain on the [ep/pcg-with-multigrid](https://github.com/CliMA/Oceananigans.jl/tree/ep/pcg-with-multigrid) branch give:. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. We'd expect the PCG to perform similarly to MG and MG-preconditioned PGC to perform better. There is definitely some issue with memory allocations but, possibly, something else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728
https://github.com/CliMA/Oceananigans.jl/pull/2729:231,Testability,test,test,231,"A Simple preliminary way to use our advection reconstruction stencils to do high-order Coriolis reconstruction. ```; advection = WENO(grid); coriolis = HydrostaticSphericalCoriolis(scheme = advection); ```. this PR is here just to test the idea, but the design will probably change",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729
https://github.com/CliMA/Oceananigans.jl/pull/2729:2,Usability,Simpl,Simple,2,"A Simple preliminary way to use our advection reconstruction stencils to do high-order Coriolis reconstruction. ```; advection = WENO(grid); coriolis = HydrostaticSphericalCoriolis(scheme = advection); ```. this PR is here just to test the idea, but the design will probably change",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729
https://github.com/CliMA/Oceananigans.jl/issues/2730:63,Availability,avail,available,63,"Hi all,. I think it would be useful for auxiliary fields to be available to tracer forcing functions in the same way that other tracers and the velocity fields are. I'm currently working round this by putting auxiliary fields in the parameters but this is quite cumbersome. It would be straightforward to implement by changing the `fields` functions e.g.:. `fields(model::NonhydrostaticModel) = merge(model.velocities, model.tracers, model.auxiliary_fields)`. I'm happy to try and do this later if there's no reason not to?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2730
https://github.com/CliMA/Oceananigans.jl/issues/2735:260,Performance,Load,Load-saved-output,260,"I just noticed that the Nusselt number calculation result in the horizontal convection example changed between v0.71.6 and v0.72.4. It almost doubled from around 10 at. https://clima.github.io/OceananigansDocumentation/v0.71.6/generated/horizontal_convection/#Load-saved-output,-process,-visualize. to around 20 in . https://clima.github.io/OceananigansDocumentation/v0.72.4/generated/horizontal_convection/#Load-saved-output,-process,-visualize. The calculation is done via. ```Julia; χ_diff = κ * b★^2 * π * tanh(2π * H / Lx). for i = 1:length(t); b = b_timeseries[i]; sum!(∫ⱽ_mod²_∇b, (∂x(b)^2 + ∂z(b)^2) * volume); Nu[i] = (κ * ∫ⱽ_mod²_∇b[1, 1, 1]) / χ_diff; end; ```. Did anything changed between these two version in the way `sum!` or `volume` works?. Here's the diff between v0.71.6 and v0.72.4: https://github.com/CliMA/Oceananigans.jl/compare/v0.71.6...v0.72.4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735
https://github.com/CliMA/Oceananigans.jl/issues/2735:408,Performance,Load,Load-saved-output,408,"I just noticed that the Nusselt number calculation result in the horizontal convection example changed between v0.71.6 and v0.72.4. It almost doubled from around 10 at. https://clima.github.io/OceananigansDocumentation/v0.71.6/generated/horizontal_convection/#Load-saved-output,-process,-visualize. to around 20 in . https://clima.github.io/OceananigansDocumentation/v0.72.4/generated/horizontal_convection/#Load-saved-output,-process,-visualize. The calculation is done via. ```Julia; χ_diff = κ * b★^2 * π * tanh(2π * H / Lx). for i = 1:length(t); b = b_timeseries[i]; sum!(∫ⱽ_mod²_∇b, (∂x(b)^2 + ∂z(b)^2) * volume); Nu[i] = (κ * ∫ⱽ_mod²_∇b[1, 1, 1]) / χ_diff; end; ```. Did anything changed between these two version in the way `sum!` or `volume` works?. Here's the diff between v0.71.6 and v0.72.4: https://github.com/CliMA/Oceananigans.jl/compare/v0.71.6...v0.72.4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735
https://github.com/CliMA/Oceananigans.jl/issues/2737:819,Safety,avoid,avoid,819,"At the moment, the construction of a matrix from a linear operation for the multigrid solver on the GPU involves scalar operations:. https://github.com/CliMA/Oceananigans.jl/blob/60470f4d716026f161dfd303a30d9d14fbfb97a1/src/Solvers/multigrid_solver.jl#L246-L279. This matrix construction is **only** called once upon initialization of the solver. Furthermore, this particular method that uses scalar operations is **not** used by the implicit free-surface solvers since in that case we provide the `MultigridSolver` constructor with the matrix itself, see:. https://github.com/CliMA/Oceananigans.jl/blob/60470f4d716026f161dfd303a30d9d14fbfb97a1/src/Models/HydrostaticFreeSurfaceModels/mg_implicit_free_surface_solver.jl#L77-L104. For general matrix construction that works for any linear operation, it would be nice to avoid using scalar operations on the GPU _or_ construct the matrix on the CPU and convert it to the GPU afterwards. cc @elise-palethorpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737
https://github.com/CliMA/Oceananigans.jl/pull/2738:392,Availability,down,downstream,392,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738
https://github.com/CliMA/Oceananigans.jl/pull/2738:330,Deployability,release,release,330,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738
https://github.com/CliMA/Oceananigans.jl/pull/2738:416,Integrability,depend,depend,416,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738
https://github.com/CliMA/Oceananigans.jl/pull/2738:143,Testability,test,tested,143,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738
https://github.com/CliMA/Oceananigans.jl/pull/2738:249,Testability,test,tests,249,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738
https://github.com/CliMA/Oceananigans.jl/pull/2738:435,Testability,test,tests,435,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738
https://github.com/CliMA/Oceananigans.jl/issues/2742:126,Deployability,upgrade,upgrade,126,"Hi all,. I run a 2D grid setup (y-z) for a while and I get advection terms through a kernel function below. ; With the recent upgrade, I switched the advection scheme from WENO5() to WENO(). ; However, the output of the u advection (fluctuation and background) becomes zero. And x-momentum is perfectly balanced between Coriolis force and viscosity.; The problem only happens in the flat direction and it remains with 5th order upwind too. I wonder if I write the function wrong, or the model really does not calculate the advection for the velocity in the flat direction. ```; @inline function _Duu_div(i,j,k,grid,dep,params); return div_𝐯u(i, j, k, grid,params.adv,params.vel,params.tracer);; end; Duu_div = Field(KernelFunctionOperation{Face, Center, Center}(_Duu_div,model.grid;parameters=(; adv = model.advection, vel = model.velocities, tracer = model.velocities.u),computed_dependencies = (1)));; ```. _My model Setup:_. ```; ## Grid ; L = 1e3;; H = 100;. Ny = 1024;; Nz = 128;. ## Streched Grid; hc = 1.37;; theta_s = 3.53;. @inline Space_z(k) = (hc*(k-Nz-1)/Nz + (H-hc)*sinh(theta_s*(k-Nz-1)/Nz)/sinh(theta_s));. grid = RectilinearGrid(GPU(); topology = (Flat, Periodic, Bounded),; size = (Ny, Nz),; y = (0, L),; z = Space_z,; );; ```. ```; model = NonhydrostaticModel(; grid, buoyancy = BuoyancyTracer(),; advection = WENO(; grid = grid),; timestepper = :RungeKutta3,; tracers = (:b), ; coriolis = FPlane(f=f),`; forcing = (b=b_force, u=u_force, v=v_force, w=w_force),; closure = (vertical_diffusive_closure, horizontal_diffusive_closure),; boundary_conditions = (u = u_bcs,),; background_fields = (u = U_bfield, b = B_bfield)); ```; Let me know if more information is needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2742
https://github.com/CliMA/Oceananigans.jl/issues/2744:20,Availability,error,error,20,"I get the following error when I call `maximum` on a field with location `Face, Center, Center` on an immersed boundary grid with a vertically stretched underlying grid on the GPU. For example:. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lx, Ly, Lz = 500, 600, 3. Nx, Ny, Nz = 128, 128, 64. σ = 1.04 # linear stretching factor; linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz). underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)). const H_deep = H = underlying_grid.Lz; const H_shelf = h = 0.5; const width_shelf = 100. shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); bathymetry(x, y) = shelf(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```. then just creating a `u` field gives:. ```julia; julia> u = Field((Face, Center, Center), grid); Error showing value of type Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:1018,Availability,Error,Error,1018,"er` on an immersed boundary grid with a vertically stretched underlying grid on the GPU. For example:. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lx, Ly, Lz = 500, 600, 3. Nx, Ny, Nz = 128, 128, 64. σ = 1.04 # linear stretching factor; linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz). underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)). const H_deep = H = underlying_grid.Lz; const H_shelf = h = 0.5; const width_shelf = 100. shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); bathymetry(x, y) = shelf(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```. then just creating a `u` field gives:. ```julia; julia> u = Field((Face, Center, Center), grid); Error showing value of type Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCond",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:2500,Availability,ERROR,ERROR,2500,"rrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.Kerne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:2512,Availability,error,error,2512,"rrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.Kerne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:2727,Availability,error,error,2727,".DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.On",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:2821,Availability,error,error,2821,"Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CUDA.CuDeviceArray{Float64, 4, 1}, ::Oceananigans.AbstractOperations.Condition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:17184,Availability,mask,mask,17184,"daryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}; condition::Nothing, mask::Float64, kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:init,), Tuple{Bool}}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:581; [24] maximum(f::Function, c::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:18878,Availability,mask,mask,18878,"Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:611; [25] maximum; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:606 [inlined]; [26] #maximum#36; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:620 [inlined]; [27] maximum; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:620 [inlined]; [28] data_summary(field::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:26365,Availability,error,error,26365,"_color::Bool); @ REPL /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:229; [42] (::REPL.var""#do_respond#61""{Bool, Bool, REPL.var""#72#82""{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:798; [43] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [44] invokelatest; @ ./essentials.jl:706 [inlined]; [45] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [46] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [47] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:417; ```. The error comes from `show()` and in particular from `maximum` that's being called in `data_summary`. Similarly for a field on `(Center, Face, Center)`! However, not on a ``(Center, Center, Face)`:. ```julia; julia> w = Field((Center, Center, Face), grid); 128×128×65 Field{Center, Center, Face} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 136×136×73 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:69) with eltype Float64 with indices -3:132×-3:132×-3:69; └── max=0.0, min=0.0, mean=0.0. julia> maximum(abs, w); 0.0; ```. Also, no problems when using a regularly spaced grid --- things look OK then!. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lx, Ly, Lz = 500, 600, 3. Nx, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/issues/2744:13626,Energy Efficiency,reduce,reducedim,13626,"rs{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; [22] #maximum!#713; @ ./reducedim.jl:895 [inlined]; [23] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744
https://github.com/CliMA/Oceananigans.jl/pull/2750:44,Availability,error,error,44,Summary of Callback with parameters gave an error before,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2750
https://github.com/CliMA/Oceananigans.jl/issues/2751:868,Availability,fault,fault,868,"Sorry in advance if I'm packing too much stuff into one issue. Let me know if that's the case and I can separate this into other issues. The function `calc_κᶜᶜᶜ()` is only defined for the AMD closure, so for every other closure it silently defaults to https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_utils.jl#L33. So one obvious thing is that we definitely should define `calc_κᶜᶜᶜ()` for other closures. A bigger question regards the use of multiple dispatch to create this ""default"" behavior for when the desired behavior isn't implemented yet. In this case, silently defaulting to `zero()` made be lose some hours of work because I thought there was something wrong with my script, when in reality `calc_κᶜᶜᶜ()` just wasn't defined for the closure I was using. Sure, this is a bit my fault for not checking the code thoroughly, but from a user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c7",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751
https://github.com/CliMA/Oceananigans.jl/issues/2751:1015,Availability,error,error,1015,"Sorry in advance if I'm packing too much stuff into one issue. Let me know if that's the case and I can separate this into other issues. The function `calc_κᶜᶜᶜ()` is only defined for the AMD closure, so for every other closure it silently defaults to https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_utils.jl#L33. So one obvious thing is that we definitely should define `calc_κᶜᶜᶜ()` for other closures. A bigger question regards the use of multiple dispatch to create this ""default"" behavior for when the desired behavior isn't implemented yet. In this case, silently defaulting to `zero()` made be lose some hours of work because I thought there was something wrong with my script, when in reality `calc_κᶜᶜᶜ()` just wasn't defined for the closure I was using. Sure, this is a bit my fault for not checking the code thoroughly, but from a user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c7",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751
https://github.com/CliMA/Oceananigans.jl/issues/2751:1167,Availability,error,error,1167,"ᶜᶜᶜ()` is only defined for the AMD closure, so for every other closure it silently defaults to https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_utils.jl#L33. So one obvious thing is that we definitely should define `calc_κᶜᶜᶜ()` for other closures. A bigger question regards the use of multiple dispatch to create this ""default"" behavior for when the desired behavior isn't implemented yet. In this case, silently defaulting to `zero()` made be lose some hours of work because I thought there was something wrong with my script, when in reality `calc_κᶜᶜᶜ()` just wasn't defined for the closure I was using. Sure, this is a bit my fault for not checking the code thoroughly, but from a user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751
https://github.com/CliMA/Oceananigans.jl/issues/2751:1702,Modifiability,variab,variables,1702,"plemented yet. In this case, silently defaulting to `zero()` made be lose some hours of work because I thought there was something wrong with my script, when in reality `calc_κᶜᶜᶜ()` just wasn't defined for the closure I was using. Sure, this is a bit my fault for not checking the code thoroughly, but from a user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751
https://github.com/CliMA/Oceananigans.jl/issues/2751:2866,Modifiability,variab,variable,2866,"user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for people like me, who aren't experts in the code. . I also understand that that is an incredibly complicated module, with no obvious way to organize it concisely. But I think using more verbose names would make it a lot more clear. So I propose we make variable and function names more verbose there. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751
https://github.com/CliMA/Oceananigans.jl/issues/2751:2146,Usability,clear,clear,2146,"user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for people like me, who aren't experts in the code. . I also understand that that is an incredibly complicated module, with no obvious way to organize it concisely. But I think using more verbose names would make it a lot more clear. So I propose we make variable and function names more verbose there. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751
https://github.com/CliMA/Oceananigans.jl/issues/2751:2838,Usability,clear,clear,2838,"user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for people like me, who aren't experts in the code. . I also understand that that is an incredibly complicated module, with no obvious way to organize it concisely. But I think using more verbose names would make it a lot more clear. So I propose we make variable and function names more verbose there. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751
https://github.com/CliMA/Oceananigans.jl/pull/2752:25,Modifiability,variab,variables,25,"This PR will rename some variables and funcitons in the `TurbulenceClosures` module to make things more clear. ~It will also remove the fallback dispatch of `calc_ κᶜᶜᶜ()` and define `calc_ κᶜᶜᶜ()` at least for the Smagorisnky-Lilly closure.~. It also changes the behavior of `viscosity()` to return a tuple when given a tuple, instead of `sum`ming all the viscosities in the tuple. This avoids misuse by unattentive users who have a tuple with different-formulation-viscosities (for example horizontal and vertical formulations). ([This comment](https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938) provides an example.). Closes https://github.com/CliMA/Oceananigans.jl/issues/2751. CC @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752
https://github.com/CliMA/Oceananigans.jl/pull/2752:388,Safety,avoid,avoids,388,"This PR will rename some variables and funcitons in the `TurbulenceClosures` module to make things more clear. ~It will also remove the fallback dispatch of `calc_ κᶜᶜᶜ()` and define `calc_ κᶜᶜᶜ()` at least for the Smagorisnky-Lilly closure.~. It also changes the behavior of `viscosity()` to return a tuple when given a tuple, instead of `sum`ming all the viscosities in the tuple. This avoids misuse by unattentive users who have a tuple with different-formulation-viscosities (for example horizontal and vertical formulations). ([This comment](https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938) provides an example.). Closes https://github.com/CliMA/Oceananigans.jl/issues/2751. CC @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752
https://github.com/CliMA/Oceananigans.jl/pull/2752:104,Usability,clear,clear,104,"This PR will rename some variables and funcitons in the `TurbulenceClosures` module to make things more clear. ~It will also remove the fallback dispatch of `calc_ κᶜᶜᶜ()` and define `calc_ κᶜᶜᶜ()` at least for the Smagorisnky-Lilly closure.~. It also changes the behavior of `viscosity()` to return a tuple when given a tuple, instead of `sum`ming all the viscosities in the tuple. This avoids misuse by unattentive users who have a tuple with different-formulation-viscosities (for example horizontal and vertical formulations). ([This comment](https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938) provides an example.). Closes https://github.com/CliMA/Oceananigans.jl/issues/2751. CC @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752
https://github.com/CliMA/Oceananigans.jl/issues/2756:20,Availability,error,error,20,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:194,Availability,error,error,194,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:239,Availability,down,down,239,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:324,Availability,error,error,324,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:380,Availability,error,error,380,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:1135,Availability,error,error,1135,"rking example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:1189,Availability,Error,Error,1189,"down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:1327,Availability,error,error,1327,"rror happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0 [inlined]; │ [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndice",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:1548,Availability,error,error,1548,"x=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0 [inlined]; │ [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:1646,Availability,error,error,1646,"),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0 [inlined]; │ [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CuDeviceArray{Float64, 4, 1}, ::Oceananigans.AbstractOperations.ConditionalOperation{Face,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:15888,Availability,mask,mask,15888,"ux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(abs), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}; condition::Nothing, mask::Float64, kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:init,), Tuple{Bool}}}); │ @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/i1inK/src/Fields/field.jl:581; │ [24] maximum(f::Function, c::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:17595,Availability,mask,mask,17595,"t64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Nothing, mask::Float64, dims::Function); │ @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/i1inK/src/Fields/field.jl:611; │ [25] maximum(f::Function, c::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:19678,Availability,Down,Downgrading,19678,"oat64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); │ @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/i1inK/src/Fields/field.jl:606; │ [26] top-level scope; │ @ logging.jl:340; │ [27] include(mod::Module, _path::String); │ @ Base ./Base.jl:386; │ [28] exec_options(opts::Base.JLOptions); │ @ Base ./client.jl:285; │ [29] _start(); │ @ Base ./client.jl:485; └ @ Main /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; ```. Has someone encountered this behavior before? Is someone able to reproduce it? Downgrading CUDA to 3.9 solves this issue for me, which indicates that this might be a CUDA bug, but I can't reproduce it using only CUDA tools so it's hard for me to open an issue there. @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:12374,Energy Efficiency,reduce,reducedim,12374,"oundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(abs), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); │ @ GPUArrays /glade/work/tomasc/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; │ [22] #maximum!#707; │ @ ./reducedim.jl:895 [inlined]; │ [23] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:1223,Testability,log,log,1223,"down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:19336,Testability,log,logging,19336,"oat64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); │ @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/i1inK/src/Fields/field.jl:606; │ [26] top-level scope; │ @ logging.jl:340; │ [27] include(mod::Module, _path::String); │ @ Base ./Base.jl:386; │ [28] exec_options(opts::Base.JLOptions); │ @ Base ./client.jl:285; │ [29] _start(); │ @ Base ./client.jl:485; └ @ Main /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; ```. Has someone encountered this behavior before? Is someone able to reproduce it? Downgrading CUDA to 3.9 solves this issue for me, which indicates that this might be a CUDA bug, but I can't reproduce it using only CUDA tools so it's hard for me to open an issue there. @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/issues/2756:286,Usability,simpl,simplify,286,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756
https://github.com/CliMA/Oceananigans.jl/pull/2760:140,Performance,optimiz,optimization,140,I am currently running a 0.083-degree global ocean simulation on Tesla V100 GPUs. I am benchmarking a bit to understand where we can target optimization to improve the performance and I thought I would leave the benchmarks here to document them for later use. (we do not have to merge this PR),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2760
https://github.com/CliMA/Oceananigans.jl/pull/2760:168,Performance,perform,performance,168,I am currently running a 0.083-degree global ocean simulation on Tesla V100 GPUs. I am benchmarking a bit to understand where we can target optimization to improve the performance and I thought I would leave the benchmarks here to document them for later use. (we do not have to merge this PR),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2760
https://github.com/CliMA/Oceananigans.jl/pull/2760:87,Testability,benchmark,benchmarking,87,I am currently running a 0.083-degree global ocean simulation on Tesla V100 GPUs. I am benchmarking a bit to understand where we can target optimization to improve the performance and I thought I would leave the benchmarks here to document them for later use. (we do not have to merge this PR),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2760
https://github.com/CliMA/Oceananigans.jl/pull/2760:212,Testability,benchmark,benchmarks,212,I am currently running a 0.083-degree global ocean simulation on Tesla V100 GPUs. I am benchmarking a bit to understand where we can target optimization to improve the performance and I thought I would leave the benchmarks here to document them for later use. (we do not have to merge this PR),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2760
https://github.com/CliMA/Oceananigans.jl/pull/2761:202,Modifiability,variab,variable,202,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:384,Modifiability,variab,variable,384,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:566,Modifiability,variab,variable,566,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:732,Modifiability,variab,variable,732,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:898,Modifiability,variab,variable,898,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:1064,Modifiability,variab,variable,1064,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:1220,Modifiability,variab,variable,1220,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:1375,Modifiability,variab,variable,1375,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:1530,Modifiability,variab,variable,1530,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:1685,Modifiability,variab,variable,1685,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/pull/2761:1840,Modifiability,variab,variable,1840,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761
https://github.com/CliMA/Oceananigans.jl/issues/2766:204,Security,validat,validation,204,"Dear Oceananigans team,. We are trying to use Oceananigans to create reference LES solutions for multiple canonical flows. We use a cubical domain and random perturbations to trigger the flow. During our validation tests, we noticed that we could not reproduce the results, i.e., running the same .jl script (same initial flow conditions) leads to different averaged solutions (see attached picture). We ran more than 16 simulations and never obtained the same solution. We tried to set the seed of the random perturbations constant, but this did not solve the problem. Do you observe this problem, and could you help us run reproducible simulations so other users can obtain the same solutions? We attached the .jl file we are using to define the simulations. Best regards,; Filipe Pereira; Luke van Roekel ; Amrapalli Garanaik; Brodie Pearson . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193599386-11eccb58-2a3f-4a1c-83d6-cde2ea429d00.png). [c16_128_128m(1).jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9698212/c16_128_128m.1.jl.zip)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766
https://github.com/CliMA/Oceananigans.jl/issues/2766:215,Testability,test,tests,215,"Dear Oceananigans team,. We are trying to use Oceananigans to create reference LES solutions for multiple canonical flows. We use a cubical domain and random perturbations to trigger the flow. During our validation tests, we noticed that we could not reproduce the results, i.e., running the same .jl script (same initial flow conditions) leads to different averaged solutions (see attached picture). We ran more than 16 simulations and never obtained the same solution. We tried to set the seed of the random perturbations constant, but this did not solve the problem. Do you observe this problem, and could you help us run reproducible simulations so other users can obtain the same solutions? We attached the .jl file we are using to define the simulations. Best regards,; Filipe Pereira; Luke van Roekel ; Amrapalli Garanaik; Brodie Pearson . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193599386-11eccb58-2a3f-4a1c-83d6-cde2ea429d00.png). [c16_128_128m(1).jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9698212/c16_128_128m.1.jl.zip)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766
https://github.com/CliMA/Oceananigans.jl/pull/2767:200,Testability,test,tested,200,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17, 0.18, 0.19` to `0.16, 0.17, 0.18, 0.19, 0.20`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2767
https://github.com/CliMA/Oceananigans.jl/pull/2767:306,Testability,test,tests,306,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17, 0.18, 0.19` to `0.16, 0.17, 0.18, 0.19, 0.20`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2767
https://github.com/CliMA/Oceananigans.jl/issues/2768:124,Availability,error,errors,124,"Happens with Julia 1.6.7 and 1.8.1 with Oceananigans v0.77.5. Not sure if this is connected to #2530 or #2709 although this errors on the CPU. ~Minimal~ working example:. ```julia; using Oceananigans. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0); ). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(constant_salinity=true),; tracers = :T,; boundary_conditions = (v=v_bcs,); ); ```. Stacktrace from Julia 1.8.1: https://gist.github.com/ali-ramadhan/e45cc2d447f2ece001b4f2d9295b36b1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768
https://github.com/CliMA/Oceananigans.jl/issues/2770:152,Availability,error,error,152,"Hi all,. I've come across a problem a few times with the output writer where it can't set up running with `indices`specified. This presents as a bounds error coming from the `offset_data` function:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/src/Grids/new_data.jl#L33-L48. An example of this occurs when you try to run the ""near_global_lat_lon"" example when it tries to output surface values:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/validation/near_global_lat_lon/near_global_quarter_degree.jl#L296-L301. Essentially what I think is happening is that when we output data and specify some slice that isn't the dimensions of the grid, in this example just the surface level `grid.Nz`, the data is being correctly (? not sure we actually want the halo here) selected as e.g. `-Hx:Nx+Hx` in dimensions specified as `:` but just whatever indices specified by the user in the other dimensions. In the `offset_data` function I think `ii` gets the halo added in all dimensions so there's a miss match. . I'm not sure how to fix this cleanly?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770
https://github.com/CliMA/Oceananigans.jl/issues/2770:525,Security,validat,validation,525,"Hi all,. I've come across a problem a few times with the output writer where it can't set up running with `indices`specified. This presents as a bounds error coming from the `offset_data` function:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/src/Grids/new_data.jl#L33-L48. An example of this occurs when you try to run the ""near_global_lat_lon"" example when it tries to output surface values:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/validation/near_global_lat_lon/near_global_quarter_degree.jl#L296-L301. Essentially what I think is happening is that when we output data and specify some slice that isn't the dimensions of the grid, in this example just the surface level `grid.Nz`, the data is being correctly (? not sure we actually want the halo here) selected as e.g. `-Hx:Nx+Hx` in dimensions specified as `:` but just whatever indices specified by the user in the other dimensions. In the `offset_data` function I think `ii` gets the halo added in all dimensions so there's a miss match. . I'm not sure how to fix this cleanly?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770
https://github.com/CliMA/Oceananigans.jl/pull/2773:330,Energy Efficiency,schedul,schedule,330,"Implements callbacks between sub-steps as described in #2772 . I chose to add them to the model since that is the only part of the simulation they have access to when they run, and went with using the same `Callback` constructor so that parameters can still be passed to the functions despite the fact that whatever the specified schedule they have to run at every sub-step.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773
https://github.com/CliMA/Oceananigans.jl/pull/2773:152,Security,access,access,152,"Implements callbacks between sub-steps as described in #2772 . I chose to add them to the model since that is the only part of the simulation they have access to when they run, and went with using the same `Callback` constructor so that parameters can still be passed to the functions despite the fact that whatever the specified schedule they have to run at every sub-step.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773
https://github.com/CliMA/Oceananigans.jl/pull/2777:183,Testability,test,tested,183,"This pull request changes the compat entry for the `SeawaterPolynomials` package from `^0.2.3` to `^0.2.3, 0.3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2777
https://github.com/CliMA/Oceananigans.jl/pull/2777:289,Testability,test,tests,289,"This pull request changes the compat entry for the `SeawaterPolynomials` package from `^0.2.3` to `^0.2.3, 0.3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2777
https://github.com/CliMA/Oceananigans.jl/pull/2778:138,Testability,test,testing,138,Changes in PR #2740 made the global simulation crash. These changes will be reverted for the moment. They will be reintroduced after more testing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2778
https://github.com/CliMA/Oceananigans.jl/pull/2781:173,Testability,test,tested,173,"This pull request changes the compat entry for the `CUDAKernels` package from `0.3.3` to `0.3.3, 0.4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2781
https://github.com/CliMA/Oceananigans.jl/pull/2781:279,Testability,test,tests,279,"This pull request changes the compat entry for the `CUDAKernels` package from `0.3.3` to `0.3.3, 0.4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2781
https://github.com/CliMA/Oceananigans.jl/issues/2794:1424,Deployability,install,installed,1424,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794
https://github.com/CliMA/Oceananigans.jl/issues/2794:1234,Integrability,depend,depends,1234,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794
https://github.com/CliMA/Oceananigans.jl/issues/2794:1257,Integrability,depend,dependencies,1257,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794
https://github.com/CliMA/Oceananigans.jl/issues/2794:1067,Modifiability,variab,variable,1067,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794
https://github.com/CliMA/Oceananigans.jl/issues/2794:1615,Performance,optimiz,optimized,1615,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794
https://github.com/CliMA/Oceananigans.jl/pull/2795:37,Performance,perform,performed,37,"At the moment, the pressure solve is performed on one GPU/CPU, but this PR builds the infrastructure to allow multi-process global solves",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795
https://github.com/CliMA/Oceananigans.jl/pull/2796:320,Safety,avoid,avoid,320,"#2740 Introduced memory allocation in output construction of `ComputedFields` because the field was recomputed with the new indices to satisfy sliced boundary conditions constraints. This PR changes the contents of `view(f::Field, indices...)` in order to automatically satisfy sliced boundary condition constraints and avoid unnecessary memory allocation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2796
https://github.com/CliMA/Oceananigans.jl/pull/2797:317,Safety,avoid,avoid,317,"https://github.com/CliMA/Oceananigans.jl/pull/2740 Introduced extra memory allocation in output construction of ComputedFields to satisfy sliced boundary conditions constraints. This PR changes the definition of `view(f::Field, indices...)` in order to automatically satisfy sliced boundary condition constraints and avoid unnecessary memory allocation. closes #2794 ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2797
https://github.com/CliMA/Oceananigans.jl/issues/2798:205,Availability,error,error,205,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798
https://github.com/CliMA/Oceananigans.jl/issues/2798:287,Availability,error,error,287,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798
https://github.com/CliMA/Oceananigans.jl/issues/2798:724,Availability,ERROR,ERROR,724,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798
https://github.com/CliMA/Oceananigans.jl/issues/2798:775,Availability,error,error,775,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798
https://github.com/CliMA/Oceananigans.jl/issues/2798:731,Performance,Load,LoadError,731,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798
https://github.com/CliMA/Oceananigans.jl/issues/2798:79,Security,validat,validaton,79,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798
https://github.com/CliMA/Oceananigans.jl/issues/2798:806,Security,access,access,806,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798
https://github.com/CliMA/Oceananigans.jl/pull/2802:121,Integrability,interface,interface,121,Plus a simple test with a plankton growth/death model similar to `examples/convecting_plankton.jl`. TODO:; * [x] Add the interface to `HydrostaticFreeSurfaceModel`; * [x] Better interface for defining the biogeochemical source function; * [x] Better interface for automagically adding biogeochemical tracers?. With @jagoosw,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802
https://github.com/CliMA/Oceananigans.jl/pull/2802:178,Integrability,interface,interface,178,Plus a simple test with a plankton growth/death model similar to `examples/convecting_plankton.jl`. TODO:; * [x] Add the interface to `HydrostaticFreeSurfaceModel`; * [x] Better interface for defining the biogeochemical source function; * [x] Better interface for automagically adding biogeochemical tracers?. With @jagoosw,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802
https://github.com/CliMA/Oceananigans.jl/pull/2802:250,Integrability,interface,interface,250,Plus a simple test with a plankton growth/death model similar to `examples/convecting_plankton.jl`. TODO:; * [x] Add the interface to `HydrostaticFreeSurfaceModel`; * [x] Better interface for defining the biogeochemical source function; * [x] Better interface for automagically adding biogeochemical tracers?. With @jagoosw,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802
https://github.com/CliMA/Oceananigans.jl/pull/2802:14,Testability,test,test,14,Plus a simple test with a plankton growth/death model similar to `examples/convecting_plankton.jl`. TODO:; * [x] Add the interface to `HydrostaticFreeSurfaceModel`; * [x] Better interface for defining the biogeochemical source function; * [x] Better interface for automagically adding biogeochemical tracers?. With @jagoosw,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802
https://github.com/CliMA/Oceananigans.jl/pull/2802:7,Usability,simpl,simple,7,Plus a simple test with a plankton growth/death model similar to `examples/convecting_plankton.jl`. TODO:; * [x] Add the interface to `HydrostaticFreeSurfaceModel`; * [x] Better interface for defining the biogeochemical source function; * [x] Better interface for automagically adding biogeochemical tracers?. With @jagoosw,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802
https://github.com/CliMA/Oceananigans.jl/issues/2809:13212,Availability,ERROR,ERROR,13212,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:13277,Availability,error,errored,13277,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:13219,Performance,Load,LoadError,13219,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:413,Testability,test,test,413,"The `test_ensemble_hydrostatic_free_surface_models.jl ` fail when I run on my laptop. ```Julia; (base) navid:OC.jl/ (ncc/fix-race-issue) $ julia --project [12:21:26]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.2 (2022-09-29); _/ |\__'_|_|_|\__'_| |; |__/ |. shell> cd test/; /Users/navid/Research/OC.jl/test. julia> include(""test_ensemble_hydrostatic_free_surface_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition update_state!(Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel{TS, E, A, S, G, T, V, B, R, F, P, U, C, Φ, K, AF} where AF where K where Φ where C where U where P where F where R where B where V where T where G where S where A<:Oceananigans.Architectures.AbstractArchitecture where E where TS) in module HydrostaticFreeSurfaceModels at /Users/navid/Research/OC.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:18 overwritten at /Users/navid/Research/OC.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:20.; ** incremental compilation may be fatally broken for this module **. [ Info: Oceananigans will use 6 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (53.522 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (15.625 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (556.792 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.679 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:448,Testability,test,test,448,"The `test_ensemble_hydrostatic_free_surface_models.jl ` fail when I run on my laptop. ```Julia; (base) navid:OC.jl/ (ncc/fix-race-issue) $ julia --project [12:21:26]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.2 (2022-09-29); _/ |\__'_|_|_|\__'_| |; |__/ |. shell> cd test/; /Users/navid/Research/OC.jl/test. julia> include(""test_ensemble_hydrostatic_free_surface_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition update_state!(Oceananigans.Models.HydrostaticFreeSurfaceModels.HydrostaticFreeSurfaceModel{TS, E, A, S, G, T, V, B, R, F, P, U, C, Φ, K, AF} where AF where K where Φ where C where U where P where F where R where B where V where T where G where S where A<:Oceananigans.Architectures.AbstractArchitecture where E where TS) in module HydrostaticFreeSurfaceModels at /Users/navid/Research/OC.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:18 overwritten at /Users/navid/Research/OC.jl/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:20.; ** incremental compilation may be fatally broken for this module **. [ Info: Oceananigans will use 6 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (53.522 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (15.625 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (556.792 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.679 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:2832,Testability,Test,Testing,2832,"ion is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (540.375 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization compl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:2893,Testability,Test,Testing,2893,"lation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (540.375 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:2954,Testability,Test,Testing,2954,".; [ Info: ... simulation initialization complete (540.375 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Si",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:3015,Testability,Test,Testing,3015,"); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.642 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:3068,Testability,Test,Test,3068,"2 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (526.458 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.628 ms).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (32.531 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (12.121 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing ScalarDiffusivity ensemble member (1, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (1, 2)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 1)...; [ Info: Testing ScalarDiffusivity ensemble member (2, 2)...; Test Summary: | Pass Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different closures | 8 8 53.4s; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.511 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.778 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.500 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (807.667 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simula",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:4668,Testability,Test,Testing,4668,"ping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (264.333 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (795.416 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.083 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (842.167 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.379 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.602 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro exp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5083,Testability,Test,Test,5083,"eration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (249.083 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (842.167 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.379 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.602 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5126,Testability,test,test,5126," (249.083 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (842.167 μs).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (33.379 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (3.602 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velociti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5543,Testability,Test,Test,5543,"nds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_model",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5552,Testability,Test,Test,5552,"nds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_model",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5615,Testability,test,test,5615,"stop iteration 100.; [ Info: Testing Coriolis ensemble member (1, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5746,Testability,Test,Test,5746,"mble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5755,Testability,Test,Test,5755,"mble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5819,Testability,test,test,5819,"4711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5956,Testability,Test,Test,5956,"12707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:5999,Testability,test,test,5999,"staticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9556945663283964, 1.9556945663283964, 1.956442207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:6428,Testability,Test,Test,6428,"42207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:6437,Testability,Test,Test,6437,"42207122461, 1.956442207122461]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:6500,Testability,test,test,6500,"/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.955788617241",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:6631,Testability,Test,Test,6631,"rostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:6640,Testability,Test,Test,6640,"rostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:6704,Testability,test,test,6704,"julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:6770,Testability,Test,Testing,6770,"ope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:7185,Testability,Test,Test,7185,"[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:7228,Testability,test,test,7228,"133340103] == [-0.4263014101951749, -0.4263014101951749, -0.4268777834601785, -0.4268777834601785]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).veloci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:7647,Testability,Test,Test,7647,"[inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:7656,Testability,Test,Test,7656,"[inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:7719,Testability,test,test,7719,"face_models.jl:56; [ Info: Testing Coriolis ensemble member (1, 2) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:7850,Testability,Test,Test,7850,"le_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:7859,Testability,Test,Test,7859,"le_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:7923,Testability,test,test,7923,"11, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8060,Testability,Test,Test,8060,"707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8103,Testability,test,test,8103,"aticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.9557886172419943, 1.9557886172419943, 1.9555813707508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8534,Testability,Test,Test,8534,"07508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8543,Testability,Test,Test,8543,"07508094, 1.9555813707508094]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8606,Testability,test,test,8606,"ulia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.9565854067170",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8737,Testability,Test,Test,8737,"static_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8746,Testability,Test,Test,8746,"static_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8810,Testability,test,test,8810,"lia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:8876,Testability,Test,Testing,8876,"e; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:9291,Testability,Test,Test,9291,", 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:9334,Testability,test,test,9334,"3340103] == [-0.4265918248071758, -0.4265918248071758, -0.42653009438207723, -0.42653009438207723]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velociti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:9751,Testability,Test,Test,9751,"7 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:9760,Testability,Test,Test,9760,"7 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:9823,Testability,test,test,9823,"urface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 1) with FPlane{Float64}(f=1.0)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:9954,Testability,Test,Test,9954,"mble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:9963,Testability,Test,Test,9963,"mble_model.velocities.u))[i, j, :] = [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10027,Testability,test,test,10027,"4711, 1.955705427024711]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10164,Testability,Test,Test,10164,"12707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10207,Testability,test,test,10207,"staticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9560957311907452, 1.9560957311907452, 1.955705427024711, 1.955705427024711] == [1.956585406717029, 1.956585406717029, 1.9562395693167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10638,Testability,Test,Test,10638,"93167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.90",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10647,Testability,Test,Test,10647,"93167451, 1.9562395693167451]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.90",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10710,Testability,test,test,10710,"ulia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.90364838",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10841,Testability,Test,Test,10841,"static_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10850,Testability,Test,Test,10850,"static_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10914,Testability,test,test,10914,"lia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:10980,Testability,Test,Testing,10980,"e; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:11397,Testability,Test,Test,11397,"1, :]; Evaluated: [-0.4262436978212707, -0.4262436978212707, -0.4264160133340103, -0.4264160133340103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:11440,Testability,test,test,11440,"40103] == [-0.42635708763199076, -0.42635708763199076, -0.4264018069597793, -0.4264018069597793]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:11861,Testability,Test,Test,11861,"ined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_model",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:11870,Testability,Test,Test,11870,"ined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_model",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:11933,Testability,test,test,11933,"_models.jl:56; [ Info: Testing Coriolis ensemble member (2, 2) with FPlane{Float64}(f=1.1)...; (parent(ensemble_model.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12064,Testability,Test,Test,12064,"odel.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12073,Testability,Test,Test,12073,"odel.velocities.u))[i, j, :] = [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12137,Testability,test,test,12137," 1.9037665478634964]; (parent(ensemble_model.velocities.v))[i, j, :] = [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12274,Testability,Test,Test,12274,"9, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752]; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12317,Testability,test,test,12317,"icFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93; Expression: (parent(ensemble_model.velocities.u))[i, j, :] == (parent((models[i, j]).velocities.u))[1, 1, :]; Evaluated: [1.9041497846248912, 1.9041497846248912, 1.9037665478634964, 1.9037665478634964] == [1.9036483826083646, 1.9036483826083646, 1.9049708317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Resea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12746,Testability,Test,Test,12746,"8317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12755,Testability,Test,Test,12755,"8317561045, 1.9049708317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12818,Testability,test,test,12818,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12949,Testability,Test,Test,12949,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:12958,Testability,Test,Test,12958,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:13022,Testability,test,test,13022,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:13080,Testability,Test,Test,13080,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:13235,Testability,test,tests,13235,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:13351,Testability,test,test,13351,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2809:13671,Testability,test,tests,13671,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809
https://github.com/CliMA/Oceananigans.jl/issues/2813:148,Performance,bottleneck,bottleneck,148,Takes **longer than 6 hrs** atm... yikes!; https://buildkite.com/clima/oceananigans/builds/9087#01845448-a0ae-4e67-89df-6a4ec2ba9c9e. I believe the bottleneck is due to the nested `for`-loops in. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Solvers/sparse_approximate_inverse.jl#L61-L86,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2813
https://github.com/CliMA/Oceananigans.jl/pull/2824:18,Availability,error,error,18,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824
https://github.com/CliMA/Oceananigans.jl/pull/2824:147,Availability,error,error,147,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824
https://github.com/CliMA/Oceananigans.jl/pull/2824:579,Availability,error,error,579,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824
https://github.com/CliMA/Oceananigans.jl/pull/2824:585,Integrability,message,message,585,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824
https://github.com/CliMA/Oceananigans.jl/pull/2824:102,Modifiability,variab,variable,102,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824
https://github.com/CliMA/Oceananigans.jl/pull/2824:571,Usability,simpl,simpler,571,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824
https://github.com/CliMA/Oceananigans.jl/issues/2829:912,Availability,error,error,912,"Hey all,. Awesome software, I am really enjoying using it. I was wondering if you have any recommendations for compatibility with [DrWatson.jl](https://github.com/JuliaDynamics/DrWatson.jl)? In particular, I am hoping to combine the [`tagsave`](https://juliadynamics.github.io/DrWatson.jl/dev/save/#DrWatson.tagsave) functionality (which stores meta information about a simulation, like git commit, filename, etc) with `JLD2OutputWriter` somehow. This is what I have tried so far. (I'll give the full script at the end). ```julia. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end. sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; # Save to `/data/simulations` based on parameters:; filename=datadir(""simulations"", savename(d, ""jld2"")),; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); ```. However, I get an error from `tag!`:; ```julia; ┌ Warning: Initialization of /Users/mcranmer/Documents/oceananigans_interpret/data/simulations/initial_condition=random_seed=0_stop_time=10.0_timestepper=RungeKutta3_Δt=0.2_Δx=0.00781.jld2 failed because MethodError: MethodError: no method matching tag!(::JLD2.JLDFile{JLD2.MmapIO}); │ Closest candidates are:; │ tag!(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829
https://github.com/CliMA/Oceananigans.jl/issues/2829:2241,Availability,error,error,2241,"(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel(; grid, timestepper, advection, closure). # Initial conditions:; rng = MersenneTwister(seed); u, v = if initial_condition == ""random""; u = rand(rng, actual_size...); v = rand(rng, actual_size...); u .-= mean(u); v .-= mean(v); u, v; else; error(""Unknown initial condition: $initial_condition""); end. set!(model; u=u, v=v). sim = Simulation(model; Δt, stop_time); sim.callbacks[:progress] = Callback(; s -> @info ""Iteration $(iteration(s)) at time $(time(s))"", IterationInterval(100); ). ω, speed = begin; u, v, _ = model.velocities; ω = ∂x(v) - ∂y(u); speed = sqrt(u^2 + v^2); ω, speed; end. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end; ; sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; filename=datadir(""simulations"", savename(d, ""jld2"")),; overwrite_existing=true,; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); return sim; end. Δt = 0.2; size = (128, 128); extent = (1, 1); Δx = extent[1] / size[1]; stop_time = 10.0; topology = (Periodic, Periodic, Flat); architecture = CPU(); timestepper = :RungeKutta3; advection = nothing; closure = nothing; initial_condition = ""random""; seed = 0. params = @strdict size extent topology architecture tim",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829
https://github.com/CliMA/Oceananigans.jl/issues/2829:837,Energy Efficiency,schedul,schedule,837,"Hey all,. Awesome software, I am really enjoying using it. I was wondering if you have any recommendations for compatibility with [DrWatson.jl](https://github.com/JuliaDynamics/DrWatson.jl)? In particular, I am hoping to combine the [`tagsave`](https://juliadynamics.github.io/DrWatson.jl/dev/save/#DrWatson.tagsave) functionality (which stores meta information about a simulation, like git commit, filename, etc) with `JLD2OutputWriter` somehow. This is what I have tried so far. (I'll give the full script at the end). ```julia. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end. sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; # Save to `/data/simulations` based on parameters:; filename=datadir(""simulations"", savename(d, ""jld2"")),; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); ```. However, I get an error from `tag!`:; ```julia; ┌ Warning: Initialization of /Users/mcranmer/Documents/oceananigans_interpret/data/simulations/initial_condition=random_seed=0_stop_time=10.0_timestepper=RungeKutta3_Δt=0.2_Δx=0.00781.jld2 failed because MethodError: MethodError: no method matching tag!(::JLD2.JLDFile{JLD2.MmapIO}); │ Closest candidates are:; │ tag!(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829
https://github.com/CliMA/Oceananigans.jl/issues/2829:2876,Energy Efficiency,schedul,schedule,2876,"src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel(; grid, timestepper, advection, closure). # Initial conditions:; rng = MersenneTwister(seed); u, v = if initial_condition == ""random""; u = rand(rng, actual_size...); v = rand(rng, actual_size...); u .-= mean(u); v .-= mean(v); u, v; else; error(""Unknown initial condition: $initial_condition""); end. set!(model; u=u, v=v). sim = Simulation(model; Δt, stop_time); sim.callbacks[:progress] = Callback(; s -> @info ""Iteration $(iteration(s)) at time $(time(s))"", IterationInterval(100); ). ω, speed = begin; u, v, _ = model.velocities; ω = ∂x(v) - ∂y(u); speed = sqrt(u^2 + v^2); ω, speed; end. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end; ; sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; filename=datadir(""simulations"", savename(d, ""jld2"")),; overwrite_existing=true,; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); return sim; end. Δt = 0.2; size = (128, 128); extent = (1, 1); Δx = extent[1] / size[1]; stop_time = 10.0; topology = (Periodic, Periodic, Flat); architecture = CPU(); timestepper = :RungeKutta3; advection = nothing; closure = nothing; initial_condition = ""random""; seed = 0. params = @strdict size extent topology architecture timestepper advection closure Δt stop_time Δx initial_condition seed. sim = makesim(params); run!(sim); ```; </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829
https://github.com/CliMA/Oceananigans.jl/issues/2829:1652,Usability,Learn,Learning,1652,"model file; end. sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; # Save to `/data/simulations` based on parameters:; filename=datadir(""simulations"", savename(d, ""jld2"")),; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); ```. However, I get an error from `tag!`:; ```julia; ┌ Warning: Initialization of /Users/mcranmer/Documents/oceananigans_interpret/data/simulations/initial_condition=random_seed=0_stop_time=10.0_timestepper=RungeKutta3_Δt=0.2_Δx=0.00781.jld2 failed because MethodError: MethodError: no method matching tag!(::JLD2.JLDFile{JLD2.MmapIO}); │ Closest candidates are:; │ tag!(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel(; grid, timestepper, advection, closure). # Initial conditions:; rng = MersenneTwister(seed); u, v = if initial_condition == ""random""; u = rand(rng, actual_size...); v = rand(rng, actual_size...); u .-= mean(u); v .-= mean(v); u, v; else; error(""Unknown initial condition: $initial_condition""); end. set!(model; u=u, v=v). sim = Simulation(model; Δt, stop_time); sim.callbacks[:progress] = Callback(; s -> @info ""Iteration $(iteration(s)) at time $(time(s))"", IterationInterval(100); ). ω, speed = begin; u, v, _ = model.velocities; ω = ∂x(v) - ∂y(u); speed = sqrt(u^2 + v^2); ω, speed; end. function init_jld2!(file, model); tag!(file) # T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829
https://github.com/CliMA/Oceananigans.jl/issues/2837:28,Availability,error,error,28,"The example below throws an error. ```julia; julia> grid = RectilinearGrid(size=(4,4,4,), extent=(1,1,1)); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid, tracers=:b); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> b = model.tracers.b; 4×4×4 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 10×10×10 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> bcs = FieldBoundaryConditions(grid, (Center, Center, Face); top=GradientBoundaryCondition(1), bottom=GradientBoundaryCondition(1)); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: PeriodicBoundaryCondition; ├── east: PeriodicBoundaryCondition; ├── south: PeriodicBoundaryCondition; ├── north: PeriodicBoundaryCondition; ├── bottom: GradientBoundaryCondition: 1; ├── top: GradientBoundaryCondition: 1; └── immersed: FluxBoundaryCondition: Nothing. julia> b_z = Field(∂z(b), boundary_conditions=bcs); ERROR: ArgumentError: Cannot specify bottom boundary condition GradientBoundaryCondition: 1 on a field at Face()!; Stacktrace:; [1] validate_boundary_condition_location(bc::BoundaryCondition{Oceananigans.BoundaryConditions.Gr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2837
https://github.com/CliMA/Oceananigans.jl/issues/2837:1776,Availability,ERROR,ERROR,1776,"Grid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 10×10×10 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> bcs = FieldBoundaryConditions(grid, (Center, Center, Face); top=GradientBoundaryCondition(1), bottom=GradientBoundaryCondition(1)); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: PeriodicBoundaryCondition; ├── east: PeriodicBoundaryCondition; ├── south: PeriodicBoundaryCondition; ├── north: PeriodicBoundaryCondition; ├── bottom: GradientBoundaryCondition: 1; ├── top: GradientBoundaryCondition: 1; └── immersed: FluxBoundaryCondition: Nothing. julia> b_z = Field(∂z(b), boundary_conditions=bcs); ERROR: ArgumentError: Cannot specify bottom boundary condition GradientBoundaryCondition: 1 on a field at Face()!; Stacktrace:; [1] validate_boundary_condition_location(bc::BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Int64}, loc::Face, side::Symbol); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/Fields/field.jl:52; [2] validate_boundary_conditions(loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, bcs::FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryConditi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2837
https://github.com/CliMA/Oceananigans.jl/issues/2840:237,Availability,avail,available,237,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:764,Availability,ERROR,ERROR,764,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:1857,Availability,avail,available,1857,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:678,Performance,load,loading,678,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:1295,Performance,load,loading,1295,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:1412,Performance,load,loading,1412,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:1469,Performance,load,loading,1469,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:1540,Performance,load,loading,1540,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:1582,Performance,load,loading,1582,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/issues/2840:1708,Performance,load,loading,1708,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840
https://github.com/CliMA/Oceananigans.jl/pull/2842:1477,Testability,test,tests,1477,"The main goal for this PR is to create a user-facing function to obtain grid spacings. EDIT:. The current behavior is that for every grid type there are functions `xspacings()`, `xspacing()`, `xnodes()` and `xnode()` (and similarly for y and z) that follow the pattern illustrated below:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 1), extent=(1, 1, 1)); 4×4×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> xnodes(grid, Center(), Center(), Face()); 4-element view(OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7), 1:4) with eltype Float64:; 0.125; 0.375; 0.625; 0.875. julia> xnode(2, 2, 2, grid, Center(), Center(), Face()); 0.375. julia> xspacings(grid, Center(), Center(), Face()); 0.25. julia> xspacing(1, 2, 3, grid, Center(), Center(), Face()); 0.25; ```. These functions also appropriately handle stretched coordinates. In addition, both `xspacings()` and `xnodes()` have a `with_halos` kwarg that controls whether of not halos points are included. Convenience functions with fewer arguments are also defined for the cases where that's possible. For example:. ```julia; julia> xnode(2,2,2, grid, Center(), Center(), Face()); 0.375. julia> xnode(2, grid, Center()); 0.375; ```. I added tests for these functions for every grid in a way that doesn't create new grid instantiations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2842
https://github.com/CliMA/Oceananigans.jl/pull/2845:13,Availability,error,error,13,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845
https://github.com/CliMA/Oceananigans.jl/pull/2845:89,Availability,ERROR,ERROR,89,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845
https://github.com/CliMA/Oceananigans.jl/pull/2845:171,Modifiability,variab,variable,171,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845
https://github.com/CliMA/Oceananigans.jl/pull/2845:201,Modifiability,variab,variable,201,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845
https://github.com/CliMA/Oceananigans.jl/pull/2845:31,Security,validat,validation,31,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845
https://github.com/CliMA/Oceananigans.jl/pull/2850:180,Testability,test,tested,180,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.7.2` to `0.7.2, 0.8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2850
https://github.com/CliMA/Oceananigans.jl/pull/2850:286,Testability,test,tests,286,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.7.2` to `0.7.2, 0.8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2850
https://github.com/CliMA/Oceananigans.jl/pull/2851:180,Testability,test,tested,180,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.7.2` to `0.7.2, 0.8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2851
https://github.com/CliMA/Oceananigans.jl/pull/2851:286,Testability,test,tests,286,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.7.2` to `0.7.2, 0.8`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2851
https://github.com/CliMA/Oceananigans.jl/pull/2852:317,Deployability,configurat,configuration,317,"This PR introduces full upwinding in vector invariant advection, which allows running eddy-permitting/resolving hydrostatic simulations without the need for an explicit viscous dissipation. In addition, it also refactors the whole vector scheme superseding PR #2820 . Examples of surface speed in modified neverworld configuration:. https://user-images.githubusercontent.com/33547697/206742914-d216ea2b-7cd2-4aa5-be70-a760b088698b.mp4. left: full upwinding 1/8th of a degree, no horizontal closure; center: full upwinding 1/4th of a degree, no horizontal closure; right: conservative vector invariant, biharmonic viscosity. Closes #2820",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2852
https://github.com/CliMA/Oceananigans.jl/pull/2852:211,Modifiability,refactor,refactors,211,"This PR introduces full upwinding in vector invariant advection, which allows running eddy-permitting/resolving hydrostatic simulations without the need for an explicit viscous dissipation. In addition, it also refactors the whole vector scheme superseding PR #2820 . Examples of surface speed in modified neverworld configuration:. https://user-images.githubusercontent.com/33547697/206742914-d216ea2b-7cd2-4aa5-be70-a760b088698b.mp4. left: full upwinding 1/8th of a degree, no horizontal closure; center: full upwinding 1/4th of a degree, no horizontal closure; right: conservative vector invariant, biharmonic viscosity. Closes #2820",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2852
https://github.com/CliMA/Oceananigans.jl/pull/2852:317,Modifiability,config,configuration,317,"This PR introduces full upwinding in vector invariant advection, which allows running eddy-permitting/resolving hydrostatic simulations without the need for an explicit viscous dissipation. In addition, it also refactors the whole vector scheme superseding PR #2820 . Examples of surface speed in modified neverworld configuration:. https://user-images.githubusercontent.com/33547697/206742914-d216ea2b-7cd2-4aa5-be70-a760b088698b.mp4. left: full upwinding 1/8th of a degree, no horizontal closure; center: full upwinding 1/4th of a degree, no horizontal closure; right: conservative vector invariant, biharmonic viscosity. Closes #2820",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2852
https://github.com/CliMA/Oceananigans.jl/issues/2856:259,Availability,ERROR,ERROR,259,"Currently I can't operate on a reduction using `AbstractOperation`s:. ```julia; julia> using Oceananigans;. julia> grid = RectilinearGrid(size=(4,4,4,), extent=(1,1,1));. julia> model = NonhydrostaticModel(grid = grid);. julia> Average(model.velocities.u)/2; ERROR: MethodError: no method matching /(::Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Tuple{Int64, Int64, Int64}}, ::Int64); Closest candidates are:; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Number, ::Oceananigans.AbstractOperations.BinaryOperation) at /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/AbstractOperations/binary_operations.jl:88; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Oceananigans.AbstractOperations.BinaryOperation, ::Number) at /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/A",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856
https://github.com/CliMA/Oceananigans.jl/issues/2857:89,Availability,error,error,89,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2857:628,Availability,error,error,628,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2857:641,Availability,ERROR,ERROR,641,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2857:37,Energy Efficiency,reduce,reduced,37,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2857:424,Energy Efficiency,schedul,schedule,424,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2857:1004,Modifiability,Variab,Variable,1004,"a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.Off",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2857:1151,Modifiability,variab,variable,1151,"using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2857:1230,Modifiability,Variab,Variable,1230,"rid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2857:648,Performance,Load,LoadError,648,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857
https://github.com/CliMA/Oceananigans.jl/issues/2860:232,Availability,error,error,232,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:297,Availability,error,error,297,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:523,Availability,error,error,523,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:4906,Deployability,Continuous,ContinuousBoundaryFunction,4906,"inlined]; [12] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/grid_utils.jl:230 [inlined]; [13] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/BoundaryConditions/continuous_boundary_function.jl:153 [inlined]; [14] north_ib_flux(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, ::Tuple{Face, Center, Center}, ::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:6217,Deployability,Continuous,ContinuousBoundaryFunction,6217,"oundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), ty",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:6676,Deployability,Continuous,ContinuousBoundaryFunction,6676,"64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:7026,Deployability,Continuous,ContinuousBoundaryFunction,7026,"n{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:7377,Deployability,Continuous,ContinuousBoundaryFunction,7377,"nigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, ::Nothing, ::Nothing, ::Clock{Float64}, ::NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, P",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:7726,Deployability,Continuous,ContinuousBoundaryFunction,7726,".LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, ::Nothing, ::Nothing, ::Clock{Float64}, ::NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:9356,Deployability,Continuous,ContinuousBoundaryFunction,9356,"oundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), ty",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:9815,Deployability,Continuous,ContinuousBoundaryFunction,9815,"64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:10165,Deployability,Continuous,ContinuousBoundaryFunction,10165,"n{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:10516,Deployability,Continuous,ContinuousBoundaryFunction,10516,"nigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:10865,Deployability,Continuous,ContinuousBoundaryFunction,10865,".LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:13604,Deployability,Continuous,ContinuousBoundaryFunction,13604,"StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:13953,Deployability,Continuous,ContinuousBoundaryFunction,13953,"Matrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:14303,Deployability,Continuous,ContinuousBoundaryFunction,14303,"ing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:14653,Deployability,Continuous,ContinuousBoundaryFunction,14653,"s.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:24244,Deployability,update,updated,24244,"enceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, CPU, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64, Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}, Nothing, Nothing, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64. ... @ Oceananigans.Simulations ~/LocalDocs/code/Oceananigans.jl/src/Simulations/run.jl:86; [10] top-level scope; @ ~/LocalDocs/code/Oceananigans.jl/validation/immersed_boundaries/flow_over_hills_test.jl:146; ```. Any pointers would be helpful! I'm happy to contribute to an updated example once I sort this out. The relevant code was included in https://github.com/CliMA/Oceananigans.jl/commit/737ee905167ed44d61940098c32b108befbf1a26",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:14,Security,validat,validation,14,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:117,Security,validat,validation,117,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:554,Security,access,access,554,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:24118,Security,validat,validation,24118,"enceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, CPU, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64, Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}, Nothing, Nothing, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64. ... @ Oceananigans.Simulations ~/LocalDocs/code/Oceananigans.jl/src/Simulations/run.jl:86; [10] top-level scope; @ ~/LocalDocs/code/Oceananigans.jl/validation/immersed_boundaries/flow_over_hills_test.jl:146; ```. Any pointers would be helpful! I'm happy to contribute to an updated example once I sort this out. The relevant code was included in https://github.com/CliMA/Oceananigans.jl/commit/737ee905167ed44d61940098c32b108befbf1a26",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/issues/2860:303,Usability,clear,clearly,303,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860
https://github.com/CliMA/Oceananigans.jl/pull/2861:84,Availability,Error,Error,84,"On main:. ```julia; julia> a = Oceananigans.BuoyancyModels.LinearEquationOfState(); Error showing value of type LinearEquationOfState{Float64}:; ERROR: MethodError: no method matching display(::LinearEquationOfState{Float64}); Closest candidates are:; display(::Any) at multimedia.jl:324; display(::AbstractDisplay, ::AbstractString, ::Any) at multimedia.jl:216; display(::AbstractString, ::Any) at multimedia.jl:217; ```. This PR:. ```julia; julia> a = Oceananigans.BuoyancyModels.LinearEquationOfState(); LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2861
https://github.com/CliMA/Oceananigans.jl/pull/2861:145,Availability,ERROR,ERROR,145,"On main:. ```julia; julia> a = Oceananigans.BuoyancyModels.LinearEquationOfState(); Error showing value of type LinearEquationOfState{Float64}:; ERROR: MethodError: no method matching display(::LinearEquationOfState{Float64}); Closest candidates are:; display(::Any) at multimedia.jl:324; display(::AbstractDisplay, ::AbstractString, ::Any) at multimedia.jl:216; display(::AbstractString, ::Any) at multimedia.jl:217; ```. This PR:. ```julia; julia> a = Oceananigans.BuoyancyModels.LinearEquationOfState(); LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2861
https://github.com/CliMA/Oceananigans.jl/pull/2865:15,Availability,error,error,15,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865
https://github.com/CliMA/Oceananigans.jl/pull/2865:430,Deployability,release,released,430,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865
https://github.com/CliMA/Oceananigans.jl/pull/2865:444,Deployability,update,update,444,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865
https://github.com/CliMA/Oceananigans.jl/pull/2865:59,Energy Efficiency,reduce,reduced,59,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865
https://github.com/CliMA/Oceananigans.jl/pull/2865:258,Testability,test,test,258,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865
https://github.com/CliMA/Oceananigans.jl/pull/2865:363,Testability,test,tests,363,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865
https://github.com/CliMA/Oceananigans.jl/issues/2866:0,Availability,Checkpoint,Checkpointer,0,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:501,Availability,checkpoint,checkpointer,501,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:517,Availability,Checkpoint,Checkpointer,517,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:703,Availability,Error,Errors,703,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:759,Availability,checkpoint,checkpointing,759,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:794,Availability,checkpoint,checkpointed,794,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:905,Availability,checkpoint,checkpointer,905,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:925,Availability,ERROR,ERROR,925,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:939,Availability,checkpoint,checkpoint,939,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:1110,Availability,checkpoint,checkpointer,1110,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/issues/2866:538,Energy Efficiency,schedul,schedule,538,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866
https://github.com/CliMA/Oceananigans.jl/pull/2867:1678,Performance,perform,performance,1678,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867
https://github.com/CliMA/Oceananigans.jl/pull/2867:547,Testability,test,tests,547,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867
https://github.com/CliMA/Oceananigans.jl/pull/2867:720,Testability,test,tests,720,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867
https://github.com/CliMA/Oceananigans.jl/pull/2867:810,Testability,test,tests,810,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867
https://github.com/CliMA/Oceananigans.jl/pull/2867:1708,Testability,test,testing,1708,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867
https://github.com/CliMA/Oceananigans.jl/pull/2867:236,Usability,clear,clear,236,"This PR removes the CubedSpheres module and re-implements CubedSphere grid using the MultiRegion module. Furthermore, it improves the OrthogonalSphericalShellGrid. ## Implemented in this PR; - uses Distances package which allowed us to clear up various utilities in the grid_utils.jl file regarding great circle distances on the sphere; - fix some bugs that didn't allow an OrthogonalSphericalShellGrid to be constructed with any topology; - better and more accurate show methods that also work on the GPU.; - construct ConformalCubedSphereGrid + tests; - introduces the Connectivity type for MultiRegionGrids + adds a default CubedSphereGrid connectivity; - adds halo filling functionality for tracers + velocities ( + tests); - introduced CubedSphereField abstraction; - introduces CubedSphereConnectivity + tests. ## Outstanding issues; (Several issues will be opened as soon as this PR is merged for the following); - Coordinate and metric halo fillings for the ConformalCubedSphereGrid are hardcoded. We need to re-implement this based on the connectivity of the grid so that it works (i) for any connectivity and (ii) for any CubedSpherePartition.; - Properties `ξₗ, ξᵣ, ηₗ, ηᵣ` should be taken out from OrthogonalSphericalShellGrid _or_, even better, be grouped together into a property `conformal_cubed_sphere` or something. This way, the OrthogonalSphericalShellGrid will be general and not necessarily tied to the conformal cubed sphere.; - Differentiate the OrthogonalSphericalShellGrid constructors from the cubed_sphere_panel constructors; - Shortcut for velocity halo filling; - Alleviate the need for multiple hallo filling passes for velocities (**important for performance/scaling**); - Add testing for MultiRegionGrids with `YPartition`; - Allow uneven x-y partition for ConformalCubedSphere",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2867
https://github.com/CliMA/Oceananigans.jl/pull/2868:112,Availability,Checkpoint,Checkpointer,112,"This is work in progress to solve #2866 so I would apprciate some advice:. 1. I added a specific constructor of Checkpointer for when the model is a ShallowWater model; 2. I added a set! function for when the model is a shallow water model (the difference of these two and the other ones is that they do not require the ""particles"" property.; 3. I added a low-res test case . Is OutputWriters/checkpointer a good place to put these methods in, or should they go somewhere in models/?; Is it okay to no add a new docstring to the new constructor and instead modify the existing one mentioning the difference with the ShallowWater case? If I add new one, the docs of Checkpointer will be huge.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2868
https://github.com/CliMA/Oceananigans.jl/pull/2868:393,Availability,checkpoint,checkpointer,393,"This is work in progress to solve #2866 so I would apprciate some advice:. 1. I added a specific constructor of Checkpointer for when the model is a ShallowWater model; 2. I added a set! function for when the model is a shallow water model (the difference of these two and the other ones is that they do not require the ""particles"" property.; 3. I added a low-res test case . Is OutputWriters/checkpointer a good place to put these methods in, or should they go somewhere in models/?; Is it okay to no add a new docstring to the new constructor and instead modify the existing one mentioning the difference with the ShallowWater case? If I add new one, the docs of Checkpointer will be huge.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2868
https://github.com/CliMA/Oceananigans.jl/pull/2868:665,Availability,Checkpoint,Checkpointer,665,"This is work in progress to solve #2866 so I would apprciate some advice:. 1. I added a specific constructor of Checkpointer for when the model is a ShallowWater model; 2. I added a set! function for when the model is a shallow water model (the difference of these two and the other ones is that they do not require the ""particles"" property.; 3. I added a low-res test case . Is OutputWriters/checkpointer a good place to put these methods in, or should they go somewhere in models/?; Is it okay to no add a new docstring to the new constructor and instead modify the existing one mentioning the difference with the ShallowWater case? If I add new one, the docs of Checkpointer will be huge.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2868
https://github.com/CliMA/Oceananigans.jl/pull/2868:364,Testability,test,test,364,"This is work in progress to solve #2866 so I would apprciate some advice:. 1. I added a specific constructor of Checkpointer for when the model is a ShallowWater model; 2. I added a set! function for when the model is a shallow water model (the difference of these two and the other ones is that they do not require the ""particles"" property.; 3. I added a low-res test case . Is OutputWriters/checkpointer a good place to put these methods in, or should they go somewhere in models/?; Is it okay to no add a new docstring to the new constructor and instead modify the existing one mentioning the difference with the ShallowWater case? If I add new one, the docs of Checkpointer will be huge.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2868
https://github.com/CliMA/Oceananigans.jl/issues/2869:69,Availability,error,errors,69,"When running a relatively complex, but small simulation, I'm getting errors on the GPU that I can't make sense of. It's hard to come up with a minimum working example that's truly small because the error seems to pop up only when there's some level of complexity, but here's what I have so far:. ```julia; using Oceananigans; arch = GPU(). z_faces = collect(0:1:6); grid = RectilinearGrid(arch, size=(8, 8, 6),; x=(0, 1), y=(0, 1), z=z_faces). @inline b_bg(x, y, z, t) = x; B_field = BackgroundField(b_bg). @inline sponge_u(x, y, z, t, u, p) = -p.σ * (u - p.α*p.u₀); @inline sponge_v(x, y, z, t, v, p) = -p.σ * (v - p.α*p.u₀); @inline sponge_w(x, y, z, t, w, p) = -p.σ * (w - p.α*p.u₀); @inline sponge_b(x, y, z, t, b, p) = -p.σ * (b - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5)). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:198,Availability,error,error,198,"When running a relatively complex, but small simulation, I'm getting errors on the GPU that I can't make sense of. It's hard to come up with a minimum working example that's truly small because the error seems to pop up only when there's some level of complexity, but here's what I have so far:. ```julia; using Oceananigans; arch = GPU(). z_faces = collect(0:1:6); grid = RectilinearGrid(arch, size=(8, 8, 6),; x=(0, 1), y=(0, 1), z=z_faces). @inline b_bg(x, y, z, t) = x; B_field = BackgroundField(b_bg). @inline sponge_u(x, y, z, t, u, p) = -p.σ * (u - p.α*p.u₀); @inline sponge_v(x, y, z, t, v, p) = -p.σ * (v - p.α*p.u₀); @inline sponge_w(x, y, z, t, w, p) = -p.σ * (w - p.α*p.u₀); @inline sponge_b(x, y, z, t, b, p) = -p.σ * (b - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5)). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:1536,Availability,ERROR,ERROR,1536,"_v(x, y, z, t, v, p) = -p.σ * (v - p.α*p.u₀); @inline sponge_w(x, y, z, t, w, p) = -p.σ * (w - p.α*p.u₀); @inline sponge_b(x, y, z, t, b, p) = -p.σ * (b - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5)). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:1559,Availability,error,error,1559,"_v(x, y, z, t, v, p) = -p.σ * (v - p.α*p.u₀); @inline sponge_w(x, y, z, t, w, p) = -p.σ * (w - p.α*p.u₀); @inline sponge_b(x, y, z, t, b, p) = -p.σ * (b - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5)). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:23025,Availability,error,error,23025,".Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64...; ```. I'm not really sure what to make of this error. Because the simulation I need to run is necessarily complex, it's been hard to get rid of this error in my main simulation. Any ideas?. PS.: I ran this MWE in particular on an NVIDIA Quadro GP100 GPU, but I have gotten the same error (albeit with a longer MWE) on Tesla V100s. ```julia; julia> versioninfo(); Julia Version 1.8.3; Commit 0434deb161e (2022-11-14 20:14 UTC); Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 72 × Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-13.0.1 (ORCJIT, skylake-avx512); Threads: 1 on 72 virtual cores; Environment:; JULIA_DEPOT_PATH = /glade/work/tomasc/.julia; LD_LIBRARY_PATH = /glade/u/apps/dav/opt/cuda/11.4.0/extras/CUPTI/lib64:/glade/u/apps/dav/opt/cuda/11.4.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/lib:/glade/u/apps/dav/opt/julia/1.8.3/lib/julia:/glade/u/apps/dav/opt/openmpi/4.1.1/gnu/10.1.0/lib:/glade/u/apps/dav/opt/ucx/1.11.0/lib:/glade/u/apps/dav/opt/gnu/10.1.0/lib64:/glade/u/ap",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:23127,Availability,error,error,23127,"ns.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64...; ```. I'm not really sure what to make of this error. Because the simulation I need to run is necessarily complex, it's been hard to get rid of this error in my main simulation. Any ideas?. PS.: I ran this MWE in particular on an NVIDIA Quadro GP100 GPU, but I have gotten the same error (albeit with a longer MWE) on Tesla V100s. ```julia; julia> versioninfo(); Julia Version 1.8.3; Commit 0434deb161e (2022-11-14 20:14 UTC); Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 72 × Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-13.0.1 (ORCJIT, skylake-avx512); Threads: 1 on 72 virtual cores; Environment:; JULIA_DEPOT_PATH = /glade/work/tomasc/.julia; LD_LIBRARY_PATH = /glade/u/apps/dav/opt/cuda/11.4.0/extras/CUPTI/lib64:/glade/u/apps/dav/opt/cuda/11.4.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/lib:/glade/u/apps/dav/opt/julia/1.8.3/lib/julia:/glade/u/apps/dav/opt/openmpi/4.1.1/gnu/10.1.0/lib:/glade/u/apps/dav/opt/ucx/1.11.0/lib:/glade/u/apps/dav/opt/gnu/10.1.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/../ncar/libglvnd/lib; JULIA_EDITOR = vim; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:23260,Availability,error,error,23260,"ns.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64...; ```. I'm not really sure what to make of this error. Because the simulation I need to run is necessarily complex, it's been hard to get rid of this error in my main simulation. Any ideas?. PS.: I ran this MWE in particular on an NVIDIA Quadro GP100 GPU, but I have gotten the same error (albeit with a longer MWE) on Tesla V100s. ```julia; julia> versioninfo(); Julia Version 1.8.3; Commit 0434deb161e (2022-11-14 20:14 UTC); Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 72 × Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-13.0.1 (ORCJIT, skylake-avx512); Threads: 1 on 72 virtual cores; Environment:; JULIA_DEPOT_PATH = /glade/work/tomasc/.julia; LD_LIBRARY_PATH = /glade/u/apps/dav/opt/cuda/11.4.0/extras/CUPTI/lib64:/glade/u/apps/dav/opt/cuda/11.4.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/lib:/glade/u/apps/dav/opt/julia/1.8.3/lib/julia:/glade/u/apps/dav/opt/openmpi/4.1.1/gnu/10.1.0/lib:/glade/u/apps/dav/opt/ucx/1.11.0/lib:/glade/u/apps/dav/opt/gnu/10.1.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/../ncar/libglvnd/lib; JULIA_EDITOR = vim; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:8461,Deployability,Continuous,ContinuousForcing,8461,"ecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Nothing}, Float64}, Oceananigans.AbstractOperations.BinaryOperation{Center, Center, Center, typeof(/), OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64, typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.identity2), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Nothing}, Float64}}}}}, NamedTuple{(:u, :v, :w, :b, :τ1, :τ2), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_v), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_w), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_b), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}; name::String, kwargs::Base.P",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:8671,Deployability,Continuous,ContinuousForcing,8671,"s.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64, typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.identity2), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Nothing}, Float64}}}}}, NamedTuple{(:u, :v, :w, :b, :τ1, :τ2), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_v), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_w), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_b), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}; name::String, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:299; [6] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:8881,Deployability,Continuous,ContinuousForcing,8881,"loat64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Nothing}, Float64}}}}}, NamedTuple{(:u, :v, :w, :b, :τ1, :τ2), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_v), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_w), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_b), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}; name::String, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:299; [6] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:102 [inlined]; [7] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, type",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:9091,Deployability,Continuous,ContinuousForcing,9091," OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Nothing}, Float64}}}}}, NamedTuple{(:u, :v, :w, :b, :τ1, :τ2), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_v), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_w), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_b), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}; name::String, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:299; [6] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:102 [inlined]; [7] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!)})(::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:11315,Integrability,depend,dependencies,11315,"ase.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::CUDAKernels.CudaEvent, workgroupsize::Nothing, progress::Function); @ CUDAKernels /glade/work/tomasc/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:194; [8] calculate_interior_tendency_contributions!(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b, :τ1, :τ2), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:1543,Performance,Load,LoadError,1543,"_v(x, y, z, t, v, p) = -p.σ * (v - p.α*p.u₀); @inline sponge_w(x, y, z, t, w, p) = -p.σ * (w - p.α*p.u₀); @inline sponge_b(x, y, z, t, b, p) = -p.σ * (b - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5)). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:2165,Performance,cache,cache,2165,"= (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 6)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/issues/2869:2374,Performance,cache,cache,2374,"eration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 6)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869
https://github.com/CliMA/Oceananigans.jl/pull/2870:145,Performance,perform,perform,145,Unfortunately the previews clog up the [OceananigansDocumentation](https://github.com/CliMA/OceananigansDocumentation) repository and we need to perform manual cleanup often... I suggest we drop the doc previews for the moment. We could build the docs manually _or_ temporarily enable them for a particular PR that includes Doc changes and then disable them again.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2870
https://github.com/CliMA/Oceananigans.jl/pull/2871:231,Safety,avoid,avoid,231,The cubed sphere grid from the MIT as read from DataDeps has the faces ordered:; 1. `+ x` direction; 2. `+ y` direction; 3. `+ z` direction (Arctic); 4. `- x` direction; 5. `- y` direction; 6. `- z` direction (Antarctica); ; So to avoid confusion for (users and developers!) I thought I make sure that the ConformalCubedSphere follows the same convention. This PR does that + it adds tests to check whether the ConformalCubedSphereGrid metrics from the grid read from file and the grid constructed in Oceananigans.jl are the same. After this is merged we'll move on to #2867 to constructing `ConformalCubedSphereGrid` using MultiRegion (an possibly nuke the `CubedSpheres` module completely). We will have a `ConformalCubedSphereGrid` (which is the same as the `cs32` grid read from file) to bench our MultiRegion implementation with!. (This PR also moves some of the spherical trigonometry utility function to `grid_utils.jl`.). Closes #1586,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2871
https://github.com/CliMA/Oceananigans.jl/pull/2871:384,Testability,test,tests,384,The cubed sphere grid from the MIT as read from DataDeps has the faces ordered:; 1. `+ x` direction; 2. `+ y` direction; 3. `+ z` direction (Arctic); 4. `- x` direction; 5. `- y` direction; 6. `- z` direction (Antarctica); ; So to avoid confusion for (users and developers!) I thought I make sure that the ConformalCubedSphere follows the same convention. This PR does that + it adds tests to check whether the ConformalCubedSphereGrid metrics from the grid read from file and the grid constructed in Oceananigans.jl are the same. After this is merged we'll move on to #2867 to constructing `ConformalCubedSphereGrid` using MultiRegion (an possibly nuke the `CubedSpheres` module completely). We will have a `ConformalCubedSphereGrid` (which is the same as the `cs32` grid read from file) to bench our MultiRegion implementation with!. (This PR also moves some of the spherical trigonometry utility function to `grid_utils.jl`.). Closes #1586,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2871
https://github.com/CliMA/Oceananigans.jl/pull/2874:76,Performance,bottleneck,bottleneck,76,"In large computations, advection tendency and implicit free surface are the bottleneck. This can be improved (probably) with an improved `SplitExplicitFreeSurface` that scales better at high resolutions and by introducing shared memory for the calculation of advection. (Another way to improve advection performance is to split the kernels based on the distance to a solid boundary such that we do not have to perform the calculations of all orders starting from 1, but it is probably a slightly more complex solution). This is an explorative PR to try to address both problems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2874
https://github.com/CliMA/Oceananigans.jl/pull/2874:304,Performance,perform,performance,304,"In large computations, advection tendency and implicit free surface are the bottleneck. This can be improved (probably) with an improved `SplitExplicitFreeSurface` that scales better at high resolutions and by introducing shared memory for the calculation of advection. (Another way to improve advection performance is to split the kernels based on the distance to a solid boundary such that we do not have to perform the calculations of all orders starting from 1, but it is probably a slightly more complex solution). This is an explorative PR to try to address both problems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2874
https://github.com/CliMA/Oceananigans.jl/pull/2874:410,Performance,perform,perform,410,"In large computations, advection tendency and implicit free surface are the bottleneck. This can be improved (probably) with an improved `SplitExplicitFreeSurface` that scales better at high resolutions and by introducing shared memory for the calculation of advection. (Another way to improve advection performance is to split the kernels based on the distance to a solid boundary such that we do not have to perform the calculations of all orders starting from 1, but it is probably a slightly more complex solution). This is an explorative PR to try to address both problems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2874
https://github.com/CliMA/Oceananigans.jl/pull/2875:162,Testability,test,tests,162,"I've been facing some trouble in https://github.com/CliMA/Oceananigans.jl/pull/2842/ for cubed sphere grids and I think that's why. Locally this change makes the tests there pass. Admittedly I know very little about cubed spheres, so input is appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2875
https://github.com/CliMA/Oceananigans.jl/issues/2876:246,Availability,error,error,246,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876
https://github.com/CliMA/Oceananigans.jl/issues/2876:740,Availability,Error,Error,740,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876
https://github.com/CliMA/Oceananigans.jl/issues/2876:931,Availability,ERROR,ERROR,931,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876
https://github.com/CliMA/Oceananigans.jl/issues/2876:982,Availability,error,error,982,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876
https://github.com/CliMA/Oceananigans.jl/issues/2876:938,Performance,Load,LoadError,938,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876
https://github.com/CliMA/Oceananigans.jl/issues/2876:1013,Security,access,access,1013,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876
https://github.com/CliMA/Oceananigans.jl/pull/2879:119,Availability,error,errors,119,"This PR implements automatically-generated function signatures with DocStringExtensions. I think this will avoid human errors when creating docstrings and also making documenting stuff easier, which hopefully will ultimately help users and novice developers. Starting this as a draft since I wanna see what effects this will have on the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2879
https://github.com/CliMA/Oceananigans.jl/pull/2879:107,Safety,avoid,avoid,107,"This PR implements automatically-generated function signatures with DocStringExtensions. I think this will avoid human errors when creating docstrings and also making documenting stuff easier, which hopefully will ultimately help users and novice developers. Starting this as a draft since I wanna see what effects this will have on the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2879
https://github.com/CliMA/Oceananigans.jl/pull/2881:171,Modifiability,extend,extend,171,"This PR adds regridding in x (and there was previously untested regridding in y). Regridding is only supported for tracer fields (though it's not a huge amount of work to extend the schemes for any field). I believe the regridding is conservative for `RectilinearGrid`, and also conservative for `LatitudeLongitudeGrid` when the grids are aligned (ie when all grid lines of the coarser of the two grids is shared with the finer grid). In the case of partial overlaps on curvilinear grids, the volumes of the overlaps are approximated and thus the regridding is not perfectly conservative. It could make sense to emit a warning in this case. In principle, this should allow regridding in 3D by forming intermediate regridding in x, y, and z. We leave multi-dimensional regridding to the user for now. This PR also adds a `minimum_turbulent_kinetic_energy` and `negative_turbulent_kinetic_energy_damping_timescale` to `CATKEVerticalDiffusivity`, either of which can help stabilize 2D or 3D simulations with CATKE (where due to advection TKE may go negative).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2881
https://github.com/CliMA/Oceananigans.jl/issues/2882:211,Deployability,update,update,211,I noticed that `similar(::Field)` does not transfer boundary conditions. https://github.com/CliMA/Oceananigans.jl/blob/a86ef32581192d82a655e1b2ff4411e79917a379/src/Fields/field.jl#L217-L227. so we might need to update . https://github.com/CliMA/Oceananigans.jl/blob/c8a65a4fdeff25722104ced3a0c74d2d921ae1cf/src/Solvers/multigrid_solver.jl#L225-L244. and in particular . https://github.com/CliMA/Oceananigans.jl/blob/c8a65a4fdeff25722104ced3a0c74d2d921ae1cf/src/Solvers/multigrid_solver.jl#L230,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2882
https://github.com/CliMA/Oceananigans.jl/pull/2883:93,Testability,test,tests,93,"This PR defines some binary operations involving `ZeroField`s that might be useful, and adds tests for those operations. The issue came up at https://github.com/tomchor/Oceanostics.jl/pull/104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2883
https://github.com/CliMA/Oceananigans.jl/issues/2884:170,Testability,test,tested,170,It seems like the animation in the internal wave example isn't displaying properly:. https://clima.github.io/OceananigansDocumentation/stable/generated/internal_wave/. I tested with 2 different browsers. It show up like this on firefox:. ![image](https://user-images.githubusercontent.com/13205162/215351544-f6b82ec2-58e6-4e31-8f89-da86c02d9714.png),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2884
https://github.com/CliMA/Oceananigans.jl/pull/2888:1053,Availability,avail,available,1053,"This PR improves the currently implemented split explicit surface solver in serial mode; (partially using the algorithm in Shchepetkin & McWilliams, Ocean Modelling 9, 2005 albeit with a linear free surface) and implements single-node parallel (`MultiRegion`), and multi-node parallel (`Distributed`) split explicit free surface. In addition, quite some improvements have been made to the distributed module to allow a distributed `LatitudeLongituteGrid` and `IBG` and various comments in the `MultiRegion` module. Edit: MPI does not exploit CUDA-aware message passing for CuArray views, so this PR also implements buffered Halo communication for distributed models, unifying a bit of the code for Distributed and MultiRegion. This is a fundamental step to achieve the goals of the next PR which will deal with heterogenous distributed - shared models (i.e. a MultiRegionGrid of a DistributedGrid) . Edit Edit: apparently CUDA-aware MPI allows passing views of CuArrays. Buffers are still implemented for those architectures where CUDA-aware MPI is not available. Edit Edit Edit: apparently for Oceananigans that sends strided memory, buffers are crucial because; > Note that derived datatypes, both contiguous and non-contiguous, are supported. However, the non-contiguous; > datatypes currently have high overhead because of the many calls to cuMemcpy to copy all the pieces of the; > buffer into the intermediate buffer. (from [openmpi-link](https://www.open-mpi.org/faq/?category=runcuda#mpi-cuda-support)). Edit: This PR adds the possibility of distributing along a `Bounded` direction, and the possibility of having correct 2D parallelization with Coriolis. Previously it was not possible because corners were not communicated correctly. Doesn't have to be merged now. (Validation cases are not necessary and will be deleted prior to merging)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888
https://github.com/CliMA/Oceananigans.jl/pull/2888:553,Integrability,message,message,553,"This PR improves the currently implemented split explicit surface solver in serial mode; (partially using the algorithm in Shchepetkin & McWilliams, Ocean Modelling 9, 2005 albeit with a linear free surface) and implements single-node parallel (`MultiRegion`), and multi-node parallel (`Distributed`) split explicit free surface. In addition, quite some improvements have been made to the distributed module to allow a distributed `LatitudeLongituteGrid` and `IBG` and various comments in the `MultiRegion` module. Edit: MPI does not exploit CUDA-aware message passing for CuArray views, so this PR also implements buffered Halo communication for distributed models, unifying a bit of the code for Distributed and MultiRegion. This is a fundamental step to achieve the goals of the next PR which will deal with heterogenous distributed - shared models (i.e. a MultiRegionGrid of a DistributedGrid) . Edit Edit: apparently CUDA-aware MPI allows passing views of CuArrays. Buffers are still implemented for those architectures where CUDA-aware MPI is not available. Edit Edit Edit: apparently for Oceananigans that sends strided memory, buffers are crucial because; > Note that derived datatypes, both contiguous and non-contiguous, are supported. However, the non-contiguous; > datatypes currently have high overhead because of the many calls to cuMemcpy to copy all the pieces of the; > buffer into the intermediate buffer. (from [openmpi-link](https://www.open-mpi.org/faq/?category=runcuda#mpi-cuda-support)). Edit: This PR adds the possibility of distributing along a `Bounded` direction, and the possibility of having correct 2D parallelization with Coriolis. Previously it was not possible because corners were not communicated correctly. Doesn't have to be merged now. (Validation cases are not necessary and will be deleted prior to merging)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888
https://github.com/CliMA/Oceananigans.jl/pull/2888:1776,Security,Validat,Validation,1776,"This PR improves the currently implemented split explicit surface solver in serial mode; (partially using the algorithm in Shchepetkin & McWilliams, Ocean Modelling 9, 2005 albeit with a linear free surface) and implements single-node parallel (`MultiRegion`), and multi-node parallel (`Distributed`) split explicit free surface. In addition, quite some improvements have been made to the distributed module to allow a distributed `LatitudeLongituteGrid` and `IBG` and various comments in the `MultiRegion` module. Edit: MPI does not exploit CUDA-aware message passing for CuArray views, so this PR also implements buffered Halo communication for distributed models, unifying a bit of the code for Distributed and MultiRegion. This is a fundamental step to achieve the goals of the next PR which will deal with heterogenous distributed - shared models (i.e. a MultiRegionGrid of a DistributedGrid) . Edit Edit: apparently CUDA-aware MPI allows passing views of CuArrays. Buffers are still implemented for those architectures where CUDA-aware MPI is not available. Edit Edit Edit: apparently for Oceananigans that sends strided memory, buffers are crucial because; > Note that derived datatypes, both contiguous and non-contiguous, are supported. However, the non-contiguous; > datatypes currently have high overhead because of the many calls to cuMemcpy to copy all the pieces of the; > buffer into the intermediate buffer. (from [openmpi-link](https://www.open-mpi.org/faq/?category=runcuda#mpi-cuda-support)). Edit: This PR adds the possibility of distributing along a `Bounded` direction, and the possibility of having correct 2D parallelization with Coriolis. Previously it was not possible because corners were not communicated correctly. Doesn't have to be merged now. (Validation cases are not necessary and will be deleted prior to merging)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888
https://github.com/CliMA/Oceananigans.jl/pull/2889:170,Testability,test,tested,170,"This pull request changes the compat entry for the `CUDA` package from `3.8, 3.9` to `3.8, 3.9, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2889
https://github.com/CliMA/Oceananigans.jl/pull/2889:276,Testability,test,tests,276,"This pull request changes the compat entry for the `CUDA` package from `3.8, 3.9` to `3.8, 3.9, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2889
https://github.com/CliMA/Oceananigans.jl/pull/2890:436,Performance,optimiz,optimization,436,"While `Array{Float32}` is neat because user output is smaller, it's a bad default because it often leads to confusing results, like the fact that outputing `Field(Integral(c))` is different (possibly by `eps(Float32)`) than computing `Integral(c_output)` in post processing when `Field(Integral(c))` is close to 0. Thus @xkykai and I propose to make the default `Array{Float64}`. We could regard outputting with `Array{Float32}` as an ""optimization"" which is premature as a default.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2890
https://github.com/CliMA/Oceananigans.jl/issues/2891:505,Integrability,wrap,wrapped,505,"The pressure correction is done here:. https://github.com/CliMA/Oceananigans.jl/blob/c21d5d6ac95e762cac85154c8f3c4de63631fca7/src/Models/NonhydrostaticModels/pressure_correction.jl#L37-L39. which uses the ""immersed boundary aware"" derivatives `∂xᶠᶜᶜ`, `∂yᶜᶠᶜ`, and `∂zᶜᶜᶠ`. Specifically, these derivatives _always_ return zero across an immersed boundary. (This can be seen from this file: https://github.com/CliMA/Oceananigans.jl/blob/main/src/ImmersedBoundaries/conditional_derivatives.jl, though it is wrapped up in metaprogramming and may be hard to figure out at first glance.). However, the pressure correction for `NonhydrostaticModel` is done in such away that the pressure field does not have zero derivative normal to immersed boundaries. The consequence is that the velocity field in `NonhydrostaticModel` likely has divergence. With an ""immersed boundary unaware"" pressure correction step, we have to make a choice. Either . 1. The velocity field is divergence free, but does not satisfy impenetrability; or; 2. The velocity field satisfies impenetrability, but is not divergence free. We used to make choice 1, but I think we are currently making choice 2. (Note that both are ""wrong"" in that the correct dynamics are _both_ divergence free and satisfy impenetrability.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2891
https://github.com/CliMA/Oceananigans.jl/pull/2898:19,Testability,test,tests,19,Attempt and making tests on https://github.com/CliMA/Oceananigans.jl/pull/2865 pass,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2898
https://github.com/CliMA/Oceananigans.jl/pull/2900:120,Testability,test,tests,120,Same as https://github.com/CliMA/Oceananigans.jl/pull/2899 but pinning GPUCompiler to version 0.16.4. This pinning made tests pass in https://github.com/CliMA/Oceananigans.jl/pull/2865,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2900
https://github.com/CliMA/Oceananigans.jl/pull/2904:109,Safety,avoid,avoided,109,"This PR changes the calculation of the diffusivities in the `SmagorinskyLilly` so that binary operations are avoided. At the moment it does so by creating a `calc_nonlinear_κᶜᶜᶜ()` kernel, similar to what is done for the AMD closure. Closes https://github.com/CliMA/Oceananigans.jl/issues/2869",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904
https://github.com/CliMA/Oceananigans.jl/pull/2906:10,Testability,test,test,10,- Fix doc test; - Revert GPUCompiler 359,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2906
https://github.com/CliMA/Oceananigans.jl/pull/2908:133,Safety,avoid,avoided,133,This PR removes the calculation of the diffusivities in `DiffusivityFields()` for the SmagorinskyLilly so that binary operations are avoided. Closes https://github.com/CliMA/Oceananigans.jl/issues/2869,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2908
https://github.com/CliMA/Oceananigans.jl/pull/2909:30,Availability,robust,robust,30,This is important for writing robust and readable code in our time-stepping algorithm.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2909
https://github.com/CliMA/Oceananigans.jl/pull/2910:137,Integrability,depend,dependencies,137,"`fill_halo_event!` is now a blocking function, i.e. we fill halos one direction at a time waiting in between. With this PR we try to use dependencies to achieve the same goal. This is an initial step to make `fill_halo_regions!` non-blocking",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2910
https://github.com/CliMA/Oceananigans.jl/pull/2913:116,Testability,test,test,116,"A recent PR broke the user-facing `diffusivity()` function for `SmagorinskyLilly` and this fixes it. It also adds a test to catch this in the future and exports `diffusivity()` at the `TurbulenceClosure` level, since it's a user-facing function.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2913
https://github.com/CliMA/Oceananigans.jl/issues/2914:593,Availability,ERROR,ERROR,593,"MWE:. ```Julia; julia> g(args...; kwargs...) = f(args...); g (generic function with 1 method). julia> f(x) = x + 1; f (generic function with 1 method). julia> x = MultiRegionObject(1, 2); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((1, 2), (CPU(), CPU())). julia> @apply_regionally a = f(x); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((2, 3), (CPU(), CPU())). julia> @apply_regionally a = g(x); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((2, 3), (CPU(), CPU())). julia> function h(x, args...; kwargs...); @apply_regionally a = g(args...; kwargs...); end; ERROR: syntax: ""..."" expression outside call around /Users/simonesilvestri/temp/Oceananigans.jl/src/Utils/multi_region_transformation.jl:212; Stacktrace:; [1] top-level scope; @ REPL[14]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2914
https://github.com/CliMA/Oceananigans.jl/issues/2916:123,Availability,error,error,123,"We have a minimum working example that tries to use a nonlinear equation of state, but when we define the model, we get an error saying, the following,. ```; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::typeof(SeawaterPolynomials.TEOS10.TEOS10EquationOfState)); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/Software/Oceananigans.jl/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.SecondOrderSeawaterPolynomials.SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/JiuSX/src/SecondOrderSeawaterPolynomials.jl:64; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/JiuSX/src/TEOS10.jl:186; ```. We are following the documentation shown [here](https://clima.github.io/OceananigansDocumentation/stable/model_setup/buoyancy_and_equation_of_state/). . Can someone help us fix this? . The code is copied below. ```; using Oceananigans; using SeawaterPolynomials. grid = RectilinearGrid(CPU();; size = (10, 10), ; x = ( 0, 1),; z = (-1, 0),; topology = (Periodic, Flat, Bounded)); ; eos = SeawaterPolynomials.TEOS10EquationOfState; buoyancy = SeawaterBuoyancy(equation_of_state=eos). model = NonhydrostaticModel(; grid, buoyancy, tracers = (:T, :S),); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2916
https://github.com/CliMA/Oceananigans.jl/issues/2916:170,Availability,error,error,170,"We have a minimum working example that tries to use a nonlinear equation of state, but when we define the model, we get an error saying, the following,. ```; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::typeof(SeawaterPolynomials.TEOS10.TEOS10EquationOfState)); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/Software/Oceananigans.jl/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.SecondOrderSeawaterPolynomials.SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/JiuSX/src/SecondOrderSeawaterPolynomials.jl:64; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/JiuSX/src/TEOS10.jl:186; ```. We are following the documentation shown [here](https://clima.github.io/OceananigansDocumentation/stable/model_setup/buoyancy_and_equation_of_state/). . Can someone help us fix this? . The code is copied below. ```; using Oceananigans; using SeawaterPolynomials. grid = RectilinearGrid(CPU();; size = (10, 10), ; x = ( 0, 1),; z = (-1, 0),; topology = (Periodic, Flat, Bounded)); ; eos = SeawaterPolynomials.TEOS10EquationOfState; buoyancy = SeawaterBuoyancy(equation_of_state=eos). model = NonhydrostaticModel(; grid, buoyancy, tracers = (:T, :S),); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2916
https://github.com/CliMA/Oceananigans.jl/pull/2917:30,Testability,test,tests,30,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917
https://github.com/CliMA/Oceananigans.jl/pull/2917:223,Testability,test,test,223,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917
https://github.com/CliMA/Oceananigans.jl/pull/2917:479,Testability,test,test,479,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917
https://github.com/CliMA/Oceananigans.jl/pull/2917:592,Testability,test,tests,592,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917
https://github.com/CliMA/Oceananigans.jl/pull/2917:814,Testability,test,tests,814,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917
https://github.com/CliMA/Oceananigans.jl/pull/2917:109,Usability,clear,clear,109,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917
https://github.com/CliMA/Oceananigans.jl/pull/2917:404,Usability,clear,clearer,404,I noticed that in a couple of tests in `test_grids.jl` the code was written in way that leads to some not-so-clear statements such as:. https://github.com/CliMA/Oceananigans.jl/blob/182e75c80645af0d6a7105ed2d8d4fcbceb7bccc/test/test_grids.jl#L381. The above seems wrong at first but it's actually correct since `Δzᵃᵃᶜ()` is defined the same way as `grid.Δzᵃᵃᶠ`. This PR changes that to make the notation clearer (i.e. `grid.Δzᵃᵃᶠ[2:Nz] == Δzᵃᵃᶠ.(2:Nz)`) and condenses 3 separate test functions for stretched grids (needing three separate grid instantiations) into one function (with the same tests). EDIT:. This also implements a suggestion by @glwagner in https://github.com/CliMA/Oceananigans.jl/pull/2865 that couldn't be implemented then. I'll open another PR in the near future to further condense some other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917
https://github.com/CliMA/Oceananigans.jl/issues/2922:127,Availability,error,error,127,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922
https://github.com/CliMA/Oceananigans.jl/issues/2922:90,Testability,test,tests,90,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922
https://github.com/CliMA/Oceananigans.jl/issues/2922:209,Testability,Test,Test,209,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922
https://github.com/CliMA/Oceananigans.jl/issues/2922:316,Testability,test,test,316,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922
https://github.com/CliMA/Oceananigans.jl/issues/2922:558,Testability,Test,Test,558,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922
https://github.com/CliMA/Oceananigans.jl/issues/2922:567,Testability,Test,Test,567,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922
https://github.com/CliMA/Oceananigans.jl/issues/2922:803,Testability,test,test,803,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922
https://github.com/CliMA/Oceananigans.jl/issues/2922:906,Testability,test,test,906,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922
https://github.com/CliMA/Oceananigans.jl/pull/2924:189,Integrability,depend,depends,189,"This likely removes some of the single device parallelism,; but decreases the risk for user mistake (everything is stream-ordered). This will cause severe merge conflicts with open PRs and depends on currently unreleased; versions of CUDA & KernelAbstractions. So I might regret doing it now, but I was curious; to see what the damage would be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924
https://github.com/CliMA/Oceananigans.jl/pull/2924:78,Safety,risk,risk,78,"This likely removes some of the single device parallelism,; but decreases the risk for user mistake (everything is stream-ordered). This will cause severe merge conflicts with open PRs and depends on currently unreleased; versions of CUDA & KernelAbstractions. So I might regret doing it now, but I was curious; to see what the damage would be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924
https://github.com/CliMA/Oceananigans.jl/issues/2925:206,Safety,avoid,avoid,206,"Should this. https://github.com/CliMA/Oceananigans.jl/blob/e2841ca6dda4414fcd9177512faec557d6f12adc/src/Coriolis/hydrostatic_spherical_coriolis.jl#L60. be . ```Julia; 1 - f(i, j, k, grid, args...); ```; to avoid type instability?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2925
https://github.com/CliMA/Oceananigans.jl/pull/2927:46,Testability,test,test,46,This PR temporarily removes GPU shallow water test (see issue #2922). We will have to regenerate the shallow water bickley jet data with a lower number of time steps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2927
https://github.com/CliMA/Oceananigans.jl/issues/2928:578,Usability,clear,clear,578,"As of now, our tracers are advected by three ""different"" velocities ; - Velocity; - Background velocity; - Advective forcing. to these, another additional velocity is being added in PR #2802 ; All these velocities are applied differently and might have different advection schemes. This might be a headache in terms of understanding the cause of stability problems. Imagine a situation in which a model is characterized by 3 different velocities that all advect a centered second-order reconstruction of the tracer. If we run into stability problems it might not be immediately clear what the course of action is: is the instability caused by the interaction of the tracer with velocity 1, 2, or 3?. This is not the only issue with this implementation. The implementation is _wrong_ if we use an upwinding reconstruction of the tracer for any of the velocities e.g.:. Imagine we have a Background velocity $U_b = 1$ and an advective forcing $U_a = -1$ and we upwind separately.; The tracer advective flux should be zero everywhere, but, if we upwind:; $$(U_b c) + (U_a c) = c^L - c^R$$. If we want to be able to advect with different velocities consistently we have to ensure that; - the same scheme is used; - we _sum_ the velocities and _not_ apply reconstruction separately. A way to do it could by defining; ```; struct AdvectiveU{A, B, C, D}; u :: A; ubkg :: B; ufrc :: C; ubgc :: D; end. Base.getindex(u::AdvectiveU, i, j, k) = u.u[i, j, k] + u.ubkg[i, j, k] + u.ubcg[i, j, k] + u.ufrc[i, j, k]; ```; and passing this velocity to the tracer tendency kernel.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2928
https://github.com/CliMA/Oceananigans.jl/issues/2930:78,Availability,error,error,78,When trying to use multi-region on multiple GPUs I get a `CUDA Irrecoverable` error on the main branch. I will post it here but I suspect that it is due to the streams allocation on multiple GPUs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2930
https://github.com/CliMA/Oceananigans.jl/issues/2931:2890,Availability,error,error,2890,"l(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, which in some cases (my case for example) is very important. - Not passing the `indices` flag (i.e. writing 3D fields instead slices) apparently gets rid of this issue. Here, even though the obvious easy solution is to separate averages from slices when writing, a user wouldn't know that since this fails silently and the wrong results can be pretty subtle (as the example above hopefully illustrates). For example, it popped up in one of my simulations and it took me a while to even realize what was happening, let alone figure out the solution. My main question is: is this expected behavior? If so, should we somehow warn users (or even throw an error) do avoid mistakes?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931
https://github.com/CliMA/Oceananigans.jl/issues/2931:1293,Energy Efficiency,schedul,schedule,1293,"julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(size=(16, 16, 16), extent = (500, 500, 120)). n_tracers = 6; tracer_symbols = [ Symbol(:τ,i) for i in 1:n_tracers ]; model = NonhydrostaticModel(; grid, tracers = (tracer_symbols...,)); @info model. uᵢ(x, y, z) = 1e-2 * randn(); set!(model, w=uᵢ). tracer_IC_odd(x, y, z) = sin(2π*z/grid.Lz); for i in 1:n_tracers; @info ""Setting tracer $i""; expression = Meta.parse(""set!(model, τ$i=tracer_IC_odd)""); eval(expression); end. simulation = Simulation(model, Δt=30, stop_time=0.15hours). u, v, w = model.velocities. wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, which in some cases (my case for example) is very important. - Not pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931
https://github.com/CliMA/Oceananigans.jl/issues/2931:2900,Safety,avoid,avoid,2900,"l(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, which in some cases (my case for example) is very important. - Not passing the `indices` flag (i.e. writing 3D fields instead slices) apparently gets rid of this issue. Here, even though the obvious easy solution is to separate averages from slices when writing, a user wouldn't know that since this fails silently and the wrong results can be pretty subtle (as the example above hopefully illustrates). For example, it popped up in one of my simulations and it took me a while to even realize what was happening, let alone figure out the solution. My main question is: is this expected behavior? If so, should we somehow warn users (or even throw an error) do avoid mistakes?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931
https://github.com/CliMA/Oceananigans.jl/issues/2931:1282,Testability,TEST,TEST,1282,"he fluxes using the `indices` flag, and an y-average of them:. ```julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(size=(16, 16, 16), extent = (500, 500, 120)). n_tracers = 6; tracer_symbols = [ Symbol(:τ,i) for i in 1:n_tracers ]; model = NonhydrostaticModel(; grid, tracers = (tracer_symbols...,)); @info model. uᵢ(x, y, z) = 1e-2 * randn(); set!(model, w=uᵢ). tracer_IC_odd(x, y, z) = sin(2π*z/grid.Lz); for i in 1:n_tracers; @info ""Setting tracer $i""; expression = Meta.parse(""set!(model, τ$i=tracer_IC_odd)""); eval(expression); end. simulation = Simulation(model, Δt=30, stop_time=0.15hours). u, v, w = model.velocities. wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, wh",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931
https://github.com/CliMA/Oceananigans.jl/pull/2933:30,Testability,test,test,30,Closes #2931 . We could add a test...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2933
https://github.com/CliMA/Oceananigans.jl/pull/2934:59,Modifiability,variab,variable,59,"This PR changes ~two things~ about the BBL example:. - The variable `κ` was used for both the von Karman constant and for the eddy diffusivity. Now it's just used for the von Karman constant; - ~When calling `NonhydrostaticModel` we were using ordered arguments, which could make a new user interpret that they should know the order of the arguments when calling `NonhydrostaticModel`. Now this call is made in a more usual way with keyword arguments, where the order doesn't matter.~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2934
https://github.com/CliMA/Oceananigans.jl/issues/2935:1098,Energy Efficiency,schedul,schedule,1098,"blow up. This can be illustrated with the following example:. ```julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(topology = (Periodic, Flat, Bounded), size = (64, 32), x = (0, 400), z = (0, 100)). model = NonhydrostaticModel(; grid, timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; buoyancy = BuoyancyTracer(),; tracers = :b,; ). noise(x, y, z) = 1e-6 * rand(); @inline constant_stratification(x, y, z) = 1e-5 * z; set!(model, u = noise, b = constant_stratification). using Statistics: mean; model.velocities.u.data.parent .-= mean(model.velocities.u). simulation = Simulation(model, Δt = 100, stop_time = 1day); wizard = TimeStepWizard(max_change=1.1, cfl=0.7); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(4)). B = Field(model.tracers.b + model.background_fields.tracers.b); simulation.output_writers[:fields] = NetCDFOutputWriter(model, (; model.velocities..., B);; filename = ""bbl.nc"",; schedule = TimeInterval(10minutes),; overwrite_existing = true); run!(simulation); ```. The example above sets up a 2D (xz) domain in which `b` is initially (stably) linearly stratified . All the boundary conditions are default, and the only other IC modification is to add a zero-mean small-scale noise (1e-6 m/s) to `u`. I'd expect this to remain quasi-quiescent. Instead, this is what I get:. https://user-images.githubusercontent.com/13205162/220440495-ab5466f3-5ad9-4c68-81c2-5ada1b422318.mp4. The code to plot the animation can be found [here](https://pastebin.com/ZB41VFPE). The same thing happens when `b=0` initially and the linear stratification is instead included as a `BackgroundVelocity`. For example, if I remove the drag boundary condition from the [tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/#) and add the same zero-mean noise, the same issue happens:. https://user-images.githubusercontent.com/13205162/220441379-9f8c83ce-2414-45e1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935
https://github.com/CliMA/Oceananigans.jl/issues/2935:2811,Testability,test,test,2811,"nitially (stably) linearly stratified . All the boundary conditions are default, and the only other IC modification is to add a zero-mean small-scale noise (1e-6 m/s) to `u`. I'd expect this to remain quasi-quiescent. Instead, this is what I get:. https://user-images.githubusercontent.com/13205162/220440495-ab5466f3-5ad9-4c68-81c2-5ada1b422318.mp4. The code to plot the animation can be found [here](https://pastebin.com/ZB41VFPE). The same thing happens when `b=0` initially and the linear stratification is instead included as a `BackgroundVelocity`. For example, if I remove the drag boundary condition from the [tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/#) and add the same zero-mean noise, the same issue happens:. https://user-images.githubusercontent.com/13205162/220441379-9f8c83ce-2414-45e1-960e-1758dee6fe65.mp4. [Here's the code for the example above.](https://pastebin.com/DUbgqtF5). I understand that hydrostatic balance in a mathematical sense doesn't exactly translate directly to a discrete system (since the forces might not exactly cancel due to the discretization, interpolation, etc.), but I also don't expect deviations from it that are this large and keep amplifying. In fact, what led me here was some pretty strange behavior that I'm experiencing in one of my simulations where internal waves seem to appear out of nowhere, so I believe this is relevant. Am I missing something here? Or is this a bug?. An important note is that we used to have a test that spun up a simulation much like the one above, ran it for a few hours, and made sure that there wasn't any movement. That test used to pass but was remove because it was too computationally-expensive. So I think this issue might have been introduced relatively recently. EDIT:. Note that this happens even when the added noise is (on average) well below the machine epsilon (for example for `noise(x, y, z) = 1e-18 * rand()`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935
https://github.com/CliMA/Oceananigans.jl/issues/2935:2942,Testability,test,test,2942,"nitially (stably) linearly stratified . All the boundary conditions are default, and the only other IC modification is to add a zero-mean small-scale noise (1e-6 m/s) to `u`. I'd expect this to remain quasi-quiescent. Instead, this is what I get:. https://user-images.githubusercontent.com/13205162/220440495-ab5466f3-5ad9-4c68-81c2-5ada1b422318.mp4. The code to plot the animation can be found [here](https://pastebin.com/ZB41VFPE). The same thing happens when `b=0` initially and the linear stratification is instead included as a `BackgroundVelocity`. For example, if I remove the drag boundary condition from the [tilted bottom boundary layer example](https://clima.github.io/OceananigansDocumentation/stable/generated/tilted_bottom_boundary_layer/#) and add the same zero-mean noise, the same issue happens:. https://user-images.githubusercontent.com/13205162/220441379-9f8c83ce-2414-45e1-960e-1758dee6fe65.mp4. [Here's the code for the example above.](https://pastebin.com/DUbgqtF5). I understand that hydrostatic balance in a mathematical sense doesn't exactly translate directly to a discrete system (since the forces might not exactly cancel due to the discretization, interpolation, etc.), but I also don't expect deviations from it that are this large and keep amplifying. In fact, what led me here was some pretty strange behavior that I'm experiencing in one of my simulations where internal waves seem to appear out of nowhere, so I believe this is relevant. Am I missing something here? Or is this a bug?. An important note is that we used to have a test that spun up a simulation much like the one above, ran it for a few hours, and made sure that there wasn't any movement. That test used to pass but was remove because it was too computationally-expensive. So I think this issue might have been introduced relatively recently. EDIT:. Note that this happens even when the added noise is (on average) well below the machine epsilon (for example for `noise(x, y, z) = 1e-18 * rand()`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935
https://github.com/CliMA/Oceananigans.jl/pull/2936:0,Testability,Test,Testing,0,"Testing this branch vs main in a 3D example with `momentum_advection = VectorInvariant(vorticity_scheme = WENO(), divergence_scheme = WENO(), vertical_scheme = WENO())` and `tracer_advection = WENO()`. This branch:; ![Screenshot 2023-02-21 at 4 34 22 PM](https://user-images.githubusercontent.com/33547697/220463656-0ab7389b-2dc1-415e-98d1-c2d772b0b302.png). Main:; ![Screenshot 2023-02-21 at 4 34 02 PM](https://user-images.githubusercontent.com/33547697/220463630-48b3c9a1-f18c-4623-99e0-b383adeed088.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2936
https://github.com/CliMA/Oceananigans.jl/pull/2938:38,Availability,checkpoint,checkpoint,38,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:407,Availability,checkpoint,checkpointer,407,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:506,Availability,error,error,506,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:593,Availability,error,error,593,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:913,Availability,checkpoint,checkpointer,913,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:929,Availability,checkpoint,checkpointer,929,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:944,Availability,Checkpoint,Checkpointer,944,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:1007,Availability,checkpoint,checkpoint,1007,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:1102,Availability,checkpoint,checkpointer,1102,"tional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:1976,Availability,checkpoint,checkpoint,1976,"r = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:2062,Availability,checkpoint,checkpointer,2062,"OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:2120,Availability,checkpoint,checkpoint,2120,"heckpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:2206,Availability,checkpoint,checkpointer,2206,"rs)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:2279,Availability,checkpoint,checkpoint,2279,"e tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:2365,Availability,checkpoint,checkpointer,2365,"rs); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:2438,Availability,checkpoint,checkpoint,2438," Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:2524,Availability,checkpoint,checkpointer,2524,"s branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:3966,Availability,error,error,3966,"oint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 4] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; ```. One option to add safety is to modify `set!(model, filepath::AbstractString)` to take an option argument `skip_missing_variables = false` (or something), which would change the behavior from throwing a warning to throwing an error. @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:972,Energy Efficiency,schedul,schedule,972,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:376,Modifiability,variab,variable,376,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:489,Modifiability,variab,variable,489,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/pull/2938:3759,Safety,safe,safety,3759,"oint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 4] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; ```. One option to add safety is to modify `set!(model, filepath::AbstractString)` to take an option argument `skip_missing_variables = false` (or something), which would change the behavior from throwing a warning to throwing an error. @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938
https://github.com/CliMA/Oceananigans.jl/issues/2940:191,Availability,error,error,191,"Hello,; I noticed a vertically irregular grid can be passed to a nonhydrostatic model and seems to run without a problem, but when the same formulation is applied to the horizontal, a method error is returned by the PressureSolver. The error persists if either the FFTBasedPoissonSolver or the FourierTridiagonalPoissonSolver are called. Is this a known issue?. A MWE follows. Notice the MWE is a reduction of the example given in the [grid documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/), which also gives back the same error when passed to a nonhydrostatic model.; ``` ; using Oceananigans. Lx, Ly, Lz = 1e4, 1e4, 1e3;; Nx, Ny, Nz = 64, 64, 32;; chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny). grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = (-Lz,0); ). model = NonhydrostaticModel(; grid); ```. Gives:; ``` ; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, ; Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:23; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:24; PressureSolver(::Any, ::ImmersedBoundaryGrid) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\Nonhydrosta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2940
https://github.com/CliMA/Oceananigans.jl/issues/2940:236,Availability,error,error,236,"Hello,; I noticed a vertically irregular grid can be passed to a nonhydrostatic model and seems to run without a problem, but when the same formulation is applied to the horizontal, a method error is returned by the PressureSolver. The error persists if either the FFTBasedPoissonSolver or the FourierTridiagonalPoissonSolver are called. Is this a known issue?. A MWE follows. Notice the MWE is a reduction of the example given in the [grid documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/), which also gives back the same error when passed to a nonhydrostatic model.; ``` ; using Oceananigans. Lx, Ly, Lz = 1e4, 1e4, 1e3;; Nx, Ny, Nz = 64, 64, 32;; chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny). grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = (-Lz,0); ). model = NonhydrostaticModel(; grid); ```. Gives:; ``` ; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, ; Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:23; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:24; PressureSolver(::Any, ::ImmersedBoundaryGrid) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\Nonhydrosta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2940
https://github.com/CliMA/Oceananigans.jl/issues/2940:565,Availability,error,error,565,"Hello,; I noticed a vertically irregular grid can be passed to a nonhydrostatic model and seems to run without a problem, but when the same formulation is applied to the horizontal, a method error is returned by the PressureSolver. The error persists if either the FFTBasedPoissonSolver or the FourierTridiagonalPoissonSolver are called. Is this a known issue?. A MWE follows. Notice the MWE is a reduction of the example given in the [grid documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/), which also gives back the same error when passed to a nonhydrostatic model.; ``` ; using Oceananigans. Lx, Ly, Lz = 1e4, 1e4, 1e3;; Nx, Ny, Nz = 64, 64, 32;; chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny). grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = (-Lz,0); ). model = NonhydrostaticModel(; grid); ```. Gives:; ``` ; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, ; Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:23; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:24; PressureSolver(::Any, ::ImmersedBoundaryGrid) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\Nonhydrosta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2940
https://github.com/CliMA/Oceananigans.jl/issues/2940:958,Availability,ERROR,ERROR,958," vertically irregular grid can be passed to a nonhydrostatic model and seems to run without a problem, but when the same formulation is applied to the horizontal, a method error is returned by the PressureSolver. The error persists if either the FFTBasedPoissonSolver or the FourierTridiagonalPoissonSolver are called. Is this a known issue?. A MWE follows. Notice the MWE is a reduction of the example given in the [grid documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/), which also gives back the same error when passed to a nonhydrostatic model.; ``` ; using Oceananigans. Lx, Ly, Lz = 1e4, 1e4, 1e3;; Nx, Ny, Nz = 64, 64, 32;; chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny). grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = (-Lz,0); ). model = NonhydrostaticModel(; grid); ```. Gives:; ``` ; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, ; Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:23; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:24; PressureSolver(::Any, ::ImmersedBoundaryGrid) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\Nonhydros",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2940
https://github.com/CliMA/Oceananigans.jl/pull/2945:259,Availability,ERROR,ERROR,259,"When trying to run a LES with a Tuple closure (such as `closure = (ScalarDiffusivity(), SmagorinskyLilly())`), the calculation of a diffusive timescale fails on main:. ```; julia> cell_diffusion_timescale(model.closure, model.diffusivity_fields, model.grid); ERROR: type Tuple has no field νₑ; Stacktrace:; [1] getproperty; @ ./Base.jl:38 [inlined]; [2] cell_diffusion_timescale(closure::SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:b,), Tuple{Float64}}}, diffusivities::Tuple{Nothing, NamedTuple{(:νₑ,), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.Off",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2945
https://github.com/CliMA/Oceananigans.jl/pull/2945:2362,Testability,test,test,2362,"ans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:b,), Tuple{Float64}}}, diffusivities::Tuple{Nothing, NamedTuple{(:νₑ,), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.TurbulenceClosures /glade/work/tomasc/.julia/packages/Oceananigans/yF0dQ/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:51; ```. This PR fixes that and generalizes a test so that this issue can be caught in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2945
https://github.com/CliMA/Oceananigans.jl/pull/2946:28,Availability,error,error,28,This PR adds an informative error when a grid with non-regularly spaced $x$ or $y$ dimensions is provided in the `NonhydrostaticModel`. Closes #2940,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2946
https://github.com/CliMA/Oceananigans.jl/pull/2949:325,Testability,test,tests,325,"Hello,; This branch contains my group's efforts to make Oceananigans.jl work with AMDGPU.jl as well as preliminary ports of PencilFFTs.jl for distributed FFTs on both CUDA and AMD GPUs. It uses a fork of AMDGPU.jl with ROCSparse support. It was working fine until today, when I rebased my fork to master. Now the distributed tests doesn't work on my end. The tests don't work on the master branch either. The rest of the tests should work fine. I need help from the developers to review this code and discuss any CUDA-specific features still remaining, as well as testing the distributed CUDA/ROCM support for FFTs. Thanks. Closes #1546",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949
https://github.com/CliMA/Oceananigans.jl/pull/2949:359,Testability,test,tests,359,"Hello,; This branch contains my group's efforts to make Oceananigans.jl work with AMDGPU.jl as well as preliminary ports of PencilFFTs.jl for distributed FFTs on both CUDA and AMD GPUs. It uses a fork of AMDGPU.jl with ROCSparse support. It was working fine until today, when I rebased my fork to master. Now the distributed tests doesn't work on my end. The tests don't work on the master branch either. The rest of the tests should work fine. I need help from the developers to review this code and discuss any CUDA-specific features still remaining, as well as testing the distributed CUDA/ROCM support for FFTs. Thanks. Closes #1546",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949
https://github.com/CliMA/Oceananigans.jl/pull/2949:421,Testability,test,tests,421,"Hello,; This branch contains my group's efforts to make Oceananigans.jl work with AMDGPU.jl as well as preliminary ports of PencilFFTs.jl for distributed FFTs on both CUDA and AMD GPUs. It uses a fork of AMDGPU.jl with ROCSparse support. It was working fine until today, when I rebased my fork to master. Now the distributed tests doesn't work on my end. The tests don't work on the master branch either. The rest of the tests should work fine. I need help from the developers to review this code and discuss any CUDA-specific features still remaining, as well as testing the distributed CUDA/ROCM support for FFTs. Thanks. Closes #1546",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949
https://github.com/CliMA/Oceananigans.jl/pull/2949:564,Testability,test,testing,564,"Hello,; This branch contains my group's efforts to make Oceananigans.jl work with AMDGPU.jl as well as preliminary ports of PencilFFTs.jl for distributed FFTs on both CUDA and AMD GPUs. It uses a fork of AMDGPU.jl with ROCSparse support. It was working fine until today, when I rebased my fork to master. Now the distributed tests doesn't work on my end. The tests don't work on the master branch either. The rest of the tests should work fine. I need help from the developers to review this code and discuss any CUDA-specific features still remaining, as well as testing the distributed CUDA/ROCM support for FFTs. Thanks. Closes #1546",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2949
https://github.com/CliMA/Oceananigans.jl/pull/2953:316,Modifiability,variab,variables,316,"Overlapping MPI communication and computation in the `HydrostaticFreeSurfaceModel`. In particular, this PR introduces the `async` keyword argument to `fill_halo_regions!` that allows launching MPI operations without waiting for the communication to complete. ; This allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an _interior_ kernel that calculates tendencies between `H` and `N-H`, and a _boundary_ kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries. This PR is contingent on #2924 . Closes #615; Closes #1882",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953
https://github.com/CliMA/Oceananigans.jl/pull/2953:377,Modifiability,variab,variables,377,"Overlapping MPI communication and computation in the `HydrostaticFreeSurfaceModel`. In particular, this PR introduces the `async` keyword argument to `fill_halo_regions!` that allows launching MPI operations without waiting for the communication to complete. ; This allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an _interior_ kernel that calculates tendencies between `H` and `N-H`, and a _boundary_ kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries. This PR is contingent on #2924 . Closes #615; Closes #1882",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953
https://github.com/CliMA/Oceananigans.jl/issues/2956:27,Testability,test,tests,27,"This function lives in the tests but is never used in the tests, right?. https://github.com/CliMA/Oceananigans.jl/blob/acb298b7f7447747e9f4bcb1ffbbfbe09d9f3d98/test/test_netcdf_output_writer.jl#L14-L46. In fact the whole of this file. I remember some issues with NetCDF at some point on linux machines -- was this why this test was removed?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2956
https://github.com/CliMA/Oceananigans.jl/issues/2956:58,Testability,test,tests,58,"This function lives in the tests but is never used in the tests, right?. https://github.com/CliMA/Oceananigans.jl/blob/acb298b7f7447747e9f4bcb1ffbbfbe09d9f3d98/test/test_netcdf_output_writer.jl#L14-L46. In fact the whole of this file. I remember some issues with NetCDF at some point on linux machines -- was this why this test was removed?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2956
https://github.com/CliMA/Oceananigans.jl/issues/2956:160,Testability,test,test,160,"This function lives in the tests but is never used in the tests, right?. https://github.com/CliMA/Oceananigans.jl/blob/acb298b7f7447747e9f4bcb1ffbbfbe09d9f3d98/test/test_netcdf_output_writer.jl#L14-L46. In fact the whole of this file. I remember some issues with NetCDF at some point on linux machines -- was this why this test was removed?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2956
https://github.com/CliMA/Oceananigans.jl/issues/2956:323,Testability,test,test,323,"This function lives in the tests but is never used in the tests, right?. https://github.com/CliMA/Oceananigans.jl/blob/acb298b7f7447747e9f4bcb1ffbbfbe09d9f3d98/test/test_netcdf_output_writer.jl#L14-L46. In fact the whole of this file. I remember some issues with NetCDF at some point on linux machines -- was this why this test was removed?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2956
https://github.com/CliMA/Oceananigans.jl/pull/2964:501,Integrability,interface,interface,501,"This PR gets rid of the kwargs `computed_dependencies` and `parameters`. Instead we just have ""arguments"", which are varargs to the constructor:. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, u, v); ```. `compute!` on `KernelFunctionOperation` calls `compute!` on all of the kernel arguments. I think this is a simpler and more intuitive interface leading to more understandable code.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2964
https://github.com/CliMA/Oceananigans.jl/pull/2964:474,Usability,simpl,simpler,474,"This PR gets rid of the kwargs `computed_dependencies` and `parameters`. Instead we just have ""arguments"", which are varargs to the constructor:. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, u, v); ```. `compute!` on `KernelFunctionOperation` calls `compute!` on all of the kernel arguments. I think this is a simpler and more intuitive interface leading to more understandable code.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2964
https://github.com/CliMA/Oceananigans.jl/pull/2964:491,Usability,intuit,intuitive,491,"This PR gets rid of the kwargs `computed_dependencies` and `parameters`. Instead we just have ""arguments"", which are varargs to the constructor:. ```julia; using Oceananigans.Operators: ζ₃ᶠᶠᶜ # called with signature ζ₃ᶠᶠᶜ(i, j, k, grid, u, v). grid = model.grid; u, v, w = model.velocities. ζ_op = KernelFunctionOperation{Face, Face, Center}(ζ₃ᶠᶠᶜ, grid, u, v); ```. `compute!` on `KernelFunctionOperation` calls `compute!` on all of the kernel arguments. I think this is a simpler and more intuitive interface leading to more understandable code.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2964
https://github.com/CliMA/Oceananigans.jl/pull/2965:176,Testability,test,tested,176,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.8` to `0.8, 0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2965
https://github.com/CliMA/Oceananigans.jl/pull/2965:282,Testability,test,tests,282,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.8` to `0.8, 0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2965
https://github.com/CliMA/Oceananigans.jl/pull/2966:13,Deployability,update,update,13,It's time to update some dependencies :),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2966
https://github.com/CliMA/Oceananigans.jl/pull/2966:25,Integrability,depend,dependencies,25,It's time to update some dependencies :),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2966
https://github.com/CliMA/Oceananigans.jl/issues/2967:391,Modifiability,extend,extend,391,"Opening this request as per the Slack conversation. Sometimes file sizes become very big (and thus are not easy to transfer, etc.), and so quite often it would probably be good to split data files according to time intervals. So something with API like; ```; split_file = Filesize(10Mb). split_file = TimeInterval(10days); ```. Is there any specific things that should be noted if we are to extend the `start_next_file()` functionality to NetCDF as well instead of just JLD2? Like any flags or things that I should note.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967
https://github.com/CliMA/Oceananigans.jl/pull/2972:225,Availability,error,errors,225,"To do:. - [ ] Add docs for `UpwindBiased` reconstruction; - [ ] Refactor `UpwindBiased` to get rid of ""coeffs"" for stretched grids; - [ ] Fix up docs for `WENO`; - [ ] Clean up constructors for advection schemes; - [ ] Throw errors in advection scheme constructors if the grid halo is too small. Resolves #2717",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2972
https://github.com/CliMA/Oceananigans.jl/pull/2972:64,Modifiability,Refactor,Refactor,64,"To do:. - [ ] Add docs for `UpwindBiased` reconstruction; - [ ] Refactor `UpwindBiased` to get rid of ""coeffs"" for stretched grids; - [ ] Fix up docs for `WENO`; - [ ] Clean up constructors for advection schemes; - [ ] Throw errors in advection scheme constructors if the grid halo is too small. Resolves #2717",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2972
https://github.com/CliMA/Oceananigans.jl/pull/2975:36,Modifiability,extend,extend,36,Closes #2507. . This PR attempts to extend shallow water system to multiple layers.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975
https://github.com/CliMA/Oceananigans.jl/pull/2975:76,Modifiability,layers,layers,76,Closes #2507. . This PR attempts to extend shallow water system to multiple layers.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975
https://github.com/CliMA/Oceananigans.jl/pull/2979:524,Energy Efficiency,meter,meters,524,"This PR makes `node` and `nodes` return the native coordinates of the grid. It changes the behavior of `x/ynode(s)`. Now `x/ynode(s)` _always_ returns `x/y` distances. The PR also introduces `λ/φnode(s)` for curvilinear grids. This way, now `node(s)` behaviour didn't change. But now they return:. - `(xnode(s), ynode(s), znode(s))` for RectilinearGrid; - `(λnode(s), φnode(s), znode(s))` for CurvilinearGrids. Note that still there are `x/y/znode(s)` methods _for all grids_ and those methods actually return distances (in meters). Before this PR when `ynode` called on, e.g., a LatitudeLongitude grid would return latitude in degrees and this was tad confusing. Closes #2978",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2979
https://github.com/CliMA/Oceananigans.jl/issues/2981:285,Performance,load,load,285,"The grids define their own `R_Earth`.; https://github.com/CliMA/Oceananigans.jl/blob/e881faee3de5f17cb382cd61e2b43c2069cadde7/src/Grids/latitude_longitude_grid.jl#L3. The `Coriolis` module defines another one... Perhaps we should have a module `Constants`, add everything in there and load it first? This potentially would come handy when we try to couple?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2981
https://github.com/CliMA/Oceananigans.jl/issues/2982:410,Integrability,interface,interface,410,"Currently the number of barotropic substeps have to be calculated in advance, and the user must manually calculate the CFL constraint. However, the SplitExplicitFreeSurface _specifies_ gravitational acceleration (and knows the grid); therefore the CFL condition can be calculated internally. Moreover it should be possible to ensure integer substeps on the fly, rather than precalculating. I think a nice user interface would be something like. ```julia; free_surface = SplitExplicitFreeSurface(gravitational_acceleration=9.81, cfl=0.7); ```. (with both defaults). Then the number of barotropic time-steps required to (1) meet the specified CFL constraint and (2) ensure integer number of substeps relative to a baroclinic substep would be calculated on the fly. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2982
https://github.com/CliMA/Oceananigans.jl/issues/2983:24,Availability,error,error,24,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983
https://github.com/CliMA/Oceananigans.jl/issues/2983:36,Availability,ERROR,ERROR,36,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983
https://github.com/CliMA/Oceananigans.jl/issues/2983:259,Availability,error,error,259,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983
https://github.com/CliMA/Oceananigans.jl/issues/2983:43,Performance,Load,LoadError,43,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983
https://github.com/CliMA/Oceananigans.jl/issues/2983:209,Usability,clear,clear,209,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983
https://github.com/CliMA/Oceananigans.jl/pull/2985:29,Deployability,update,update,29,@simone-silvestri I tried to update this script but still it won't run. Could you have a look?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985
https://github.com/CliMA/Oceananigans.jl/issues/2986:122,Deployability,update,updated,122,"I tried running two examples in the docstring of `netcdf_output_writer.jl` and found something that I believe needs to be updated. [Line 274](https://github.com/CliMA/Oceananigans.jl/blob/2001a7fae296977608378223045bf46e24ea2853/src/OutputWriters/netcdf_output_writer.jl#L274), defines the nodes but this didn't work for me. I believe we should change it to the following:. `xC, yF = xnodes(Center, grid), ynodes(Face, grid)`. Also, it might helpful to add this line at the beginning, as otherwise, the example does not run,. `using Oceananigans.Grids: xnodes, ynodes, znodes`. If people agree with this I can make the changes but thought I would suggest it before creating a PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2986
https://github.com/CliMA/Oceananigans.jl/issues/2988:285,Availability,ERROR,ERROR,285,"This code:. ```julia; using Oceananigans; using Oceananigans.Grids: with_halo. underlying_grid = RectilinearGrid(size=(3, 3, 3), x=(0, 2), y=(0, 1), z=(0, 1)); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> x)). with_halo((4, 4, 4), grid); ```. produces. ```; ERROR: LoadError: ArgumentError: The dimensions of the immersed boundary (9, 9) do not match the grid size (11, 11); Stacktrace:; [1] validate_ib_size; @ ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92 [inlined]; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2988
https://github.com/CliMA/Oceananigans.jl/issues/2988:292,Performance,Load,LoadError,292,"This code:. ```julia; using Oceananigans; using Oceananigans.Grids: with_halo. underlying_grid = RectilinearGrid(size=(3, 3, 3), x=(0, 2), y=(0, 1), z=(0, 1)); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> x)). with_halo((4, 4, 4), grid); ```. produces. ```; ERROR: LoadError: ArgumentError: The dimensions of the immersed boundary (9, 9) do not match the grid size (11, 11); Stacktrace:; [1] validate_ib_size; @ ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92 [inlined]; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2988
https://github.com/CliMA/Oceananigans.jl/issues/2988:2185,Testability,test,test,2185,"[inlined]; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/ImmersedBoundaries.jl:140; [4] top-level scope; @ ~/Desktop/test.jl:9; [5] include(fname::String); @ Base.MainInclude ./client.jl:476; [6] top-level scope; @ REPL[10]:1; [7] top-level scope; @ ~/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```. This prevents us from writing `WENO(immersed_boundary_grid)`, since `with_halo` is used by `WENO` to calculate reconstruction coefficients for stretched grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2988
https://github.com/CliMA/Oceananigans.jl/pull/2989:111,Integrability,interface,interface,111,"This PR adds a docstring for `ImmersedBoundaryGrid` that includes the `active_cells_map` feature. It moves the interface to the top-level, and fixes `with_halo` to work with the new interface. We should add a test for `with_halo` with `ImmersedBoundaryGrid`. resolves #2988",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2989
https://github.com/CliMA/Oceananigans.jl/pull/2989:182,Integrability,interface,interface,182,"This PR adds a docstring for `ImmersedBoundaryGrid` that includes the `active_cells_map` feature. It moves the interface to the top-level, and fixes `with_halo` to work with the new interface. We should add a test for `with_halo` with `ImmersedBoundaryGrid`. resolves #2988",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2989
https://github.com/CliMA/Oceananigans.jl/pull/2989:209,Testability,test,test,209,"This PR adds a docstring for `ImmersedBoundaryGrid` that includes the `active_cells_map` feature. It moves the interface to the top-level, and fixes `with_halo` to work with the new interface. We should add a test for `with_halo` with `ImmersedBoundaryGrid`. resolves #2988",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2989
https://github.com/CliMA/Oceananigans.jl/pull/2990:508,Testability,test,tests,508,"This is the second attempt at flipping the sign of `gravity_unit_vector`. The first attempt (https://github.com/CliMA/Oceananigans.jl/pull/2963) had an issue where the doctests were getting stuck with no apparent cause. For this attempt, I proceeded more carefully, step by step to try and pinpoint what was happening. The good news is that the doctests are now passing locally. The bad news is that I still don't know why they were getting stuck in https://github.com/CliMA/Oceananigans.jl/pull/2963. Since tests pass locally for me (I tested everything except the examples) I'm hopefully that this time they'll also pass on buildkite. @navidcy your modifications to https://github.com/CliMA/Oceananigans.jl/pull/2963 are also included here!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2990
https://github.com/CliMA/Oceananigans.jl/pull/2990:537,Testability,test,tested,537,"This is the second attempt at flipping the sign of `gravity_unit_vector`. The first attempt (https://github.com/CliMA/Oceananigans.jl/pull/2963) had an issue where the doctests were getting stuck with no apparent cause. For this attempt, I proceeded more carefully, step by step to try and pinpoint what was happening. The good news is that the doctests are now passing locally. The bad news is that I still don't know why they were getting stuck in https://github.com/CliMA/Oceananigans.jl/pull/2963. Since tests pass locally for me (I tested everything except the examples) I'm hopefully that this time they'll also pass on buildkite. @navidcy your modifications to https://github.com/CliMA/Oceananigans.jl/pull/2963 are also included here!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2990
https://github.com/CliMA/Oceananigans.jl/pull/3014:87,Usability,usab,usable,87,"This PR cleans up / shortens code for `FieldTimeSeries` and makes the `OnDisk` backend usable. In a future PR I think we'll need a ""partially in memory"" abstraction, ie chunked data retrieval.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3014
https://github.com/CliMA/Oceananigans.jl/pull/3015:91,Energy Efficiency,schedul,schedules,91,"This PR homogenizes the interface for initializing things: models, simulations, callbacks, schedules. It also makes it so `SpecifiedTimes` schedules do not actuate at iteration 0 unless time=0 is contained in the schedule. Closes #2719",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015
https://github.com/CliMA/Oceananigans.jl/pull/3015:139,Energy Efficiency,schedul,schedules,139,"This PR homogenizes the interface for initializing things: models, simulations, callbacks, schedules. It also makes it so `SpecifiedTimes` schedules do not actuate at iteration 0 unless time=0 is contained in the schedule. Closes #2719",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015
https://github.com/CliMA/Oceananigans.jl/pull/3015:213,Energy Efficiency,schedul,schedule,213,"This PR homogenizes the interface for initializing things: models, simulations, callbacks, schedules. It also makes it so `SpecifiedTimes` schedules do not actuate at iteration 0 unless time=0 is contained in the schedule. Closes #2719",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015
https://github.com/CliMA/Oceananigans.jl/pull/3015:24,Integrability,interface,interface,24,"This PR homogenizes the interface for initializing things: models, simulations, callbacks, schedules. It also makes it so `SpecifiedTimes` schedules do not actuate at iteration 0 unless time=0 is contained in the schedule. Closes #2719",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3015
https://github.com/CliMA/Oceananigans.jl/pull/3017:170,Testability,test,tested,170,"This pull request changes the compat entry for the `CUDA` package from `3.8, 3.9` to `3.8, 3.9, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3017
https://github.com/CliMA/Oceananigans.jl/pull/3017:276,Testability,test,tests,276,"This pull request changes the compat entry for the `CUDA` package from `3.8, 3.9` to `3.8, 3.9, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3017
https://github.com/CliMA/Oceananigans.jl/pull/3018:176,Testability,test,tested,176,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.8` to `0.8, 0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3018
https://github.com/CliMA/Oceananigans.jl/pull/3018:282,Testability,test,tests,282,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.8` to `0.8, 0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3018
https://github.com/CliMA/Oceananigans.jl/issues/3020:333,Availability,recover,recover,333,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:685,Availability,recover,recover,685,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:333,Safety,recover,recover,333,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:685,Safety,recover,recover,685,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:208,Testability,Test,Test,208,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:278,Testability,Test,Test,278,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:382,Testability,test,tests,382,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:560,Testability,Test,Test,560,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:630,Testability,Test,Test,630,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3020:734,Testability,test,tests,734,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020
https://github.com/CliMA/Oceananigans.jl/issues/3021:12,Testability,test,test,12,Implement a test that simply inspects the halos for correctness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3021
https://github.com/CliMA/Oceananigans.jl/issues/3021:22,Usability,simpl,simply,22,Implement a test that simply inspects the halos for correctness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3021
https://github.com/CliMA/Oceananigans.jl/issues/3025:712,Availability,ERROR,ERROR,712,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:93,Deployability,update,updated,93,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:2390,Deployability,Continuous,ContinuousForcing,2390,"cePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to jl_f_getfield); Stacktrace:; [1] getindex; @ ./namedtuple.jl:136; [2] field_arguments; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Utils/user_function_arguments.jl:1; [3] user_function_arguments; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Utils/user_function_arguments.jl:21; [4] ContinuousForcing; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Forcings/continuous_forcing.jl:118; [5] u_velocity_tendency; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:64; [6] macr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:3163,Deployability,Continuous,ContinuousForcing,3163,"{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to jl_f_getfield); Stacktrace:; [1] getindex; @ ./namedtuple.jl:136; [2] field_arguments; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Utils/user_function_arguments.jl:1; [3] user_function_arguments; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Utils/user_function_arguments.jl:21; [4] ContinuousForcing; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Forcings/continuous_forcing.jl:118; [5] u_velocity_tendency; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:64; [6] macro expansion; @ /glade/work/tomasc/.julia/packages/Oceananigans/Zg9Bd/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:134; [7] gpu_calculate_Gu!; @ /glade/work/tomasc/.julia/packages/KernelAbstractions/C8flJ/src/macros.jl:81; [8] gpu_calculate_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:5680,Deployability,Continuous,ContinuousForcing,5680,"stractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/S3TWf/src/validation.jl:141; ```. Changing the forcing function so as to not depend on `u` also makes it pass on the GPU, so the issue seems to be when getting the forcing function arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:6215,Integrability,depend,depend,6215,"stractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/S3TWf/src/validation.jl:141; ```. Changing the forcing function so as to not depend on `u` also makes it pass on the GPU, so the issue seems to be when getting the forcing function arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:73,Modifiability,variab,variables,73,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:169,Modifiability,variab,variable,169,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:719,Performance,Load,LoadError,719,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/issues/3025:6148,Security,validat,validation,6148,"stractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(), Tuple{}}, NamedTuple{(:a,), Tuple{Int64}}, Nothing, NamedTuple{(:u, :v, :w, :a), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, Nothing, typeof(forc_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/S3TWf/src/validation.jl:141; ```. Changing the forcing function so as to not depend on `u` also makes it pass on the GPU, so the issue seems to be when getting the forcing function arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025
https://github.com/CliMA/Oceananigans.jl/pull/3027:1025,Testability,Test,Tests,1025,"I've had a go at fixing #2928 which doesn't seem to be as hard as I thought it would be using @glwagner's idea for `SumOfFields. So far I've only done the nonhydrostatic model kernels but it wasn't much work and looks like its worked. Using the same code as https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1433398895 I now get:. https://user-images.githubusercontent.com/26657828/227528544-2f786e88-4243-40b6-850e-1992b1e2d8d9.mp4. Which I believe is what we were expecting. I wasn't sure where to put the `SumOfFields` struct so currently have it in the `Fields.jl` file. These changes also negate the need for `biogeochemistry_rhs` since we don't need the advection to be with the biogeochemical tendencies (I think we origionally did this so we didn't need to change all of the kernels, but not we have todo that anyway), it does prevent us from using different advection schemes for the `biogeochemical_drift_velocity`. To do:. - [x] Hydrostatic free surface kernels; - [x] Shallow water kernels; - [x] Tests; - [x] Benchmark; - [x] Fix particle advection",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027
https://github.com/CliMA/Oceananigans.jl/pull/3027:1038,Testability,Benchmark,Benchmark,1038,"I've had a go at fixing #2928 which doesn't seem to be as hard as I thought it would be using @glwagner's idea for `SumOfFields. So far I've only done the nonhydrostatic model kernels but it wasn't much work and looks like its worked. Using the same code as https://github.com/CliMA/Oceananigans.jl/issues/2928#issuecomment-1433398895 I now get:. https://user-images.githubusercontent.com/26657828/227528544-2f786e88-4243-40b6-850e-1992b1e2d8d9.mp4. Which I believe is what we were expecting. I wasn't sure where to put the `SumOfFields` struct so currently have it in the `Fields.jl` file. These changes also negate the need for `biogeochemistry_rhs` since we don't need the advection to be with the biogeochemical tendencies (I think we origionally did this so we didn't need to change all of the kernels, but not we have todo that anyway), it does prevent us from using different advection schemes for the `biogeochemical_drift_velocity`. To do:. - [x] Hydrostatic free surface kernels; - [x] Shallow water kernels; - [x] Tests; - [x] Benchmark; - [x] Fix particle advection",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027
https://github.com/CliMA/Oceananigans.jl/pull/3030:628,Testability,test,test,628,"On main we are passing the tendency kernel function as an argument to the kernel. ; Apparently, this prevents compilation on the CPU.; Another place where this design was implemented is the vertically implicit solver, where we pass functions to calculate the tridiagonal matrix coefficients. This PR fixes both problems. After this PR we should remember that we cannot pass functions as kernel arguments, ; not even as properties of a struct! Instead we can pass `Val(:function_name)` and dispatch on that to call the correct `function_name` (as implemented in this PR for the vertically implicit solver). Baroclinic adjustment test (with `Nx = Ny = 128, Nz = 10`); on main:; ```julia; [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 870.922 ms, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 16.500 minutes; [ Info: ... simulation initialization complete (957.942 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (19.178 seconds).; [15.28%] i: 20, t: 5.500 hours, wall time: 1.732 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 18.150 minutes; [32.08%] i: 40, t: 11.550 hours, wall time: 1.376 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 19.965 minutes; [50.57%] i: 60, t: 18.205 hours, wall time: 1.333 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 20 minutes; [69.09%] i: 80, t: 1.036 days, wall time: 1.219 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 20 minutes; [87.61%] i: 100, t: 1.314 days, wall time: 1.175 minutes, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 20 minutes; [ Info: Simulation is stopping after running for 7.623 minutes.; [ Info: Simulation time 1.500 days equals or exceeds stop time 1.500 days.; ```. on this PR:; ```julia; [ Info: Initializing simulation...; [00.00%] i: 0, t: 0 seconds, wall time: 9.474 seconds, max(u): (0.000e+00, 0.000e+00, 0.000e+00) m/s, next Δt: 16.500 minutes; [ Info: ... simulation in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030
https://github.com/CliMA/Oceananigans.jl/issues/3031:1459,Testability,test,test,1459," Receiving objects: 100% (103248/103248), 119.80 MiB | 1.54 MiB/s, done.; Resolving deltas: 100% (78348/78348), done.; (base) $ du -sh Oceananigans-6.jl; 131M	Oceananigans-6.jl; ```. I run [a script](https://dev.to/jakecarpenter/shrinking-your-git-repository-with-bfg-repo-cleaner-145e) to find the big files. There are some `.jld2` files in the GitHub repo... and also some `report-....nsys-rep` files.... (@simone-silvestri?). ```; All sizes are in kB's. The pack column is the size of the object, compressed, inside the pack file.; size pack SHA location; 48992 16829 1dd3f4706ebc79549624bee40f78b5aa2c0d644d report-last.sqlite; 48916 16814 839a363a9dd693e35abb48f4822be360ac313a4c report-shared-memory.sqlite; 20694 12212 950954a5d3ef4fac9d6d0480886b95e66d7ec510 report-shufflin.nsys-rep; 20664 12149 283618488234bf4285558c4da6617a6c9583482c report-last.nsys-rep; 20605 12036 1f746e5f46363e656115984a84ddae8003572135 report-shared-memory.nsys-rep; 2465 1984 eeeca1f2b394f43e2547462dc8bbc09d8b2e379d test/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:1569,Testability,log,logger,1569,"l; 131M	Oceananigans-6.jl; ```. I run [a script](https://dev.to/jakecarpenter/shrinking-your-git-repository-with-bfg-repo-cleaner-145e) to find the big files. There are some `.jld2` files in the GitHub repo... and also some `report-....nsys-rep` files.... (@simone-silvestri?). ```; All sizes are in kB's. The pack column is the size of the object, compressed, inside the pack file.; size pack SHA location; 48992 16829 1dd3f4706ebc79549624bee40f78b5aa2c0d644d report-last.sqlite; 48916 16814 839a363a9dd693e35abb48f4822be360ac313a4c report-shared-memory.sqlite; 20694 12212 950954a5d3ef4fac9d6d0480886b95e66d7ec510 report-shufflin.nsys-rep; 20664 12149 283618488234bf4285558c4da6617a6c9583482c report-last.nsys-rep; 20605 12036 1f746e5f46363e656115984a84ddae8003572135 report-shared-memory.nsys-rep; 2465 1984 eeeca1f2b394f43e2547462dc8bbc09d8b2e379d test/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:2256,Testability,test,test,2256,49 283618488234bf4285558c4da6617a6c9583482c report-last.nsys-rep; 20605 12036 1f746e5f46363e656115984a84ddae8003572135 report-shared-memory.nsys-rep; 2465 1984 eeeca1f2b394f43e2547462dc8bbc09d8b2e379d test/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_i,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:2461,Testability,test,test,2461,st/deep_convection_golden_master_model_checkpoint_10.jld; 2229 628 f72f4d2641339222c75da6404a1808dd8e4a8952 logger; 1413 1303 7ef3d2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfd,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:2569,Testability,test,test,2569,2c84f36e91ee7c4988629454c05cc451a6b docs/src/appendix/convergence_plots/cosine_advection_diffusion_solutions.png; 1407 1399 2f48fac8a7f5f0202abd72c6d90a2603c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 47,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:2724,Testability,test,test,2724,03c42b3430 paper/free_convection_and_baroclinic_instability.png; 1319 1220 061ab36b8d442c52e2564826d9c5cbb72462654a docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:2879,Testability,test,test,2879,_plots/cosine_advection_diffusion_solutions.png; 1062 972 841a7461932f5ceefa996d3f993fdda7b8e042ea docs/src/appendix/convergence_plots/gaussian_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/r,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:3021,Testability,test,test,3021,n_advection_diffusion_solutions.png; 990 905 937939cc1ef2ec5ef69a08c6c79b79ac45715af4 docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remo,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:3163,Testability,test,test,3163,n_solutions.png; 924 674 bddab0c2f59062e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you',MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:3328,Testability,test,test,3328,62e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you'd push them back at next `git push`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:3493,Testability,test,test,3493,62e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you'd push them back at next `git push`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:3635,Testability,test,test,3635,62e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you'd push them back at next `git push`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:3777,Testability,test,test,3777,62e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you'd push them back at next `git push`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/issues/3031:3889,Testability,test,test,3889,62e7013b49c582242d338e6cb735 test/regression_tests/data/data_rayleigh_benard_regression.jld2; 796 794 e2cf3b5a147885d73a4262590bf440e35337a8e5 examples/Inertial_Instability_2D_old.mp4; 730 550 0ee7298c84ad9e9fa223824ef3ed9f1584c0695a test/thermal_bubble_golden_master_model_checkpoint_10.jld; 718 505 41f8e56c345f11959fcfc70a545f5abb8cbe0a02 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10000.jld2; 718 506 a7a57fa8fdc70604f81db7062541f065119d44b5 test/regression_tests/data/ocean_large_eddy_simulation_AnisotropicMinimumDissipation_iteration10010.jld2; 718 506 51891abf2cd18ddbc2b2b77af54dd7d9bfd2e71c test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 506 c48525b35c1b6870a2a3594cab85f73dec71787d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 718 479 3519eeb0dea062209f7940c7d5cb6442d2fcdd37 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 718 479 fbf720bf84dcb9a2d2f429187851a7f891989da7 test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 718 479 5b796cdfdf8e792506ea49835ecb81aa5769f52d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; 718 479 ba4645921310e028a606481e85f20c2529f3909d test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 712 496 9765742b042b9df25192c4ddbaf6de02d858b770 test/regression_tests/data/rayleigh_benard_iteration1000.jld2; 712 496 d6932dc59613019ec19000d84700fd8e20fb7ee7 test/regression_tests/data/rayleigh_benard_iteration1100.jld2; ```. I can use [BFG repo-cleaner](https://rtyley.github.io/bfg-repo-cleaner/) to remove those files from the git history of the repo. But **NOTE that everyone would have to delete their local clones after that and reclone**. Otherwise you'd push them back at next `git push`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3031
https://github.com/CliMA/Oceananigans.jl/pull/3035:719,Availability,error,error,719,"This PR fixes the rendering of a LaTeX string and changes `eos = RoquetSeawaterPolynomial(:Freezing)` -> `eos = RoquetEquationOfState(:Freezing)` in the documentation for `buoyancy models and equation of state.md`. The reason for this change is that with the `eos` set as a `RoquetSeawaterPolynomial`,. ```julia; julia> using SeawaterPolynomials.SecondOrderSeawaterPolynomials. julia> eos = RoquetSeawaterPolynomial(:Freezing); 0.7718 Sᴬ - 0.0491 Θ + 0.0 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² - 0.005027 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035
https://github.com/CliMA/Oceananigans.jl/pull/3035:1494,Availability,error,error,1494," Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² - 0.005027 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10Seawate",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035
https://github.com/CliMA/Oceananigans.jl/pull/3035:1598,Availability,avail,available,1598,"rBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/TEOS10.jl:186; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035
https://github.com/CliMA/Oceananigans.jl/pull/3035:1728,Availability,Error,Error,1728,"rBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/TEOS10.jl:186; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035
https://github.com/CliMA/Oceananigans.jl/pull/3035:1856,Availability,error,error,1856,"rBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/TEOS10.jl:186; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035
https://github.com/CliMA/Oceananigans.jl/pull/3035:1617,Deployability,update,updated,1617,"rBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/TEOS10.jl:186; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035
https://github.com/CliMA/Oceananigans.jl/pull/3035:1716,Deployability,update,updated,1716,"rBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/TEOS10.jl:186; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035
https://github.com/CliMA/Oceananigans.jl/issues/3036:1695,Energy Efficiency,schedul,schedule,1695,"(), gravity_unit_vector=-[sin(θ_rad), 0, cos(θ_rad)]),; tracers = :b,; background_fields = (; b=B_field),; ). amp = 1e-3; xₚ = grid.Lx*rand(5); zₚ = -grid.Lz*rand(5) # random locations for 5 gaussians; σx = 4min_Δx(grid); σz = 4min_Δz(grid) # spread of Gaussians; resolved_noise(x, y, z) = sum(@. amp * exp(-(x-xₚ)^2/σx^2 -(z-zₚ)^2/σz^2)); set!(model, u=resolved_noise, w=resolved_noise). u, v, w = model.velocities; b = model.tracers.b. using Statistics: mean; u.data.parent .-= mean(u); w.data.parent .-= mean(w). simulation = Simulation(model, Δt = 0.5 * min_Δz(grid) / maximum(abs, v),; stop_time = 3days). wizard = TimeStepWizard(max_change=1.01, cfl=0.2, diffusive_cfl=0.1, max_Δt=0.2/√N²∞); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(2)). KE = Average((u^2 + w^2) / 2); PE = Average(b^2/(2*N²∞)); outputs = (; u, w, b, KE, PE). simulation.output_writers[:writer] = NetCDFOutputWriter(model, outputs;; filename = ""mwe.nc"",; schedule = TimeInterval(1hour),; with_halos = false,; overwrite_existing = true); run!(simulation). using Rasters, Plots; fpath_xz1 = simulation.output_writers[:writer].filepath; ds_xz1 = RasterStack(fpath_xz1); u_lims = (-amp, +amp). times = dims(ds_xz1, :Ti); anim = @animate for frame in 1:length(times); p1 = heatmap(ds_xz1[:u][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""u""); p2 = heatmap(ds_xz1[:w][Ti=frame, yC=1]', clim=u_lims, c=:balance, title=""w""); p3 = heatmap(ds_xz1[:b][Ti=frame, yC=1]', title=""b""); p4 = plot(ds_xz1[:KE]); plot!(p4, ds_xz1[:PE]); vline!(p4, [times[frame]], label=""time"", linestyle=:dash). fullplot = plot(p1, p2, p3, p4, layout = Plots.grid(2, 2), size=(1000, 600)); end. mp4(anim, ""mwe.mp4"", fps=16). ```. I expected this simulation to slowly lose or approximately conserve total energy. Instead I get these grid-scale noises popping up and a build up of kinetic and potential energy seemingly out of nowhere:. https://user-images.githubusercontent.com/13205162/228424859-905f3dd6-b167-440b-b073-af09008f4f04",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036
