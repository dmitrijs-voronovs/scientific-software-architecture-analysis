id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:1954,Deployability,update,update,1954,"""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we will remember this time, but in general I think this approach doesn't scale, and also does something highly undesirable by placing barriers in the way of development. What do you think @tomchor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:1757,Energy Efficiency,reduce,reduce,1757,"""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we will remember this time, but in general I think this approach doesn't scale, and also does something highly undesirable by placing barriers in the way of development. What do you think @tomchor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:457,Modifiability,extend,extended,457,"I think we should make it a rule that we don't write about experimental and transient features in the docs. I propose that instead we use Discussions and Issues for that. I prefer we make the docs ""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:1307,Modifiability,parameteriz,parameterizations,1307,"""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we will remember this time, but in general I think this approach doesn't scale, and also does something highly undesirable by placing barriers in the way of development. What do you think @tomchor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:545,Safety,avoid,avoiding,545,"I think we should make it a rule that we don't write about experimental and transient features in the docs. I propose that instead we use Discussions and Issues for that. I prefer we make the docs ""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107245548:535,Usability,clear,clear,535,"> > If we all agree, maybe we should add some of that info that I just mentioned to the documentation (ie a statement of purpose for the documentation, and the places to look for other kinds of information). How about that?; > ; > I was about to write that :). But mostly, to elaborate, I think the docs can be ""shaped"" and curated in many ways and still be super useful. What you're proposing is definitely one good way to do it, and I agree especially with your third point. But I think no matter what we decide, we should make that clear somewhere that's relatively easy to find. Following your proposal, we should exclude the references to the PRs and issues and only keep the link to the discussion in this PR. Also we should probably create a discussion for multi-GPUs and link that as well since the distributed discussion that exists rn only focuses on MPI. How does that sounds @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107245548
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107259562:1274,Deployability,update,update,1274,"> > > If we all agree, maybe we should add some of that info that I just mentioned to the documentation (ie a statement of purpose for the documentation, and the places to look for other kinds of information). How about that?; > > ; > > ; > > I was about to write that :); > ; > But mostly, to elaborate, I think the docs can be ""shaped"" and curated in many ways and still be super useful. What you're proposing is definitely one good way to do it, and I agree especially with your third point. But I think no matter what we decide, we should make that clear somewhere that's relatively easy to find.; > ; > Following your proposal, we should exclude the references to the PRs and issues and only keep the link to the discussion in this PR. Also we should probably create a discussion for multi-GPUs and link that as well since the distributed discussion that exists rn only focuses on MPI.; > ; > How does that sounds @glwagner ?. That sounds good, except that there's nothing to discuss yet about multi-GPU so we probably don't need to create a discussion about it. I'd also propose not linking to any specific discussions in the docs. The reason is that the discussions are organic and different threads may rise or fall in importance over time. We don't want to have to update the docs when that happens.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107259562
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107259562:553,Usability,clear,clear,553,"> > > If we all agree, maybe we should add some of that info that I just mentioned to the documentation (ie a statement of purpose for the documentation, and the places to look for other kinds of information). How about that?; > > ; > > ; > > I was about to write that :); > ; > But mostly, to elaborate, I think the docs can be ""shaped"" and curated in many ways and still be super useful. What you're proposing is definitely one good way to do it, and I agree especially with your third point. But I think no matter what we decide, we should make that clear somewhere that's relatively easy to find.; > ; > Following your proposal, we should exclude the references to the PRs and issues and only keep the link to the discussion in this PR. Also we should probably create a discussion for multi-GPUs and link that as well since the distributed discussion that exists rn only focuses on MPI.; > ; > How does that sounds @glwagner ?. That sounds good, except that there's nothing to discuss yet about multi-GPU so we probably don't need to create a discussion about it. I'd also propose not linking to any specific discussions in the docs. The reason is that the discussions are organic and different threads may rise or fall in importance over time. We don't want to have to update the docs when that happens.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107259562
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534:303,Deployability,Integrat,Integrated,303,"I think you have a different vision of what the ""docs"" should be perhaps. Is there maybe another solution that we can entertain? It's just important to understand the ultimate form that this object I am calling the ""documentation"" might have to take. For example check out the documentation for ECMWF's Integrated Forecast System:. https://www.ecmwf.int/en/publications/ifs-documentation. Or the NEMO ocean model:. https://zenodo.org/record/6334656#.YmNicS-B2gQ. We probably will want the docs to be citable, and may also want to submit parts of them as a paper. I'm trying to reduce the amount of work we'll have to do when the time comes around to make that transformation. I also don't want to have to erase this important work and information when we get there. We want to create knowledge in a sustainable way that can persist. So, I also think the information you want to add to the ""knowledge ecosystem"" is very useful, we just have to find the right place to put it. Maybe discussions aren't great for it either and we need another place besides Issues / Discussions / Pull requests for living knowledge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534:577,Energy Efficiency,reduce,reduce,577,"I think you have a different vision of what the ""docs"" should be perhaps. Is there maybe another solution that we can entertain? It's just important to understand the ultimate form that this object I am calling the ""documentation"" might have to take. For example check out the documentation for ECMWF's Integrated Forecast System:. https://www.ecmwf.int/en/publications/ifs-documentation. Or the NEMO ocean model:. https://zenodo.org/record/6334656#.YmNicS-B2gQ. We probably will want the docs to be citable, and may also want to submit parts of them as a paper. I'm trying to reduce the amount of work we'll have to do when the time comes around to make that transformation. I also don't want to have to erase this important work and information when we get there. We want to create knowledge in a sustainable way that can persist. So, I also think the information you want to add to the ""knowledge ecosystem"" is very useful, we just have to find the right place to put it. Maybe discussions aren't great for it either and we need another place besides Issues / Discussions / Pull requests for living knowledge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534:799,Energy Efficiency,sustainab,sustainable,799,"I think you have a different vision of what the ""docs"" should be perhaps. Is there maybe another solution that we can entertain? It's just important to understand the ultimate form that this object I am calling the ""documentation"" might have to take. For example check out the documentation for ECMWF's Integrated Forecast System:. https://www.ecmwf.int/en/publications/ifs-documentation. Or the NEMO ocean model:. https://zenodo.org/record/6334656#.YmNicS-B2gQ. We probably will want the docs to be citable, and may also want to submit parts of them as a paper. I'm trying to reduce the amount of work we'll have to do when the time comes around to make that transformation. I also don't want to have to erase this important work and information when we get there. We want to create knowledge in a sustainable way that can persist. So, I also think the information you want to add to the ""knowledge ecosystem"" is very useful, we just have to find the right place to put it. Maybe discussions aren't great for it either and we need another place besides Issues / Discussions / Pull requests for living knowledge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534:303,Integrability,Integrat,Integrated,303,"I think you have a different vision of what the ""docs"" should be perhaps. Is there maybe another solution that we can entertain? It's just important to understand the ultimate form that this object I am calling the ""documentation"" might have to take. For example check out the documentation for ECMWF's Integrated Forecast System:. https://www.ecmwf.int/en/publications/ifs-documentation. Or the NEMO ocean model:. https://zenodo.org/record/6334656#.YmNicS-B2gQ. We probably will want the docs to be citable, and may also want to submit parts of them as a paper. I'm trying to reduce the amount of work we'll have to do when the time comes around to make that transformation. I also don't want to have to erase this important work and information when we get there. We want to create knowledge in a sustainable way that can persist. So, I also think the information you want to add to the ""knowledge ecosystem"" is very useful, we just have to find the right place to put it. Maybe discussions aren't great for it either and we need another place besides Issues / Discussions / Pull requests for living knowledge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107272534
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576:201,Energy Efficiency,green,green,201,"I think for idealized stuff the hydrostatic model is fairly well tested, but if one wants to do complex domains, problems requiring mixing parameterizations, etc, then our capability is still a little green I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576:139,Modifiability,parameteriz,parameterizations,139,"I think for idealized stuff the hydrostatic model is fairly well tested, but if one wants to do complex domains, problems requiring mixing parameterizations, etc, then our capability is still a little green I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576
https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576:65,Testability,test,tested,65,"I think for idealized stuff the hydrostatic model is fairly well tested, but if one wants to do complex domains, problems requiring mixing parameterizations, etc, then our capability is still a little green I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576
https://github.com/CliMA/Oceananigans.jl/issues/2470#issuecomment-1112673782:44,Security,access,access,44,"Who can edit? I guess those with repo write access, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2470#issuecomment-1112673782
https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285:76,Deployability,Install,Installation-and-getting-started-with-Oceananigans,76,"Do you want to add this here: https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans ? . Let's phase these ""extended instructions"" out of the Documenter-based docs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285
https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285:150,Modifiability,extend,extended,150,"Do you want to add this here: https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans ? . Let's phase these ""extended instructions"" out of the Documenter-based docs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285
https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068879:30,Deployability,install,installation,30,"Actually though these are not installation instructions at all but more ""best practices"". How bout a new wiki page ""Tips and best practices when using Oceananigans""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068879
https://github.com/CliMA/Oceananigans.jl/pull/2474#issuecomment-1109320532:20,Deployability,install,installation,20,I moved much of the installation instructions into. https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments. and a little bit into. https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2474#issuecomment-1109320532
https://github.com/CliMA/Oceananigans.jl/pull/2474#issuecomment-1109320532:225,Deployability,Install,Installation-and-getting-started-with-Oceananigans,225,I moved much of the installation instructions into. https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments. and a little bit into. https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2474#issuecomment-1109320532
https://github.com/CliMA/Oceananigans.jl/pull/2474#issuecomment-1110514716:96,Deployability,update,update,96,I think this is probably ready to merge. The README will need more work soon because we need to update the movies pretty badly with more recent examples (and some sphere stuff too!) So that should be coming relatively soon anyways.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2474#issuecomment-1110514716
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966:104,Deployability,integrat,integrate,104,"But still, I think that you first derive the equation for \eta (after the time discretization) and then integrate in volume. In the end it is still a derivative of a derivative (Following the docs from mitgcm https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html). So the \partial x on the LHS should be correct. You 'll see that the term that doesn't cancel (as you derived above) is contained in the integral of the area. On the other hand, I think we should change the batropic pressure gradient correction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966:104,Integrability,integrat,integrate,104,"But still, I think that you first derive the equation for \eta (after the time discretization) and then integrate in volume. In the end it is still a derivative of a derivative (Following the docs from mitgcm https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html). So the \partial x on the LHS should be correct. You 'll see that the term that doesn't cancel (as you derived above) is contained in the integral of the area. On the other hand, I think we should change the batropic pressure gradient correction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109623966
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145:374,Deployability,integrat,integrated,374,"Actually, I think those docs are misleading. The straightforward way to arrive at the implicit step equation is to first discretize in space, and then after that derive the fractional step method. The key steps are:. 1. Discretize the continuity equation, and then sum in the vertical to obtain the finite-volume discretized free surface equation in terms of the vertically integrated transports; 2. Introduce the predictor velocities in the discretized momentum equation, and then sum the discretized momentum equation in the vertical.; 3. Combine the discretized momentum equation with the free surface equation by taking the divergence of the vertically-summed momentum equation. Steps 2 introduces the vertical sum of the discretized barotropic pressure gradient into the implicit step equation, which is how we see that these two contributions in fact come from the same place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145:374,Integrability,integrat,integrated,374,"Actually, I think those docs are misleading. The straightforward way to arrive at the implicit step equation is to first discretize in space, and then after that derive the fractional step method. The key steps are:. 1. Discretize the continuity equation, and then sum in the vertical to obtain the finite-volume discretized free surface equation in terms of the vertically integrated transports; 2. Introduce the predictor velocities in the discretized momentum equation, and then sum the discretized momentum equation in the vertical.; 3. Combine the discretized momentum equation with the free surface equation by taking the divergence of the vertically-summed momentum equation. Steps 2 introduces the vertical sum of the discretized barotropic pressure gradient into the implicit step equation, which is how we see that these two contributions in fact come from the same place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145:414,Safety,predict,predictor,414,"Actually, I think those docs are misleading. The straightforward way to arrive at the implicit step equation is to first discretize in space, and then after that derive the fractional step method. The key steps are:. 1. Discretize the continuity equation, and then sum in the vertical to obtain the finite-volume discretized free surface equation in terms of the vertically integrated transports; 2. Introduce the predictor velocities in the discretized momentum equation, and then sum the discretized momentum equation in the vertical.; 3. Combine the discretized momentum equation with the free surface equation by taking the divergence of the vertically-summed momentum equation. Steps 2 introduces the vertical sum of the discretized barotropic pressure gradient into the implicit step equation, which is how we see that these two contributions in fact come from the same place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109690145
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687:204,Deployability,integrat,integrated,204,"It just helps to ensure that the discrete continuity equation (and thus discrete conservation of mass) is handled correctly. It's possible that it's not necessary (but it's the reason that the vertically integrated lateral face areas pop up in the numerics). Here are some notes:. <img width=""955"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165295054-4f3205c2-bf71-46b2-947a-b1c23241328e.png"">. <img width=""954"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165296417-38c25dde-5636-40c0-8ed3-6059f9f95740.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687:204,Integrability,integrat,integrated,204,"It just helps to ensure that the discrete continuity equation (and thus discrete conservation of mass) is handled correctly. It's possible that it's not necessary (but it's the reason that the vertically integrated lateral face areas pop up in the numerics). Here are some notes:. <img width=""955"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165295054-4f3205c2-bf71-46b2-947a-b1c23241328e.png"">. <img width=""954"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/165296417-38c25dde-5636-40c0-8ed3-6059f9f95740.png"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109706687
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917:13,Availability,down,down,13,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917:23,Integrability,rout,route,23,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917:415,Usability,clear,clear,415,"What drew me down this route is that the discrete continuity equation involves lateral face areas and so these are what show up when the continuity equation is summed up and the boundary condition is applied to arrive at an equation for dt(eta). It's this equation which is then discretized implicitly in time. Perhaps the most important argument is exactly what we are talking about --- the above derivation makes clear that the terms which arise in the implicit eta equation are indeed the barotropic pressure gradient terms (with some further manipulations). So if one can come to another conclusion by the other method, that is a proof that we cannot switch the order of the discretization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109709917
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:224,Deployability,integrat,integrate,224,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:374,Deployability,integrat,integrate,374,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:478,Deployability,integrat,integration,478,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:599,Energy Efficiency,Green,Green,599,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:722,Energy Efficiency,Green,Green,722,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:802,Energy Efficiency,Green,Green,802,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:224,Integrability,integrat,integrate,224,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:374,Integrability,integrat,integrate,374,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:478,Integrability,integrat,integration,478,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407:81,Usability,clear,clear,81,"I wanted to comment on the first step, just to make sure everything is perfectly clear. The x-component of the momentum equation can be written as. `` ; ∂ₜu + g ∂ₓη = Gₓ; ``. The first step of the finite volume method is to integrate over the volume and then divide by the volume. This leads to . ``; ∂ₜū + g/Vfcc ∭ ∂ₓη dV = 1/Vfcc ∭ G_x dV; ``. So far we all agree. If we integrate the term with the free-surface we don't get a line integral, we get a surface integral. Using integration by parts, second integral yields. ``; ∭ ∂ₓη dV = ∬ [ η ]_{west}^{east} dy dz; ``. Line integrals happen from Green's/Stokes' theorems but those begin with area integrals. Unless you are keeping the vertical integral fixed and using Green's theorem on the horizontal integral over the area?. If you wanted to use Green's Theorem in the horizontal, then I believe you would get. ``; ∭ ∂ₓη dV = ∫ [∮ η dy ] dz; ``. I just want to make sure we are being careful and using the right theorem here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1109830407
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916:232,Deployability,integrat,integrate,232,"I think I have answered my own question. If you think of the momentum equation in terms fo the stress tensor, then in vector form it is. ``; ∂ₜuᵢ - ∂ⱼ⋅σᵢⱼ= 0,; ``. where the second term is the divergence of the stress tensor. If we integrate this over the volume, and divide by the volume then we get upon using **Gauss' Divergence Theorem**. ``; ∂ₜūᵢ =1/Vfcc∭ ∂ⱼ⋅σᵢⱼ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS; ``. In the case of an idea fluid we have `σᵢⱼ=-pδᵢⱼ` and therefore our equation above becomes. ``; ∂ₜūᵢ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS = - 1/Vfcc ∬ p δᵢⱼ⋅ n̂ⱼ dS = - 1/Vfcc ∬ p n̂ᵢ dS; ``. This shows that the desired result follows from application of Gauss' Divergence Theorem on the stress tensor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916
https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916:232,Integrability,integrat,integrate,232,"I think I have answered my own question. If you think of the momentum equation in terms fo the stress tensor, then in vector form it is. ``; ∂ₜuᵢ - ∂ⱼ⋅σᵢⱼ= 0,; ``. where the second term is the divergence of the stress tensor. If we integrate this over the volume, and divide by the volume then we get upon using **Gauss' Divergence Theorem**. ``; ∂ₜūᵢ =1/Vfcc∭ ∂ⱼ⋅σᵢⱼ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS; ``. In the case of an idea fluid we have `σᵢⱼ=-pδᵢⱼ` and therefore our equation above becomes. ``; ∂ₜūᵢ = 1/Vfcc ∬ σᵢⱼ⋅n̂ dS = - 1/Vfcc ∬ p δᵢⱼ⋅ n̂ⱼ dS = - 1/Vfcc ∬ p n̂ᵢ dS; ``. This shows that the desired result follows from application of Gauss' Divergence Theorem on the stress tensor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2475#issuecomment-1111343916
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115727698:81,Testability,test,tested,81,"I believe the changes in this PR are resulting in a significant slowdown (I only tested small CPU models, but the slowdown was around 50%), so I'm going to experiment a bit. I'll put some benchmarks in as well. The goal is speed _up_ not slowdown...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115727698
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115727698:188,Testability,benchmark,benchmarks,188,"I believe the changes in this PR are resulting in a significant slowdown (I only tested small CPU models, but the slowdown was around 50%), so I'm going to experiment a bit. I'll put some benchmarks in as well. The goal is speed _up_ not slowdown...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115727698
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:2326,Performance,perform,performance,2326,"s │ 910.295 ms │ 914.968 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 886.053 ms │ 892.564 ms │ 894.281 ms │ 904.917 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 910.500 ms │ 924.085 ms │ 923.571 ms │ 931.683 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 914.391 ms │ 916.636 ms │ 916.407 ms │ 917.164 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 923.307 ms │ 925.553 ms │ 926.892 ms │ 932.185 ms │ 772.19 KiB │ 1131 │ 6 │; └───────────────┴─────────────────┴────────────────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; [2022/05/03 01:05:45.458] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬─────────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 0.993457 │ 1.45702 │ 1.14257 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 1.00973 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 0.994272 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 1.00813 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 0.98639 │ 1.34134 │ 1.10396 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 0.98391 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 0.973739 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## 2D model (256x256x1). ```; Topologies benchmarks; ┌───────────────┬─────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:5129,Performance,perform,performance,5129,", Bounded) │ 23.479 ms │ 23.727 ms │ 23.792 ms │ 24.619 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 30.863 ms │ 30.990 ms │ 31.205 ms │ 31.858 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 31.041 ms │ 31.521 ms │ 31.982 ms │ 33.815 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 25.631 ms │ 26.845 ms │ 26.749 ms │ 28.206 ms │ 837.97 KiB │ 1154 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 31.354 ms │ 31.398 ms │ 31.477 ms │ 32.215 ms │ 771.44 KiB │ 1115 │ 10 │; └───────────────┴───────────────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; [2022/05/03 00:56:15.050] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬───────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼───────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 0.865858 │ 1.45702 │ 1.14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 1.01269 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.760326 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.999539 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.765277 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 1.01667 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.756078 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴───────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # This PR. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:7992,Performance,perform,performance,7992,"s │ 899.881 ms │ 900.082 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 882.563 ms │ 883.710 ms │ 883.524 ms │ 884.131 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 912.389 ms │ 916.994 ms │ 915.908 ms │ 917.212 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 916.691 ms │ 917.084 ms │ 917.270 ms │ 918.438 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 918.221 ms │ 920.232 ms │ 920.871 ms │ 925.207 ms │ 772.19 KiB │ 1131 │ 6 │; └───────────────┴─────────────────┴────────────────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘; [2022/05/03 00:36:02.528] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬─────────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 0.981253 │ 1.45702 │ 1.14257 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 1.00343 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 0.976245 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 0.999901 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 0.972442 │ 1.34134 │ 1.10396 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 0.980426 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 0.963608 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## 2D model (256x256x1). ```; Topologies benchmarks; ┌───────────────┬──",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:10798,Performance,perform,performance,10798,", Periodic, Bounded) │ 23.208 ms │ 23.282 ms │ 23.646 ms │ 24.667 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 23.736 ms │ 24.691 ms │ 24.854 ms │ 26.482 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 31.277 ms │ 32.486 ms │ 32.212 ms │ 32.999 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 30.844 ms │ 30.903 ms │ 31.003 ms │ 31.769 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 23.704 ms │ 23.832 ms │ 24.042 ms │ 25.055 ms │ 837.97 KiB │ 1154 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 31.354 ms │ 31.632 ms │ 31.816 ms │ 32.916 ms │ 772.19 KiB │ 1131 │ 10 │; └───────────────┴───────────────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; [2022/05/03 00:42:25.915] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬───────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼───────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 0.669516 │ 1.45702 │ 1.14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 0.888622 │ 1.34264 │ 1.1198 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.665425 │ 1.34264 │ 1.1198 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.912619 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.693639 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 0.868158 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.654046 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; ```. The fastest is fully bounded for whatever reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:173,Safety,avoid,avoiding,173,"Here's some benchmarks against the current implementation. Contrary to what I just claimed, there is some speed up for `Bounded` domains, especially with 2D problems (where avoiding halos is advantageous) -- but nothing too significant. Note these are with `WENO5` advection, which should pessimize `Periodic` models as there are larger halos to fill. I came to the prior conclusions by running the two-dimensional turbulence example. I'll try to make sure the ""speed up"" is generic and also benchmark GPU and the hydrostatic model. # `main`. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬─────────────────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 900.894 ms │ 901.887 ms │ 902.516 ms │ 905.129 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 895.527 ms │ 911.386 ms │ 910.441 ms │ 921.211 ms │ 772.19 KiB │ 1131 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 900.389 ms │ 904.161 ms │ 906.879 ms │ 916.145 ms │ 771.44 KiB │ 1115 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 903.676 ms │ 910.638 ms │ 910.295 ms │ 914.968 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 886.053 ms │ 892.564 ms │ 894.281 ms │ 904.917 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 910.500 ms │ 924.085 ms │ 923.571 ms │ 931.683 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 914.391 ms │ 916.636 ms │ 916.407 ms │ 917.164 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:12,Testability,benchmark,benchmarks,12,"Here's some benchmarks against the current implementation. Contrary to what I just claimed, there is some speed up for `Bounded` domains, especially with 2D problems (where avoiding halos is advantageous) -- but nothing too significant. Note these are with `WENO5` advection, which should pessimize `Periodic` models as there are larger halos to fill. I came to the prior conclusions by running the two-dimensional turbulence example. I'll try to make sure the ""speed up"" is generic and also benchmark GPU and the hydrostatic model. # `main`. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬─────────────────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 900.894 ms │ 901.887 ms │ 902.516 ms │ 905.129 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 895.527 ms │ 911.386 ms │ 910.441 ms │ 921.211 ms │ 772.19 KiB │ 1131 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 900.389 ms │ 904.161 ms │ 906.879 ms │ 916.145 ms │ 771.44 KiB │ 1115 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 903.676 ms │ 910.638 ms │ 910.295 ms │ 914.968 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 886.053 ms │ 892.564 ms │ 894.281 ms │ 904.917 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 910.500 ms │ 924.085 ms │ 923.571 ms │ 931.683 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 914.391 ms │ 916.636 ms │ 916.407 ms │ 917.164 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:492,Testability,benchmark,benchmark,492,"Here's some benchmarks against the current implementation. Contrary to what I just claimed, there is some speed up for `Bounded` domains, especially with 2D problems (where avoiding halos is advantageous) -- but nothing too significant. Note these are with `WENO5` advection, which should pessimize `Periodic` models as there are larger halos to fill. I came to the prior conclusions by running the two-dimensional turbulence example. I'll try to make sure the ""speed up"" is generic and also benchmark GPU and the hydrostatic model. # `main`. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬─────────────────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 900.894 ms │ 901.887 ms │ 902.516 ms │ 905.129 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 895.527 ms │ 911.386 ms │ 910.441 ms │ 921.211 ms │ 772.19 KiB │ 1131 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 900.389 ms │ 904.161 ms │ 906.879 ms │ 916.145 ms │ 771.44 KiB │ 1115 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 903.676 ms │ 910.638 ms │ 910.295 ms │ 914.968 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 886.053 ms │ 892.564 ms │ 894.281 ms │ 904.917 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 910.500 ms │ 924.085 ms │ 923.571 ms │ 931.683 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 914.391 ms │ 916.636 ms │ 916.407 ms │ 917.164 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:593,Testability,benchmark,benchmarks,593,"Here's some benchmarks against the current implementation. Contrary to what I just claimed, there is some speed up for `Bounded` domains, especially with 2D problems (where avoiding halos is advantageous) -- but nothing too significant. Note these are with `WENO5` advection, which should pessimize `Periodic` models as there are larger halos to fill. I came to the prior conclusions by running the two-dimensional turbulence example. I'll try to make sure the ""speed up"" is generic and also benchmark GPU and the hydrostatic model. # `main`. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬─────────────────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 900.894 ms │ 901.887 ms │ 902.516 ms │ 905.129 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 895.527 ms │ 911.386 ms │ 910.441 ms │ 921.211 ms │ 772.19 KiB │ 1131 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 900.389 ms │ 904.161 ms │ 906.879 ms │ 916.145 ms │ 771.44 KiB │ 1115 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 903.676 ms │ 910.638 ms │ 910.295 ms │ 914.968 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 886.053 ms │ 892.564 ms │ 894.281 ms │ 904.917 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 910.500 ms │ 924.085 ms │ 923.571 ms │ 931.683 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 914.391 ms │ 916.636 ms │ 916.407 ms │ 917.164 ms │ 575.12 KiB │ 1010 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:3454,Testability,benchmark,benchmarks,3454,"57 │ 1.45702 │ 1.14257 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 1.00973 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 0.994272 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 1.00813 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 0.98639 │ 1.34134 │ 1.10396 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 0.98391 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 0.973739 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## 2D model (256x256x1). ```; Topologies benchmarks; ┌───────────────┬───────────────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 23.527 ms │ 23.573 ms │ 23.652 ms │ 24.354 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 30.958 ms │ 31.004 ms │ 31.160 ms │ 31.948 ms │ 575.12 KiB │ 1010 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 23.061 ms │ 23.442 ms │ 25.189 ms │ 39.441 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 23.479 ms │ 23.727 ms │ 23.792 ms │ 24.619 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 30.863 ms │ 30.990 ms │ 31.205 ms │ 31.858 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 31.041 ms │ 31.521 ms │ 31.982 ms │ 33.815 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:6259,Testability,benchmark,benchmarks,6259,".14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 1.01269 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.760326 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.999539 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.765277 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 1.01667 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.756078 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴───────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # This PR. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬─────────────────┬────────────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────────┼────────────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 896.626 ms │ 899.133 ms │ 900.518 ms │ 909.853 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 895.069 ms │ 895.299 ms │ 895.293 ms │ 895.583 ms │ 772.19 KiB │ 1131 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 891.466 ms │ 891.811 ms │ 891.996 ms │ 893.026 ms │ 771.44 KiB │ 1115 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Bounded) │ 899.668 ms │ 899.891 ms │ 899.881 ms │ 900.082 ms │ 837.97 KiB │ 1154 │ 6 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 882.563 ms │ 883.710 ms │ 883.524 ms │ 884.131 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 912.389 ms │ 916.994 ms │ 915.908 ms │ 917.212 ms │ 703.45 KiB │ 1081 │ 6 │; │ CPU │ (1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:9123,Testability,benchmark,benchmarks,9123,"│ 1.45702 │ 1.14257 │; │ CPU │ (128, 128, 128) │ (Bounded, Bounded, Periodic) │ 1.00343 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Bounded) │ 0.976245 │ 1.34264 │ 1.1198 │; │ CPU │ (128, 128, 128) │ (Bounded, Periodic, Periodic) │ 0.999901 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Bounded) │ 0.972442 │ 1.34134 │ 1.10396 │; │ CPU │ (128, 128, 128) │ (Periodic, Bounded, Periodic) │ 0.980426 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Bounded) │ 0.963608 │ 1.22313 │ 1.0703 │; │ CPU │ (128, 128, 128) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## 2D model (256x256x1). ```; Topologies benchmarks; ┌───────────────┬───────────────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ Ns │ Topologies │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────┼────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 23.465 ms │ 23.687 ms │ 23.895 ms │ 24.833 ms │ 772.19 KiB │ 1131 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 34.145 ms │ 35.596 ms │ 35.767 ms │ 38.008 ms │ 575.12 KiB │ 1010 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 23.208 ms │ 23.282 ms │ 23.646 ms │ 24.667 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 23.736 ms │ 24.691 ms │ 24.854 ms │ 26.482 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 31.277 ms │ 32.486 ms │ 32.212 ms │ 32.999 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 30.844 ms │ 30.903 ms │ 31.003 ms │ 31.769 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491:633,Availability,mask,masking,633,"Just a few notes:. * There's surprisingly little ""interpolation"" / reconstruction in our code (except for trivial reconstruction). Most of the reconstruction occurs for advection, but advective reconstruction doesn't need to be touched by this PR. So this PR actually mostly affects the implementation of GM.; * There are a few things re: using homogeneous operators for Coriolis forces. I suspect that it won't have an effect, but it needs to be tested.; * It should be feasible to use homogeneous / boundary-aware operators _only_ for fluxes. ; * Finally, I'm going to implement an ""enforce_impenetrability!"" operator that does 3D masking and works for both non-immersed and immersed boundaries. After that, we can use `nothing` as a default boundary condition for velocities rather than `ImpenetrableBoundaryCondition` and avoid `mask_immersed_field!` during time-stepping. It seems that impenetrable is still useful for users though for ""user-defined, additional"" velocity components so we may want to keep it...; * An even further step would eliminate the need for masking boundary regions by never updating the tendency there. But this approach allows users to more easily make mistakes, ie changing the velocity field during a run, but forgetting to enforce impenetrability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491:1070,Availability,mask,masking,1070,"Just a few notes:. * There's surprisingly little ""interpolation"" / reconstruction in our code (except for trivial reconstruction). Most of the reconstruction occurs for advection, but advective reconstruction doesn't need to be touched by this PR. So this PR actually mostly affects the implementation of GM.; * There are a few things re: using homogeneous operators for Coriolis forces. I suspect that it won't have an effect, but it needs to be tested.; * It should be feasible to use homogeneous / boundary-aware operators _only_ for fluxes. ; * Finally, I'm going to implement an ""enforce_impenetrability!"" operator that does 3D masking and works for both non-immersed and immersed boundaries. After that, we can use `nothing` as a default boundary condition for velocities rather than `ImpenetrableBoundaryCondition` and avoid `mask_immersed_field!` during time-stepping. It seems that impenetrable is still useful for users though for ""user-defined, additional"" velocity components so we may want to keep it...; * An even further step would eliminate the need for masking boundary regions by never updating the tendency there. But this approach allows users to more easily make mistakes, ie changing the velocity field during a run, but forgetting to enforce impenetrability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491:826,Safety,avoid,avoid,826,"Just a few notes:. * There's surprisingly little ""interpolation"" / reconstruction in our code (except for trivial reconstruction). Most of the reconstruction occurs for advection, but advective reconstruction doesn't need to be touched by this PR. So this PR actually mostly affects the implementation of GM.; * There are a few things re: using homogeneous operators for Coriolis forces. I suspect that it won't have an effect, but it needs to be tested.; * It should be feasible to use homogeneous / boundary-aware operators _only_ for fluxes. ; * Finally, I'm going to implement an ""enforce_impenetrability!"" operator that does 3D masking and works for both non-immersed and immersed boundaries. After that, we can use `nothing` as a default boundary condition for velocities rather than `ImpenetrableBoundaryCondition` and avoid `mask_immersed_field!` during time-stepping. It seems that impenetrable is still useful for users though for ""user-defined, additional"" velocity components so we may want to keep it...; * An even further step would eliminate the need for masking boundary regions by never updating the tendency there. But this approach allows users to more easily make mistakes, ie changing the velocity field during a run, but forgetting to enforce impenetrability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491:447,Testability,test,tested,447,"Just a few notes:. * There's surprisingly little ""interpolation"" / reconstruction in our code (except for trivial reconstruction). Most of the reconstruction occurs for advection, but advective reconstruction doesn't need to be touched by this PR. So this PR actually mostly affects the implementation of GM.; * There are a few things re: using homogeneous operators for Coriolis forces. I suspect that it won't have an effect, but it needs to be tested.; * It should be feasible to use homogeneous / boundary-aware operators _only_ for fluxes. ; * Finally, I'm going to implement an ""enforce_impenetrability!"" operator that does 3D masking and works for both non-immersed and immersed boundaries. After that, we can use `nothing` as a default boundary condition for velocities rather than `ImpenetrableBoundaryCondition` and avoid `mask_immersed_field!` during time-stepping. It seems that impenetrable is still useful for users though for ""user-defined, additional"" velocity components so we may want to keep it...; * An even further step would eliminate the need for masking boundary regions by never updating the tendency there. But this approach allows users to more easily make mistakes, ie changing the velocity field during a run, but forgetting to enforce impenetrability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116063491
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116109797:96,Testability,test,test,96,"> This all looks very promising. Silly question, how is `slowdown` computed exactly?. Probably. test / reference. so < 1 means ""speed _up_""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116109797
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953:88,Availability,mask,mask,88,"It looks like our problems with GM are not solved by this PR --- even when we correctly mask interior values (it might be worth testing this a second time, but I think I did this correctly). Here are results for https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/1c183f9a8df7b97f5074f18ce622b247b7b1c923, in which the stencil is rewritten to compute the ""gradient of the average"". When we do this, and use ""boundary-aware averages"", we eliminate a dependence on the boundary (ie the GM stencil is ""inward looking""). It doesn't fix the basic issue with spurious fluxes near the boundary:. https://user-images.githubusercontent.com/15271942/166609754-1c832d73-3089-48d0-89c4-a99caac344b1.mp4. Hmm... For reference, here's what happens when we revert to ""average of the gradient"" via https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/b7a67598db1fe8d5afea27cece5d35d0c20aac93:. https://user-images.githubusercontent.com/15271942/166610211-95376390-bb80-4993-8b7b-6a3cbe27bebf.mp4. My next best hypothesis is that we are seeing the precise instability that Griffies 1998 points out, and the only solution is i) horizontal diffusion or ii) the Griffies stencil. @jm-c thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953:456,Integrability,depend,dependence,456,"It looks like our problems with GM are not solved by this PR --- even when we correctly mask interior values (it might be worth testing this a second time, but I think I did this correctly). Here are results for https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/1c183f9a8df7b97f5074f18ce622b247b7b1c923, in which the stencil is rewritten to compute the ""gradient of the average"". When we do this, and use ""boundary-aware averages"", we eliminate a dependence on the boundary (ie the GM stencil is ""inward looking""). It doesn't fix the basic issue with spurious fluxes near the boundary:. https://user-images.githubusercontent.com/15271942/166609754-1c832d73-3089-48d0-89c4-a99caac344b1.mp4. Hmm... For reference, here's what happens when we revert to ""average of the gradient"" via https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/b7a67598db1fe8d5afea27cece5d35d0c20aac93:. https://user-images.githubusercontent.com/15271942/166610211-95376390-bb80-4993-8b7b-6a3cbe27bebf.mp4. My next best hypothesis is that we are seeing the precise instability that Griffies 1998 points out, and the only solution is i) horizontal diffusion or ii) the Griffies stencil. @jm-c thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953:128,Testability,test,testing,128,"It looks like our problems with GM are not solved by this PR --- even when we correctly mask interior values (it might be worth testing this a second time, but I think I did this correctly). Here are results for https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/1c183f9a8df7b97f5074f18ce622b247b7b1c923, in which the stencil is rewritten to compute the ""gradient of the average"". When we do this, and use ""boundary-aware averages"", we eliminate a dependence on the boundary (ie the GM stencil is ""inward looking""). It doesn't fix the basic issue with spurious fluxes near the boundary:. https://user-images.githubusercontent.com/15271942/166609754-1c832d73-3089-48d0-89c4-a99caac344b1.mp4. Hmm... For reference, here's what happens when we revert to ""average of the gradient"" via https://github.com/CliMA/Oceananigans.jl/pull/2477/commits/b7a67598db1fe8d5afea27cece5d35d0c20aac93:. https://user-images.githubusercontent.com/15271942/166610211-95376390-bb80-4993-8b7b-6a3cbe27bebf.mp4. My next best hypothesis is that we are seeing the precise instability that Griffies 1998 points out, and the only solution is i) horizontal diffusion or ii) the Griffies stencil. @jm-c thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1116841953
https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1127186179:185,Modifiability,parameteriz,parameterization,185,"It also bears mention that the curious behavior in the lat-lon results above (what looks like spurious boundary fluxes after around 20 days) apparently occurs whether we include the GM parameterization or not. So something else is wrong, perhaps with Bounded boundary conditions on lat-lon (but not sure).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1127186179
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111123328:109,Deployability,update,update,109,"@simone-silvestri do you have anything to offer?. I think issues like this do make it a bit more pressing to update to latest CUDA + KernelAbstractions, which we've been slacking on for quite a while now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111123328
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111150235:68,Deployability,update,update,68,"If you post a MWE, I can try to look at the issue. We should indeed update...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111150235
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087:36,Availability,error,error,36,"@glwagner this should reproduce the error. The message is thrown when calling `set(model,...)`. ```using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, mask_immersed_field!. using Oceananigans.Architectures: device; using Oceananigans.Grids: xnode, znode; using KernelAbstractions: MultiEvent; using JLD2; using Printf; #using GLMakie; using SpecialFunctions. arch = GPU(); Nx = 256; Nz = 64 # Resolution; #Ny = 64; κ = 1e-6 # Diffusivity and viscosity (Prandtl = 1). underlying_grid = RectilinearGrid(arch,; size = (Nx, Nz),; x = (0, 5),; z = (-0.05, 1.0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). #const gamx = 2.0; #const gamy = 20.0. @inline bottom_topography(x,y) = 0.0;#*exp.(-gamy*y.^2); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom_topography)). no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(bottom=no_slip, immersed=no_slip); w_bcs = FieldBoundaryConditions(immersed=no_slip); boundary_conditions = (; u = u_bcs, w = w_bcs). model = NonhydrostaticModel(grid = grid,; advection = WENO5(),; boundary_conditions = boundary_conditions,; closure = ScalarDiffusivity(ν=κ,κ=κ),; coriolis = nothing,; tracers = :b,; buoyancy = BuoyancyTracer()). b₀(x,y, z) =0.5*(erf.((x.-1.0)*10).-1.0); set!(model, u = 0.0, b = b₀)```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087:47,Integrability,message,message,47,"@glwagner this should reproduce the error. The message is thrown when calling `set(model,...)`. ```using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom, mask_immersed_field!. using Oceananigans.Architectures: device; using Oceananigans.Grids: xnode, znode; using KernelAbstractions: MultiEvent; using JLD2; using Printf; #using GLMakie; using SpecialFunctions. arch = GPU(); Nx = 256; Nz = 64 # Resolution; #Ny = 64; κ = 1e-6 # Diffusivity and viscosity (Prandtl = 1). underlying_grid = RectilinearGrid(arch,; size = (Nx, Nz),; x = (0, 5),; z = (-0.05, 1.0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). #const gamx = 2.0; #const gamy = 20.0. @inline bottom_topography(x,y) = 0.0;#*exp.(-gamy*y.^2); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom_topography)). no_slip = ValueBoundaryCondition(0); u_bcs = FieldBoundaryConditions(bottom=no_slip, immersed=no_slip); w_bcs = FieldBoundaryConditions(immersed=no_slip); boundary_conditions = (; u = u_bcs, w = w_bcs). model = NonhydrostaticModel(grid = grid,; advection = WENO5(),; boundary_conditions = boundary_conditions,; closure = ScalarDiffusivity(ν=κ,κ=κ),; coriolis = nothing,; tracers = :b,; buoyancy = BuoyancyTracer()). b₀(x,y, z) =0.5*(erf.((x.-1.0)*10).-1.0); set!(model, u = 0.0, b = b₀)```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1111858087
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1115990673:12,Safety,avoid,avoiding,12,Did you try avoiding broadcasting ? That's the first thing to do. Then we can take a closer look at the initial condition function and see if there's more to change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1115990673
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1116137572:35,Availability,error,error,35,"Actually I think the fact that the error comes from set!(model, ...) might imply deeper issues. Can you set fields individually? You might try figuring out exactly what kernel is causing the problem...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1116137572
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117335654:19,Availability,error,error,19,@glwagner the same error is returned whether I set the velocity or buoyancy tracer fields individually.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117335654
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117371351:51,Usability,clear,clear,51,"How about `set!(u, something)` (I'm not sure I was clear about what I asked, sorry about that)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1117371351
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634:36,Availability,error,error,36,"Running on julia debug level 2: the error seems to be an out-of-bounds array access coming from `_mask_immersed_field!` triggered at `mask_immersed_velocities!` (which is called in `set!(model; kwargs...)`. . Indeed, if you `set!(b, b₀)` the error disappears, but it is still there whenever you will call `mask_immersed_field!` (i.e., when updating the model). The output is a little difficult to interpret but the error seems to be located here. ```; peripheral_node(::Center, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Flat, ; Bounded, RectilinearGrid{Float64, Bounded, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, ; Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, ; GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuDeviceMatrix{Float64, 1}}}, Nothing}) at ; /home/ssilvest/Oceananigans.jl/src/Grids/inactive_node.jl:104; ```. So it seems like it is trying to do a `peripheral_node` of the v velocity, which in this case is flattened since the direction is `Flat`. In this case it will try to do; ```; @inline peripheral_node(LX, ::Face, LZ, i, j, k, grid) = inactive_cell(i, j, k, grid) | inactive_cell(i, j-1, k, grid); ```; hitting `inactive_cell(i, 0, k, grid)`. That is not a problem for a normal grid bit for an immersed grid it is because it evaluates `immersed_cell` at a zero location.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634:242,Availability,error,error,242,"Running on julia debug level 2: the error seems to be an out-of-bounds array access coming from `_mask_immersed_field!` triggered at `mask_immersed_velocities!` (which is called in `set!(model; kwargs...)`. . Indeed, if you `set!(b, b₀)` the error disappears, but it is still there whenever you will call `mask_immersed_field!` (i.e., when updating the model). The output is a little difficult to interpret but the error seems to be located here. ```; peripheral_node(::Center, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Flat, ; Bounded, RectilinearGrid{Float64, Bounded, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, ; Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, ; GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuDeviceMatrix{Float64, 1}}}, Nothing}) at ; /home/ssilvest/Oceananigans.jl/src/Grids/inactive_node.jl:104; ```. So it seems like it is trying to do a `peripheral_node` of the v velocity, which in this case is flattened since the direction is `Flat`. In this case it will try to do; ```; @inline peripheral_node(LX, ::Face, LZ, i, j, k, grid) = inactive_cell(i, j, k, grid) | inactive_cell(i, j-1, k, grid); ```; hitting `inactive_cell(i, 0, k, grid)`. That is not a problem for a normal grid bit for an immersed grid it is because it evaluates `immersed_cell` at a zero location.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634:415,Availability,error,error,415,"Running on julia debug level 2: the error seems to be an out-of-bounds array access coming from `_mask_immersed_field!` triggered at `mask_immersed_velocities!` (which is called in `set!(model; kwargs...)`. . Indeed, if you `set!(b, b₀)` the error disappears, but it is still there whenever you will call `mask_immersed_field!` (i.e., when updating the model). The output is a little difficult to interpret but the error seems to be located here. ```; peripheral_node(::Center, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Flat, ; Bounded, RectilinearGrid{Float64, Bounded, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, ; Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, ; GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuDeviceMatrix{Float64, 1}}}, Nothing}) at ; /home/ssilvest/Oceananigans.jl/src/Grids/inactive_node.jl:104; ```. So it seems like it is trying to do a `peripheral_node` of the v velocity, which in this case is flattened since the direction is `Flat`. In this case it will try to do; ```; @inline peripheral_node(LX, ::Face, LZ, i, j, k, grid) = inactive_cell(i, j, k, grid) | inactive_cell(i, j-1, k, grid); ```; hitting `inactive_cell(i, 0, k, grid)`. That is not a problem for a normal grid bit for an immersed grid it is because it evaluates `immersed_cell` at a zero location.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634:77,Security,access,access,77,"Running on julia debug level 2: the error seems to be an out-of-bounds array access coming from `_mask_immersed_field!` triggered at `mask_immersed_velocities!` (which is called in `set!(model; kwargs...)`. . Indeed, if you `set!(b, b₀)` the error disappears, but it is still there whenever you will call `mask_immersed_field!` (i.e., when updating the model). The output is a little difficult to interpret but the error seems to be located here. ```; peripheral_node(::Center, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Flat, ; Bounded, RectilinearGrid{Float64, Bounded, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, ; Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, ; StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, ; GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuDeviceMatrix{Float64, 1}}}, Nothing}) at ; /home/ssilvest/Oceananigans.jl/src/Grids/inactive_node.jl:104; ```. So it seems like it is trying to do a `peripheral_node` of the v velocity, which in this case is flattened since the direction is `Flat`. In this case it will try to do; ```; @inline peripheral_node(LX, ::Face, LZ, i, j, k, grid) = inactive_cell(i, j, k, grid) | inactive_cell(i, j-1, k, grid); ```; hitting `inactive_cell(i, 0, k, grid)`. That is not a problem for a normal grid bit for an immersed grid it is because it evaluates `immersed_cell` at a zero location.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120085634
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120087401:18,Availability,down,down,18,Yeah just writing down the whole rationale to remember it and fix it later :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1120087401
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:62,Availability,error,error,62,"Thanks @simone-silvestri @glwagner! I encountered a different error on CPU recently that might be related. I ran a 3D (Bounded,Bounded,Bounded) simulation with immersed boundary on CPU. When using `FieldTimeSeries` to load the JLD2 output, I get a `BoundsError` message:. ```b = FieldTimeSeries(""moving_source_complex_topography.jld2"",""b"",grid=nothing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:354,Availability,Error,Error,354,"Thanks @simone-silvestri @glwagner! I encountered a different error on CPU recently that might be related. I ran a 3D (Bounded,Bounded,Bounded) simulation with immersed boundary on CPU. When using `FieldTimeSeries` to load the JLD2 output, I get a `BoundsError` message:. ```b = FieldTimeSeries(""moving_source_complex_topography.jld2"",""b"",grid=nothing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:1320,Availability,ERROR,ERROR,1320,"othing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}} at index [1, 1, 1]; Stacktrace:; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:262,Integrability,message,message,262,"Thanks @simone-silvestri @glwagner! I encountered a different error on CPU recently that might be related. I ran a 3D (Bounded,Bounded,Bounded) simulation with immersed boundary on CPU. When using `FieldTimeSeries` to load the JLD2 output, I get a `BoundsError` message:. ```b = FieldTimeSeries(""moving_source_complex_topography.jld2"",""b"",grid=nothing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:218,Performance,load,load,218,"Thanks @simone-silvestri @glwagner! I encountered a different error on CPU recently that might be related. I ran a 3D (Bounded,Bounded,Bounded) simulation with immersed boundary on CPU. When using `FieldTimeSeries` to load the JLD2 output, I get a `BoundsError` message:. ```b = FieldTimeSeries(""moving_source_complex_topography.jld2"",""b"",grid=nothing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638:1351,Security,access,access,1351,"othing); Error showing value of type FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 512×512×128×10 FieldTimeSeries{Center, Center, Center, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}} at index [1, 1, 1]; Stacktrace:; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1124607638
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817:110,Availability,error,error,110,"Ah yes indeed, sorry I should have specified that the data sets were still usable, I was just confused by the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817
https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817:75,Usability,usab,usable,75,"Ah yes indeed, sorry I should have specified that the data sets were still usable, I was just confused by the error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479#issuecomment-1125115817
https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631:112,Energy Efficiency,Adapt,Adapt,112,"Future work:. 1) Make sure that the symmetric flux of buoyancy is very small, even on a stretched grid, etc; 2) Adapt the taper factor calculation to be boundary-friendly; 3) Also make sure the slope calculation is boundary-friendly. I don't really know how to do (3) so we need @jm-c help for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631
https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631:112,Modifiability,Adapt,Adapt,112,"Future work:. 1) Make sure that the symmetric flux of buoyancy is very small, even on a stretched grid, etc; 2) Adapt the taper factor calculation to be boundary-friendly; 3) Also make sure the slope calculation is boundary-friendly. I don't really know how to do (3) so we need @jm-c help for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631
https://github.com/CliMA/Oceananigans.jl/pull/2484#issuecomment-1111551048:75,Usability,clear,clear,75,"> oh sorry you mean we just didn't register it?. Yes, sorry if that wasn't clear!. I thought registering and tagging could be used interchangeably since the registrator automatically registers _and_ tags a new version, no? I'll try to be more precise with the language in the future",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2484#issuecomment-1111551048
https://github.com/CliMA/Oceananigans.jl/pull/2487#issuecomment-1112130751:134,Modifiability,refactor,refactoring,134,"Not working yet --- we have to be able to calculate the isopycnal slope inside the vertically-implicit diffusion solver, so need some refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2487#issuecomment-1112130751
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112084764:16,Testability,test,tests,16,I'll merge when tests pass!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112084764
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112090393:70,Deployability,release,release,70,I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112090393
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112090393:3,Usability,pause,paused,3,I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112090393
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112098203:72,Deployability,release,release,72,"> I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly. wow, I didn't know you could do that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112098203
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112098203:5,Usability,pause,paused,5,"> I [paused](https://github.com/JuliaRegistries/General/pull/59278) the release of 0.75.3 when I realised the pinning was not done correctly. wow, I didn't know you could do that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112098203
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112102806:39,Integrability,depend,dependency,39,I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112102806
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418:284,Availability,error,error,284,"> I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`. Ah, I didn't realize this was specifically a Mac M1 issue. I think we'll continue to get issues and questions about this error if we don't do something about it (and its very inconvenient for this important subset of users). What's the best way to solve this problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418:41,Integrability,depend,dependency,41,"> I don't think we should pin a indirect dependency. Using Julia 1.7 with Mac M1 is decidedly unsupported and the user can do the pinning in their `Project.toml`. Ah, I didn't realize this was specifically a Mac M1 issue. I think we'll continue to get issues and questions about this error if we don't do something about it (and its very inconvenient for this important subset of users). What's the best way to solve this problem?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112118418
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112139030:60,Availability,down,downloads,60,There is a Mac M1 version of Julia at https://julialang.org/downloads/ so people will download that and try to use Oceananigans with it...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112139030
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112139030:86,Availability,down,download,86,There is a Mac M1 version of Julia at https://julialang.org/downloads/ so people will download that and try to use Oceananigans with it...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112139030
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112623087:172,Integrability,depend,dependency,172,Any code using threading is eventually just going to hang on M1. My point is that Oceanigans should not be working around this for the user since it declares an unecessary dependency for everyone else. Users can pin mpich_jll locally if needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112623087
https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112728261:93,Integrability,depend,dependency,93,OK. How about we close this PR and open another on in which we:; - drop the MPICH_jll direct dependency; - add a remark in the docs for how people need to work around that for julia 1.7 + Mac M1s,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488#issuecomment-1112728261
https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281:120,Modifiability,refactor,refactoring,120,"@matinraayai I think it will also help us get those tests passing quicker, because keeping `GPU` will allow us to avoid refactoring a lot of existing code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281
https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281:114,Safety,avoid,avoid,114,"@matinraayai I think it will also help us get those tests passing quicker, because keeping `GPU` will allow us to avoid refactoring a lot of existing code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281
https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281:52,Testability,test,tests,52,"@matinraayai I think it will also help us get those tests passing quicker, because keeping `GPU` will allow us to avoid refactoring a lot of existing code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:325,Deployability,integrat,integration,325,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:325,Integrability,integrat,integration,325,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:131,Modifiability,refactor,refactor,131,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:273,Security,validat,validation,273,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:294,Security,validat,validation,294,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:67,Testability,test,tests,67,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:144,Testability,test,tests,144,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:284,Testability,test,tests,284,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:337,Testability,test,test,337,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:376,Testability,test,test,376,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112418189:49,Safety,detect,detect,49,"I also think it'd be fun to try to automatically detect the appropriate device. Something like. ```julia; function GPU(); has_cuda_device = has_cuda(); has_amd_device = AMDGPU.has_rocm_gpu(); has_cuda_device && has_amd_device && # this user is blessed with CUDA _and_ ROCm!!; throw(ArgumentError(""Both a CUDA _and_ an AMD GPU are detected! One of them must be selected for the GPU architecture"")). has_cuda_device && return CUDAGPU(); has_amd_device && return ROCMGPU(). throw(ArgumentError(""Cannot build GPU architecture because neither a CUDA GPU nor an AMD GPU were detected!"")); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112418189
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112418189:330,Safety,detect,detected,330,"I also think it'd be fun to try to automatically detect the appropriate device. Something like. ```julia; function GPU(); has_cuda_device = has_cuda(); has_amd_device = AMDGPU.has_rocm_gpu(); has_cuda_device && has_amd_device && # this user is blessed with CUDA _and_ ROCm!!; throw(ArgumentError(""Both a CUDA _and_ an AMD GPU are detected! One of them must be selected for the GPU architecture"")). has_cuda_device && return CUDAGPU(); has_amd_device && return ROCMGPU(). throw(ArgumentError(""Cannot build GPU architecture because neither a CUDA GPU nor an AMD GPU were detected!"")); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112418189
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112418189:569,Safety,detect,detected,569,"I also think it'd be fun to try to automatically detect the appropriate device. Something like. ```julia; function GPU(); has_cuda_device = has_cuda(); has_amd_device = AMDGPU.has_rocm_gpu(); has_cuda_device && has_amd_device && # this user is blessed with CUDA _and_ ROCm!!; throw(ArgumentError(""Both a CUDA _and_ an AMD GPU are detected! One of them must be selected for the GPU architecture"")). has_cuda_device && return CUDAGPU(); has_amd_device && return ROCMGPU(). throw(ArgumentError(""Cannot build GPU architecture because neither a CUDA GPU nor an AMD GPU were detected!"")); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112418189
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:202,Deployability,continuous,continuous,202,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:213,Deployability,integrat,integration,213,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:213,Integrability,integrat,integration,213,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:149,Security,access,access,149,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:173,Testability,test,test,173,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720:225,Testability,test,testing,225,"Nice work @matinraayai !. Happy to merge this but then what's the plan for @matinraayai to continue to contribute @christophernhill ?. Also, who has access to an AMD GPU to test this code? Any plan for continuous integration testing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112437720
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112500783:66,Security,access,access,66,@glwagner our lab at Northeastern and @christophernhill both have access to a set of MI50 and MI100 AMD GPUs. We're using them for now for our development code. I don't know the plan after we get the tests working.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112500783
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112500783:200,Testability,test,tests,200,@glwagner our lab at Northeastern and @christophernhill both have access to a set of MI50 and MI100 AMD GPUs. We're using them for now for our development code. I don't know the plan after we get the tests working.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112500783
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:340,Deployability,integrat,integration,340,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:340,Integrability,integrat,integration,340,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:139,Modifiability,refactor,refactor,139,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:288,Security,validat,validation,288,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:309,Security,validat,validation,309,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:75,Testability,test,tests,75,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:152,Testability,test,tests,152,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:299,Testability,test,tests,299,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:352,Testability,test,test,352,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702:391,Testability,test,test,391,"> @matinraayai I made a bunch of suggestions!; > ; > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > ; > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > ; > ```julia; > using Oceananigans; > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > model = NonhydrostaticModel(; grid, advection=WENO5()); > ϵ(x, y, z) = 2rand() - 1; > set!(model, u=ϵ, v=ϵ); > simulation = Simulation(model; Δt=0.01, stop_time=4); > run!(simulation); > ```; > ; > should be enough?. @glwagner I'm okay with that. I can take a look at this once this PR is accepted to ```amdgpu```.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112506702
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112510197:51,Safety,detect,detect,51,"> I also think it'd be fun to try to automatically detect the appropriate device. Something like; > ; > ```julia; > function GPU(); > has_cuda_device = has_cuda(); > has_amd_device = AMDGPU.has_rocm_gpu(); > has_cuda_device && has_amd_device && # this user is blessed with CUDA _and_ ROCm!!; > throw(ArgumentError(""Both a CUDA _and_ an AMD GPU are detected! One of them must be selected for the GPU architecture"")); > ; > has_cuda_device && return CUDAGPU(); > has_amd_device && return ROCMGPU(); > ; > throw(ArgumentError(""Cannot build GPU architecture because neither a CUDA GPU nor an AMD GPU were detected!"")); > end; > ```. I think it's a nice thing to have, but I'm not sure where this will be called. Will it be Oceananigans.jl's top module file?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112510197
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112510197:348,Safety,detect,detected,348,"> I also think it'd be fun to try to automatically detect the appropriate device. Something like; > ; > ```julia; > function GPU(); > has_cuda_device = has_cuda(); > has_amd_device = AMDGPU.has_rocm_gpu(); > has_cuda_device && has_amd_device && # this user is blessed with CUDA _and_ ROCm!!; > throw(ArgumentError(""Both a CUDA _and_ an AMD GPU are detected! One of them must be selected for the GPU architecture"")); > ; > has_cuda_device && return CUDAGPU(); > has_amd_device && return ROCMGPU(); > ; > throw(ArgumentError(""Cannot build GPU architecture because neither a CUDA GPU nor an AMD GPU were detected!"")); > end; > ```. I think it's a nice thing to have, but I'm not sure where this will be called. Will it be Oceananigans.jl's top module file?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112510197
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112510197:601,Safety,detect,detected,601,"> I also think it'd be fun to try to automatically detect the appropriate device. Something like; > ; > ```julia; > function GPU(); > has_cuda_device = has_cuda(); > has_amd_device = AMDGPU.has_rocm_gpu(); > has_cuda_device && has_amd_device && # this user is blessed with CUDA _and_ ROCm!!; > throw(ArgumentError(""Both a CUDA _and_ an AMD GPU are detected! One of them must be selected for the GPU architecture"")); > ; > has_cuda_device && return CUDAGPU(); > has_amd_device && return ROCMGPU(); > ; > throw(ArgumentError(""Cannot build GPU architecture because neither a CUDA GPU nor an AMD GPU were detected!"")); > end; > ```. I think it's a nice thing to have, but I'm not sure where this will be called. Will it be Oceananigans.jl's top module file?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112510197
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:338,Deployability,integrat,integration,338,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:338,Integrability,integrat,integration,338,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:139,Modifiability,refactor,refactor,139,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:286,Security,validat,validation,286,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:307,Security,validat,validation,307,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:1044,Security,validat,validation,1044,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:75,Testability,test,tests,75,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:152,Testability,test,tests,152,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:297,Testability,test,tests,297,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:350,Testability,test,test,350,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787:389,Testability,test,test,389,"> > @matinraayai I made a bunch of suggestions!; > > I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`.; > > Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like; > > ```julia; > > using Oceananigans; > > grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); > > model = NonhydrostaticModel(; grid, advection=WENO5()); > > ϵ(x, y, z) = 2rand() - 1; > > set!(model, u=ϵ, v=ϵ); > > simulation = Simulation(model; Δt=0.01, stop_time=4); > > run!(simulation); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > should be enough?; > ; > @glwagner I'm okay with that. I can take a look at this once this PR is accepted to `amdgpu`. @glwagner and @matinraayai focusing on `validation/` , `rectilinear`, `non hydrostatic` would work. ; I can set up some CI against the cluster machines we have. I am not sure if we would want it to run for all PRs yet, so I could try https://stackoverflow.com/questions/62325286/run-github-actions-when-pull-requests-have-a-specific-label",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112523787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115048138:35,Usability,clear,clear,35,@glwagner @christophernhill can we clear this pull request?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115048138
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115055787:103,Usability,learn,learning,103,"@matinraayai I am just setting up a buildkite CI . Unfortunately I don't know how buildkite works, but learning!!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115055787
https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115065707:175,Testability,test,tests,175,"This PR just goes into `amdgpu` by the way, so we can merge at any time in my opinion. We then need to open a second PR between `amdgpu` and `main`; to merge that we need all tests to pass and should probably have some CI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1115065707
https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461:593,Availability,error,error,593,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461
https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461:423,Integrability,depend,depends,423,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461
https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461:866,Usability,simpl,simpler,866,"> You're right that it's a little bit misleading. It is not technically a ""divergence damping"", because the actual operator is; > ; > ```; > ∇(ν(∇ ⋅ Δu)); > ```; > ; > So it damps the laplacian of the velocity (here we switched the divergence and the laplacian operators). Thanks! And now I get why this is called biharmonic divergence damping. . We could also write the term as . ``; ∇ ( ν Δ (∇ ⋅ u)); ``. to show that it depends explicitly on the divergence of the velocity. If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. . Not a problem, but I just wanted to make sure I understand this as I didn't know about this before today. Incidently, we don't have the rotational equivalent that was mentioned before? I presume for that we would just use the Laplacian, which is simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112559461
https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112563320:118,Availability,error,error,118,"> If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. Close! But we failed to mention that this damps the _horizontal_ divergence, not the 3D divergence... So it's not damping error; it's damping physical flows with non-small `dw/dz`. And you're right, we haven't implemented a separate ""rotational damping"" closure. But we could. And yeah, you can exchange those operators in continuous space, but not the discrete analogs. So the order of operators matters discretely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112563320
https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112563320:265,Availability,error,error,265,"> If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. Close! But we failed to mention that this damps the _horizontal_ divergence, not the 3D divergence... So it's not damping error; it's damping physical flows with non-small `dw/dz`. And you're right, we haven't implemented a separate ""rotational damping"" closure. But we could. And yeah, you can exchange those operators in continuous space, but not the discrete analogs. So the order of operators matters discretely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112563320
https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112563320:466,Deployability,continuous,continuous,466,"> If we ever get a divergence free solver then this would be exactly zero. But the damping occurs here because of the error of the divergence. Close! But we failed to mention that this damps the _horizontal_ divergence, not the 3D divergence... So it's not damping error; it's damping physical flows with non-small `dw/dz`. And you're right, we haven't implemented a separate ""rotational damping"" closure. But we could. And yeah, you can exchange those operators in continuous space, but not the discrete analogs. So the order of operators matters discretely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2495#issuecomment-1112563320
https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:721,Availability,ERROR,ERROR,721,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067
https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:499,Integrability,Depend,Depending,499,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067
https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:728,Performance,Load,LoadError,728,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067
https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:1054,Safety,avoid,avoid,1054,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067
https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:634,Security,access,access,634,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067
https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067:763,Security,access,access,763,"It turns out this also affects `JLD2OutputWriter`. I believe this is due to us ""double-counting"" indices in `construct_output()`. Specifically, we _always_ slice outputs with `indices` here: https://github.com/CliMA/Oceananigans.jl/blob/3322f1879cf8c84c88e9c7cf4e33bdcf70520c36/src/OutputWriters/output_construction.jl#L49-L51. When a `Field` isn't ""pre-sliced"" (i.e., isn't constructed with the `indices` keyword) then that's okay. But if a `Field` is already sliced, then we slice it again there. Depending on how both `indices` are defined (the one when constructing the `Field` and the one passed to the output writer), we try to access outputs at indices that aren't there anymore, leading to a `BoundsError`:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; ```. I'll open a PR soon to fix this, but I just wanted to leave this saved here. I think the way to go is to change the default `indices` in the constructors to `nothing` and then use that to avoid the double slicing in `construct_output()`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497#issuecomment-1115482067
https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:77,Availability,error,errors,77,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017
https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:121,Availability,robust,robust,121,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017
https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:507,Availability,error,error,507,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017
https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:321,Modifiability,extend,extends,321,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017
https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:46,Safety,avoid,avoid,46,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017
https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1120070082:92,Availability,down,down,92,"Not really, I just used `BigFloat`, it's better but still not perfect (now the round-off is down to `1e-18`). The range implementation is much better, we should get that in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1120070082
https://github.com/CliMA/Oceananigans.jl/issues/2501#issuecomment-1480004924:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2501#issuecomment-1480004924
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162:37,Availability,error,error,37,@simone-silvestri have you seen this error:. ```; NetCDF output writer [GPU]: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_netcdf_output_writer.jl:786; --;   | Got exception outside of a @test;   | This object is not a GPU array;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33; ```. before? It occurs here: https://buildkite.com/clima/oceananigans/builds/7106#944c7ad6-33d9-461a-af46-324a2563205f/24-526,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162:78,Availability,Error,Error,78,@simone-silvestri have you seen this error:. ```; NetCDF output writer [GPU]: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_netcdf_output_writer.jl:786; --;   | Got exception outside of a @test;   | This object is not a GPU array;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33; ```. before? It occurs here: https://buildkite.com/clima/oceananigans/builds/7106#944c7ad6-33d9-461a-af46-324a2563205f/24-526,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162:333,Availability,error,error,333,@simone-silvestri have you seen this error:. ```; NetCDF output writer [GPU]: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_netcdf_output_writer.jl:786; --;   | Got exception outside of a @test;   | This object is not a GPU array;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33; ```. before? It occurs here: https://buildkite.com/clima/oceananigans/builds/7106#944c7ad6-33d9-461a-af46-324a2563205f/24-526,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162:364,Availability,error,error,364,@simone-silvestri have you seen this error:. ```; NetCDF output writer [GPU]: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_netcdf_output_writer.jl:786; --;   | Got exception outside of a @test;   | This object is not a GPU array;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33; ```. before? It occurs here: https://buildkite.com/clima/oceananigans/builds/7106#944c7ad6-33d9-461a-af46-324a2563205f/24-526,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162:91,Testability,Test,Test,91,@simone-silvestri have you seen this error:. ```; NetCDF output writer [GPU]: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_netcdf_output_writer.jl:786; --;   | Got exception outside of a @test;   | This object is not a GPU array;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33; ```. before? It occurs here: https://buildkite.com/clima/oceananigans/builds/7106#944c7ad6-33d9-461a-af46-324a2563205f/24-526,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162:191,Testability,test,test,191,@simone-silvestri have you seen this error:. ```; NetCDF output writer [GPU]: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_netcdf_output_writer.jl:786; --;   | Got exception outside of a @test;   | This object is not a GPU array;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33; ```. before? It occurs here: https://buildkite.com/clima/oceananigans/builds/7106#944c7ad6-33d9-461a-af46-324a2563205f/24-526,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162:266,Testability,test,test,266,@simone-silvestri have you seen this error:. ```; NetCDF output writer [GPU]: Error During Test at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-9/clima/oceananigans/test/test_netcdf_output_writer.jl:786; --;   | Got exception outside of a @test;   | This object is not a GPU array;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33; ```. before? It occurs here: https://buildkite.com/clima/oceananigans/builds/7106#944c7ad6-33d9-461a-af46-324a2563205f/24-526,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114807162
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114826923:823,Deployability,update,update,823,"Yeah, it's because of this line; ```; i1, i2 = round(Int, Nx/4), round(Int, 3Nx/4); j1, j2 = round(Int, Ny/4), round(Int, 3Ny/4); k1, k2 = round(Int, Nz/4), round(Int, 3Nz/4); CUDA.@allowscalar model.tracers.T.data[i1:i2, j1:j2, k1:k2] .+= 0.01; ```; apparently `@allowscalar` does not like `OffsetArrays`, you can fix it like this; ```; i1, i2 = round(Int, Nx/4) - model.tracers.T.data.offsets[1] , round(Int, 3Nx/4) - model.tracers.T.data.offsets[1] ; j1, j2 = round(Int, Ny/4) - model.tracers.T.data.offsets[2] , round(Int, 3Ny/4) - model.tracers.T.data.offsets[2] ; k1, k2 = round(Int, Nz/4) - model.tracers.T.data.offsets[3] , round(Int, 3Nz/4) - model.tracers.T.data.offsets[3] ; CUDA.@allowscalar model.tracers.T.data.parent[i1:i2, j1:j2, k1:k2] .+= 0.01; ```. (you have to change it in a couple of places). Did you update CUDA by any chance?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114826923
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114840125:24,Deployability,update,updated,24,"Yeah, it looks like you updated `GPUArrays`, I guess it might be in there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114840125
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588:215,Integrability,wrap,wrapped,215,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588:704,Testability,test,tests,704,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588:689,Usability,simpl,simplifies,689,"https://github.com/CliMA/Oceananigans.jl/pull/2502/commits/75f423d276352ecf96d845a64e46578b7f7a3a7d adds a method that allows us to broadcast with windowed fields. GPUArrays / CUDA include utilities for ""one-level"" wrapped arrays, ie `SubArray` / `view` of `CuArray`. But they do not include utilities for `OffsetArray` of GPU array (or heaven forbid, `OffsetArray` of `SubArray` of `CuArray`). So that commit supports experimental syntax for broadcasting with ""windowed fields"" which are created by `view`. It might only work with 3D windows (ie if a field is _not_ windowed in some direction it won't have expected behavior). But I think that experimental support is ok for now since it simplifies our tests...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114900588
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114903011:418,Availability,down,down,418,"> Perfect! Maybe we can also raise an issue in GPUArrays.jl. Yeah I'm not 100% sure what the issue is... I think something is happening with broadcasting. Not that those lines attempt to broadcast over a `SubArray` of an `OffsetArray` of a `CuArray` --- because the syntax `a[i1:i2] .= b` creates a `view` of `a`. Since there `a` was an `OffsetArray`, this is a `view` of an `OffsetArray`. The `CuArray` is two levels down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1114903011
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1115545126:12,Testability,test,tests,12,Merge after tests pass?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1115545126
https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1116030533:155,Deployability,update,update,155,"> never seen actually, can it have something to so with the conditionals?. This PR doesn't touch conditionals though! My only guess is that the `GPUArray` update did it. But. https://github.com/JuliaGPU/GPUArrays.jl/pull/401/commits/5896c28b003ccfc12b67bea6d9c4b5c130424f0a. seems innocuous...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502#issuecomment-1116030533
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:228,Deployability,continuous,continuous,228,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:432,Integrability,interface,interface,432,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:1022,Integrability,interface,interface,1022,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:577,Modifiability,layers,layers,577,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115543942:303,Availability,mask,mask,303,"> Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. I think I see what you're saying. `h` just goes to 0 where a layer impinges on a boundary (including an island), we don't have to mask anything. > I agree with the idea of using the z coordiante for the layer number. Seems like the main annoying thing is that `Δz` might be irrelevant (despite that it exists). I've thought about this a bit in the context of eventually supporting generalized vertical coordinates. Some codes use the name ""r"" instead of ""z"", which they believe grants them license to interpret ""r"" as density (or buoyancy) rather than height. We can also ""just"" interpret ""z"" as buoyancy. Then every grid and model property is meaningful, which I like... but on the other hand, they may not have the meaning you expect, if the name ""z"" is hard coded in your brain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115543942
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115546770:160,Energy Efficiency,efficient,efficient,160,"Exactly! We have to allow for `h` getting close to zero, maybe even zero, but never anything negative. . Using this for the density seems like a good way to be efficient, but then we also have to make sure how it's used in the model Seems doable, one just has to be careful and worry about the details. I need to think more about `Δz`, but thanks for sharing your thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115546770
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:420,Energy Efficiency,reduce,reduced,420,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:515,Integrability,interface,interface,515,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:224,Modifiability,variab,variable,224,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:773,Modifiability,layers,layers,773,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:685,Testability,test,test,685,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194:991,Modifiability,layers,layers,991,"Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html). > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say. In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194:1314,Security,validat,validation,1314,"Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html). > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say. In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583:1557,Energy Efficiency,reduce,reduced,1557,"> Buoyancy might not be worth the hassle...; > ; > I just know that density drops out of the Boussinesq equations; if we then convert to buoyancy coordinates and discretize in buoyancy space, we might obtain something identical or similar to the layered shallow water equations.; > ; > We've written Oceananigans to deal with buoyancy rather than density with great intention: a ""reference density"" does not always appear in every setup / numerical experiment (for example: using buoyancy itself as a tracer), and when it does appear it's only meaningful in a few specific places (equation of state, thermodynamic calculations at the surface). This not only clarifies the physics (eg what role _does_ the reference density play?) but also helps reproducibility (we shouldn't have to report / set a reference density for experiments where its _dynamically_ irrelevant). Yes, it's different from how we normally think about the problem, but there's always room for progress...; > ; > I'm not sure if the layered shallow water benefits from this philosophy too. I don't know if using buoyancy instead of density affects the layered shallow water model much. One way to think of the model is that the density/buoyancy is piecewise constant, which is why one is just a scalar multiple of each other. We use hydrostatic balance to determine the pressure in terms of density/buoyancy and we can then use either variable. . If we are going to use buoyancy in the n-layer problem, then we might want to start with the one-layer version. I prefer to think of it as a reduced gravity shallow water model, since that is more general. In that context we define the reduced gravity as `g' = Δρ g/ ρ₀`, where `Δρ` is the change in density and `ρ₀` is a reference density. It seems that the reduced gravity is proportional to the change in buoyancy between two layers. Not sure if that helps at all, but its an observation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583:1652,Energy Efficiency,reduce,reduced,1652,"> Buoyancy might not be worth the hassle...; > ; > I just know that density drops out of the Boussinesq equations; if we then convert to buoyancy coordinates and discretize in buoyancy space, we might obtain something identical or similar to the layered shallow water equations.; > ; > We've written Oceananigans to deal with buoyancy rather than density with great intention: a ""reference density"" does not always appear in every setup / numerical experiment (for example: using buoyancy itself as a tracer), and when it does appear it's only meaningful in a few specific places (equation of state, thermodynamic calculations at the surface). This not only clarifies the physics (eg what role _does_ the reference density play?) but also helps reproducibility (we shouldn't have to report / set a reference density for experiments where its _dynamically_ irrelevant). Yes, it's different from how we normally think about the problem, but there's always room for progress...; > ; > I'm not sure if the layered shallow water benefits from this philosophy too. I don't know if using buoyancy instead of density affects the layered shallow water model much. One way to think of the model is that the density/buoyancy is piecewise constant, which is why one is just a scalar multiple of each other. We use hydrostatic balance to determine the pressure in terms of density/buoyancy and we can then use either variable. . If we are going to use buoyancy in the n-layer problem, then we might want to start with the one-layer version. I prefer to think of it as a reduced gravity shallow water model, since that is more general. In that context we define the reduced gravity as `g' = Δρ g/ ρ₀`, where `Δρ` is the change in density and `ρ₀` is a reference density. It seems that the reduced gravity is proportional to the change in buoyancy between two layers. Not sure if that helps at all, but its an observation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583:1775,Energy Efficiency,reduce,reduced,1775,"> Buoyancy might not be worth the hassle...; > ; > I just know that density drops out of the Boussinesq equations; if we then convert to buoyancy coordinates and discretize in buoyancy space, we might obtain something identical or similar to the layered shallow water equations.; > ; > We've written Oceananigans to deal with buoyancy rather than density with great intention: a ""reference density"" does not always appear in every setup / numerical experiment (for example: using buoyancy itself as a tracer), and when it does appear it's only meaningful in a few specific places (equation of state, thermodynamic calculations at the surface). This not only clarifies the physics (eg what role _does_ the reference density play?) but also helps reproducibility (we shouldn't have to report / set a reference density for experiments where its _dynamically_ irrelevant). Yes, it's different from how we normally think about the problem, but there's always room for progress...; > ; > I'm not sure if the layered shallow water benefits from this philosophy too. I don't know if using buoyancy instead of density affects the layered shallow water model much. One way to think of the model is that the density/buoyancy is piecewise constant, which is why one is just a scalar multiple of each other. We use hydrostatic balance to determine the pressure in terms of density/buoyancy and we can then use either variable. . If we are going to use buoyancy in the n-layer problem, then we might want to start with the one-layer version. I prefer to think of it as a reduced gravity shallow water model, since that is more general. In that context we define the reduced gravity as `g' = Δρ g/ ρ₀`, where `Δρ` is the change in density and `ρ₀` is a reference density. It seems that the reduced gravity is proportional to the change in buoyancy between two layers. Not sure if that helps at all, but its an observation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583:1404,Modifiability,variab,variable,1404,"> Buoyancy might not be worth the hassle...; > ; > I just know that density drops out of the Boussinesq equations; if we then convert to buoyancy coordinates and discretize in buoyancy space, we might obtain something identical or similar to the layered shallow water equations.; > ; > We've written Oceananigans to deal with buoyancy rather than density with great intention: a ""reference density"" does not always appear in every setup / numerical experiment (for example: using buoyancy itself as a tracer), and when it does appear it's only meaningful in a few specific places (equation of state, thermodynamic calculations at the surface). This not only clarifies the physics (eg what role _does_ the reference density play?) but also helps reproducibility (we shouldn't have to report / set a reference density for experiments where its _dynamically_ irrelevant). Yes, it's different from how we normally think about the problem, but there's always room for progress...; > ; > I'm not sure if the layered shallow water benefits from this philosophy too. I don't know if using buoyancy instead of density affects the layered shallow water model much. One way to think of the model is that the density/buoyancy is piecewise constant, which is why one is just a scalar multiple of each other. We use hydrostatic balance to determine the pressure in terms of density/buoyancy and we can then use either variable. . If we are going to use buoyancy in the n-layer problem, then we might want to start with the one-layer version. I prefer to think of it as a reduced gravity shallow water model, since that is more general. In that context we define the reduced gravity as `g' = Δρ g/ ρ₀`, where `Δρ` is the change in density and `ρ₀` is a reference density. It seems that the reduced gravity is proportional to the change in buoyancy between two layers. Not sure if that helps at all, but its an observation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583:1845,Modifiability,layers,layers,1845,"> Buoyancy might not be worth the hassle...; > ; > I just know that density drops out of the Boussinesq equations; if we then convert to buoyancy coordinates and discretize in buoyancy space, we might obtain something identical or similar to the layered shallow water equations.; > ; > We've written Oceananigans to deal with buoyancy rather than density with great intention: a ""reference density"" does not always appear in every setup / numerical experiment (for example: using buoyancy itself as a tracer), and when it does appear it's only meaningful in a few specific places (equation of state, thermodynamic calculations at the surface). This not only clarifies the physics (eg what role _does_ the reference density play?) but also helps reproducibility (we shouldn't have to report / set a reference density for experiments where its _dynamically_ irrelevant). Yes, it's different from how we normally think about the problem, but there's always room for progress...; > ; > I'm not sure if the layered shallow water benefits from this philosophy too. I don't know if using buoyancy instead of density affects the layered shallow water model much. One way to think of the model is that the density/buoyancy is piecewise constant, which is why one is just a scalar multiple of each other. We use hydrostatic balance to determine the pressure in terms of density/buoyancy and we can then use either variable. . If we are going to use buoyancy in the n-layer problem, then we might want to start with the one-layer version. I prefer to think of it as a reduced gravity shallow water model, since that is more general. In that context we define the reduced gravity as `g' = Δρ g/ ρ₀`, where `Δρ` is the change in density and `ρ₀` is a reference density. It seems that the reduced gravity is proportional to the change in buoyancy between two layers. Not sure if that helps at all, but its an observation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116106583
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257:1007,Modifiability,layers,layers,1007,"> Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html).; > ; > > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say.; > ; > In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable. Thanks for the reference @apaloczy ! I know of Rick's work but didn't know whether people were using it very much. The reference seems like it will shed some light on the matter. This might very well be worth playing with to see what approach we prefer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257:1330,Security,validat,validation,1330,"> Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html).; > ; > > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say.; > ; > In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable. Thanks for the reference @apaloczy ! I know of Rick's work but didn't know whether people were using it very much. The reference seems like it will shed some light on the matter. This might very well be worth playing with to see what approach we prefer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116110257
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998:113,Modifiability,layers,layers,113,"Just to add a reference, [Kevlahan et al. 2015](http://doi.org/10.5194/gmd-8-3891-2015) doesn't discuss multiple layers, but seems to do a good job incorporating bathymetry and immersed-boundary continents that have proper wave reflection and don't increase wave speeds inside the continents. I'm trying this model out in Dedalus and maybe it's possible to extend this approach to multiple layers, but I'm not a shallow water expert.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998:357,Modifiability,extend,extend,357,"Just to add a reference, [Kevlahan et al. 2015](http://doi.org/10.5194/gmd-8-3891-2015) doesn't discuss multiple layers, but seems to do a good job incorporating bathymetry and immersed-boundary continents that have proper wave reflection and don't increase wave speeds inside the continents. I'm trying this model out in Dedalus and maybe it's possible to extend this approach to multiple layers, but I'm not a shallow water expert.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998:390,Modifiability,layers,layers,390,"Just to add a reference, [Kevlahan et al. 2015](http://doi.org/10.5194/gmd-8-3891-2015) doesn't discuss multiple layers, but seems to do a good job incorporating bathymetry and immersed-boundary continents that have proper wave reflection and don't increase wave speeds inside the continents. I'm trying this model out in Dedalus and maybe it's possible to extend this approach to multiple layers, but I'm not a shallow water expert.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116318993:400,Deployability,Update,Update,400,"Thanks @kburns for the reference. . Nicholas Kevlahan and I are collaborating on a problem now and we have used his wavelet based model. I agree that it does do a lot of things very well. It deals with topography and coastlines using Brinkman penalization, which is quite distinct from our immersed boundary method. I don't know how he preserves positivity in the height field but I will find out. **Update:** their model uses a vertical coordiante in the vertical to avoid layer collapse. Also, in the multi-layer case they use a discretization of vertical diffusion, to also prevent layer collapse (depths going to zero).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116318993
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116318993:468,Safety,avoid,avoid,468,"Thanks @kburns for the reference. . Nicholas Kevlahan and I are collaborating on a problem now and we have used his wavelet based model. I agree that it does do a lot of things very well. It deals with topography and coastlines using Brinkman penalization, which is quite distinct from our immersed boundary method. I don't know how he preserves positivity in the height field but I will find out. **Update:** their model uses a vertical coordiante in the vertical to avoid layer collapse. Also, in the multi-layer case they use a discretization of vertical diffusion, to also prevent layer collapse (depths going to zero).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116318993
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031:86,Availability,down,down,86,"@iuryt you're right, the environment here is really amazing! . I will think and write down some FV discretisation equations by the time we zoom in. I'm not the best person to talk on how we should implement it in Oceananigans in terms of using z-coordinate as different levels, but it seems like a great and innovative idea. . Perhaps I'm asking a silly question but it's not clear to me that the equations I've written up (and I'll double check this with someone else too) seems to consider varying bathymetry, and I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. I agree with @francispoulin, maybe it doesn't matter much whether we use density or buoyancy as our vertical coordinate. I do like the idea of using buoyancy instead of density, but that's just a personal preference.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031:376,Usability,clear,clear,376,"@iuryt you're right, the environment here is really amazing! . I will think and write down some FV discretisation equations by the time we zoom in. I'm not the best person to talk on how we should implement it in Oceananigans in terms of using z-coordinate as different levels, but it seems like a great and innovative idea. . Perhaps I'm asking a silly question but it's not clear to me that the equations I've written up (and I'll double check this with someone else too) seems to consider varying bathymetry, and I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. I agree with @francispoulin, maybe it doesn't matter much whether we use density or buoyancy as our vertical coordinate. I do like the idea of using buoyancy instead of density, but that's just a personal preference.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117301031
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117376977:465,Modifiability,layers,layers,465,"> I'm not sure if Oceananigans explicitly models bathymetry by adding a pressure gradient, and whether we would be double counting the effects of bathymetry using the equations I shared above. `ShallowWaterModel` is totally independent from the other models --- so this is up to how `ShallowWaterModel` is written. But in a shallow water system it seems (based on the discussion on this thread) that bathymetry is treated via pressure gradients (and also vanishing layers or other techniques to handle outcropping). So we won't use `ImmersedBoundaryGrid`, which is how complex domains are handled elsewhere in Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117376977
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473:20,Modifiability,layers,layers,20,Regarding vanishing layers: what MOM6 does (I think) is that layers never vanish but they are restricted to have height of 1e-10.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473:61,Modifiability,layers,layers,61,Regarding vanishing layers: what MOM6 does (I think) is that layers never vanish but they are restricted to have height of 1e-10.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975:88,Modifiability,extend,extend,88,After #2522 me and @dhruvbhagtani will start working on the multi-layer. The plan is to extend the `ShallowWaterModel` to allow non-flat `z` dimensions with `Nz` the number of fluid layers. It would be good if we add a regression test for the single-layer `ShallowWaterModel` to ensure we don't break things in the process.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975:182,Modifiability,layers,layers,182,After #2522 me and @dhruvbhagtani will start working on the multi-layer. The plan is to extend the `ShallowWaterModel` to allow non-flat `z` dimensions with `Nz` the number of fluid layers. It would be good if we add a regression test for the single-layer `ShallowWaterModel` to ensure we don't break things in the process.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975:230,Testability,test,test,230,After #2522 me and @dhruvbhagtani will start working on the multi-layer. The plan is to extend the `ShallowWaterModel` to allow non-flat `z` dimensions with `Nz` the number of fluid layers. It would be good if we add a regression test for the single-layer `ShallowWaterModel` to ensure we don't break things in the process.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137962212:63,Testability,test,test,63,The Bickley jet might be a good example to use as a regression test!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137962212
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137969032:37,Modifiability,config,config,37,"Yeap, I agree. So are you thinking a config similar to the examples (e.g., rectilinear), start with mean state + some prescribed perturbation and run for up to, e.g., t=20 and compare output? How does that sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137969032
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146735146:63,Modifiability,layers,layers,63,"ok, now that #2522 is merged we can start thinking of multiple layers :) ; I put an overleaf doc with eqs at https://www.overleaf.com/read/mtyjxnnrjpqv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146735146
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348:72,Energy Efficiency,reduce,reduced,72,"The notes look great! . One question though. In your definition for the reduced gravity, why not divide by $\rho_j$ instead of $\rho_{j+1}$, since that's what naturally apprears in the pressure graident term? I know that because the densities are almsot the same, it won't matter much, but it is not clear why you make this approximation when you don't need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348
https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348:300,Usability,clear,clear,300,"The notes look great! . One question though. In your definition for the reduced gravity, why not divide by $\rho_j$ instead of $\rho_{j+1}$, since that's what naturally apprears in the pressure graident term? I know that because the densities are almsot the same, it won't matter much, but it is not clear why you make this approximation when you don't need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146884348
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1115525480:608,Availability,down,down,608,"> Maybe just; > ; > ```julia; > const WindowedData = OffsetArray{<:Any, <:Any, <:SubArray}; > const WindowedField = Field{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:WindowedData}; > construct_output(user_windowed_field::WindowedField, indices) = user_windowed_field # don't re-index a windowed field; > ```; > ; > `WindowedField` is defined in #2502, but its ok to redefine it here and we can consolidate later. This indeed appears to work, thanks for the suggestion. A quick note here is that by not reindexing, the output writer's keyword `with_halos` has not effect. Ideally we want `with_halos` to trim down the halos even in windowed fields, no? Any thoughts? (Or maybe we can add `with_halos` option to `Field`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1115525480
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116126721:8,Testability,test,test,8,> Great test! I requested a change to `construct_output` so that it works `with_halos`. @glwagner did you catch my comment on your suggestion? Is it better to try to make `with_halo` work here with indexed fields or is it better to add a `with_halo` keyword to `Field()` in addition to the `indices` keyword.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116126721
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116252314:564,Availability,error,error,564,"Posting this here for my own reference later. With the current code, when I run this example:. ```; using Oceananigans; using Oceananigans.OutputWriters: construct_output. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities. op = u^2+v^2. indices1 = (:, :, :); indices2 = (1, 2:3, :). u_sliced1 = Field(u, indices=indices1); u_sliced2 = Field(u, indices=indices2). construct_output(u_sliced2, model.grid, indices1, false); ```. I get this error:. ```; ERROR: BoundsError: attempt to access 1×2×10 view(::Array{Float64, 3}, 4:4, 5:6, :) with eltype Float64 at index [4:4, 5:6, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:225; [5] view(f::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116252314
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116252314:577,Availability,ERROR,ERROR,577,"Posting this here for my own reference later. With the current code, when I run this example:. ```; using Oceananigans; using Oceananigans.OutputWriters: construct_output. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities. op = u^2+v^2. indices1 = (:, :, :); indices2 = (1, 2:3, :). u_sliced1 = Field(u, indices=indices1); u_sliced2 = Field(u, indices=indices2). construct_output(u_sliced2, model.grid, indices1, false); ```. I get this error:. ```; ERROR: BoundsError: attempt to access 1×2×10 view(::Array{Float64, 3}, 4:4, 5:6, :) with eltype Float64 at index [4:4, 5:6, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:225; [5] view(f::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116252314
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116252314:608,Security,access,access,608,"Posting this here for my own reference later. With the current code, when I run this example:. ```; using Oceananigans; using Oceananigans.OutputWriters: construct_output. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities. op = u^2+v^2. indices1 = (:, :, :); indices2 = (1, 2:3, :). u_sliced1 = Field(u, indices=indices1); u_sliced2 = Field(u, indices=indices2). construct_output(u_sliced2, model.grid, indices1, false); ```. I get this error:. ```; ERROR: BoundsError: attempt to access 1×2×10 view(::Array{Float64, 3}, 4:4, 5:6, :) with eltype Float64 at index [4:4, 5:6, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:225; [5] view(f::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116252314
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706:144,Integrability,wrap,wrapped,144,"It's out of bounds because the indices of. > 1×2×10 view. are 1:1, 1:2, and 1:10. If you create a windowed `Field`, then `Field.data` is double-wrapped:. * `field.data` is an _OffsetArray_; * `parent(field.data)` is a `SubArray` (the thing that's created by `view`). Both of them have indices. `field.data` has ""global"" indices, or the indices of `field.grid`. But `field.data.parent` has ""simple"" indices, ie `1:1, 1:2, 1:10` in your case. Hopefully studying this code will help:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L271-L293. `offset_windowed_data` creates an `OffsetArray` (with global indices) around ""windowed data"", ie a `view` of the underlying array:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L217-L230. `offset_data` is here:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Grids/new_data.jl#L33-L38",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706:390,Usability,simpl,simple,390,"It's out of bounds because the indices of. > 1×2×10 view. are 1:1, 1:2, and 1:10. If you create a windowed `Field`, then `Field.data` is double-wrapped:. * `field.data` is an _OffsetArray_; * `parent(field.data)` is a `SubArray` (the thing that's created by `view`). Both of them have indices. `field.data` has ""global"" indices, or the indices of `field.grid`. But `field.data.parent` has ""simple"" indices, ie `1:1, 1:2, 1:10` in your case. Hopefully studying this code will help:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L271-L293. `offset_windowed_data` creates an `OffsetArray` (with global indices) around ""windowed data"", ie a `view` of the underlying array:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Fields/field.jl#L217-L230. `offset_data` is here:. https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Grids/new_data.jl#L33-L38",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116283706
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116295969:27,Testability,test,tested,27,"Hmm, I don't think we have tested that we can _re-index_ a `WindowedField`. That's what we're trying to do here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116295969
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116299744:588,Testability,test,test,588,"@tomchor you need to generalize this line:. https://github.com/CliMA/Oceananigans.jl/blob/0c23eeaca4f5d1888c3d78f85de3ff221a732bb4/src/Fields/field.jl#L225. to work when `parent(data)` is a `SubArray`. I think here we want a recursive parent that extracts the underlying array, something like:. ```julia; rparent(a) = rparent(parent(a)). const UnderlyingArrays = Union{Array, CuArray}; rparent(a::UnderlyingArrays) = a; ```. and use this to extract the global data via. ```julia; windowed_parent = view(rparent(data), parent_indices...) ; ```. That code might not work verbatim (I didn't test), but the concept is there I think. I'm happy to figure this out if you like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116299744
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116303580:642,Testability,test,test,642,"> @tomchor you need to generalize this line:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/0c23eeaca4f5d1888c3d78f85de3ff221a732bb4/src/Fields/field.jl#L225; > ; > to work when `parent(data)` is a `SubArray`. I think here we want a recursive parent that extracts the underlying array, something like:; > ; > ```julia; > rparent(a) = rparent(parent(a)); > ; > const UnderlyingArrays = Union{Array, CuArray}; > rparent(a::UnderlyingArrays) = a; > ```; > ; > and use this to extract the global data via; > ; > ```julia; > windowed_parent = view(rparent(data), parent_indices...) ; > ```; > ; > That code might not work verbatim (I didn't test), but the concept is there I think. I'm happy to figure this out if you like. Thanks @glwagner, that's super helpful. Feel free to commit to this PR if you think it'll be easier. I can definitely try to figure this out (like you said, the pieces are all there), but it probably will take me a while (both because of my familiarity with the code and because of other priorities...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1116303580
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886:103,Integrability,depend,depend,103,"@tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886:185,Testability,log,logic,185,"@tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127140886
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:1037,Availability,error,error,1037,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:141,Energy Efficiency,allocate,allocate,141,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:246,Energy Efficiency,allocate,allocated,246,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:493,Energy Efficiency,allocate,allocated,493,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:741,Security,access,access,741,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178:1070,Usability,simpl,simplest,1070,"Let's review what we want to support here:. 1. `user_output` is an AbstractOperation or a Reduction. Therefore it has no indices, and we can allocate only the data we need for output. Easy and supported prior to this PR.; 2. `user_output` is pre-allocated `Field` with full indices. We compute the output indices given `user_indices` and `with_halo` (this is what we supported previously), and then construct a `view(field, indices...)`. Supported prior to this PR.; 3. `user_output` is a pre-allocated `Field` with _non-default indices_. This case is tricker, because there are several possible scenarios:; - `user_output` is a view over a full field (aka `WindowedField`). In this case, we can in principle re-index at will, since we have access to the full underlying data.; - `user_output` is a ""partial field"" with data that covers only part of the grid. In this case, not all indices are valid. We don't have any infrastructure for constructing views into ""partial fields"" in the code right now. This is probably the source of the error we are seeing. I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`. To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices.; It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127145178
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127151051:105,Integrability,depend,depend,105,"> @tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`. Not at all! I'm taking long with this PR because I'm not that familiar with the internal workings on `Field`s. I'm currently editing some files right now but honestly it doesn't feel like I'm making any progress, so feel free to help me out. And I appreciate it :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127151051
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127151051:187,Testability,log,logic,187,"> @tomchor I found some dispatch on `ComputedField` --- but nothing about the output construction should depend on whether a field has an abstract operation underneath or not; all of the logic we are working on regards data but not operand, right? Do you mind if I clean this up? I also think we need to sort out a bug with `parent_index_range`. Not at all! I'm taking long with this PR because I'm not that familiar with the internal workings on `Field`s. I'm currently editing some files right now but honestly it doesn't feel like I'm making any progress, so feel free to help me out. And I appreciate it :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127151051
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127152305:14,Usability,simpl,simplest,14,"> I guess the simplest solution is just to ignore ""output writer indices"" for fields that have non-default indices. And this is the first solution discussed on this PR... but then we can't respect the argument `with_halos`.; > ; > To respect `with_halos` it looks to me like we need more infrastructure for calculating index intersections. For example, we have to be able to deduce that a field with already-chopped halos should not have their indices ""re-chopped"". `parent_index_range` as written knows nothing about ""partial fields"" with non-standard parent indices. It's certainly possible to support this and probably just a little careful arithmetic to get it right. Doesn't seem super high priority though... I'm good with both options for `with_halo`. IMO the only important thing is for this PR is to support the output of sliced `Field`s. It definitely would be nice to also support `with_halos`, but given how tricky it can be and the low priority, I'm definitely okay merging this without `with_halo` support for sliced fields. I'll leave the call up to you.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127152305
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:433,Integrability,depend,depend,433,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:98,Modifiability,extend,extended,98,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:539,Modifiability,extend,extend,539,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127173273:60,Testability,test,tests,60,"> Ok, let me know what you think. Looks good! From my local tests it seems like even these tests are passing: https://github.com/CliMA/Oceananigans.jl/blob/87f8093477104f112c107de1b3f0e677aa2498d1/test/test_output_writers.jl#L56-L57. Although I thought they had to fail under this new scheme... I'll bump a new version since this was a bug, but If tests indeed pass (and you're okay with it) I think we should merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127173273
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127173273:91,Testability,test,tests,91,"> Ok, let me know what you think. Looks good! From my local tests it seems like even these tests are passing: https://github.com/CliMA/Oceananigans.jl/blob/87f8093477104f112c107de1b3f0e677aa2498d1/test/test_output_writers.jl#L56-L57. Although I thought they had to fail under this new scheme... I'll bump a new version since this was a bug, but If tests indeed pass (and you're okay with it) I think we should merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127173273
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127173273:197,Testability,test,test,197,"> Ok, let me know what you think. Looks good! From my local tests it seems like even these tests are passing: https://github.com/CliMA/Oceananigans.jl/blob/87f8093477104f112c107de1b3f0e677aa2498d1/test/test_output_writers.jl#L56-L57. Although I thought they had to fail under this new scheme... I'll bump a new version since this was a bug, but If tests indeed pass (and you're okay with it) I think we should merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127173273
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127173273:348,Testability,test,tests,348,"> Ok, let me know what you think. Looks good! From my local tests it seems like even these tests are passing: https://github.com/CliMA/Oceananigans.jl/blob/87f8093477104f112c107de1b3f0e677aa2498d1/test/test_output_writers.jl#L56-L57. Although I thought they had to fail under this new scheme... I'll bump a new version since this was a bug, but If tests indeed pass (and you're okay with it) I think we should merge.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127173273
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127177867:24,Testability,test,tests,24,I'll take a look at the tests and see if we need to change anything before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127177867
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127883538:0,Testability,Test,Test,0,"Test are passing! @glwagner please lmk if you want changes in the test. If not, I'll merge and register a new version.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127883538
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127883538:66,Testability,test,test,66,"Test are passing! @glwagner please lmk if you want changes in the test. If not, I'll merge and register a new version.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127883538
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:232,Availability,ERROR,ERROR,232,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:257,Availability,error,error,257,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:402,Availability,error,error,402,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:8,Deployability,update,update,8,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:188,Modifiability,variab,variables,188,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:282,Modifiability,variab,variable,282,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:866,Modifiability,variab,variable,866,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:920,Modifiability,Variab,Variable,920,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:1083,Modifiability,variab,variable,1083,"uts are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:1161,Modifiability,Variab,Variable,1161,"reates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.Twic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:49725,Modifiability,variab,variable,49725,"nditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:195; ```. That is to say `NetCDFWriter` isn't correctly inferring the sizes for each variable when creating the NetCDF file. I think atm each file creating assumes all outputs are sliced similarly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:239,Performance,Load,LoadError,239,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655
https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:331,Energy Efficiency,allocate,allocate,331,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860
https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:222,Modifiability,evolve,evolve,222,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860
https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:314,Usability,simpl,simply,314,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860
https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502:26,Energy Efficiency,allocate,allocate,26,"Yes, except that we don't allocate memory for vorticity at all; we compute it on the fly. The prognostic fields are velocity components and tracers. For hydrostatic, w is diagnostic and free surface is prognostic. For nonhydrostatic, w is prognostic. The diagnostic fields include pressure, w if hydrostatic, and any diagnostics fields associated with the closure. We will also have a user interface for closure prognoetic fields at some point too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502
https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502:390,Integrability,interface,interface,390,"Yes, except that we don't allocate memory for vorticity at all; we compute it on the fly. The prognostic fields are velocity components and tracers. For hydrostatic, w is diagnostic and free surface is prognostic. For nonhydrostatic, w is prognostic. The diagnostic fields include pressure, w if hydrostatic, and any diagnostics fields associated with the closure. We will also have a user interface for closure prognoetic fields at some point too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116461502
https://github.com/CliMA/Oceananigans.jl/pull/2511#issuecomment-1116728705:58,Integrability,depend,dependency,58,@simone-silvestri we should probably remove this explicit dependency if it isn't needed,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2511#issuecomment-1116728705
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781:522,Modifiability,parameteriz,parameterized,522,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781:958,Modifiability,layers,layers,958,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781:1531,Usability,simpl,simply,1531,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657:1105,Availability,avail,available,1105,"Yeah.. I am not yet sure how this would work embedded. By now, what I have is just some functions that the user has to add as callbacks.; e.g.; https://github.com/iuryt/Bioceananigans.jl/blob/ab35a7235fea532fe7ed283ce6e06ac12f378dae/test/NNP.jl#L109-L117; btw.. this test script is not yet fully developed 😄. Thinking more, it would be so the function automatically adds the callbacks to the simulation?. ```julia; const Δb=(g/ρₒ) * 0.03; h = Field{Center, Center, Nothing}(grid) ; MixedLayerDepth(simulation, h, Δb). # constants for the NP model; const μ₀ = 1/day # surface growth rate; const m = 0.015/day # mortality rate due to virus and zooplankton grazing; const Kw = 0.059 # meter^-1; const kn = 0.75; const kr = 0.5. # https://doi.org/10.1029/2017GB005850; const chl2c = 0.06 # average value for winter in North Atlantic. const α = 0.0538/day. const average = :growth; const shading = true. light_growth = Field{Center, Center, Center}(grid). # time evolution of shortwave radiation (North Atlantic); @inline Lₒ(t) = 116.5 * sin( 2π * ( t / days + 50 ) / 375.7 + 1.3 ) + 132.3; # evolution of the available light at the surface; @inline light_function(t, z) = 0.43 * Lₒ(t) * exp( z * Kw ); # light profile; @inline light_growth_function(light) = μ₀ * ( light * α ) / sqrt( μ₀^2 + ( light * α )^2 ). phytoplankton = (""P"",) # list of phytoplankton tracers ; LightGrowth(light_growth, h, simulation, phytoplankton, light_function, light_growth_function, time(simulation), average, shading, chl2c); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657:682,Energy Efficiency,meter,meter,682,"Yeah.. I am not yet sure how this would work embedded. By now, what I have is just some functions that the user has to add as callbacks.; e.g.; https://github.com/iuryt/Bioceananigans.jl/blob/ab35a7235fea532fe7ed283ce6e06ac12f378dae/test/NNP.jl#L109-L117; btw.. this test script is not yet fully developed 😄. Thinking more, it would be so the function automatically adds the callbacks to the simulation?. ```julia; const Δb=(g/ρₒ) * 0.03; h = Field{Center, Center, Nothing}(grid) ; MixedLayerDepth(simulation, h, Δb). # constants for the NP model; const μ₀ = 1/day # surface growth rate; const m = 0.015/day # mortality rate due to virus and zooplankton grazing; const Kw = 0.059 # meter^-1; const kn = 0.75; const kr = 0.5. # https://doi.org/10.1029/2017GB005850; const chl2c = 0.06 # average value for winter in North Atlantic. const α = 0.0538/day. const average = :growth; const shading = true. light_growth = Field{Center, Center, Center}(grid). # time evolution of shortwave radiation (North Atlantic); @inline Lₒ(t) = 116.5 * sin( 2π * ( t / days + 50 ) / 375.7 + 1.3 ) + 132.3; # evolution of the available light at the surface; @inline light_function(t, z) = 0.43 * Lₒ(t) * exp( z * Kw ); # light profile; @inline light_growth_function(light) = μ₀ * ( light * α ) / sqrt( μ₀^2 + ( light * α )^2 ). phytoplankton = (""P"",) # list of phytoplankton tracers ; LightGrowth(light_growth, h, simulation, phytoplankton, light_function, light_growth_function, time(simulation), average, shading, chl2c); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657:233,Testability,test,test,233,"Yeah.. I am not yet sure how this would work embedded. By now, what I have is just some functions that the user has to add as callbacks.; e.g.; https://github.com/iuryt/Bioceananigans.jl/blob/ab35a7235fea532fe7ed283ce6e06ac12f378dae/test/NNP.jl#L109-L117; btw.. this test script is not yet fully developed 😄. Thinking more, it would be so the function automatically adds the callbacks to the simulation?. ```julia; const Δb=(g/ρₒ) * 0.03; h = Field{Center, Center, Nothing}(grid) ; MixedLayerDepth(simulation, h, Δb). # constants for the NP model; const μ₀ = 1/day # surface growth rate; const m = 0.015/day # mortality rate due to virus and zooplankton grazing; const Kw = 0.059 # meter^-1; const kn = 0.75; const kr = 0.5. # https://doi.org/10.1029/2017GB005850; const chl2c = 0.06 # average value for winter in North Atlantic. const α = 0.0538/day. const average = :growth; const shading = true. light_growth = Field{Center, Center, Center}(grid). # time evolution of shortwave radiation (North Atlantic); @inline Lₒ(t) = 116.5 * sin( 2π * ( t / days + 50 ) / 375.7 + 1.3 ) + 132.3; # evolution of the available light at the surface; @inline light_function(t, z) = 0.43 * Lₒ(t) * exp( z * Kw ); # light profile; @inline light_growth_function(light) = μ₀ * ( light * α ) / sqrt( μ₀^2 + ( light * α )^2 ). phytoplankton = (""P"",) # list of phytoplankton tracers ; LightGrowth(light_growth, h, simulation, phytoplankton, light_function, light_growth_function, time(simulation), average, shading, chl2c); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657:267,Testability,test,test,267,"Yeah.. I am not yet sure how this would work embedded. By now, what I have is just some functions that the user has to add as callbacks.; e.g.; https://github.com/iuryt/Bioceananigans.jl/blob/ab35a7235fea532fe7ed283ce6e06ac12f378dae/test/NNP.jl#L109-L117; btw.. this test script is not yet fully developed 😄. Thinking more, it would be so the function automatically adds the callbacks to the simulation?. ```julia; const Δb=(g/ρₒ) * 0.03; h = Field{Center, Center, Nothing}(grid) ; MixedLayerDepth(simulation, h, Δb). # constants for the NP model; const μ₀ = 1/day # surface growth rate; const m = 0.015/day # mortality rate due to virus and zooplankton grazing; const Kw = 0.059 # meter^-1; const kn = 0.75; const kr = 0.5. # https://doi.org/10.1029/2017GB005850; const chl2c = 0.06 # average value for winter in North Atlantic. const α = 0.0538/day. const average = :growth; const shading = true. light_growth = Field{Center, Center, Center}(grid). # time evolution of shortwave radiation (North Atlantic); @inline Lₒ(t) = 116.5 * sin( 2π * ( t / days + 50 ) / 375.7 + 1.3 ) + 132.3; # evolution of the available light at the surface; @inline light_function(t, z) = 0.43 * Lₒ(t) * exp( z * Kw ); # light profile; @inline light_growth_function(light) = μ₀ * ( light * α ) / sqrt( μ₀^2 + ( light * α )^2 ). phytoplankton = (""P"",) # list of phytoplankton tracers ; LightGrowth(light_growth, h, simulation, phytoplankton, light_function, light_growth_function, time(simulation), average, shading, chl2c); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116864657
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116866522:211,Integrability,interface,interface,211,@iuryt https://github.com/iuryt/Bioceananigans.jl looks like an awesome start!!! 🚀 . @glwagner arguably it could be biogeochemonanigans.jl or biogeocheminanigans.jl ? . Would it be interesting to think about an interface that could be helpful for projects like https://github.com/openjournals/joss-reviews/issues/4207/https://github.com/JuliaOcean/PlanktonIndividuals.jl from @[zhenwu0728](https://github.com/zhenwu0728) and @gaelforget too at some point? . Note -. 1. in the end both Eulerian and Lagrangian formulations of biogeocheminanigans/biogeochemonanigans/Bioceananigans/Bichemoceananigans style stuff end up as mostly pointwise functions. So a number of bits of an API framework could be common across Eulerian and Lagrangian I think. . 2. On the fluid solver side the API could also support reactive and passive transport in an atmosphere (i.e. work with atmoscheminanigans 😄 ),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116866522
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116870174:323,Deployability,update,update,323,"> @glwagner arguably it could be biogeochemonanigans.jl or biogeocheminanigans.jl ?. I know _chemistry_! Ahaha I like those. `Biogeochemmingaround.jl`? Ok, let's brainstorm. > Thinking more, it would be so the function automatically adds the callbacks to the simulation?. There are multiple possible places where one might update the `biogeochemical_state`. An ""external"" paradigm requires `Callback`. But an ""embedded"" paradigm can hard-code functionality into `update_state(model)!`:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl. I think we want to pursue code design that allows these paradigms to be interchanged. I think it's crucial that functionality developed ""externally"" can be ""copy/pasted"" into `Biogeoceananigans.jl`. This probably would be less pretty than it sounds (style, code quality, names...), but I think is still a good organizing principle for the design. > Would it be interesting to think about an interface that could be helpful for projects like https://github.com/openjournals/joss-reviews/issues/4207/https://github.com/JuliaOcean/PlanktonIndividuals.jl from @[zhenwu0728](https://github.com/zhenwu0728) and @gaelforget too at some point?. I see very much what you're saying. There's an opportunity to also support biogeochemistry on Lagrangian particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116870174
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116870174:999,Integrability,interface,interface,999,"> @glwagner arguably it could be biogeochemonanigans.jl or biogeocheminanigans.jl ?. I know _chemistry_! Ahaha I like those. `Biogeochemmingaround.jl`? Ok, let's brainstorm. > Thinking more, it would be so the function automatically adds the callbacks to the simulation?. There are multiple possible places where one might update the `biogeochemical_state`. An ""external"" paradigm requires `Callback`. But an ""embedded"" paradigm can hard-code functionality into `update_state(model)!`:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl. I think we want to pursue code design that allows these paradigms to be interchanged. I think it's crucial that functionality developed ""externally"" can be ""copy/pasted"" into `Biogeoceananigans.jl`. This probably would be less pretty than it sounds (style, code quality, names...), but I think is still a good organizing principle for the design. > Would it be interesting to think about an interface that could be helpful for projects like https://github.com/openjournals/joss-reviews/issues/4207/https://github.com/JuliaOcean/PlanktonIndividuals.jl from @[zhenwu0728](https://github.com/zhenwu0728) and @gaelforget too at some point?. I see very much what you're saying. There's an opportunity to also support biogeochemistry on Lagrangian particles.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116870174
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691:521,Integrability,interface,interface,521,"> I suggest we wait on this for the time being. We are in discussions to start a formal collaboration to develop the ocean biogeochemistry component of the CliMA model. We need to plan our strategy with the new collaborators who will join us. It will happen soon and we can then have a discussion with all people involved on what is the best strategy moving forward. I agree, this issue is for planning purposes, but there's no timeline for setting up a new package. I think the package itself is easy, but designing the interface that allows different ""biogeochemical models"" to plug in to Oceananigans will require a bit more care. On the Oceananigans side, it seems like some necessary features of a `biogeochemistry` interface are. * User-specified `biogeochemistry` model ""automatically"" adds the tracers it needs in the model constructor (does not require user to explicitly specify tracers): `model_tracers = add_biogeochemical_tracers(biogeochemistry, user_tracers)`.; * There's a ""biogeochemical tendency"" term in the tracer equations that's controlled by `model.biogeochemistry` type.; * There's an interface in `update_state!(model)` like `update_biogeochemical_state!(model.biogeochemistry, model)` so that biogeochemistry models can precompute a state (eg cumulative integrals to determine light penetration) when needed. Perhaps further consultation will produce additional requirements. One big one that I see is for chemistry models that require subcycling or special numerical methods for time-stepping (ie stiff carbonate chemistry systems as in [Smith et al 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001486)). Supporting those cases will be more challenging. I think our Lagrangian particles already (or are intended to) support dynamics-on-particles so there may not be much to do there on the Oceananigans side.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691:721,Integrability,interface,interface,721,"> I suggest we wait on this for the time being. We are in discussions to start a formal collaboration to develop the ocean biogeochemistry component of the CliMA model. We need to plan our strategy with the new collaborators who will join us. It will happen soon and we can then have a discussion with all people involved on what is the best strategy moving forward. I agree, this issue is for planning purposes, but there's no timeline for setting up a new package. I think the package itself is easy, but designing the interface that allows different ""biogeochemical models"" to plug in to Oceananigans will require a bit more care. On the Oceananigans side, it seems like some necessary features of a `biogeochemistry` interface are. * User-specified `biogeochemistry` model ""automatically"" adds the tracers it needs in the model constructor (does not require user to explicitly specify tracers): `model_tracers = add_biogeochemical_tracers(biogeochemistry, user_tracers)`.; * There's a ""biogeochemical tendency"" term in the tracer equations that's controlled by `model.biogeochemistry` type.; * There's an interface in `update_state!(model)` like `update_biogeochemical_state!(model.biogeochemistry, model)` so that biogeochemistry models can precompute a state (eg cumulative integrals to determine light penetration) when needed. Perhaps further consultation will produce additional requirements. One big one that I see is for chemistry models that require subcycling or special numerical methods for time-stepping (ie stiff carbonate chemistry systems as in [Smith et al 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001486)). Supporting those cases will be more challenging. I think our Lagrangian particles already (or are intended to) support dynamics-on-particles so there may not be much to do there on the Oceananigans side.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691:1109,Integrability,interface,interface,1109,"> I suggest we wait on this for the time being. We are in discussions to start a formal collaboration to develop the ocean biogeochemistry component of the CliMA model. We need to plan our strategy with the new collaborators who will join us. It will happen soon and we can then have a discussion with all people involved on what is the best strategy moving forward. I agree, this issue is for planning purposes, but there's no timeline for setting up a new package. I think the package itself is easy, but designing the interface that allows different ""biogeochemical models"" to plug in to Oceananigans will require a bit more care. On the Oceananigans side, it seems like some necessary features of a `biogeochemistry` interface are. * User-specified `biogeochemistry` model ""automatically"" adds the tracers it needs in the model constructor (does not require user to explicitly specify tracers): `model_tracers = add_biogeochemical_tracers(biogeochemistry, user_tracers)`.; * There's a ""biogeochemical tendency"" term in the tracer equations that's controlled by `model.biogeochemistry` type.; * There's an interface in `update_state!(model)` like `update_biogeochemical_state!(model.biogeochemistry, model)` so that biogeochemistry models can precompute a state (eg cumulative integrals to determine light penetration) when needed. Perhaps further consultation will produce additional requirements. One big one that I see is for chemistry models that require subcycling or special numerical methods for time-stepping (ie stiff carbonate chemistry systems as in [Smith et al 2018](https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2018MS001486)). Supporting those cases will be more challenging. I think our Lagrangian particles already (or are intended to) support dynamics-on-particles so there may not be much to do there on the Oceananigans side.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117605691
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:1629,Deployability,integrat,integration,1629,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:1629,Integrability,integrat,integration,1629,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:994,Modifiability,sandbox,sandbox,994,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:994,Testability,sandbox,sandbox,994,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509:1615,Usability,usab,usability,1615,"> > The more the merrier! Contributors are generally welcome on our end too. Links @christophernhill in his comment were broken. So just in case:; > > ; > > * [JOSS issue (accepted)](https://github.com/openjournals/joss-reviews/issues/4207), [paper (proofs)](https://github.com/openjournals/joss-papers/blob/joss.04207/joss.04207/10.21105.joss.04207.pdf); > > * [Github repo (JuliaOcean)](https://github.com/JuliaOcean/PlanktonIndividuals.jl); > > ; > > _PlanktonIndividuals.jl: A GPU supported individual-based phytoplankton life cycle model_; > ; > @gaelforget it looks like you might have some Oceananigans examples which is super cool!! Can you point to them for us? Have you considered expanding to ""online"" capabilities? What are the pros and cons of that?. The two models we currently have some support for (offline) are `MITgcm` and `oceananigans.jl`. . I have examples for both models in <https://gaelforget.github.io/ClimateModels.jl/dev/examples/> which you can run the JuliaClimate sandbox <https://juliaclimate.github.io/Notebooks/> and generate the kind of model output that `PlanktonIndividuals.jl` or `IndividualDisplacement.jl` can then ingest as input for offline computation. The `PlanktonIndividuals.jl` documentation has corresponding examples on the ecology + bgc side. An online mode with models like `MITgcm` and `oceananigans.jl` would be useful in my view, in the case of both `PlanktonIndividuals.jl` or `IndividualDisplacement.jl`. With this being said, I tend to most like the idea of small'ish modeling components developed outside of monolitic modeling efforts that emphasize code re-usability and integration with multiple models. . For completeness, here is the reference to the JOSS paper on [IndividualDisplacement.jl](https://joss.theoj.org/papers/10.21105/joss.02813) -- https://joss.theoj.org/papers/10.21105/joss.02813.pdf -- and the [GitHub repo](https://github.com/JuliaClimate/IndividualDisplacements.jl)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117637509
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871:242,Deployability,integrat,integration,242,"I guess if you have a (julia) function that takes a particle time-step, given a velocity field (ie 3D array), then you can use PlanktonIndividuals.jl online with Oceananigans now, using the `Callback` Oceananigans feature that's designed for integration with other models. So maybe it already works in fact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871
https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871:242,Integrability,integrat,integration,242,"I guess if you have a (julia) function that takes a particle time-step, given a velocity field (ie 3D array), then you can use PlanktonIndividuals.jl online with Oceananigans now, using the `Callback` Oceananigans feature that's designed for integration with other models. So maybe it already works in fact.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1117996871
https://github.com/CliMA/Oceananigans.jl/pull/2513#issuecomment-1120040282:30,Testability,test,tests,30,@simone-silvestri distributed tests passed so this should be good to merge soon,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2513#issuecomment-1120040282
https://github.com/CliMA/Oceananigans.jl/pull/2517#issuecomment-1118111898:31,Integrability,depend,dependency,31,"My mistake, we can remove this dependency",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517#issuecomment-1118111898
https://github.com/CliMA/Oceananigans.jl/pull/2518#issuecomment-1118126410:22,Testability,Benchmark,BenchmarkTools,22,should also take off `BenchmarkTools` that I added by mistake to `deps` in #2253? (closing #2517),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2518#issuecomment-1118126410
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1118623597:231,Testability,test,test,231,"Wonderful to see @simone-silvestri ! Please let me know how I can help. One question, could we change the name of this PR to `Vector Invariant Formuation of ShallowWaterModel`? It seems like a good quality to highlight. Also, as a test problem, could we use the same initial conditions as we have in the [Bickley Jet example](https://github.com/CliMA/Oceananigans.jl/blob/main/examples/shallow_water_Bickley_jet.jl)? Might make for a good comparison.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1118623597
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1118992666:216,Testability,test,test,216,"@francispoulin I have implemented the vector invariant / non conservative form of the equations. I have also separated the advection between momentum / velocity, height and tracers. Now we have to think at some nice test cases, I ll start with the bickley jet experiment",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1118992666
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119130951:159,Safety,predict,predicts,159,"Those look great and very similar, as they should be. Each if them should compute a growth rate of the instability. Did you see what that numbers were? Theory predicts 0.139 and before we had 0.138. As long as they are 0.13 ish, then I think we have two working models!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119130951
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119176866:238,Safety,avoid,avoided,238,"> > Now what is remaining to do is a global run on a lat lon grid of a `ShallowWater` ocean!; > ; > We can do that? That would be amazing to see, and so much faster than the hydrostatic model. I'm not sure about _so much_. The only thing avoided is the computation of vertical velocity, right? The differences are not cost per time step (likely very similar), but physics and numerics: the `ShallowWaterModel` has a fully nonlinear, explicit free surface, while the hydrostatic model has an implicit, linear free surface. So the shallow water model is more accurate for non-negligible surface slopes, but much more costly because gravity wave time-scales must be resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119176866
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119190705:198,Energy Efficiency,reduce,reduce,198,"@glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future). 1. Rigid lid (solve for the surface pressure); 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping). Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. The rigid lid would allow use to test the exact equatorial Rossby wave solutions. @simone-silvestri : I think trying this with realistic coastlines would be a lot of fun and I look forward to seeing what you discover. I'll be hoping WENO can manage it without a problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119190705
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119190705:519,Testability,test,test,519,"@glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future). 1. Rigid lid (solve for the surface pressure); 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping). Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. The rigid lid would allow use to test the exact equatorial Rossby wave solutions. @simone-silvestri : I think trying this with realistic coastlines would be a lot of fun and I look forward to seeing what you discover. I'll be hoping WENO can manage it without a problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119190705
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:200,Energy Efficiency,reduce,reduce,200,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:694,Modifiability,layers,layers,694,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:942,Performance,perform,performance,942,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:814,Safety,avoid,avoids,814,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:762,Testability,benchmark,benchmarked,762,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:649,Usability,simpl,simple,649,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119299248:126,Deployability,integrat,integrated,126,"> . You can also treat the CFL limitation due to the free surface by using a mode-splitting technique, solving the vertically integrated equations with the small CFL imposed time-step while doing the full 3D calculations with a larger time step. That would allow for a better representation of shorter gravity waves but needs careful designs to ensure a consistent 2D transport with the 3D velocities (e.g. Killworth 1991, Beckers 1991).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119299248
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119299248:126,Integrability,integrat,integrated,126,"> . You can also treat the CFL limitation due to the free surface by using a mode-splitting technique, solving the vertically integrated equations with the small CFL imposed time-step while doing the full 3D calculations with a larger time step. That would allow for a better representation of shorter gravity waves but needs careful designs to ensure a consistent 2D transport with the 3D velocities (e.g. Killworth 1991, Beckers 1991).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119299248
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358:95,Integrability,depend,depend,95,"Using hu vs u: My reasoning was always the following: The dynamical balance of your model will depend on the practical problem and scales you will look at, hence the conclusion which (dominant) terms should be discretized ""naturally"" and ""nicely"" may vary. On the other hand, all incompressible models have the same volume conservation constraint which is most naturally discretized using hu as fundamental variables (specially on a C-grid). m2c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358:407,Modifiability,variab,variables,407,"Using hu vs u: My reasoning was always the following: The dynamical balance of your model will depend on the practical problem and scales you will look at, hence the conclusion which (dominant) terms should be discretized ""naturally"" and ""nicely"" may vary. On the other hand, all incompressible models have the same volume conservation constraint which is most naturally discretized using hu as fundamental variables (specially on a C-grid). m2c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:142,Availability,ERROR,ERROR,142,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:186,Availability,error,error,186,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:241,Availability,error,error,241,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:272,Availability,error,error,272,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:1296,Availability,Error,Error,1296,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:1354,Availability,error,error,1354,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495:149,Performance,Load,LoadError,149,"I saw there's a problem with making the documentation, see below. This doesn't seem directly relelvant to what was changed here though?. ```. ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:266 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage5/buildkite-agent/.julia-7245/packages/Documenter/7hBIS/src/Documenter.jl:265 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-3/clima/oceananigans/docs/make.jl:154;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119854495
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936:474,Energy Efficiency,reduce,reduce,474,"@simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this, ; ```; ∇⋅(ν∇⃗ u⃗); ```; which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way. In the future I think it would be better to have something like this, . ```; 1/h ∇⋅(ν h ∇⃗ u⃗); ```. since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936:113,Usability,simpl,simple,113,"@simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this, ; ```; ∇⋅(ν∇⃗ u⃗); ```; which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way. In the future I think it would be better to have something like this, . ```; 1/h ∇⋅(ν h ∇⃗ u⃗); ```. since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119857936
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980:513,Energy Efficiency,reduce,reduce,513,"> @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > ; > ```; > ∇⋅(ν∇⃗ u⃗); > ```; > ; > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > ; > In the future I think it would be better to have something like this,; > ; > ```; > 1/h ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR. This depends on the formulation right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980:668,Integrability,depend,depends,668,"> @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > ; > ```; > ∇⋅(ν∇⃗ u⃗); > ```; > ; > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > ; > In the future I think it would be better to have something like this,; > ; > ```; > 1/h ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR. This depends on the formulation right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980:115,Usability,simpl,simple,115,"> @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > ; > ```; > ∇⋅(ν∇⃗ u⃗); > ```; > ; > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > ; > In the future I think it would be better to have something like this,; > ; > ```; > 1/h ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR. This depends on the formulation right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119865980
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306:645,Energy Efficiency,reduce,reduce,645,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306:1101,Energy Efficiency,energy,energy,1101,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306:807,Integrability,depend,depends,807,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306:117,Usability,simpl,simple,117,"> > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > ```; > > ∇⋅(ν∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > In the future I think it would be better to have something like this,; > > ```; > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > ; > This depends on the formulation right?. Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents. For the conservative form, I think it would be easiest to have. ```; ∇⋅(ν h ∇⃗ u⃗); ```. which does insure that viscosity does not increase kinetic energy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119868306
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091:709,Energy Efficiency,reduce,reduce,709,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091:1204,Energy Efficiency,energy,energy,1204,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091:881,Integrability,depend,depends,881,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091:119,Usability,simpl,simple,119,"> > > @simone-silvestri : if you wanted to reproduce something like what you did in the one-degree simulations, with a simple closure scheme, we could try this,; > > > ```; > > > ∇⋅(ν∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > which in the case of constant viscosity we have the regular Laplacian. By the same rights you could also as in biharmonic viscoisty in a similar way.; > > > In the future I think it would be better to have something like this,; > > > ```; > > > 1/h ∇⋅(ν h ∇⃗ u⃗); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > since it ensures that viscosity will always reduce the visocisty but I think this is harder to apply in a finite volume formulation because of the function in front. Best saved for a future PR.; > > ; > > ; > > This depends on the formulation right?; > ; > Yes, what I was suggesting above is for the vector invariant form, since we need this form to have continents.; > ; > For the conservative form, I think it would be easiest to have; > ; > ```; > ∇⋅(ν h ∇⃗ u⃗); > ```; > ; > which does insure that viscosity does not increase kinetic energy. Cool!. We have to write this as a ""rotational"" and ""divergence"" term to reproduce our other results, which only use divergence damping (relying on WENO vector invariant to dissipation enstrophy).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119871091
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119880246:54,Usability,learn,learn,54,Thanks for clarifying @glwagner . . I guess I need to learn how this is done in the other models.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119880246
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119920762:61,Usability,learn,learn,61,"> Thanks for clarifying @glwagner .; > ; > I guess I need to learn how this is done in the other models. But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119920762
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119938028:61,Usability,learn,learn,61,"> > Thanks for clarifying @glwagner .; > > I guess I need to learn how this is done in the other models.; > ; > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us). I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119938028
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:655,Deployability,configurat,configuration,655,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:655,Modifiability,config,configuration,655,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:1057,Performance,perform,perform,1057,"; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:1624,Performance,perform,perform,1624," ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:2104,Safety,avoid,avoid,2104," ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:65,Usability,learn,learn,65,"> > > Thanks for clarifying @glwagner .; > > > I guess I need to learn how this is done in the other models.; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119964872:191,Availability,avail,available,191,"Thanks for clarifying the situation @glwagner . I agree that it's easiest to first try comparing shallow water and hydrostatic model with no explicit dissiaption. The tools are all currently available and no new code needs to be written. Subsequently, we can try doing comparisions with explicit dissipations. One thing to mention is that the theory of western intensification says we will get western boundary currents as long as we have some kind of dissipation. This could be bottom drag (Stommel), lateral viscosity (Munk), hyperviscosity or anything else for that matter. Without having any explicit form of viscosity then the dissipation is slight and will yield western boundary currents of different widths, as the resolution changes and the implicit dissipation changes in magntiude with different resolutions. . Eventually it would be nice to have some explicit dissiaption since then we can show convergence with increasing resolution, but that is a longer term goal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119964872
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380:645,Modifiability,evolve,evolve,645,"@jmbeckers thanks for the delucidation! Indeed, a conservative discretization might be more ""natural"" (have better discrete properties) in terms of momentum conservation. Especially because vector invariant formulations do not conserve momentum but angular momentum. @francispoulin, indeed, I think that, for a one layer model explicit dissipation might not be necessary because the noise associated with a horizontal velocity divergence is encoded in the mass equation which is discretized with a WENO formulation also (another way of repeating what @glwagner said). This is the difference with the hydrostatic model where we do not explicitly evolve a prognostic equation for the vertical velocity and we have to explicitly damp the noise contained in the vertical velocity `w` through a divergence damping closure. So you can think at that ""divergence damping"" closure as a ""WENO"" for an hypothetical `w` equation (which we have in the shallow water equations explicitly trough `h`). I agree also that we should introduce a diffusion term anyways. It is always good to be able to quickly quantify the dissipation you have in your model and with implicit dissipation that is very difficult (implicit LES is frowned upon by many purist of turbulence). for the documentation problem I think it's just because I changed the example. I ll fix the test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380:1345,Testability,test,test,1345,"@jmbeckers thanks for the delucidation! Indeed, a conservative discretization might be more ""natural"" (have better discrete properties) in terms of momentum conservation. Especially because vector invariant formulations do not conserve momentum but angular momentum. @francispoulin, indeed, I think that, for a one layer model explicit dissipation might not be necessary because the noise associated with a horizontal velocity divergence is encoded in the mass equation which is discretized with a WENO formulation also (another way of repeating what @glwagner said). This is the difference with the hydrostatic model where we do not explicitly evolve a prognostic equation for the vertical velocity and we have to explicitly damp the noise contained in the vertical velocity `w` through a divergence damping closure. So you can think at that ""divergence damping"" closure as a ""WENO"" for an hypothetical `w` equation (which we have in the shallow water equations explicitly trough `h`). I agree also that we should introduce a diffusion term anyways. It is always good to be able to quickly quantify the dissipation you have in your model and with implicit dissipation that is very difficult (implicit LES is frowned upon by many purist of turbulence). for the documentation problem I think it's just because I changed the example. I ll fix the test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124077820:36,Availability,error,errors,36,"@simone-silvestri : I looked at the errors and both of them seem to be due to a version problem. Any idea what the problem could be?. ```; ERROR: The manifest file you are using was most likely generated by a different version of Julia and is not compatible with this Julia version; ```. Also, I looked at what the viscosity terms look like in vector invariant form for the shallow water model . Should I put that in another issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124077820
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124077820:139,Availability,ERROR,ERROR,139,"@simone-silvestri : I looked at the errors and both of them seem to be due to a version problem. Any idea what the problem could be?. ```; ERROR: The manifest file you are using was most likely generated by a different version of Julia and is not compatible with this Julia version; ```. Also, I looked at what the viscosity terms look like in vector invariant form for the shallow water model . Should I put that in another issue?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124077820
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248:67,Availability,down,downgrade,67,"The problem is that I am developing on my mac that requires an MPI downgrade to run, so I update the Manifest with julia 1.7 and that is not compatible with the CI julia. I ll revert it back. I think the viscosity can be added also here while we're at it, but also I wanted to ask how do we add bathymetry. If we add it as a pressure term in the momentum equations or as an additional advection term in the continuity equation as such. https://capture.dropbox.com/LxsRg26SQzFKu4lb. No matter what I try, the bathymetry seems to make the 1/4 degree simulation with one layer unstable (maybe I have implemented it wrong). Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248:90,Deployability,update,update,90,"The problem is that I am developing on my mac that requires an MPI downgrade to run, so I update the Manifest with julia 1.7 and that is not compatible with the CI julia. I ll revert it back. I think the viscosity can be added also here while we're at it, but also I wanted to ask how do we add bathymetry. If we add it as a pressure term in the momentum equations or as an additional advection term in the continuity equation as such. https://capture.dropbox.com/LxsRg26SQzFKu4lb. No matter what I try, the bathymetry seems to make the 1/4 degree simulation with one layer unstable (maybe I have implemented it wrong). Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248:783,Deployability,integrat,integrated,783,"The problem is that I am developing on my mac that requires an MPI downgrade to run, so I update the Manifest with julia 1.7 and that is not compatible with the CI julia. I ll revert it back. I think the viscosity can be added also here while we're at it, but also I wanted to ask how do we add bathymetry. If we add it as a pressure term in the momentum equations or as an additional advection term in the continuity equation as such. https://capture.dropbox.com/LxsRg26SQzFKu4lb. No matter what I try, the bathymetry seems to make the 1/4 degree simulation with one layer unstable (maybe I have implemented it wrong). Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248:783,Integrability,integrat,integrated,783,"The problem is that I am developing on my mac that requires an MPI downgrade to run, so I update the Manifest with julia 1.7 and that is not compatible with the CI julia. I ll revert it back. I think the viscosity can be added also here while we're at it, but also I wanted to ask how do we add bathymetry. If we add it as a pressure term in the momentum equations or as an additional advection term in the continuity equation as such. https://capture.dropbox.com/LxsRg26SQzFKu4lb. No matter what I try, the bathymetry seems to make the 1/4 degree simulation with one layer unstable (maybe I have implemented it wrong). Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1124216248
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447:165,Deployability,integrat,integrated,165,"> Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?. Sorry I forgot to reply to this sooner. If we use `ch` then we can write the advection term as a divergence form, and then use a lot of the existing code that we have for the other models. This seems easier to me, rather than having to write different solvers for the alternative form of advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447:165,Integrability,integrat,integrated,165,"> Another point to clarify is the tracer transport. The model right now (and before) was/is evolving directly the tracer, should we switch to evolving the thickness integrated tracer (`ch`) or stick to `c`?. Sorry I forgot to reply to this sooner. If we use `ch` then we can write the advection term as a divergence form, and then use a lot of the existing code that we have for the other models. This seems easier to me, rather than having to write different solvers for the alternative form of advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125432447
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125959750:222,Energy Efficiency,reduce,reduce,222,"> Weird, for me it worked (with small time steps though, like 10-100 seconds, the six minutes there was for the implicit free surface case). What time step are you using?. Ah, that's my problem. I used the default. I will reduce it and try it again. Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1125959750
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147:283,Availability,error,error,283,"@simone-silvestri : Good news is that it is running with `Δt = 10seconds`. It's taking some time but still stable after 6 hours. I am tryinig to look at the data set to see what's going on but I am having some trouble. After `using NCDatasets` I try reading it and get the following error. Is this because it's writing at the same time and I can't open it until the file is closed? Or is there something else going on here. ```; julia> ds = NCDataset(""near_global_lat_lon_1440_600__fine_surface.jld2"", ""r""); ERROR: NetCDF error: Opening path near_global_lat_lon_1440_600__fine_surface.jld2: NetCDF: HDF error (NetCDF error code: -101); Stacktrace:; [1] nc_open(path::String, mode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:273; [2] NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Vector{Any}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:187; [3] NCDataset(filename::String, mode::String); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:157; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147:508,Availability,ERROR,ERROR,508,"@simone-silvestri : Good news is that it is running with `Δt = 10seconds`. It's taking some time but still stable after 6 hours. I am tryinig to look at the data set to see what's going on but I am having some trouble. After `using NCDatasets` I try reading it and get the following error. Is this because it's writing at the same time and I can't open it until the file is closed? Or is there something else going on here. ```; julia> ds = NCDataset(""near_global_lat_lon_1440_600__fine_surface.jld2"", ""r""); ERROR: NetCDF error: Opening path near_global_lat_lon_1440_600__fine_surface.jld2: NetCDF: HDF error (NetCDF error code: -101); Stacktrace:; [1] nc_open(path::String, mode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:273; [2] NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Vector{Any}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:187; [3] NCDataset(filename::String, mode::String); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:157; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147:522,Availability,error,error,522,"@simone-silvestri : Good news is that it is running with `Δt = 10seconds`. It's taking some time but still stable after 6 hours. I am tryinig to look at the data set to see what's going on but I am having some trouble. After `using NCDatasets` I try reading it and get the following error. Is this because it's writing at the same time and I can't open it until the file is closed? Or is there something else going on here. ```; julia> ds = NCDataset(""near_global_lat_lon_1440_600__fine_surface.jld2"", ""r""); ERROR: NetCDF error: Opening path near_global_lat_lon_1440_600__fine_surface.jld2: NetCDF: HDF error (NetCDF error code: -101); Stacktrace:; [1] nc_open(path::String, mode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:273; [2] NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Vector{Any}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:187; [3] NCDataset(filename::String, mode::String); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:157; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147:603,Availability,error,error,603,"@simone-silvestri : Good news is that it is running with `Δt = 10seconds`. It's taking some time but still stable after 6 hours. I am tryinig to look at the data set to see what's going on but I am having some trouble. After `using NCDatasets` I try reading it and get the following error. Is this because it's writing at the same time and I can't open it until the file is closed? Or is there something else going on here. ```; julia> ds = NCDataset(""near_global_lat_lon_1440_600__fine_surface.jld2"", ""r""); ERROR: NetCDF error: Opening path near_global_lat_lon_1440_600__fine_surface.jld2: NetCDF: HDF error (NetCDF error code: -101); Stacktrace:; [1] nc_open(path::String, mode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:273; [2] NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Vector{Any}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:187; [3] NCDataset(filename::String, mode::String); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:157; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147:617,Availability,error,error,617,"@simone-silvestri : Good news is that it is running with `Δt = 10seconds`. It's taking some time but still stable after 6 hours. I am tryinig to look at the data set to see what's going on but I am having some trouble. After `using NCDatasets` I try reading it and get the following error. Is this because it's writing at the same time and I can't open it until the file is closed? Or is there something else going on here. ```; julia> ds = NCDataset(""near_global_lat_lon_1440_600__fine_surface.jld2"", ""r""); ERROR: NetCDF error: Opening path near_global_lat_lon_1440_600__fine_surface.jld2: NetCDF: HDF error (NetCDF error code: -101); Stacktrace:; [1] nc_open(path::String, mode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:273; [2] NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, attrib::Vector{Any}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:187; [3] NCDataset(filename::String, mode::String); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/dataset.jl:157; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126245147
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:101,Energy Efficiency,adapt,adapt,101,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:101,Modifiability,adapt,adapt,101,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:316,Security,validat,validation,316,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126723606:33,Usability,simpl,simple,33,@francispoulin those figures are simple heatmaps:. https://makie.juliaplots.org/stable/examples/plotting_functions/heatmap/. The code you are writing looks like code for producing a surface plot on the sphere. Heatmap might be easier!. It might help to start from scratch rather than fixing whatever’s there too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126723606
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126741085:218,Availability,error,error,218,"Thanks @glwagner . Yes, easier is better for starting. I have something that is starting to take shape. . When I just try plotting the field I can get a heat map. Unfortunately, when I try plotting with `x,y` I get an error. . ```; julia> heatmap(x, y, ζ′); Error showing value of type Makie.FigureAxisPlot:; ERROR: InexactError: trunc(Int32, 748984662721); ```; Anyone else see this error before?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126741085
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126741085:258,Availability,Error,Error,258,"Thanks @glwagner . Yes, easier is better for starting. I have something that is starting to take shape. . When I just try plotting the field I can get a heat map. Unfortunately, when I try plotting with `x,y` I get an error. . ```; julia> heatmap(x, y, ζ′); Error showing value of type Makie.FigureAxisPlot:; ERROR: InexactError: trunc(Int32, 748984662721); ```; Anyone else see this error before?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126741085
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126741085:309,Availability,ERROR,ERROR,309,"Thanks @glwagner . Yes, easier is better for starting. I have something that is starting to take shape. . When I just try plotting the field I can get a heat map. Unfortunately, when I try plotting with `x,y` I get an error. . ```; julia> heatmap(x, y, ζ′); Error showing value of type Makie.FigureAxisPlot:; ERROR: InexactError: trunc(Int32, 748984662721); ```; Anyone else see this error before?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126741085
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126741085:384,Availability,error,error,384,"Thanks @glwagner . Yes, easier is better for starting. I have something that is starting to take shape. . When I just try plotting the field I can get a heat map. Unfortunately, when I try plotting with `x,y` I get an error. . ```; julia> heatmap(x, y, ζ′); Error showing value of type Makie.FigureAxisPlot:; ERROR: InexactError: trunc(Int32, 748984662721); ```; Anyone else see this error before?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126741085
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047:160,Availability,error,error,160,"> What happens if you first create Figure and Axis, and draw the heatmap into Axis? You'll want to use ""heatmap!"" rather than ""heatmap"". Sadly, I still get the error. Just to be clear, I am trying the following:. ```; fig = Figure(resolution = (1000, 1000)); ax = Axis(fig[1,1], xlabel = ""x"", ylabel = ""y"", title=""vorticity""); heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=clims); ```. In our case, `x,y`, are arrays, but in the examples, `x,y`, are vectors. Maybe heatmap doesn't work so well for this type of data?. For fun I tried `surface!`, which is used in the other visualization.jl code, and that does plot, but i get it on a desk. Not so easy to sort out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047:178,Usability,clear,clear,178,"> What happens if you first create Figure and Axis, and draw the heatmap into Axis? You'll want to use ""heatmap!"" rather than ""heatmap"". Sadly, I still get the error. Just to be clear, I am trying the following:. ```; fig = Figure(resolution = (1000, 1000)); ax = Axis(fig[1,1], xlabel = ""x"", ylabel = ""y"", title=""vorticity""); heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=clims); ```. In our case, `x,y`, are arrays, but in the examples, `x,y`, are vectors. Maybe heatmap doesn't work so well for this type of data?. For fun I tried `surface!`, which is used in the other visualization.jl code, and that does plot, but i get it on a desk. Not so easy to sort out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126779047
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126796762:56,Usability,learn,learn,56,Thanks @navidcy ! That definitely did the trick. Now to learn how to make an animation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126796762
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126801203:563,Availability,error,error,563,"In another code that made an animation I found the following lines of code. ```; iter = Node(0); ζ′ = @lift file[""timeseries/ζ/"" * string($iter)][:, :, 1]; ```. which was used as one of the earlier steps of making an animation. Since `Node` no longer exists, and we should be using `Observable`, I have tried the following to read in a file, or a place holder of a file I suppose. ```. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = file[""timeseries/ζ/"" * string($iter)][:, :, 1]. ```. Unfortunately, the syntax is wrong and I get an error saying `RROR: syntax: ""$"" expression outside quote around`. . Does someone know what the correct syntax should be?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126801203
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126828919:200,Usability,learn,learn,200,"This definitely needs some polishing, and it only contains the results for the first 200 days (165 days still yet to be computed), but it looks promising. Thanks @navidcy and @glwagner for helping me learn more about `Makie`. Any suggestions on what I should do to improve this are very welcome. https://user-images.githubusercontent.com/8239041/168451788-556cf7ca-ade4-415f-ad84-40c57bfb303c.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126828919
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126829065:91,Availability,Error,Error,91,Also the docs seem to fail because it can't find the docs for `ShallowWatermodel`?. ```; ┌ Error: no docs found for 'ShallowWaterModel' in `@docs` block in src/model_setup/overview.md:26-28; --;   | │ ```@docs;   | │ ShallowWaterModel;   | │; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126829065
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126829436:101,Availability,Error,Error,101,> Also the docs seem to fail because it can't find the docs for `ShallowWatermodel`?; > ; > ```; > ┌ Error: no docs found for 'ShallowWaterModel' in `@docs` block in src/model_setup/overview.md:26-28; > --; >   | │ ```@docs; >   | │ ShallowWaterModel; >   | │; > ```. I can have a look laters,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126829436
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127181498:202,Usability,learn,learn,202,"> This definitely needs some polishing, and it only contains the results for the first 200 days (165 days still yet to be computed), but it looks promising. Thanks @navidcy and @glwagner for helping me learn more about `Makie`.; > ; > Any suggestions on what I should do to improve this are very welcome.; > ; > near_global_lat_lon_1440_600__fine_surface.mp4. I suggest changing the color scale to reveal more detail. You can set the limits of `colorrange` to something like 1/4 or 1/10 of the maximum(abs, vorticity).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127181498
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759:104,Integrability,wrap,wrapper,104,"> hmmm, can you read a jld2 file with NCDatasets? I am not sure how that package works. NCDatasets is a wrapper on top of the NetCDF C API which is based (in part) on the HDF5 library. As JLD2 is a julia implementation of HDF5, some simple JLD2 files are (surprisingly) readable NCDatasets but this is not generally the case, and arbitrary HDF5 files are [not supported by the NetCDF C library](https://docs.unidata.ucar.edu/netcdf-c/current/interoperability_hdf5.html). It is indeed better to use JLD2.jl for JLD2 files.😃",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759:233,Usability,simpl,simple,233,"> hmmm, can you read a jld2 file with NCDatasets? I am not sure how that package works. NCDatasets is a wrapper on top of the NetCDF C API which is based (in part) on the HDF5 library. As JLD2 is a julia implementation of HDF5, some simple JLD2 files are (surprisingly) readable NCDatasets but this is not generally the case, and arbitrary HDF5 files are [not supported by the NetCDF C library](https://docs.unidata.ucar.edu/netcdf-c/current/interoperability_hdf5.html). It is indeed better to use JLD2.jl for JLD2 files.😃",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127385759
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127725566:101,Availability,Error,Error,101,> Also the docs seem to fail because it can't find the docs for `ShallowWatermodel`?; > ; > ```; > ┌ Error: no docs found for 'ShallowWaterModel' in `@docs` block in src/model_setup/overview.md:26-28; > --; >   | │ ```@docs; >   | │ ShallowWaterModel; >   | │; > ```. [4d6cda6](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/4d6cda6f51e2739312ac971c459686b47618232f) should fix it! The docstring had moved away from its function :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1127725566
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128050024:804,Availability,error,error,804,"> Yeah this looks quite weird, are the boundary conditions / drag implemented correctly? (I am not sure what I did there); > . In the case without any closure (viscosity) the only boundary conditions we can impose are no-normal flow. But if we had to impose more, I would think that Neumann conditions on the tangential compoment and the height would be the best. > It seems like the southern ocean flows in the wrong direction. Looking at it, there is an incorrect minus sign in the wind stress because I just copied it from the bc which require a minus sign because of our sign convention (forcing do not). (remove the minus in lines 104 and 105) That might also help with the western boundary currents....; > . Yes, I agree that the ACC is going in the wrong direction, which suggests there is a sign error. When I look in `solution_and_tracer_tendencies.jl`, I see a `+` in front of forcings, so that looks right. Maybe there is a problem with how the wind stress is specified? . Is it easy to plot the wind stress? I imagine that would clarify what's going on. > It is also true that there is no density/salinity structure here... And the hydrostatic model is initialized with stratified ocean (maybe you want to play with the initial condition of `h`?). Also bathymetry is absent (which nucleates the eddies in the southern ocean during spinup).; > . I think starting off with `h` as constant, is a good choice. Certainly bathymetry would have an impact, but it should give us western boundary currents in the big oceans. > We should probably discuss how to implement bathymetry correctly, because I am not completely sure that what is done here is correct. On the other hand, I can also provide a spectrally ""smoothed"" bathymetry which might help with stability. @francispoulin let me know if that could be a good idea; > . I agree that it is important to do the bathymetry correctly. Smoothing it certainly would help. My first thought was to try it with the topography with 1/10 or 1/100 the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128050024
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128050024:2473,Testability,test,tests,2473,"I just copied it from the bc which require a minus sign because of our sign convention (forcing do not). (remove the minus in lines 104 and 105) That might also help with the western boundary currents....; > . Yes, I agree that the ACC is going in the wrong direction, which suggests there is a sign error. When I look in `solution_and_tracer_tendencies.jl`, I see a `+` in front of forcings, so that looks right. Maybe there is a problem with how the wind stress is specified? . Is it easy to plot the wind stress? I imagine that would clarify what's going on. > It is also true that there is no density/salinity structure here... And the hydrostatic model is initialized with stratified ocean (maybe you want to play with the initial condition of `h`?). Also bathymetry is absent (which nucleates the eddies in the southern ocean during spinup).; > . I think starting off with `h` as constant, is a good choice. Certainly bathymetry would have an impact, but it should give us western boundary currents in the big oceans. > We should probably discuss how to implement bathymetry correctly, because I am not completely sure that what is done here is correct. On the other hand, I can also provide a spectrally ""smoothed"" bathymetry which might help with stability. @francispoulin let me know if that could be a good idea; > . I agree that it is important to do the bathymetry correctly. Smoothing it certainly would help. My first thought was to try it with the topography with 1/10 or 1/100 the magntiude, to see if that would run with the same time step. However, maybe we should confirm that the wind stress is correct?. > To color the continents in black you can set to `NaN` all the vorticity points identically equal to zero and then `heatmap(vorticity, nan_color=:black)`. I tried the following but with no difference Did you mean something else?. ```heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:black)```. Also, I noticed the tests pass. That's nice to see!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128050024
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128069971:1316,Safety,avoid,avoid,1316,"Thanks @simone-silvestri !. > So, the wind stress has a negative sign in the script lines 104 and 105 which has to be removed; > ; > ```; > τˣ = arch_array(arch, - τˣ); > τʸ = arch_array(arch, - τʸ); > ```; > ; > to; > ; > ```; > τˣ = arch_array(arch, τˣ); > τʸ = arch_array(arch, τʸ); > ```; > ; > The negative sign was there because in the hydrostatic model wind stress is a boundary condition and, at the top, a negative flux is a source of momentum. In the shallow water model, this wind stress is a forcing so it does not follow the same convention (we should do something about this convention someday....) and the minus should be removed. (By boundary conditions I meant the forcings); > . That makes sense. I can push the change this afternoon. > to color the continents, if `ζ′` is your vorticity, you should do:; > ; > ```; > Z = interior(ζ′); > Z[Z .== 0] .= NaN; > heatmap!(ax, x, y, Z, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:black); > ```. Very nice. . I had to modify it a little bit (vorticity is not an offset array) but I was able to paint the continents black. . When I make `iter` an Observable, then the vorticity becomes an Observable or a matrix. Unfortunately, it doesn't like this line and I'm not sure how to get it to work with using `@lift`. . ```Z[Z .== 0] .= NaN```. To avoid this in the future, is there a way to do this before we save the data?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128069971
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953:180,Modifiability,variab,variable,180,"Then you can just load in your ""bottom"" from the `ImmersedBoundaryGrid` and set that to; ```; bottom[ bottom .>0 ] .= NaN; bottom[ bottom .<0 ] .= 0.0; ```; then when you lift the variable; ```; ζ′ = @lift file[""timestepper/ζ′/ *string($iter][:, 1:end-1, 1] .+ bottom; ```; (it is not going to be in the exact same position since `ζ′` is at faces and bottom is at centers, but on a 1/4 degree resolution I don't think makes much of a change)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953:18,Performance,load,load,18,"Then you can just load in your ""bottom"" from the `ImmersedBoundaryGrid` and set that to; ```; bottom[ bottom .>0 ] .= NaN; bottom[ bottom .<0 ] .= 0.0; ```; then when you lift the variable; ```; ζ′ = @lift file[""timestepper/ζ′/ *string($iter][:, 1:end-1, 1] .+ bottom; ```; (it is not going to be in the exact same position since `ζ′` is at faces and bottom is at centers, but on a 1/4 degree resolution I don't think makes much of a change)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128173670:31,Availability,mask,mask,31,"@simone-silvestri Do you mean `mask`? When I look in the file that's the only string I find in `immersed_boundary`. ```; julia> keys(file[""grid/immersed_boundary""]); 1-element Vector{String}:; ""mask""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128173670
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128173670:194,Availability,mask,mask,194,"@simone-silvestri Do you mean `mask`? When I look in the file that's the only string I find in `immersed_boundary`. ```; julia> keys(file[""grid/immersed_boundary""]); 1-element Vector{String}:; ""mask""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128173670
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480:25,Availability,mask,mask,25,"Ah sure, you can use the mask! (I forgot this was a `GridFittedBoundary` and not a `GridFittedBottom`); In this case you just have to covert the mask to Int and then NaN it; ```; mask = Int.(mask); mask[mask .== 1] .= NaN; ```. then you add that to the `@lift`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480:145,Availability,mask,mask,145,"Ah sure, you can use the mask! (I forgot this was a `GridFittedBoundary` and not a `GridFittedBottom`); In this case you just have to covert the mask to Int and then NaN it; ```; mask = Int.(mask); mask[mask .== 1] .= NaN; ```. then you add that to the `@lift`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480:179,Availability,mask,mask,179,"Ah sure, you can use the mask! (I forgot this was a `GridFittedBoundary` and not a `GridFittedBottom`); In this case you just have to covert the mask to Int and then NaN it; ```; mask = Int.(mask); mask[mask .== 1] .= NaN; ```. then you add that to the `@lift`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480:191,Availability,mask,mask,191,"Ah sure, you can use the mask! (I forgot this was a `GridFittedBoundary` and not a `GridFittedBottom`); In this case you just have to covert the mask to Int and then NaN it; ```; mask = Int.(mask); mask[mask .== 1] .= NaN; ```. then you add that to the `@lift`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480:198,Availability,mask,mask,198,"Ah sure, you can use the mask! (I forgot this was a `GridFittedBoundary` and not a `GridFittedBottom`); In this case you just have to covert the mask to Int and then NaN it; ```; mask = Int.(mask); mask[mask .== 1] .= NaN; ```. then you add that to the `@lift`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480:203,Availability,mask,mask,203,"Ah sure, you can use the mask! (I forgot this was a `GridFittedBoundary` and not a `GridFittedBottom`); In this case you just have to covert the mask to Int and then NaN it; ```; mask = Int.(mask); mask[mask .== 1] .= NaN; ```. then you add that to the `@lift`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128187480
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:124,Availability,mask,mask,124,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:216,Availability,mask,mask,216,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:261,Availability,mask,mask,261,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:289,Availability,mask,mask,289,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:294,Availability,mask,mask,294,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:445,Availability,mask,mask,445,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011:774,Energy Efficiency,green,green,774,"Thanks @simone-silvestri !. I had to do a few changes, replace `Int` with `Float`, and manually exclude the halo regions in mask, but in the end I was able to make an animation. . I am including my code below.; ```; mask = Float32.(file[""grid/immersed_boundary/mask""][5:end-4,4:end-4,1]); mask[mask .== 1] .= NaN. iter = Observable(0); iters = parse.(Int, keys(file[""timeseries/t""])); ζ′ = @lift(file[""timeseries/ζ/"" * string($iter)][:, :, 1] + mask). title = @lift(@sprintf(""Vorticity in Shallow Water Model at time = %s"", prettytime(file[""timeseries/t/"" * string($iter)]))); fig = Figure(resolution = (2000, 1000)); ax = Axis(fig[1,1], xlabel = ""longitude"", ylabel = ""latitude"", title=title). heatmap!(ax, x, y, ζ′, colormap=:balance, colorrange=(-2e-5, 2e-5), nan_color=:green). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128866011
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128944255:375,Integrability,depend,depends,375,"This is the bathymetry that the code is currently using. Looks pretty nice. @simone-silvestri I am looking in `shallow_water_advection_operators.jl` and find something odd. Bathymetry only appears in `div_Uh` but not in `div_hUu` and `div_hUv`. I think this is reversed as the evolution equation for height doesn't care about the bathymetry, it's only the pressure term that depends on it. Do you agree?. ; ![topography](https://user-images.githubusercontent.com/8239041/168833014-c399f006-b5cb-4c30-b72c-f4b221b911c0.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128944255
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326:1590,Availability,error,errors,1590,"That was my doubt...; I am not sure wether bathymetry should be added to the momentum equations (as an additional pressure term) or to the continuity equation following ; https://capture.dropbox.com/LxsRg26SQzFKu4lb. I think it depends on how you define `h`. If `h = η + Const` then you add bathymetry to the continuity. If you want to add it to the momentum then `h = η + Const + hB` (and then you add the bathymetry to the momentum because you have to subtract it from the pressure term as bathymetry does not directly influence momentum, but it is directly included in the continuity in this way). The difference is between (if `h = η + Const + hB`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=\partial_x g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=\partial_y g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x(hu)%2B\partial_y(hv)=0}"">. and (if `h = η + Const`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x((h%2Bh_B)u)%2B\partial_y((h%2Bh_B)v)=0}"">. the two formulations should be equivalent. I don't know specifically which method is better, I though including it in the continuity would avoid cancellation errors, What do you think?. for the bathymetry, it is the same one I use for the hydrostatic model, but it has a ton of grid noise in it. I think smoothing it a bit might be helpful with increasing the time step without affecting the solution too much. With @sandreza and @kburns we just implemented a spectral smoothing tool for bathymetry recently, so I though we can try it out here",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326:228,Integrability,depend,depends,228,"That was my doubt...; I am not sure wether bathymetry should be added to the momentum equations (as an additional pressure term) or to the continuity equation following ; https://capture.dropbox.com/LxsRg26SQzFKu4lb. I think it depends on how you define `h`. If `h = η + Const` then you add bathymetry to the continuity. If you want to add it to the momentum then `h = η + Const + hB` (and then you add the bathymetry to the momentum because you have to subtract it from the pressure term as bathymetry does not directly influence momentum, but it is directly included in the continuity in this way). The difference is between (if `h = η + Const + hB`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=\partial_x g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=\partial_y g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x(hu)%2B\partial_y(hv)=0}"">. and (if `h = η + Const`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x((h%2Bh_B)u)%2B\partial_y((h%2Bh_B)v)=0}"">. the two formulations should be equivalent. I don't know specifically which method is better, I though including it in the continuity would avoid cancellation errors, What do you think?. for the bathymetry, it is the same one I use for the hydrostatic model, but it has a ton of grid noise in it. I think smoothing it a bit might be helpful with increasing the time step without affecting the solution too much. With @sandreza and @kburns we just implemented a spectral smoothing tool for bathymetry recently, so I though we can try it out here",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326:1571,Safety,avoid,avoid,1571,"That was my doubt...; I am not sure wether bathymetry should be added to the momentum equations (as an additional pressure term) or to the continuity equation following ; https://capture.dropbox.com/LxsRg26SQzFKu4lb. I think it depends on how you define `h`. If `h = η + Const` then you add bathymetry to the continuity. If you want to add it to the momentum then `h = η + Const + hB` (and then you add the bathymetry to the momentum because you have to subtract it from the pressure term as bathymetry does not directly influence momentum, but it is directly included in the continuity in this way). The difference is between (if `h = η + Const + hB`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=\partial_x g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=\partial_y g h_B}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x(hu)%2B\partial_y(hv)=0}"">. and (if `h = η + Const`); <img src=""https://render.githubusercontent.com/render/math?math={\partial_tu-(\zeta%2Bf)v%2B\partial_x(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_tv%2B(\zeta%2Bf)u%2B\partial_y(gh%2Bk)=0}"">; <img src=""https://render.githubusercontent.com/render/math?math={\partial_th%2B\partial_x((h%2Bh_B)u)%2B\partial_y((h%2Bh_B)v)=0}"">. the two formulations should be equivalent. I don't know specifically which method is better, I though including it in the continuity would avoid cancellation errors, What do you think?. for the bathymetry, it is the same one I use for the hydrostatic model, but it has a ton of grid noise in it. I think smoothing it a bit might be helpful with increasing the time step without affecting the solution too much. With @sandreza and @kburns we just implemented a spectral smoothing tool for bathymetry recently, so I though we can try it out here",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128958326
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128972918:85,Modifiability,layers,layers,85,"I think we want `h` to be the layer thickness, so that these ideas generalize to ""n"" layers. Then the ""surface height"" is `H(x, y, t) = h(x, y, t) + b(x, y, t)`, where `b` is the height of the bathymetry. `eta` is defined relative to some reference height, eg `eta(x, y, t) = H(x, y, t) - H0`. I think with this definition, `b` comes into the pressure gradient but not momentum.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128972918
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128976538:289,Integrability,depend,depends,289,"Thanks @simone-silvestri . I believe we found our bug!. The continuity equation (conservation of mass equation) does not change whether there is topography or not. It should always be, as follows, where `h` is the total depth:. ```; ∂ₜh + ∇⋅(h u⃗) = 0; ```. The pressure gradient, however depends only on the free surface, or if we write it in terms of the total depth we need to include the topography,. ```; ∇ η = ∇(h + b); ```. I am not sure what convention we are following, but there might be a negative in front of the `b`. . Does that make sense?. The equations you shared have some mistakes in them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128976538
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128978553:9,Integrability,depend,depends,9,"Well, it depends what definition of `h` you have if you include b in momentum or continuity, I agree with you that if `h` is total depth, b is found in the momentum equations. If not is found in continuity",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128978553
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220:50,Modifiability,variab,variable,50,"There is a choice we need to make about the third variable: the total depth (what we usually denote as `h`) or the free-surface (what we usually denote with `\eta`). In the equations you have above, the first set of equations is using `h` as the total depth, but the second uses it as a free-surface. I am fine with either but if we are using the variable `h`, I would vote for the layer depth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220:347,Modifiability,variab,variable,347,"There is a choice we need to make about the third variable: the total depth (what we usually denote as `h`) or the free-surface (what we usually denote with `\eta`). In the equations you have above, the first set of equations is using `h` as the total depth, but the second uses it as a free-surface. I am fine with either but if we are using the variable `h`, I would vote for the layer depth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129053952:377,Energy Efficiency,schedul,schedule,377,"I am having some issues i modifying the code to output the solution fields and the vorticity. I tried the following but it doesn't work. What is the right syntax for including both solution fields and `Fields`?; ```; u, v, h = model.solution. ζ = Field(∂x(v) - ∂y(u)); compute!(ζ); ; simulation.output_writers[:surface_fields] = JLD2OutputWriter(model, merge(u, v, h, (; ζ)),; schedule = TimeInterval(save_interval),; filename = output_prefix * ""_surface"",; overwrite_existing = true). ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129053952
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129065140:156,Energy Efficiency,reduce,reduce,156,"@simone-silvestri : I wanted to confirm that when I try turning on topography, I get `NaN` after 30 minutes. This is with a time step of 20 seconds. When I reduce the time step by a factor of 2, it still happens at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129065140
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129071864:382,Energy Efficiency,schedul,schedule,382,"ok, then we shift the bathymetry as a pressure term in the momentum and initialize ; `h = bathymetry` in the global simulation. for the NaNs, it might be a problem of implementation, changing `h` to total depth might fix it... ; I'll change it now. @francispoulin you can try; ```; simulation.output_writers[:surface_fields] = JLD2OutputWriter(model, merge(model.solution, (; ζ)),; schedule = TimeInterval(save_interval),; filename = output_prefix * ""_surface"",; overwrite_existing = true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129071864
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129127651:133,Availability,error,error,133,"Actually, I get NaNs in the `h` field after just one time step (on the south USA coast near florida)... It must be an implementation error",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129127651
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129129182:97,Availability,error,error,97,"> Actually, I get NaNs in the `h` field after just one time step... It must be an implementation error. A great thing to observe! I am happy to chat if you wanted to discuss what's going on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129129182
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129168647:227,Energy Efficiency,reduce,reduced,227,"I reducing the time step to `0.1`, and it still becomes unstable. . What's interesting is that `NaN`'s appear in the velocity field after about 100 iterations, regardless of whether the time step is 20 or 0.1 seconds. . When I reduced the amplitude of the topograpahy by a factor of 2, it was stable for a long time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129168647
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129192752:186,Safety,avoid,avoid,186,"> It might be a problem of the forcings which are divided by `h` (I am not sure that is correct, but I forsee a problem when `h → 0`). I agree that this case is a problem and we need to avoid vanishing layer depth. I noticed that the bathymetry had a maximum that was 100, not 0. Since we are setting `h = - bathymetry`, i think we have negative heights from the very beginning. This is part of the problem maybe?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129192752
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129196732:216,Energy Efficiency,meter,meters,216,"That was for sure a problem, we want both bathymetry and `h` to be positive (I changed it in the later commit) It still NaNs very quickly though. . It is for sure vanishing `h`... if I displace the bathymetry by 400 meters, it's stable",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129196732
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129220793:194,Integrability,depend,depends,194,"> Nono in the code it should stay the same, because pressure due to `h` and `hB` should have opposite signs. Also for the `VectorInvariantFormulation` I directly calculate `g ∂xᵢ(h - hB)`. That depends on whether `b` is positive or negative. Before, `b <0`, and therefore the total height was `h = \eta -b`, where `\eta` is the free-surface. However, if `b > 0`, then `h = \eta + b`. . This becomes important when we evaluate the pressure graident. . In the first case we have, which is not what we had; ```; -∇η = -∇(h + b) = - ∇h - ∇b; ```; In the second case, we should have ; ```; -∇η = -∇(h - b) = - ∇h + ∇b; ```; which is what we have. Actually, now it seems that with changing the sign of `b`, the code is consistant with the equations we are now solving. Does that make sense?. But if you compute it directly, then do we need to extra `bathymetry` terms that I pointed to above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129220793
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129228701:990,Deployability,update,updated,990,"> Well, that is removed for `VectorInvariantFormulation`; > ; > ```; > @inline x_pressure_gradient(i, j, k, grid, g, h, hB, formulation) = ∂xᶠᶜᶜ(i, j, k, grid, half_g_h², h, g); > @inline y_pressure_gradient(i, j, k, grid, g, h, hB, formulation) = ∂yᶜᶠᶜ(i, j, k, grid, half_g_h², h, g); > ; > @inline x_pressure_gradient(i, j, k, grid, g, h, hB, ::VectorInvariantFormulation) = g * ∂xᶠᶜᶜ(i, j, k, grid, h_minus_hB, h, hB); > @inline y_pressure_gradient(i, j, k, grid, g, h, hB, ::VectorInvariantFormulation) = g * ∂yᶜᶠᶜ(i, j, k, grid, h_minus_hB, h, hB); > ; > @inline x_bathymetry(i, j, k, grid, g, h, hB, formulation) = g * h[i, j, k] * ∂xᶠᶜᶜ(i, j, k, grid, hB); > @inline y_bathymetry(i, j, k, grid, g, h, hB, formulation) = g * h[i, j, k] * ∂yᶜᶠᶜ(i, j, k, grid, hB); > ; > @inline x_bathymetry(i, j, k, grid, g, h, hB, ::VectorInvariantFormulation) = zero(grid); > @inline y_bathymetry(i, j, k, grid, g, h, hB, ::VectorInvariantFormulation) = zero(grid); > ```. Sorry, I didn't see the updated version. Since it's zero, i agree that the bathymetry terms don't do anything. . And we both agree that we should have `h - b` or `h - hB`, as you have in the code. The code looks good to me. Hmm, but we still have blow up very quickly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129228701
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129451506:239,Testability,test,tests,239,> It was a bathymetry problem... I smoothed it out and it works like a charm... I ll post the animation soon. That is wonderful news @simone-silvestri ! Congratulations on figuring it out. . I see a bunch of changes have happened and some tests are failing. I'll be happy to run something myself tomorrow and see how things work.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1129451506
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130027776:158,Security,access,access,158,"These are notes showing the equations for `ShallowWaterModel` in vector invariant form on the first page. I believe that @simone-silvestri and @glwagner have access to this document. On the second page I started derving the weak form using finite volume including both divergent and rotational viscosity. It needs more work. I believe that the divergent form is included in this PR and I would suggest saving the rotational form can be saved for a future PR. I need to better understand how the nonlinear terms are dealt with. Maybe @simone-silvestri can help me with this?. Some of this could make it's way into the docs, if there is interest. [ShallowWaterModel.pdf](https://github.com/CliMA/Oceananigans.jl/files/8716623/ShallowWaterModel.pdf)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130027776
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785:90,Availability,error,error,90,"@simone-silvestri : I tried running the branch in it's current version and received a GPU error. Is this something that works on your machine?. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Guh!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.v; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785:149,Availability,ERROR,ERROR,149,"@simone-silvestri : I tried running the branch in it's current version and received a GPU error. Is this something that works on your machine?. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Guh!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.v; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785:156,Performance,Load,LoadError,156,"@simone-silvestri : I tried running the branch in it's current version and received a GPU error. Is this something that works on your machine?. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Guh!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.v; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130310286:120,Deployability,update,update,120,"> shallow_water_global.mp4 ; > @francispoulin I ll take a look on why it doesn't work. Thanks @simone-silvestri for the update. . Yes, I agree that there is some weird behaviour near the poles. Maybe ringing, but I usually those of that only happening in spectral methods. Also, no western boundary currents seem to develop, or if they do, they don't develop any eddies. Maybe because of the viscosity?. I'm happy to try and run this and take a look but the code that is pushed doesn't run for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130310286
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1131228070:45,Availability,down,download,45,Can you put it somewhere public and use Base.download?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1131228070
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1137236644:268,Security,validat,validating,268,We are almost there... for what concerns advection (and Coriolis term) it seems like we're ok. I am not equally sure about bathymetry and closures. If you want to take a look at it go ahead! I think we can wait till the end of this week to merge so that we can finish validating all the terms a bit better,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1137236644
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1140401885:18,Deployability,update,update,18,Perhaps we should update https://github.com/CliMA/Oceananigans.jl/blob/ss-fjp/non-conservative-shallow-water/docs/src/physics/shallow_water_model.md ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1140401885
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1140402565:326,Security,validat,validation,326,"There are some merge conflicts after #2576. For the shallow_water_bickley_jet.jl example the merge should be. ```julia; gravitational_acceleration = 1; coriolis = FPlane(f=1). model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO5()); ```. But for the validation script I'm not sure...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1140402565
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141146381:20,Deployability,update,update,20,"> Perhaps we should update https://github.com/CliMA/Oceananigans.jl/blob/ss-fjp/non-conservative-shallow-water/docs/src/physics/shallow_water_model.md ?. Yes, good idea, and I can put something together, unless you prefer to @simone-silvestri ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141146381
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141167762:102,Testability,test,test,102,Go ahead @francispoulin! I ll fix the merge conflicts and set up the shallow water bickley regression test,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141167762
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141459542:2,Deployability,update,updated,2,I updated the model equations and you can find the code here. It occurs to me that I didn't include the topography in the conservative form. I can fix that easily enough but are there other things people would like fixed?. https://github.com/CliMA/Oceananigans.jl/blob/ss-fjp/non-conservative-shallow-water/docs/src/physics/shallow_water_model.md,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141459542
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141502801:4,Deployability,update,updated,4,"> I updated the model equations and you can find the code here. Nice!. > It occurs to me that I didn't include the topography in the conservative form. I can fix that easily enough but are there other things people would like fixed?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/ss-fjp/non-conservative-shallow-water/docs/src/physics/shallow_water_model.md. You mean ""other things people need to fix"" in the `.md` file or in the code?. I'll have a go a the docs. It may be easier to push changes instead of commenting on file. Is this OK @francispoulin?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141502801
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088:122,Availability,error,error,122,"Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088:150,Integrability,message,message,150,"Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1141614088
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890:124,Availability,error,error,124,"> Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?. Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid. I agree that we should have a test for that and maybe something in the docs, sometime?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890:152,Integrability,message,message,152,"> Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?. Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid. I agree that we should have a test for that and maybe something in the docs, sometime?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890:455,Testability,test,test,455,"> Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?. Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid. I agree that we should have a test for that and maybe something in the docs, sometime?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142148890
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142151054:316,Availability,down,down,316,"> In the Docs, should we write `𝐟` or `f𝐤` for the Coriolis term? Does the shallow water model only supports Coriolis aligned in the vertical?. Yes, for shallow water we can only have the Coriolis vector in the vertical direction. Otherwise, we will have 3D motion and the basic assumption of columnar motion breaks down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1142151054
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451:126,Availability,error,error,126,"> > Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?; > ; > Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid.; > ; > I agree that we should have a test for that and maybe something in the docs, sometime?. Added a note in docstring + an `@assert` check. See [43cfed7](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/43cfed75cf5601f543f91eef8cdd3c29d90fa05e)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451:154,Integrability,message,message,154,"> > Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?; > ; > Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid.; > ; > I agree that we should have a test for that and maybe something in the docs, sometime?. Added a note in docstring + an `@assert` check. See [43cfed7](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/43cfed75cf5601f543f91eef8cdd3c29d90fa05e)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451:470,Testability,test,test,470,"> > Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?; > ; > Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid.; > ; > I agree that we should have a test for that and maybe something in the docs, sometime?. Added a note in docstring + an `@assert` check. See [43cfed7](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/43cfed75cf5601f543f91eef8cdd3c29d90fa05e)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451:561,Testability,assert,assert,561,"> > Only `VectorInvariantFormulation()` works on a lat-lon grid right? I was trying to see whether the model constructor will error with some informative message if, e.g., a lat-lon grid is provided with `ConservativeFormulation()` but I couldn't see something. Is this something we'd like?; > ; > Correct. For the the conservative form we need to use the rectilinear grid but the vector invariant form, I think we can use any grid.; > ; > I agree that we should have a test for that and maybe something in the docs, sometime?. Added a note in docstring + an `@assert` check. See [43cfed7](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/43cfed75cf5601f543f91eef8cdd3c29d90fa05e)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143043451
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094:215,Availability,ERROR,ERROR,215,"I tried to create a lat-lon grid that is flat in `z` but got this... ```Julia; julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; Stacktrace:; [1] getindex(A::Vector{Any}, i1::Int64); @ Base ./array.jl:805; [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```. @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094:246,Security,access,access,246,"I tried to create a lat-lon grid that is flat in `z` but got this... ```Julia; julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; Stacktrace:; [1] getindex(A::Vector{Any}, i1::Int64); @ Base ./array.jl:805; [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; [4] top-level scope; @ REPL[5]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; ```. @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143210094
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355:282,Availability,error,error,282,"I found this in the validation script:; ```Julia; grid = LatitudeLongitudeGrid(size = (12, 14),; longitude = (-180, 180),; latitude = (-30, 30),; z = (0, 0),; halo = (4, 4),; topology = (Periodic, Bounded, Flat)); ```. Hm.... `z = (0, 0)` seems to be crucial! Removing it gives the error I posted above. But with `z`-dimension Flat then `z = (0, 0)` shouldn't be needed. We should fix the `LatitudeLongitudeGrid` constructor accordingly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355:20,Security,validat,validation,20,"I found this in the validation script:; ```Julia; grid = LatitudeLongitudeGrid(size = (12, 14),; longitude = (-180, 180),; latitude = (-30, 30),; z = (0, 0),; halo = (4, 4),; topology = (Periodic, Bounded, Flat)); ```. Hm.... `z = (0, 0)` seems to be crucial! Removing it gives the error I posted above. But with `z`-dimension Flat then `z = (0, 0)` shouldn't be needed. We should fix the `LatitudeLongitudeGrid` constructor accordingly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143215355
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669:228,Availability,ERROR,ERROR,228,"> I tried to create a lat-lon grid that is flat in `z` but got this...; > ; > ```julia; > julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); > ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; > Stacktrace:; > [1] getindex(A::Vector{Any}, i1::Int64); > @ Base ./array.jl:805; > [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; > [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; > [4] top-level scope; > @ REPL[5]:1; > [5] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```; > ; > @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?. Hmm, I have done this with help from @simone-silvestri . I'll go look at our example and get back with some details in a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669:259,Security,access,access,259,"> I tried to create a lat-lon grid that is flat in `z` but got this...; > ; > ```julia; > julia> grid = LatitudeLongitudeGrid(size=(36, 34), longitude = (-180, 180), latitude = (-85, 85), topology = (Bounded, Bounded, Flat)); > ERROR: BoundsError: attempt to access 0-element Vector{Any} at index [1]; > Stacktrace:; > [1] getindex(A::Vector{Any}, i1::Int64); > @ Base ./array.jl:805; > [2] generate_coordinate(FT::Type, topology::Type, N::Int64, H::Int64, coord::Nothing, arch::CPU); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/grid_generation.jl:60; > [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Nothing, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); > @ Oceananigans.Grids ~/Research/OC.jl/src/Grids/latitude_longitude_grid.jl:195; > [4] top-level scope; > @ REPL[5]:1; > [5] top-level scope; > @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52; > ```; > ; > @francispoulin, given that 3rd dimension needs to be flat, how were you running the SWE simulations on lat-lon grid?. Hmm, I have done this with help from @simone-silvestri . I'll go look at our example and get back with some details in a bit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143548669
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143584189:33,Security,validat,validate,33,"Yeah, the lat-lon grid does not `validate` Flat directions, we can change that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1143584189
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144196914:30,Testability,test,tests,30,"I looked at one of the failed tests in shallow water model and it seems to be at these lines below. ```; @testset ""Must be Flat in the vertical"" begin; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; ```; I tried it locally and the test passes, so I'm a bit confused as to the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144196914
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144196914:106,Testability,test,testset,106,"I looked at one of the failed tests in shallow water model and it seems to be at these lines below. ```; @testset ""Must be Flat in the vertical"" begin; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; ```; I tried it locally and the test passes, so I'm a bit confused as to the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144196914
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144196914:261,Testability,Assert,AssertionError,261,"I looked at one of the failed tests in shallow water model and it seems to be at these lines below. ```; @testset ""Must be Flat in the vertical"" begin; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; ```; I tried it locally and the test passes, so I'm a bit confused as to the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144196914
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144196914:369,Testability,test,test,369,"I looked at one of the failed tests in shallow water model and it seems to be at these lines below. ```; @testset ""Must be Flat in the vertical"" begin; grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; ```; I tried it locally and the test passes, so I'm a bit confused as to the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144196914
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628:32,Testability,test,tests,32,"> I looked at one of the failed tests in shallow water model and it seems to be at these lines below.; > ; > ```; > @testset ""Must be Flat in the vertical"" begin; > grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); > @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; > ```; > ; > I tried it locally and the test passes, so I'm a bit confused as to the problem. Ok! You found it. But the model throws an `ArgumentError`, not `AssertionError`. I'll fix it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628:117,Testability,test,testset,117,"> I looked at one of the failed tests in shallow water model and it seems to be at these lines below.; > ; > ```; > @testset ""Must be Flat in the vertical"" begin; > grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); > @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; > ```; > ; > I tried it locally and the test passes, so I'm a bit confused as to the problem. Ok! You found it. But the model throws an `ArgumentError`, not `AssertionError`. I'll fix it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628:276,Testability,Assert,AssertionError,276,"> I looked at one of the failed tests in shallow water model and it seems to be at these lines below.; > ; > ```; > @testset ""Must be Flat in the vertical"" begin; > grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); > @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; > ```; > ; > I tried it locally and the test passes, so I'm a bit confused as to the problem. Ok! You found it. But the model throws an `ArgumentError`, not `AssertionError`. I'll fix it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628:392,Testability,test,test,392,"> I looked at one of the failed tests in shallow water model and it seems to be at these lines below.; > ; > ```; > @testset ""Must be Flat in the vertical"" begin; > grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); > @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; > ```; > ; > I tried it locally and the test passes, so I'm a bit confused as to the problem. Ok! You found it. But the model throws an `ArgumentError`, not `AssertionError`. I'll fix it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628:510,Testability,Assert,AssertionError,510,"> I looked at one of the failed tests in shallow water model and it seems to be at these lines below.; > ; > ```; > @testset ""Must be Flat in the vertical"" begin; > grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1), topology=(Periodic,Periodic,Bounded)); > @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; > ```; > ; > I tried it locally and the test passes, so I'm a bit confused as to the problem. Ok! You found it. But the model throws an `ArgumentError`, not `AssertionError`. I'll fix it!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144201628
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500:664,Availability,ERROR,ERROR,664,"@navidcy . I am copying my output below and I believe it does throw `AssertionError`. Maybe you can try it locally and see if you get the same thing?. ```; julia> ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; [2022/06/01 18:12:45.154] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; [2022/06/01 18:12:45.155] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; ERROR: AssertionError: ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; Stacktrace:; [1] ShallowWaterModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, gravitational_acceleration::Int64, clock::Clock{Float64}, momentum_advection::UpwindBiasedFifthOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, mass_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, coriolis::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, bathymetry::Nothing, tracers::Tuple{}, diffusivity_fields::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, timestepper::Symbol, formulation::Oceananigans.Models.ShallowWaterModels.ConservativeFormulation); @ Oceananigans.Models.ShallowWaterModels ~/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:121; [2] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500:69,Testability,Assert,AssertionError,69,"@navidcy . I am copying my output below and I believe it does throw `AssertionError`. Maybe you can try it locally and see if you get the same thing?. ```; julia> ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; [2022/06/01 18:12:45.154] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; [2022/06/01 18:12:45.155] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; ERROR: AssertionError: ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; Stacktrace:; [1] ShallowWaterModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, gravitational_acceleration::Int64, clock::Clock{Float64}, momentum_advection::UpwindBiasedFifthOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, mass_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, coriolis::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, bathymetry::Nothing, tracers::Tuple{}, diffusivity_fields::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, timestepper::Symbol, formulation::Oceananigans.Models.ShallowWaterModels.ConservativeFormulation); @ Oceananigans.Models.ShallowWaterModels ~/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:121; [2] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500:671,Testability,Assert,AssertionError,671,"@navidcy . I am copying my output below and I believe it does throw `AssertionError`. Maybe you can try it locally and see if you get the same thing?. ```; julia> ShallowWaterModel(grid=grid, gravitational_acceleration=1) ; [2022/06/01 18:12:45.154] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; [2022/06/01 18:12:45.155] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; ERROR: AssertionError: ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; Stacktrace:; [1] ShallowWaterModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, gravitational_acceleration::Int64, clock::Clock{Float64}, momentum_advection::UpwindBiasedFifthOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, mass_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, coriolis::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, bathymetry::Nothing, tracers::Tuple{}, diffusivity_fields::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, timestepper::Symbol, formulation::Oceananigans.Models.ShallowWaterModels.ConservativeFormulation); @ Oceananigans.Models.ShallowWaterModels ~/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:121; [2] ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500:2130,Testability,Assert,AssertionError,2130," ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; Stacktrace:; [1] ShallowWaterModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, gravitational_acceleration::Int64, clock::Clock{Float64}, momentum_advection::UpwindBiasedFifthOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, mass_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, coriolis::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, bathymetry::Nothing, tracers::Tuple{}, diffusivity_fields::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, timestepper::Symbol, formulation::Oceananigans.Models.ShallowWaterModels.ConservativeFormulation); @ Oceananigans.Models.ShallowWaterModels ~/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:121; [2] top-level scope; @ REPL[10]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) . [2022/06/01 18:14:12.544] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; [2022/06/01 18:14:12.545] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; Test Passed; Thrown: AssertionError; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500:2646,Testability,Test,Test,2646," ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; Stacktrace:; [1] ShallowWaterModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, gravitational_acceleration::Int64, clock::Clock{Float64}, momentum_advection::UpwindBiasedFifthOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, mass_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, coriolis::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, bathymetry::Nothing, tracers::Tuple{}, diffusivity_fields::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, timestepper::Symbol, formulation::Oceananigans.Models.ShallowWaterModels.ConservativeFormulation); @ Oceananigans.Models.ShallowWaterModels ~/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:121; [2] top-level scope; @ REPL[10]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) . [2022/06/01 18:14:12.544] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; [2022/06/01 18:14:12.545] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; Test Passed; Thrown: AssertionError; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500:2667,Testability,Assert,AssertionError,2667," ShallowWaterModel requires `topology(grid, 3) === Flat`. Use `topology = (Periodic, Periodic, Flat)` when constructing `grid`.; Stacktrace:; [1] ShallowWaterModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, gravitational_acceleration::Int64, clock::Clock{Float64}, momentum_advection::UpwindBiasedFifthOrder, tracer_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, mass_advection::WENO5{Float64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, true, Nothing}, coriolis::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, bathymetry::Nothing, tracers::Tuple{}, diffusivity_fields::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, timestepper::Symbol, formulation::Oceananigans.Models.ShallowWaterModels.ConservativeFormulation); @ Oceananigans.Models.ShallowWaterModels ~/Software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:121; [2] top-level scope; @ REPL[10]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. julia> @test_throws AssertionError ShallowWaterModel(grid=grid, gravitational_acceleration=1) . [2022/06/01 18:14:12.544] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; [2022/06/01 18:14:12.545] WARN defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended -@-> /home/fpoulin/Software/Oceananigans.jl/src/Advection/weno_fifth_order.jl:187; Test Passed; Thrown: AssertionError; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144204500
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144208360:31,Testability,test,tests,31,"Should we merge this PR if all tests pass? Is there any other outstanding issues?. Regarding bathymetry properly included in `ConservativeFormulation()`, if there is more work needed there perhaps it belongs to a different PR (given the title of *this* PR)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144208360
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144211824:33,Testability,test,tests,33,"> Should we merge this PR if all tests pass? Is there any other outstanding issues?; > ; > Regarding bathymetry properly included in `ConservativeFormulation()`, if there is more work needed there perhaps it belongs to a different PR (given the title of _this_ PR)?. I agree that we should not wait to get bathymetry working with `ConservativeFormulation()`. . @simone-silvestri and I were playing with a realistic global ocean model using the `VectorInvariantForm` and had some success. There were some issues when we included realistic topography, but I don't think that should hold us back. That is a hard problem and will take more time. This is a great addition and should allow for some very interesting simulations!. And we have 208 comments. That must be a record?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144211824
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144236447:9,Testability,test,test,9,"OK, when test pass let's merge. And let's open an issue or PR for proper treatment of bathymetry in conservative formulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144236447
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144247947:171,Usability,undo,undo,171,"I agree. So I pushed [8eaf216](https://github.com/CliMA/Oceananigans.jl/pull/2522/commits/8eaf216f277bf245d4035b277bbe7d65766d2fec). If there are opposing opinions we can undo this. With this export we can do:. ```Julia; julia> ShallowWaterModel(; gravitational_acceleration=1, grid, formulation=VectorInvariantFormulation(), momentum_advection = VectorInvariant()); ```; instead of ; ```julia; julia> ShallowWaterModel(; gravitational_acceleration=1, grid, formulation=Oceananigans.Models.ShallowWaterModels.VectorInvariantFormulation(), momentum_advection = VectorInvariant()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1144247947
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1145558997:23,Testability,test,test,23,"omg, there is only one test pending... smells like merging is close by...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1145558997
https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1146244837:26,Testability,test,test,26,I 'll merge when the last test passes,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1146244837
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032:241,Integrability,wrap,wrapping,241,"> Expose the parallelism in RungeKutta3 timestepper and in the update_state! method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in @apply_regionally. This is not strictly necessary right? Just if we want to also support RungeKutta3.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032:2,Security,Expose,Expose,2,"> Expose the parallelism in RungeKutta3 timestepper and in the update_state! method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in @apply_regionally. This is not strictly necessary right? Just if we want to also support RungeKutta3.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118671032
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:367,Energy Efficiency,Allocate,Allocate,367,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:857,Modifiability,extend,extending,857,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:124,Performance,perform,perform,124,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:309,Performance,perform,perform,309,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:415,Performance,perform,perform,415,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:1211,Performance,perform,performant,1211,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:1333,Performance,perform,performance,1333,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:1530,Performance,perform,performant,1530,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:191,Integrability,wrap,wrapping,191,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:15,Modifiability,extend,extending,15,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:181,Performance,perform,performed,181,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:335,Performance,perform,performed,335,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119868092:99,Performance,perform,performed,99,"> For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). Just `storage` is an array; `plan` is a `CUFFT` object, not an array. If we use `cufftxt` would this happen be default?. ie with `cufftxt` we have to build a unified `storage` (and maybe unified eigenvalues). Then provided we can fill up storage correctly, and empty it correctly at the end, the thing that's left is to ""just do"" the fft (transposes etc handled under the hood). Does broadcasting work with unified memory arrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119868092
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674:1258,Deployability,configurat,configuration,1258,"> yep broadcasting works. My thought was that `plan` can be hacked to store unified memory. I still have to look at the data structure to see how to do it.; > ; > cufftxt basically works in the same way (local FFT direction distributed among the workers then transpose and nonlocal FFT). I am not sure they use unified memory but they for sure use transposes https://on-demand.gputechconf.com/gtc/2014/presentations/S4788-rapid-multi-gpu-programming-cuda-libraries.pdf. Mmm ok. Is this proposal a way to avoid cuffxt basically? I think what you outlined is somehow roughly how PencilFTTs work:. 1. FFT along local direction (dim=1); 2. Simultaneously communicate and permute data to (2, 1, 3) (or is it (2, 3, 1)?); 3. FFT along local direction (dim=2); 4. Simultaneously communicate and permute data to (3, 2, 1); 5. FFT along dim=3. At the end, the data has permutation (3, 2, 1). The backwards transform then reverses this process. `solver.storage` is actually a tuple of 3 preallocated arrays to support this algorithm. For the tridiagonal solver I think we want to use the same algorithm, except that we skip step 1 (ie the first step is to communicate and permute data with no transform). Once the two other transforms are complete we have data in the configuration (x, y, z) where z is local, and we can do a tridiagonal solve in eigenfunction space. Then we transform back and obtain data back in the (z, y, x) permutation, with z local, and copy into the pressure. We have to extend the tridiagonal solver to accomodate this kind of permutation for distributed CPU, so if we have an algorithm like the one above we can then also use it for MultiRegionGrid solves on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674:1258,Modifiability,config,configuration,1258,"> yep broadcasting works. My thought was that `plan` can be hacked to store unified memory. I still have to look at the data structure to see how to do it.; > ; > cufftxt basically works in the same way (local FFT direction distributed among the workers then transpose and nonlocal FFT). I am not sure they use unified memory but they for sure use transposes https://on-demand.gputechconf.com/gtc/2014/presentations/S4788-rapid-multi-gpu-programming-cuda-libraries.pdf. Mmm ok. Is this proposal a way to avoid cuffxt basically? I think what you outlined is somehow roughly how PencilFTTs work:. 1. FFT along local direction (dim=1); 2. Simultaneously communicate and permute data to (2, 1, 3) (or is it (2, 3, 1)?); 3. FFT along local direction (dim=2); 4. Simultaneously communicate and permute data to (3, 2, 1); 5. FFT along dim=3. At the end, the data has permutation (3, 2, 1). The backwards transform then reverses this process. `solver.storage` is actually a tuple of 3 preallocated arrays to support this algorithm. For the tridiagonal solver I think we want to use the same algorithm, except that we skip step 1 (ie the first step is to communicate and permute data with no transform). Once the two other transforms are complete we have data in the configuration (x, y, z) where z is local, and we can do a tridiagonal solve in eigenfunction space. Then we transform back and obtain data back in the (z, y, x) permutation, with z local, and copy into the pressure. We have to extend the tridiagonal solver to accomodate this kind of permutation for distributed CPU, so if we have an algorithm like the one above we can then also use it for MultiRegionGrid solves on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674:1485,Modifiability,extend,extend,1485,"> yep broadcasting works. My thought was that `plan` can be hacked to store unified memory. I still have to look at the data structure to see how to do it.; > ; > cufftxt basically works in the same way (local FFT direction distributed among the workers then transpose and nonlocal FFT). I am not sure they use unified memory but they for sure use transposes https://on-demand.gputechconf.com/gtc/2014/presentations/S4788-rapid-multi-gpu-programming-cuda-libraries.pdf. Mmm ok. Is this proposal a way to avoid cuffxt basically? I think what you outlined is somehow roughly how PencilFTTs work:. 1. FFT along local direction (dim=1); 2. Simultaneously communicate and permute data to (2, 1, 3) (or is it (2, 3, 1)?); 3. FFT along local direction (dim=2); 4. Simultaneously communicate and permute data to (3, 2, 1); 5. FFT along dim=3. At the end, the data has permutation (3, 2, 1). The backwards transform then reverses this process. `solver.storage` is actually a tuple of 3 preallocated arrays to support this algorithm. For the tridiagonal solver I think we want to use the same algorithm, except that we skip step 1 (ie the first step is to communicate and permute data with no transform). Once the two other transforms are complete we have data in the configuration (x, y, z) where z is local, and we can do a tridiagonal solve in eigenfunction space. Then we transform back and obtain data back in the (z, y, x) permutation, with z local, and copy into the pressure. We have to extend the tridiagonal solver to accomodate this kind of permutation for distributed CPU, so if we have an algorithm like the one above we can then also use it for MultiRegionGrid solves on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674:504,Safety,avoid,avoid,504,"> yep broadcasting works. My thought was that `plan` can be hacked to store unified memory. I still have to look at the data structure to see how to do it.; > ; > cufftxt basically works in the same way (local FFT direction distributed among the workers then transpose and nonlocal FFT). I am not sure they use unified memory but they for sure use transposes https://on-demand.gputechconf.com/gtc/2014/presentations/S4788-rapid-multi-gpu-programming-cuda-libraries.pdf. Mmm ok. Is this proposal a way to avoid cuffxt basically? I think what you outlined is somehow roughly how PencilFTTs work:. 1. FFT along local direction (dim=1); 2. Simultaneously communicate and permute data to (2, 1, 3) (or is it (2, 3, 1)?); 3. FFT along local direction (dim=2); 4. Simultaneously communicate and permute data to (3, 2, 1); 5. FFT along dim=3. At the end, the data has permutation (3, 2, 1). The backwards transform then reverses this process. `solver.storage` is actually a tuple of 3 preallocated arrays to support this algorithm. For the tridiagonal solver I think we want to use the same algorithm, except that we skip step 1 (ie the first step is to communicate and permute data with no transform). Once the two other transforms are complete we have data in the configuration (x, y, z) where z is local, and we can do a tridiagonal solve in eigenfunction space. Then we transform back and obtain data back in the (z, y, x) permutation, with z local, and copy into the pressure. We have to extend the tridiagonal solver to accomodate this kind of permutation for distributed CPU, so if we have an algorithm like the one above we can then also use it for MultiRegionGrid solves on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119919377:94,Safety,avoid,avoid,94,"Exactly, in practice a transpose is communication + permutation, but with `unified_memory` we avoid the communication part (I mean it is there but it's handled by CUDA)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119919377
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119921486:96,Safety,avoid,avoid,96,"> Exactly, in practice a transpose is communication + permutation, but with `unified_memory` we avoid the communication part (I mean it is there but it's handled by CUDA). So maybe we need three unified memory arrays for `solver.storage`, each permuted with respect to one another?. I was thinking it'd be nice to avoid coding it ourselves by using cufftxt, but now that we're talking about it doesn't seem too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119921486
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119921486:314,Safety,avoid,avoid,314,"> Exactly, in practice a transpose is communication + permutation, but with `unified_memory` we avoid the communication part (I mean it is there but it's handled by CUDA). So maybe we need three unified memory arrays for `solver.storage`, each permuted with respect to one another?. I was thinking it'd be nice to avoid coding it ourselves by using cufftxt, but now that we're talking about it doesn't seem too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119921486
https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1630300780:121,Safety,avoid,avoid,121,"yeah, #2795 does supersede this PR, although #2795 has a custom implementation of transpose + FFT which we might want to avoid now that pencilFFT supports CuArrays",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1630300780
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1125727906:15,Availability,error,error,15,I get the same error with no-slip on GPU.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1125727906
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639:65,Integrability,depend,depend,65,Also wondering why there isn't a test that catches this? Does it depend on the size of the problem?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639:33,Testability,test,test,33,Also wondering why there isn't a test that catches this? Does it depend on the size of the problem?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261408639
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:109,Availability,error,error,109,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:499,Deployability,release,release,499,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:16,Integrability,depend,depends,16,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:623,Modifiability,variab,variable,623,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:664,Modifiability,config,config,664,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:724,Modifiability,config,config,724,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873
https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:760,Modifiability,Config,Config,760,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873
https://github.com/CliMA/Oceananigans.jl/pull/2532#issuecomment-1120109027:52,Deployability,update,update,52,"Ok, looking at the code more I see we don't need to update `inactive_node` or peripheral_node for `Flat`. The reason is they don't do any array access on their own (except potentially through `immersed_cell`). So the right fix here is to modify `immersed_cell`. I took the liberties to scope creep and also added unrelated comments and did some clean up in `inactive_node`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2532#issuecomment-1120109027
https://github.com/CliMA/Oceananigans.jl/pull/2532#issuecomment-1120109027:144,Security,access,access,144,"Ok, looking at the code more I see we don't need to update `inactive_node` or peripheral_node for `Flat`. The reason is they don't do any array access on their own (except potentially through `immersed_cell`). So the right fix here is to modify `immersed_cell`. I took the liberties to scope creep and also added unrelated comments and did some clean up in `inactive_node`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2532#issuecomment-1120109027
https://github.com/CliMA/Oceananigans.jl/issues/2534#issuecomment-1120301572:309,Availability,error,error,309,"I guess it's mostly for boundary conditions. With boundary conditions I don't think we want to auto-partition, because very often the application of using a boundary condition array is to pass fluxes between models or from data into a model. I think the most useable / friendly solution is to throw a helpful error that tells the user to use `on_grid`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2534#issuecomment-1120301572
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120302022:70,Modifiability,variab,variable,70,"The more I think about it, the more I like the idea of an environment variable to have a ""pickup mode"". Let's see what others think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120302022
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:296,Availability,checkpoint,checkpoint,296,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:450,Availability,checkpoint,checkpoint,450,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:509,Availability,checkpoint,checkpoint,509,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:662,Availability,checkpoint,checkpointer,662,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:821,Availability,redundant,redundant,821,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:27,Safety,Avoid,Avoid,27,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:796,Safety,safe,safely,796,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:803,Safety,avoid,avoid,803,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544:821,Safety,redund,redundant,821,"I'm gonna add to this:. 1. Avoid throwing a warning when initializing an output writer in ""pickup mode""; 2. Perhaps some way to check that a time-series is ""valid"" when appending to a file during pickup mode?. Here's an example that illustrates how 2 could work:. - During a big run, we record a checkpoint at iteration 1234.; - The run continues, saving high frequency output for iterations 1244 and 1254.; - The allocation ends and the most recent checkpoint is 1234. -- later --. - We restart the run from checkpoint 1234.; - When doing this, we observe that existing output writers have output for 1244 and 1254.; - This means that compatibility between the checkpointer and existing output writers _requires_ that the pickup simulation triggers output writing at 1244 and 1254 (which we can safely avoid, since it's redundant with the data already in the file. Conversely, if the pickup simulation does _not_ ask for output at these iterations, something is wrong (perhaps an invalid timeseries is being recorded). Similar to overriding `overwrite_existing`, implementing this feature basically makes the output writers ""pickup-aware"" (either after creation in `run!`, or via some environmental ""pickup mode"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120443544
https://github.com/CliMA/Oceananigans.jl/pull/2536#issuecomment-1120338368:178,Security,validat,validation,178,"This PR also provides _experimental_ (untested) supported for Bounded domains: @johnryantaylor @raphaelouillon. Future work / PRs can add tests for these cases, and perhaps some validation experiments. I also think we've unlocked the requirements for FFT + tridiagonal solve, but that is yet again for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536#issuecomment-1120338368
https://github.com/CliMA/Oceananigans.jl/pull/2536#issuecomment-1120338368:138,Testability,test,tests,138,"This PR also provides _experimental_ (untested) supported for Bounded domains: @johnryantaylor @raphaelouillon. Future work / PRs can add tests for these cases, and perhaps some validation experiments. I also think we've unlocked the requirements for FFT + tridiagonal solve, but that is yet again for a future PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536#issuecomment-1120338368
https://github.com/CliMA/Oceananigans.jl/pull/2537#issuecomment-1120614353:49,Deployability,patch,patch,49,"You could classify this as a bug fix, so I think patch is appropriate. If we go now it'll capture both this and #2536. Or we can wait for #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537#issuecomment-1120614353
https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1188224053:39,Testability,test,tests,39,@glwagner it seems the only reason the tests aren't passing is because `mpiexecjl` isn't properly linked:. ```; /bin/bash: /storage5/buildkite-agent/.julia-7523/bin/mpiexecjl: No such file or directory ; ```. Maybe fix that and merge since (apparently) this PR is otherwise ready to go?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1188224053
https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1189222498:23,Availability,error,error,23,There's a less trivial error here: https://buildkite.com/clima/oceananigans/builds/7523#311535ff-f56d-410e-8571-c3b1d9757daf. I'll try to restart the whole build and see what happens.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1189222498
https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194144494:30,Testability,test,tests,30,Just realized the distributed tests have been running for 6 days. I guess it's fair to say there's still something to fix lol. Just killed it to save resources,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194144494
https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194182257:25,Testability,test,test,25,"@tomchor are you able to test locally? I believe these passed locally for me, so the problem might be relatively easy to solve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194182257
https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194189228:27,Testability,test,test,27,"> @tomchor are you able to test locally? I believe these passed locally for me, so the problem might be relatively easy to solve. I've never tested anything in parallel locally, but I can definitely try",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194189228
https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194189228:141,Testability,test,tested,141,"> @tomchor are you able to test locally? I believe these passed locally for me, so the problem might be relatively easy to solve. I've never tested anything in parallel locally, but I can definitely try",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194189228
https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194728110:20,Testability,test,tests,20,@glwagner I ran the tests and they got stuck in the same place where [this test](https://buildkite.com/clima/oceananigans/builds/8208#01821729-56d9-42df-8776-730055a3332e) got stuck. So it appears that there's something to be fixed here...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194728110
https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194728110:75,Testability,test,test,75,@glwagner I ran the tests and they got stuck in the same place where [this test](https://buildkite.com/clima/oceananigans/builds/8208#01821729-56d9-42df-8776-730055a3332e) got stuck. So it appears that there's something to be fixed here...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2538#issuecomment-1194728110
https://github.com/CliMA/Oceananigans.jl/pull/2540#issuecomment-1121030783:67,Modifiability,extend,extended,67,I think some stuff in `broadcast_abstract_field.jl` may need to be extended:. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl. specifically. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L18. which helps us identify when we're broadcasting between arrays and fields so that we hit . https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L42. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L46. Also. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L24-L28. where we take a shortcut for things like `u .= a` where `u isa Field` and a is some kind of array.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540#issuecomment-1121030783
https://github.com/CliMA/Oceananigans.jl/issues/2541#issuecomment-1121534955:125,Deployability,update,updated,125,"Thank you @glwagner and @navidcy , you are correct my Oceananigans was not the latest and greatest. I am happy to say that I updated and it's all better now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2541#issuecomment-1121534955
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1122842967:125,Security,validat,validation,125,Try deleting `show_axis=false` from:; https://github.com/CliMA/Oceananigans.jl/blob/d4a462b259073b5c698f2cf9a8f419304f74262b/validation/barotropic_gyre/visualize_barotropic_gyre.jl#L64. ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1122842967
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1122845108:6,Deployability,update,updated,6,Makie updated the way this works. See second bullet point in https://makie.juliaplots.org/stable/documentation/news/#v016,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1122845108
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:53,Availability,error,error,53,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:191,Availability,error,error,191,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:410,Availability,error,error,410,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:452,Availability,error,error,452,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:671,Availability,error,error,671,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:713,Availability,error,error,713,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:936,Availability,error,error,936,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1379,Availability,ERROR,ERROR,1379,"ADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1149,Deployability,install,installed,1149,"gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1669,Energy Efficiency,monitor,monitor,1669,"lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1683,Energy Efficiency,Monitor,Monitor,1683,"driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:2014,Energy Efficiency,monitor,monitor,2014,"/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:435 [inlined]; [9] backend_display; @ ~/.julia/packages/GLMakie/XG7Hm/src/display.jl:2 [inlined]; [10] VideoStream(scene::Scene; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/displa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:203,Performance,LOAD,LOADER,203,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:427,Performance,load,load,427,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:464,Performance,LOAD,LOADER,464,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:688,Performance,load,load,688,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:725,Performance,LOAD,LOADER,725,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:953,Performance,load,load,953,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1386,Performance,Load,LoadError,1386,"ADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:120,Security,validat,validation,120,"I removed `show_axis=false` and it still produces an error, see below. . ```; fpoulin@pop-os:~/Software/Oceananigans.jl/validation/barotropic_gyre$ julia visualize_barotropic_gyre.jl ; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fulls",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:3346,Security,validat,validation,3346,"::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:435 [inlined]; [9] backend_display; @ ~/.julia/packages/GLMakie/XG7Hm/src/display.jl:2 [inlined]; [10] VideoStream(scene::Scene; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:329; [11] #VideoStream#909; @ ~/.julia/packages/Makie/umL6V/src/display.jl:342 [inlined]; [12] Record(func::var""#5#10""{Observable{Int64}, Vector{Int64}}, scene::Figure, iter::Vector{Int64}; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:589; [13] #record#915; @ ~/.julia/packages/Makie/umL6V/src/display.jl:584 [inlined]; [14] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:72; [15] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:3457,Security,validat,validation,3457,"::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:435 [inlined]; [9] backend_display; @ ~/.julia/packages/GLMakie/XG7Hm/src/display.jl:2 [inlined]; [10] VideoStream(scene::Scene; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:329; [11] #VideoStream#909; @ ~/.julia/packages/Makie/umL6V/src/display.jl:342 [inlined]; [12] Record(func::var""#5#10""{Observable{Int64}, Vector{Int64}}, scene::Figure, iter::Vector{Int64}; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:589; [13] #record#915; @ ~/.julia/packages/Makie/umL6V/src/display.jl:584 [inlined]; [14] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:72; [15] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:3582,Security,validat,validation,3582,"::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:291 [inlined]; [7] global_gl_screen(resolution::Tuple{Int64, Int64}, visibility::Bool, tries::Int64); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:436; [8] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:435 [inlined]; [9] backend_display; @ ~/.julia/packages/GLMakie/XG7Hm/src/display.jl:2 [inlined]; [10] VideoStream(scene::Scene; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:329; [11] #VideoStream#909; @ ~/.julia/packages/Makie/umL6V/src/display.jl:342 [inlined]; [12] Record(func::var""#5#10""{Observable{Int64}, Vector{Int64}}, scene::Figure, iter::Vector{Int64}; framerate::Int64); @ Makie ~/.julia/packages/Makie/umL6V/src/display.jl:589; [13] #record#915; @ ~/.julia/packages/Makie/umL6V/src/display.jl:584 [inlined]; [14] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:72; [15] top-level scope; @ ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:94; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1124016648:53,Deployability,install,installed,53,"I realize that this is a problem with how `Makie` is installed on my compter. I will try and figure this out but if anyone has any advice, please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1124016648
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1128314831:249,Energy Efficiency,monitor,monitors,249,"Oh, if GLMakie works with the ""correct"" GPU then stick to that. Because it produces output. CairoMakie doesn't produce a figure but only can save, e.g., to a png file. We use CairoMakie in the docs because they are build on remote computers without monitors.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1128314831
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1144819974:13,Deployability,update,update,13,I'm going to update this shortly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1144819974
https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1480575821:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1480575821
https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122646996:95,Security,validat,validation,95,"Change. https://github.com/CliMA/Oceananigans.jl/blob/d4a462b259073b5c698f2cf9a8f419304f74262b/validation/mesoscale_turbulence/baroclinic_adjustment.jl#L51. to. ```julia; diffusive_closure = VerticalScalarDiffusivity(VerticallyImplicitTimeDiscretization(), ν = νz, κ = κz) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122646996
https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122736117:52,Availability,error,error,52,"Thanks @glwagner , that helped. . I see there is an error with `FieldSlicer`. The lines should be updated to be as follows:. ```; slicers = (west = (1, :, :),; east = (grid.Nx, :, :),; south = (:, 1, :),; north = (:, grid.Ny, :),; bottom = (:, :, 1),; top = (:, :, grid.Nz)); ```. Then it complains about this line in the two `JLD2OutputWriter`. These lines need to be removed,. ```; field_slicer = field_slicer; ```. Finally, `AverageField` needs to be updated, as follows:. ```; B = Field(Average(model.tracers.b, dims=1)); C = Field(Average(model.tracers.c, dims=1)); U = Field(Average(model.velocities.u, dims=1)); V = Field(Average(model.velocities.v, dims=1)); W = Field(Average(model.velocities.w, dims=1)); ```. Things seem to be running now. I created a PR in #2545 and will close this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122736117
https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122736117:98,Deployability,update,updated,98,"Thanks @glwagner , that helped. . I see there is an error with `FieldSlicer`. The lines should be updated to be as follows:. ```; slicers = (west = (1, :, :),; east = (grid.Nx, :, :),; south = (:, 1, :),; north = (:, grid.Ny, :),; bottom = (:, :, 1),; top = (:, :, grid.Nz)); ```. Then it complains about this line in the two `JLD2OutputWriter`. These lines need to be removed,. ```; field_slicer = field_slicer; ```. Finally, `AverageField` needs to be updated, as follows:. ```; B = Field(Average(model.tracers.b, dims=1)); C = Field(Average(model.tracers.c, dims=1)); U = Field(Average(model.velocities.u, dims=1)); V = Field(Average(model.velocities.v, dims=1)); W = Field(Average(model.velocities.w, dims=1)); ```. Things seem to be running now. I created a PR in #2545 and will close this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122736117
https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122736117:454,Deployability,update,updated,454,"Thanks @glwagner , that helped. . I see there is an error with `FieldSlicer`. The lines should be updated to be as follows:. ```; slicers = (west = (1, :, :),; east = (grid.Nx, :, :),; south = (:, 1, :),; north = (:, grid.Ny, :),; bottom = (:, :, 1),; top = (:, :, grid.Nz)); ```. Then it complains about this line in the two `JLD2OutputWriter`. These lines need to be removed,. ```; field_slicer = field_slicer; ```. Finally, `AverageField` needs to be updated, as follows:. ```; B = Field(Average(model.tracers.b, dims=1)); C = Field(Average(model.tracers.c, dims=1)); U = Field(Average(model.velocities.u, dims=1)); V = Field(Average(model.velocities.v, dims=1)); W = Field(Average(model.velocities.w, dims=1)); ```. Things seem to be running now. I created a PR in #2545 and will close this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543#issuecomment-1122736117
https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468:56,Security,validat,validation,56,I compared them and I don't see anything that is in the validation that we don't have in the example. I am going to close this PR and create a new one that simply removes that file.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468
https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468:156,Usability,simpl,simply,156,I compared them and I don't see anything that is in the validation that we don't have in the example. I am going to close this PR and create a new one that simply removes that file.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545#issuecomment-1123086468
https://github.com/CliMA/Oceananigans.jl/pull/2547#issuecomment-1125632111:151,Availability,down,down,151,This PR also fixes some memory leakage problems with the Implicit solver which would fill up the memory in case of large (1e8) meshes quickly and slow down execution to wait for GC,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2547#issuecomment-1125632111
https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125402382:116,Availability,error,error,116,Good observation and I would vote for yes. I would prefer if we check and if the sizes don't match the user gets an error and is asked to fix it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125402382
https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125536496:166,Integrability,interface,interfaces,166,Just to clarify that the output was expected (z^aac is an OffsetArray that includes halo points). But I agree a warning would be nice if the length of a coordinate's interfaces does not match the requested cells + 1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125536496
https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125538583:142,Availability,error,error,142,"> The length is correct -- 4 points plus 3 halo points on either side. You're right! That was a bad example. But like you mentioned later, an error/warning is desired",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548#issuecomment-1125538583
https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125298630:207,Integrability,depend,depend,207,"I think you can define in `ImmerdsedBoundaries`; ```; return_metrics(grid::ImmersedBoundaryGrid) = return_metrics(grid.underlying_grid); ```; and that should solve the problem, because the coefficients only depend on the metrics, not on the grid itself (then maybe change some warnings); ideally we can put the `return_metrics` function in the `Grids` module, as it is not particular to `WENO` (although it is used only there at the moment)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125298630
https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125307847:225,Integrability,depend,depend,225,"> I think you can define in `ImmerdsedBoundaries`; > ; > ```; > return_metrics(grid::ImmersedBoundaryGrid) = return_metrics(grid.underlying_grid); > ```; > ; > and that should solve the problem, because the coefficients only depend on the metrics, not on the grid itself (then maybe change some warnings) ideally we can put the `return_metrics` function in the `Grids` module, as it is not particular to `WENO` (although it is used only there at the moment). Good point!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125307847
https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125330740:26,Testability,test,test,26,"Should we have a separate test file for construction of things like `WENO5(grid=grid)`? For this specific case there isn't any (and no obvious place to include it rn):. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<WENO5"" *  ✔  25s   base  ; test_hydrostatic_free_surface_models.jl: for momentum_advection in (VectorInvariant(), CenteredSecondOrder(), WENO5()); test_multi_region_advection_diffusion.jl: tracer_advection = WENO5(),; test_multi_region_advection_diffusion.jl: tracer_advection = WENO5(),; test_nonhydrostatic_models.jl: for scheme in (WENO5(), UpwindBiasedFifthOrder()); test_shallow_water_models.jl: for advection in (nothing, CenteredSecondOrder(), WENO5()); test_time_stepping.jl: WENO5()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125330740
https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125330740:198,Testability,test,test,198,"Should we have a separate test file for construction of things like `WENO5(grid=grid)`? For this specific case there isn't any (and no obvious place to include it rn):. ```; ~/repos/Oceananigans.jl/test $ grep -r ""\<WENO5"" *  ✔  25s   base  ; test_hydrostatic_free_surface_models.jl: for momentum_advection in (VectorInvariant(), CenteredSecondOrder(), WENO5()); test_multi_region_advection_diffusion.jl: tracer_advection = WENO5(),; test_multi_region_advection_diffusion.jl: tracer_advection = WENO5(),; test_nonhydrostatic_models.jl: for scheme in (WENO5(), UpwindBiasedFifthOrder()); test_shallow_water_models.jl: for advection in (nothing, CenteredSecondOrder(), WENO5()); test_time_stepping.jl: WENO5()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125330740
https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125341674:145,Deployability,release,release,145,We should probably register a new version after this (no need to bump version). I think there are some bug fixes that haven't been captured in a release,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549#issuecomment-1125341674
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126373167:29,Availability,error,error,29,I'm not sure I agree with an error --- what do others think? It seems like you could do this intentionally and we wouldn't want to forbid that. But I don't feel strongly.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126373167
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126377818:40,Availability,error,errors,40,"Another though: I think we should limit errors to when we _know_ something is incorrect. Here we restricting what users can do because of our ""opinion"" about how users should write code, which I think is a misguided philosophy. A warning is appropriate because this is a mistake in the majority of cases, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126377818
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126379756:121,Availability,error,error,121,"I couldn't think of any situation where a user would intentionally want to mismatch a coordinate and its size, hence the error. But I also don't feel particularly strong about it, so feel free to change it to a warning.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126379756
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:584,Availability,down,down,584,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:911,Availability,error,error,911,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:242,Energy Efficiency,reduce,reduce,242,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:511,Energy Efficiency,power,power,511,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:554,Integrability,depend,dependence,554,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:1005,Safety,predict,predict,1005,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524:886,Usability,guid,guideline,886,"Well, the usage is limited here because we always ""count from 1"". For an atmospheric simulation with a sponge layer on top, you might have a stretched coordinate as the domain gets higher and higher. Then you could keep your levels fixed and reduce the height of the domain by changing Nz. This might be convenient if you've carefully designed your vertical coordinate to get the spacings ""right"" at the bottom of the domain, but care a lot less about what happens higher up. Then if you get more computational power, you can increase Nz (decreasing the dependence of the stuff lower down on your ""sponge region""). We actually have a similar situation in the ocean where the vertical coordinate is carefully designed in the upper ocean; we could in principle ask for fewer ""lower"" levels --- now that would be a feature we might want to add too!. I think that's why it's good to have a guideline like ""throw an error when we _know_ things are incorrect"". Because if we get into the business of trying to ""predict what users want to do"", we'll quickly find our imaginations are limited! Personally my philosophy is to allow as much as possible because it lets people exercise creativity as freely as possible (not limited by what I personally think people should do). What do you think about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126381524
https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126391584:179,Availability,error,error,179,"There's definitely a trade-off in this case, as in many... and there are different, valid, philosophies for designing an API. I just can't think of another case where we throw an error when something could in principle be valid. So this would mark a turning point for us in terms of API design. Which is ok if that's what people would prefer. I just personally get annoyed when I encounter this kind of thing with other codes (a developer couldn't ""imagine"" what I want to do, so they made it impossible without changing the source code...), so I thought we might want to take a different approach! Since it's impossible to imagine all possible uses, I think a different approach is to ask ""what would be _wrong_"", and prevent that if possible (ie, a blacklisting approach rather than a whitelisting approach, for API design specifically).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550#issuecomment-1126391584
https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126149856:122,Availability,error,error,122,"If everyone's okay with this, I'll register a new version after merging since I'd say this bug is important (it throws an error every time value or gradient BCs are applied to IBMs).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126149856
https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126166730:22,Modifiability,variab,variables,22,"Perhaps we rename all variables to `closures` when they are tuples of 2 elements or more? Just a suggestion, feel free to ignore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126166730
https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142:799,Modifiability,extend,extendlow,799,"As soon as I put `fig[0, :] = Label(fig, title, textsize=24)` then the plot size gets all small and weird... Any ideas?. ```Julia; using GLMakie. filename = ""internal_wave"". fig = Figure(resolution = (800, 400)). ax = Axis(fig[1, 1];; xlabel = ""x"",; ylabel = ""z"",; limits = ((-π, π), (-π, π)),; aspect = AxisAspect(1)). iter = Observable(0). using JLD2. file = jldopen(filename * "".jld2""); grid = file[""serialized/grid""]. title = @lift(string(""ωt = "",; string(round(file[""timeseries/t/"" * string($iter)] * ω, digits=3)))). w = @lift(Array(file[""timeseries/w/"" * string($iter)][:, 1, :])). x, y, z = nodes((Center, Center, Center), grid). w_lim = 1e-8; w_levels = range(-w_lim, stop=w_lim, length=10). contourf!(ax, x, z, w; ; levels = w_levels,; colormap = :balance,; colorrange = (-w_lim, w_lim),; extendlow = :auto,; extendhigh = :auto). fig[0, :] = Label(fig, title, textsize=24). iterations = parse.(Int, keys(file[""timeseries/t""])). record(fig, filename * "".mp4"", iterations, framerate=8) do i; @info ""Plotting iteration $i of $(iterations[end])...""; iter[] = i; end; ```. https://user-images.githubusercontent.com/7112768/168449952-2ce68db5-1e21-4f04-8dc8-a29d2fba6c57.mp4. While with **everything same except** the line `fig[0, :] = Label(fig, title, textsize=24)` I get. https://user-images.githubusercontent.com/7112768/168450064-ab456174-06da-45e4-8674-55f0a3356091.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142
https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142:819,Modifiability,extend,extendhigh,819,"As soon as I put `fig[0, :] = Label(fig, title, textsize=24)` then the plot size gets all small and weird... Any ideas?. ```Julia; using GLMakie. filename = ""internal_wave"". fig = Figure(resolution = (800, 400)). ax = Axis(fig[1, 1];; xlabel = ""x"",; ylabel = ""z"",; limits = ((-π, π), (-π, π)),; aspect = AxisAspect(1)). iter = Observable(0). using JLD2. file = jldopen(filename * "".jld2""); grid = file[""serialized/grid""]. title = @lift(string(""ωt = "",; string(round(file[""timeseries/t/"" * string($iter)] * ω, digits=3)))). w = @lift(Array(file[""timeseries/w/"" * string($iter)][:, 1, :])). x, y, z = nodes((Center, Center, Center), grid). w_lim = 1e-8; w_levels = range(-w_lim, stop=w_lim, length=10). contourf!(ax, x, z, w; ; levels = w_levels,; colormap = :balance,; colorrange = (-w_lim, w_lim),; extendlow = :auto,; extendhigh = :auto). fig[0, :] = Label(fig, title, textsize=24). iterations = parse.(Int, keys(file[""timeseries/t""])). record(fig, filename * "".mp4"", iterations, framerate=8) do i; @info ""Plotting iteration $i of $(iterations[end])...""; iter[] = i; end; ```. https://user-images.githubusercontent.com/7112768/168449952-2ce68db5-1e21-4f04-8dc8-a29d2fba6c57.mp4. While with **everything same except** the line `fig[0, :] = Label(fig, title, textsize=24)` I get. https://user-images.githubusercontent.com/7112768/168450064-ab456174-06da-45e4-8674-55f0a3356091.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142
https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126952448:131,Safety,avoid,avoid,131,"> As soon as I put `fig[0, :] = Label(fig, title, textsize=24)` then the plot size gets all small and weird... Any ideas?. I would avoid using index `0` and also using `:` if you can. What happens when you put the label in `fig[1, 1:2]` and the contours in `fig[1, 2]`?. I also think it's probably better to use heatmap for all plots. While contour does look better, heatmap is a lot faster and less finnicky, and we get 95% percent of the educational value of the visualization with a heatmap. I almost never use contour except at the very final stages of visualization for paper plots, so...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126952448
https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126969454:10,Safety,avoid,avoid,10,"> I would avoid using index `0` and also using `:` if you can. What happens when you put the label in `fig[1, 1:2]` and the contours in `fig[1, 2]`?. The 0 indexing was not the issue. `tellwidth=false` did the trick!!!. ```julia; fig[0, :] = Label(fig, title, textsize=24, tellwidth=false); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126969454
https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126983885:12,Safety,avoid,avoid,12,Can we also avoid using index 0 even if it works this time?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126983885
https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128280245:206,Modifiability,layers,layers,206,This is great to see!. I imagine we could use this for the height field in `ShallowWaterModel` to allow for wetting and drying for a single layer. And also to prevent layer collapse in the case of multiple layers.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128280245
https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128350043:85,Modifiability,refactor,refactor,85,Just a small plea to make this implementation compatible with / moves us towards the refactor envisioned in #2454,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128350043
https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1130023720:671,Integrability,depend,depend,671,"> I like it! I changed the NonhydrostaticModel to be the same.; > ; > A way to facilitate users is that we leave the option to specify a global `advection` (so that we keep the keyword) or two separate `momentum_advection` and `tracer_advection`. I would rather just change it to be consistent with the HydrostaticFreeSurfaceModel directly.; > ; > what do you guys think?. I think we should do that in a different PR because it's a major, major breaking change to the most popular model!. As for the syntax I'd prefer --- I would prefer one keyword argument `advection`. We need that for the changes proposed in #2454 --- because the schemes for different components can depend on one another. So it's easier to put it in one object. I also feel it's better to just specify `grid` once to the `advection` constructor. But that would be harder to implement now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1130023720
https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128827661:46,Availability,error,error,46,I tried the same code and reproduced the same error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128827661
https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128947176:410,Availability,error,error,410,"You should use `FluxBoundaryCondition(nothing)` for zero flux boundary condition since it simplifies the code _slightly_ (the difference between ""adding 0"", and not calling a function at all). It's also the default so you shouldn't have to set it (this might've been an MWE --- just want to make sure people know). I think we should ""regularize"" boundary conditions with `Number` to `Float64`; we've seen this error a few times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128947176
https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128947176:90,Usability,simpl,simplifies,90,"You should use `FluxBoundaryCondition(nothing)` for zero flux boundary condition since it simplifies the code _slightly_ (the difference between ""adding 0"", and not calling a function at all). It's also the default so you shouldn't have to set it (this might've been an MWE --- just want to make sure people know). I think we should ""regularize"" boundary conditions with `Number` to `Float64`; we've seen this error a few times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128947176
https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128949553:208,Performance,perform,performant,208,"> Seems like we have to ensure that types are correct... I ll take a look. This is really a compiler issue... I guess we ""shouldn't"" have to enforce types, but maybe it helps with inlining (which we need for performant code and GPU compilation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128949553
https://github.com/CliMA/Oceananigans.jl/pull/2562#issuecomment-1131952753:50,Testability,log,logic,50,no bug @francispoulin. I just had a mistake in my logic. ; 9191c0d fixes it. Thanks!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2562#issuecomment-1131952753
https://github.com/CliMA/Oceananigans.jl/pull/2562#issuecomment-1131953352:50,Testability,log,logic,50,no bug @francispoulin. I just had a mistake in my logic. ; 9191c0d fixes it. Thanks!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2562#issuecomment-1131953352
https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748:270,Energy Efficiency,adapt,adapted,270,"I don't think you can pass a field_dependency as symbols `(:v, :w)` because symbols cannot be passed into GPU kernels.; I'll check the proper syntax for `field_dependencies`. Correction: you should be able to because `field_dependencies` should not pass to the GPU when adapted, but now it is being passed internally somewhere...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748
https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748:270,Modifiability,adapt,adapted,270,"I don't think you can pass a field_dependency as symbols `(:v, :w)` because symbols cannot be passed into GPU kernels.; I'll check the proper syntax for `field_dependencies`. Correction: you should be able to because `field_dependencies` should not pass to the GPU when adapted, but now it is being passed internally somewhere...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748
https://github.com/CliMA/Oceananigans.jl/pull/2564#issuecomment-1131227485:8,Deployability,patch,patch,8,Was the patch version bumped?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2564#issuecomment-1131227485
https://github.com/CliMA/Oceananigans.jl/pull/2564#issuecomment-1131233965:56,Availability,error,error,56,I think we should also add a test that would catch this error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2564#issuecomment-1131233965
https://github.com/CliMA/Oceananigans.jl/pull/2564#issuecomment-1131233965:29,Testability,test,test,29,I think we should also add a test that would catch this error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2564#issuecomment-1131233965
https://github.com/CliMA/Oceananigans.jl/pull/2568#issuecomment-1133527273:45,Testability,test,tests,45,There seems to be a pattern with the failing tests 🤔 🤔 🤔 🤔 🤔 @simone-silvestri,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2568#issuecomment-1133527273
https://github.com/CliMA/Oceananigans.jl/pull/2570#issuecomment-1135811177:18,Testability,test,test,18,Any idea why this test might be failing in this PR?. ```; HeptadiagonalIterativeSolver: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_matrix_poisson_solver.jl:104;   | Expression: all(interior(∇²ϕ_solution) .≈ interior(∇²ϕ));  ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2570#issuecomment-1135811177
https://github.com/CliMA/Oceananigans.jl/pull/2570#issuecomment-1135811177:88,Testability,Test,Test,88,Any idea why this test might be failing in this PR?. ```; HeptadiagonalIterativeSolver: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_matrix_poisson_solver.jl:104;   | Expression: all(interior(∇²ϕ_solution) .≈ interior(∇²ϕ));  ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2570#issuecomment-1135811177
https://github.com/CliMA/Oceananigans.jl/pull/2570#issuecomment-1135811177:165,Testability,test,test,165,Any idea why this test might be failing in this PR?. ```; HeptadiagonalIterativeSolver: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_matrix_poisson_solver.jl:104;   | Expression: all(interior(∇²ϕ_solution) .≈ interior(∇²ϕ));  ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2570#issuecomment-1135811177
https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136259842:361,Usability,learn,learn,361,"> If that's the case, then the syntax; > ; > ```julia; > δ = ∂x(u) + ∂y(v); > ```; > ; > is valid on all grids --- isn't it?. Yes, I agree that it should be the case. . By the same rationale, the formulas for vorticity should also work on all grids, except maybe a cubed sphere?. I will experiment with the two approaches on the lat-lon grid and see what I can learn. . I will close this and return to it if I think there's a need.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136259842
https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956:399,Energy Efficiency,Green,Green,399,"At the moment I'm playing with rectilinear and lon-lat grids, so those are the ones that I'm thinking about. However, I appreciate that we want these methods to work on all the grids that we support. . On these two grids, we could use the difference operators without any concern, for both the vertical component of vorticity and the horizontal component of divergence. No problem there. If you use Green's theorem to rewerite the integral of a vorticity as a circulation integral, then we should be able to rewrite the horizontal divergence using Gauss' divergence theorem as a line integral. Maybe that would generealize better to more exotic grids?. I will look at the paper you cited. Thanks for pointing this out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956
https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956:508,Modifiability,rewrite,rewrite,508,"At the moment I'm playing with rectilinear and lon-lat grids, so those are the ones that I'm thinking about. However, I appreciate that we want these methods to work on all the grids that we support. . On these two grids, we could use the difference operators without any concern, for both the vertical component of vorticity and the horizontal component of divergence. No problem there. If you use Green's theorem to rewerite the integral of a vorticity as a circulation integral, then we should be able to rewrite the horizontal divergence using Gauss' divergence theorem as a line integral. Maybe that would generealize better to more exotic grids?. I will look at the paper you cited. Thanks for pointing this out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956
https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1136614274:590,Energy Efficiency,reduce,reduced,590,"> @francispoulin the shallow water Bickley jet example claims to be non-dimensional,; > ; > https://github.com/CliMA/Oceananigans.jl/blob/45931bd231e1ffc0bb2dd8decf2f28e0c8101275/examples/shallow_water_Bickley_jet.jl#L43; > ; > yet chooses g = 9.8,; > ; > https://github.com/CliMA/Oceananigans.jl/blob/45931bd231e1ffc0bb2dd8decf2f28e0c8101275/examples/shallow_water_Bickley_jet.jl#L48; > ; > what's going on?. Sorry about that. The shallow water model is dimensional. We pick $g = 9.81$ to model the interaction of water below air, but we could replace $g$ with $g\prime$ that allows for a reduced gravity. I suggest we say dimensional.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1136614274
https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116426:321,Availability,down,down,321,"ok, the problem is that. ```; U = 1 # Maximum jet velocity; f = coriolis.f; g = gravitational_acceleration; Δη = f * U / g # Maximum free-surface deformation as dictated by geostrophy; ```; now implies that `Δη = 1` which is same as `Lz`! That we have a vanishing layer at some points which makes the CFL criterion break down...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116426
https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116592:33,Integrability,message,message,33,oh @francispoulin I now saw your message!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139116592
https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139117389:35,Integrability,message,message,35,"> oh @francispoulin I now saw your message!. Great minds think alike, and at the same time it seems! ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2576#issuecomment-1139117389
https://github.com/CliMA/Oceananigans.jl/pull/2577#issuecomment-1138666471:139,Integrability,Depend,Depends,139,"<img width=""356"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/170514466-0fe28fcd-def6-4034-abf6-9c794b4c42f7.png"">. Depends on who ""we"" is",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2577#issuecomment-1138666471
https://github.com/CliMA/Oceananigans.jl/pull/2580#issuecomment-1139148066:122,Modifiability,extend,extending,122,"> Or maybe we can do this just with `AbstractOperations`, the problem is that we have to define a ""helper"" model. I think extending the capabilities of the `DiscreteDiffusionFunction` is the right approach here. But I also think we should only make the necessary changes in abstract_scalar_diffusivity.jl and abstract_biharmonic_scalar_diffusivity.jl and leave the tendency kernels and existing closures (like AMD) unchanged. The only thing that needs to be done is `merge(U, C)` there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2580#issuecomment-1139148066
https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139144269:265,Integrability,depend,dependent,265,"It's because the two fields use the same data:. ```julia; u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data); ```. therefore, the problem is that we are not ""recomputing"" the dependent operands of `outputs_avg.u1` correctly. If we don't recompute the operands of `outputs_avg.u1` and `outputs_avg.v1` when we compute them, then they can be identical (and thus wrong) because they are both computed using the same array.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139144269
https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139232131:285,Integrability,depend,dependent,285,"> It's because the two fields use the same data:; > ; > ```julia; > u1 = Field((@at (Center, Center, Center) 1*u), data=ccc_scratch.data); > v1 = Field((@at (Center, Center, Center) 1*v), data=ccc_scratch.data); > ```; > ; > therefore, the problem is that we are not ""recomputing"" the dependent operands of `outputs_avg.u1` correctly. If we don't recompute the operands of `outputs_avg.u1` and `outputs_avg.v1` when we compute them, then they can be identical (and thus wrong) because they are both computed using the same array. That makes sense, especially because if I don't specify the scratch data it goes away. But any guesses as to why it only pops up when using IBMs?. https://github.com/CliMA/Oceananigans.jl/pull/2582 seems to suggest that it's because the Average is only computed at fluid nodes and therefore is applied conditionally. Is that it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139232131
https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:112,Availability,mask,mask,112,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:43,Energy Efficiency,reduce,reduced,43,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:66,Integrability,wrap,wrapped,66,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:815,Safety,avoid,avoid,815,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191:1050,Usability,clear,clear,1050,"It's because on an immersed boundary grid, reduced operations are wrapped in `ConditionalOperation` in order to mask the reduction --- and `ConditionalOperation` had a bug; namely it was missing a definition of `compute_at!` (which all the other abstract operations have, eg `BinaryOperation`). For `compute!` on a reduction to be correct, we first have to compute all of the fields that are involved in the reduction. To make this work, we call `compute_at!` on `reduction.operand`. This in turn has to trigger the computation of _any_ fields that are in the expression tree associated with `reduction.operand`. Thus all `AbstractOperations` with field operands must define `compute_at!`. The difference between `compute_at!` and `compute!` is that `compute_at!` has a ""time"" associated with it. This allows us to avoid ""recomputing"" fields --- if possible (eg, if a field is not sharing its data with another field). PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139758191
https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139763353:133,Usability,clear,clear,133,"> PS I think a better descriptor than ""Odd behavior"" would be ""Wrong behavior"". ""Odd"" is a bit too general... by the title, it's not clear that something is actually amiss! ""Odd"" might just mean ""unexpected"", but somehow technically correct. Here that's not the case, the results are definitely wrong. I've been accused of being too harsh with my words before in issues, so I try to be conservative with by adjectives whenever I can :). Thanks for the explanation! It makes perfect sense",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2581#issuecomment-1139763353
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200:438,Availability,error,error,438,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200:451,Availability,error,error,451,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200:188,Testability,test,tests,188,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200:718,Testability,test,test,718,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200:587,Usability,simpl,simplify,587,"@glwagner do you mind if I merge main here? I wanna re-run my simulations after https://github.com/CliMA/Oceananigans.jl/pull/2587 but also with this bugfix. I can also take a look at the tests that are failing and fix them so that we can merge this. On recent versions of Oceananigans with IBM some of the more complex abstract operations that used to compile (without IBM) are not compiling anymore for me and are instead throwing this error: `CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)`. So I'm pretty sure is what's happening here and we just have to simplify the abstract operations used here: https://github.com/CliMA/Oceananigans.jl/blob/525984e8d013517fb40fc9a374fa99b46544d9fd/test/test_computed_field.jl#L529-L534",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142591200
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142600028:21,Testability,test,tests,21,"Let's not change the tests, but rather add `@test_broken` for the failing cases (here, GPU + immersed boundary grid). Ideally we get these tests passing eventually. I don't want to change the tests for good and lose that initiative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142600028
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142600028:139,Testability,test,tests,139,"Let's not change the tests, but rather add `@test_broken` for the failing cases (here, GPU + immersed boundary grid). Ideally we get these tests passing eventually. I don't want to change the tests for good and lose that initiative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142600028
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142600028:192,Testability,test,tests,192,"Let's not change the tests, but rather add `@test_broken` for the failing cases (here, GPU + immersed boundary grid). Ideally we get these tests passing eventually. I don't want to change the tests for good and lose that initiative.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142600028
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142601356:194,Safety,avoid,avoid,194,"PS, you can always create a new branch from this one and merge main there. You don't need anybody's permission to run a simulation with certain code. Development is always welcome but we should avoid manufacturing a ""sense of urgency""!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142601356
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:83,Availability,error,error,83,"~~Actually it appears that I was wrong. It's not the complexity that's causing the error, it's happening due to the indexing. Here's what I'm getting on the REPL using an immersed boundary on a GPU:~~. ```julia; julia> simple_ao = Field(1*u);. julia> compute!(simple_ao); 4×4×4 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ├── operand: BinaryOperation at (Face, Center, Center); ├── status: time=0.0; └── data: 10×10×10 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=-0.125, min=-0.875, mean=-0.5. julia> simple_ao_sliced = Field(1*u, indices=(2:3, 2, 2));. julia> compute!(simple_ao_sliced); ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Error showing value of type Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:973,Availability,ERROR,ERROR,973,"~~Actually it appears that I was wrong. It's not the complexity that's causing the error, it's happening due to the indexing. Here's what I'm getting on the REPL using an immersed boundary on a GPU:~~. ```julia; julia> simple_ao = Field(1*u);. julia> compute!(simple_ao); 4×4×4 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ├── operand: BinaryOperation at (Face, Center, Center); ├── status: time=0.0; └── data: 10×10×10 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=-0.125, min=-0.875, mean=-0.5. julia> simple_ao_sliced = Field(1*u, indices=(2:3, 2, 2));. julia> compute!(simple_ao_sliced); ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Error showing value of type Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:1009,Availability,ERROR,ERROR,1009,"ong. It's not the complexity that's causing the error, it's happening due to the indexing. Here's what I'm getting on the REPL using an immersed boundary on a GPU:~~. ```julia; julia> simple_ao = Field(1*u);. julia> compute!(simple_ao); 4×4×4 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ├── operand: BinaryOperation at (Face, Center, Center); ├── status: time=0.0; └── data: 10×10×10 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=-0.125, min=-0.875, mean=-0.5. julia> simple_ao_sliced = Field(1*u, indices=(2:3, 2, 2));. julia> compute!(simple_ao_sliced); ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Error showing value of type Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:1118,Availability,Error,Error,1118,"n the REPL using an immersed boundary on a GPU:~~. ```julia; julia> simple_ao = Field(1*u);. julia> compute!(simple_ao); 4×4×4 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ├── operand: BinaryOperation at (Face, Center, Center); ├── status: time=0.0; └── data: 10×10×10 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=-0.125, min=-0.875, mean=-0.5. julia> simple_ao_sliced = Field(1*u, indices=(2:3, 2, 2));. julia> compute!(simple_ao_sliced); ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Error showing value of type Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Ocean",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:4726,Availability,ERROR,ERROR,4726,"ePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: KernelException: exception thrown during kernel execution on device Tesla V100-SXM2-32GB; Stacktrace:; [1] check_exceptions(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/exceptions.jl:34; [2] nonblocking_synchronize; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:331 [inlined]; [3] device_synchronize(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:319; [4] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:41; [5] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:23 [inlined]; [6] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/execution.jl:479; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:26843,Availability,mask,mask,26843,"ryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}; condition::Nothing, mask::Float64, kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:init,), Tuple{Bool}}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:579; [16] maximum(f::Function, c::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:30652,Availability,mask,mask,30652,"Vector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:609; [17] maximum; @ ~/repos/Oceananigans.jl/src/Fields/field.jl:604 [inlined]; [18] #maximum#36; @ ~/repos/Oceananigans.jl/src/Fields/field.jl:618 [inlined]; [19] maximum; @ ~/repos/Oceananigans.jl/src/Fields/field.jl:618 [inlined]; [20] data_summary(field::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:21320,Energy Efficiency,reduce,reducedim,21320,"Flux, Nothing}}, Oceananigans.Fields.FieldStatus{Float64}, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); @ GPUArrays /glade/work/tomasc/.julia/packages/GPUArrays/Zecv7/src/host/mapreduce.jl:10; [14] #maximum!#707; @ ./reducedim.jl:895 [inlined]; [15] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, No",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:5688,Performance,cache,cache,5688,", Nothing, Nothing, Nothing}}:; ERROR: KernelException: exception thrown during kernel execution on device Tesla V100-SXM2-32GB; Stacktrace:; [1] check_exceptions(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/exceptions.jl:34; [2] nonblocking_synchronize; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:331 [inlined]; [3] device_synchronize(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:319; [4] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:41; [5] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:23 [inlined]; [6] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/execution.jl:479; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/XyxTy/src/cache.jl:95; [8] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(max), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, CUDA.CuDeviceArray{Float64, 4, 1}, Oceananigans.AbstractOperations.ConditionalOperation{Face, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:5897,Performance,cache,cache,5897,"masc/.julia/packages/CUDA/fAEDi/src/compiler/exceptions.jl:34; [2] nonblocking_synchronize; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:331 [inlined]; [3] device_synchronize(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:319; [4] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:41; [5] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:23 [inlined]; [6] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/execution.jl:479; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/XyxTy/src/cache.jl:95; [8] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(max), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, CUDA.CuDeviceArray{Float64, 4, 1}, Oceananigans.AbstractOperations.ConditionalOperation{Face, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePreci",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:1000,Security,access,access,1000,"~~Actually it appears that I was wrong. It's not the complexity that's causing the error, it's happening due to the indexing. Here's what I'm getting on the REPL using an immersed boundary on a GPU:~~. ```julia; julia> simple_ao = Field(1*u);. julia> compute!(simple_ao); 4×4×4 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; ├── operand: BinaryOperation at (Face, Center, Center); ├── status: time=0.0; └── data: 10×10×10 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=-0.125, min=-0.875, mean=-0.5. julia> simple_ao_sliced = Field(1*u, indices=(2:3, 2, 2));. julia> compute!(simple_ao_sliced); ERROR: Out-of-bounds array access.; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Error showing value of type Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142641804:5,Availability,error,error,5,"That error is from `show` though, not `compute!`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142641804
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142709219:7,Availability,error,error,7,"> That error is from `show` though, not `compute!`. Oops, I missed that. Thanks for catching it @glwagner. In any case the error indeed doesn't seem to be caused by complexity. The first `compute!()` in the lines below works, but not the second:. ```julia; tke_ccc = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2. computed_tke = Field(tke_ccc);; compute!(computed_tke). tke_window = Field(tke_ccc, indices=(2:3, 2:3, 2:3));; compute!(tke_window);; ```. Which suggests that it's the slicing that's creating the problem. However, the line below works, which I don't really understand:. ```; tke_xy = Field(tke_ccc, indices=(:, :, 2)) ;; compute!(tke_xy); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142709219
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142709219:123,Availability,error,error,123,"> That error is from `show` though, not `compute!`. Oops, I missed that. Thanks for catching it @glwagner. In any case the error indeed doesn't seem to be caused by complexity. The first `compute!()` in the lines below works, but not the second:. ```julia; tke_ccc = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2. computed_tke = Field(tke_ccc);; compute!(computed_tke). tke_window = Field(tke_ccc, indices=(2:3, 2:3, 2:3));; compute!(tke_window);; ```. Which suggests that it's the slicing that's creating the problem. However, the line below works, which I don't really understand:. ```; tke_xy = Field(tke_ccc, indices=(:, :, 2)) ;; compute!(tke_xy); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142709219
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1144372947:111,Testability,test,tests,111,> I think we should fix the issue with show and compute!. Apparently it wasn't that straightforward to fix the tests...; I'm getting ready for two back to back conferences so I won't have time to fix this for a few weeks. Feel free to take a crack at it in the meantime! Otherwise I'll take a look again after I'm back,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1144372947
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166183656:255,Availability,error,errors,255,"@glwagner if you're okay with this, I'm gonna merge this since tests are passing. Or you can merge it yourself. My rationale for merging right now is that this seems like a reasonably important bug that's being fixed and I have no idea what's causing the errors on the GPU. So maybe we can merge this and then open a second PR to deal with the GPU tests that are failing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166183656
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166183656:63,Testability,test,tests,63,"@glwagner if you're okay with this, I'm gonna merge this since tests are passing. Or you can merge it yourself. My rationale for merging right now is that this seems like a reasonably important bug that's being fixed and I have no idea what's causing the errors on the GPU. So maybe we can merge this and then open a second PR to deal with the GPU tests that are failing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166183656
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166183656:348,Testability,test,tests,348,"@glwagner if you're okay with this, I'm gonna merge this since tests are passing. Or you can merge it yourself. My rationale for merging right now is that this seems like a reasonably important bug that's being fixed and I have no idea what's causing the errors on the GPU. So maybe we can merge this and then open a second PR to deal with the GPU tests that are failing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166183656
https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166384070:0,Testability,test,test,0,"test pass, let's merge this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1166384070
https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140507140:162,Usability,simpl,simple,162,Maybe a lat-lon barotropic double gyre like MITgcm has? . https://mitgcm.readthedocs.io/en/latest/examples/barotropic_gyre/barotropic_gyre.html. Let's keep it as simple as possible too...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140507140
https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140522625:53,Usability,simpl,simpler,53,"oh, you suggested barotropic... yeah, that'd be even simpler!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1140522625
https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1142173685:7,Deployability,update,updated,7,"I have updated #1085 so that it runs, but it's still on a rectilinear grid. . My next step is to update it to a lat-lon grid. . Do we want to do this on a new PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1142173685
https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1142173685:97,Deployability,update,update,97,"I have updated #1085 so that it runs, but it's still on a rectilinear grid. . My next step is to update it to a lat-lon grid. . Do we want to do this on a new PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2584#issuecomment-1142173685
https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141260259:378,Availability,error,error,378,"What you tried with `∂x` will not work because when you pass the `field_dependency` to a continuous forcing function, the P that you have as an input in your forcing function is not the field itself, but it's the value of that field interpolated to your location at the `i, j, k` corresponding to your `x, y, z` (`model.tracers.P[i, j, k]`). (i.e. it will be a `Float64` as the error suggests and not a `Field`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141260259
https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141260259:89,Deployability,continuous,continuous,89,"What you tried with `∂x` will not work because when you pass the `field_dependency` to a continuous forcing function, the P that you have as an input in your forcing function is not the field itself, but it's the value of that field interpolated to your location at the `i, j, k` corresponding to your `x, y, z` (`model.tracers.P[i, j, k]`). (i.e. it will be a `Float64` as the error suggests and not a `Field`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141260259
https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141327558:230,Integrability,depend,dependent,230,"Say if we wanted to further modify the forcing function to have second derivatives so that the forcing function looks something like:. $$; (\mu_{0}\exp(z/\lambda) - m)\partial_x(\frac{\partial_y(P)}{T}); $$. where $T$ is possibly dependent on $x$ and $y$, would the code look something like this?. ```; using Oceananigans.Operators: ℑxᶜᵃᵃ, ∂xᶠᶜᶜ, ℑyᵃᶜᵃ, ∂yᶜᶠᶜ. function growing_and_grazing(i, j, k, grid, clock, fields, params) ; z = znode(Center(), Center(), Center(), i, j, k, grid); return (params.μ₀ * exp(z / params.λ) - params.m) * ℑxᶜᵃᵃ(i, j, k, grid, ∂xᶠᶜᶜ, ℑyᵃᶜᵃ(i, j, k, grid, ∂yᶜᶠᶜ, fields.P)/fields.T); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586#issuecomment-1141327558
https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142606347:57,Availability,error,error,57,"I really would rather emit a warning here rather than an error because I don't think an error is appropriate when input is legitimate (which was the case for what `FieldTimeSeries` did, prior to this PR). @tomchor @simone-silvestri is that ok with you two?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142606347
https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142606347:88,Availability,error,error,88,"I really would rather emit a warning here rather than an error because I don't think an error is appropriate when input is legitimate (which was the case for what `FieldTimeSeries` did, prior to this PR). @tomchor @simone-silvestri is that ok with you two?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142606347
https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142619937:59,Availability,error,error,59,"> I really would rather emit a warning here rather than an error because I don't think an error is appropriate when input is legitimate (which was the case for what `FieldTimeSeries` did, prior to this PR). @tomchor @simone-silvestri is that ok with you two?. Sure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142619937
https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142619937:90,Availability,error,error,90,"> I really would rather emit a warning here rather than an error because I don't think an error is appropriate when input is legitimate (which was the case for what `FieldTimeSeries` did, prior to this PR). @tomchor @simone-silvestri is that ok with you two?. Sure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2589#issuecomment-1142619937
https://github.com/CliMA/Oceananigans.jl/issues/2595#issuecomment-1144794360:14,Availability,redundant,redundant,14,"Agree this is redundant and if we aren't checking in the grid constructor, we should.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595#issuecomment-1144794360
https://github.com/CliMA/Oceananigans.jl/issues/2595#issuecomment-1144794360:14,Safety,redund,redundant,14,"Agree this is redundant and if we aren't checking in the grid constructor, we should.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595#issuecomment-1144794360
https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:381,Availability,ERROR,ERROR,381,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140
https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:270,Integrability,depend,dependency,270,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140
https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:388,Performance,Load,LoadError,388,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140
https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:399,Performance,Load,LoadError,399,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140
https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:53,Testability,test,tests,53,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140
https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:351,Testability,Test,Testing,351,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140
https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140:367,Testability,test,tests,367,"Thanks @navidcy for the quick approval. Strangely, 3 tests have already failed. I looked at one and see that it can't find a file, see below. This is not actually related to this PR but I don't know how to fix it. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 88 seconds (199 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7768/compiled/v1.6/Oceananigans/hU93i_huVsp.ji"": No such file or directory;  ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146595140
https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146677821:4,Testability,test,tests,4,All tests have passed so will merge!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2598#issuecomment-1146677821
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:91,Integrability,depend,depends,91,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:150,Modifiability,layers,layers,150,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:317,Modifiability,layers,layers,317,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:208,Deployability,update,update,208,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:179,Integrability,depend,dependencies,179,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:307,Performance,race condition,race conditions,307,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320:95,Safety,avoid,avoid,95,I think the way to go is to write a single kernel (3D or 2D with a loop in z). In this way you avoid the cost of multiple kernel launching. If you have a 3D kernel with non Local dependencies and you have to update nonlocal values (I don't Think it's the case) you have to make sure that there are no write race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147416320
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147435214:271,Availability,error,error,271,"Hmmm, I can appreciate that if we set the topology in the `z` direction to be `Flat`, then we have one layer. I presume that if we set it to be something else, say `Layered`, then we will have layered? . I like that idea a lot, however, I think we still need to throw an error if the user sets the topography to be `Bounded` or `Periodic`. Do you agree @navidcy ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147435214
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147860430:278,Availability,error,error,278,"> Hmmm, I can appreciate that if we set the topology in the `z` direction to be `Flat`, then we have one layer. I presume that if we set it to be something else, say `Layered`, then we will have layered?; > ; > I like that idea a lot, however, I think we still need to throw an error if the user sets the topography to be `Bounded` or `Periodic`. Do you agree @navidcy ?. I suggest that `Flat` means single layer algorithm, `Bounded` means multi layer algorithm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147860430
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343:102,Modifiability,layers,layers,102,"Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right? . I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343:200,Usability,intuit,intuitive,200,"Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right? . I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717:104,Modifiability,layers,layers,104,"> Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right?; > ; > I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me. I'm talking about the relationship between the vertical grid topology and the algorithm used by `ShallowWaterModel` to solve a problem on that grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717
https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717:207,Usability,intuit,intuitive,207,"> Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right?; > ; > I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me. I'm talking about the relationship between the vertical grid topology and the algorithm used by `ShallowWaterModel` to solve a problem on that grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210:217,Modifiability,refactor,refactor,217,"I am thinking about it actually, for the moment I am dealing with bug fixing and improving stability and accuracy (which should be basically finished), when I have everything tested and verified I ll proceed with the refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210:175,Testability,test,tested,175,"I am thinking about it actually, for the moment I am dealing with bug fixing and improving stability and accuracy (which should be basically finished), when I have everything tested and verified I ll proceed with the refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156536786:712,Testability,test,test,712,"@simone-silvestri this looks like a great PR!. > It also solves a bug for which high-order stencils were not correctly limited close to immersed boundaries which led to spurious values being generated. About the comment above, I looked at the code changes you made and couldn't quite identify the bug you're talking about. Do you mind pointing it out or briefly explaining it? . The reason I ask is because I'm facing some instabilities on my code with IBM + WENO5 where something near the boundaries creates lots of spurious internal waves. My first thought was something related to the pressure solver, but maybe this is impacting thing as well. (Also if this part of the PR is already done I can go ahead and test my code in this branch.). CC @wenegrat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156536786
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:296,Availability,mask,masking,296,"@tomchor there was an interface location at which high order methods were looking ""into"" the immersed boundary. This is because the boundary treatment was the same as for regular boundaries where we always fill at least one halo. Since the value inside the immersed region is zero because of the masking, this was producing an effectively higher (lower) and lower (higher) tracer source in two consecutive cells (i.e. a spurious maximum and minimum). . This problem was difficult to find because in some way it is ""masked"" by the WENO weighting procedure:; WENO evaluates three different stencils and weights them based on their individual smoothness. Most of the times, the stencil containing the invalid cell has a very low smoothness which means that it is removed by the calculation. This might seem like a fix but it can lead to stability problems because the only stencils remaining might be the ""centered"" and ""downwind"" stencil which are inherently more unstable than the upwind stencil. The issue is immediately visible if you try to advect a constant tracer field `c=1` with high order reconstruction such as Upwind 5 or Upwind 3 (it is not immediately visible in WENO because of the above reason). . If you run this code you'll notice that the advective fluxes (which should be only 0 and 1) actually have a different value (0.96666667) at one specified location near the immersed boundary; ```; using Oceananigans; using Oceananigans.BoundaryConditions; using Oceananigans.ImmersedBoundaries; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10), topology = (Bounded, Bounded, Bounded)). Nx, Ny, Nz = size(grid). boundary = zeros(Nx, Ny, Nz); boundary[1:2, :, :] .= 1; boundary[:, 1:2, :] .= 1; boundary[:, :, 1:2] .= 1. ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary(boundary)). model = HydrostaticFreeSurfaceModel(grid = ibg, ; closure = nothing, ; buoyancy = nothing, ; tracers = :c, ; tracer_advection = Up",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:515,Availability,mask,masked,515,"@tomchor there was an interface location at which high order methods were looking ""into"" the immersed boundary. This is because the boundary treatment was the same as for regular boundaries where we always fill at least one halo. Since the value inside the immersed region is zero because of the masking, this was producing an effectively higher (lower) and lower (higher) tracer source in two consecutive cells (i.e. a spurious maximum and minimum). . This problem was difficult to find because in some way it is ""masked"" by the WENO weighting procedure:; WENO evaluates three different stencils and weights them based on their individual smoothness. Most of the times, the stencil containing the invalid cell has a very low smoothness which means that it is removed by the calculation. This might seem like a fix but it can lead to stability problems because the only stencils remaining might be the ""centered"" and ""downwind"" stencil which are inherently more unstable than the upwind stencil. The issue is immediately visible if you try to advect a constant tracer field `c=1` with high order reconstruction such as Upwind 5 or Upwind 3 (it is not immediately visible in WENO because of the above reason). . If you run this code you'll notice that the advective fluxes (which should be only 0 and 1) actually have a different value (0.96666667) at one specified location near the immersed boundary; ```; using Oceananigans; using Oceananigans.BoundaryConditions; using Oceananigans.ImmersedBoundaries; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10), topology = (Bounded, Bounded, Bounded)). Nx, Ny, Nz = size(grid). boundary = zeros(Nx, Ny, Nz); boundary[1:2, :, :] .= 1; boundary[:, 1:2, :] .= 1; boundary[:, :, 1:2] .= 1. ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary(boundary)). model = HydrostaticFreeSurfaceModel(grid = ibg, ; closure = nothing, ; buoyancy = nothing, ; tracers = :c, ; tracer_advection = Up",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:918,Availability,down,downwind,918,"@tomchor there was an interface location at which high order methods were looking ""into"" the immersed boundary. This is because the boundary treatment was the same as for regular boundaries where we always fill at least one halo. Since the value inside the immersed region is zero because of the masking, this was producing an effectively higher (lower) and lower (higher) tracer source in two consecutive cells (i.e. a spurious maximum and minimum). . This problem was difficult to find because in some way it is ""masked"" by the WENO weighting procedure:; WENO evaluates three different stencils and weights them based on their individual smoothness. Most of the times, the stencil containing the invalid cell has a very low smoothness which means that it is removed by the calculation. This might seem like a fix but it can lead to stability problems because the only stencils remaining might be the ""centered"" and ""downwind"" stencil which are inherently more unstable than the upwind stencil. The issue is immediately visible if you try to advect a constant tracer field `c=1` with high order reconstruction such as Upwind 5 or Upwind 3 (it is not immediately visible in WENO because of the above reason). . If you run this code you'll notice that the advective fluxes (which should be only 0 and 1) actually have a different value (0.96666667) at one specified location near the immersed boundary; ```; using Oceananigans; using Oceananigans.BoundaryConditions; using Oceananigans.ImmersedBoundaries; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10), topology = (Bounded, Bounded, Bounded)). Nx, Ny, Nz = size(grid). boundary = zeros(Nx, Ny, Nz); boundary[1:2, :, :] .= 1; boundary[:, 1:2, :] .= 1; boundary[:, :, 1:2] .= 1. ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary(boundary)). model = HydrostaticFreeSurfaceModel(grid = ibg, ; closure = nothing, ; buoyancy = nothing, ; tracers = :c, ; tracer_advection = Up",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:22,Integrability,interface,interface,22,"@tomchor there was an interface location at which high order methods were looking ""into"" the immersed boundary. This is because the boundary treatment was the same as for regular boundaries where we always fill at least one halo. Since the value inside the immersed region is zero because of the masking, this was producing an effectively higher (lower) and lower (higher) tracer source in two consecutive cells (i.e. a spurious maximum and minimum). . This problem was difficult to find because in some way it is ""masked"" by the WENO weighting procedure:; WENO evaluates three different stencils and weights them based on their individual smoothness. Most of the times, the stencil containing the invalid cell has a very low smoothness which means that it is removed by the calculation. This might seem like a fix but it can lead to stability problems because the only stencils remaining might be the ""centered"" and ""downwind"" stencil which are inherently more unstable than the upwind stencil. The issue is immediately visible if you try to advect a constant tracer field `c=1` with high order reconstruction such as Upwind 5 or Upwind 3 (it is not immediately visible in WENO because of the above reason). . If you run this code you'll notice that the advective fluxes (which should be only 0 and 1) actually have a different value (0.96666667) at one specified location near the immersed boundary; ```; using Oceananigans; using Oceananigans.BoundaryConditions; using Oceananigans.ImmersedBoundaries; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10), topology = (Bounded, Bounded, Bounded)). Nx, Ny, Nz = size(grid). boundary = zeros(Nx, Ny, Nz); boundary[1:2, :, :] .= 1; boundary[:, 1:2, :] .= 1; boundary[:, :, 1:2] .= 1. ibg = ImmersedBoundaryGrid(grid, GridFittedBoundary(boundary)). model = HydrostaticFreeSurfaceModel(grid = ibg, ; closure = nothing, ; buoyancy = nothing, ; tracers = :c, ; tracer_advection = Up",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454:4159,Testability,test,test,4159,"ask_immersed_field!(w)). fill_halo_regions!((c, u, v, w)). using Oceananigans.Advection: ; _advective_tracer_flux_x,; _advective_tracer_flux_y, ; _advective_tracer_flux_z,. atx = zeros(Nx, Ny, Nz); aty = zeros(Nx, Ny, Nz); atz = zeros(Nx, Ny, Nz). for i in 1:Nx, j in 1:Ny, k in 1:Nz; atx[i, j, k] = _advective_tracer_flux_x(i, j, k, ibg, model.advection.c, u, c); aty[i, j, k] = _advective_tracer_flux_y(i, j, k, ibg, model.advection.c, v, c); atz[i, j, k] = _advective_tracer_flux_z(i, j, k, ibg, model.advection.c, w, c); end; ```. This PR fixes this problem by ensuring that the stencil used by the reconstruction (whether it's left biased, right biased or symmetric) is always an `active` value. . In addition, bug aside, `WENO5` is currently limited to `CenteredSecondOrder` when it is not valid, which means that a diffusive scheme is switched to a dispersive scheme near the boundaries. Therefore, the stability of the simulation is limited by the (lower) stability of a dispersive scheme in up to 3 nodes near the boundary (which is not that few!). Since boundaries might handle the largest gradients (at least they do in ocean simulations), it means that it is necessary to artificially increase viscosity to ensure stability near the boundaries and the benefit of WENO is effectively cancelled. The same goes in small enough ""immersed"" lakes where WENO is not used at all. For this reason in this PR I introduced a WENO3 scheme such that when approaching boundaries (real and immersed) the reconstruction follows the rule:; `WENO5` (when possible) otherwise `WENO3` (when possible) otherwise `UpwindFirstOrder` (only in the first point near the boundary). The same goes with `UpwindBiasedFifthOrder` which limits to `UpwindBiasedThirdOrder` and then `UpwindBiasedFirstOrder`. In this way we do not switch between diffusive and dispersive schemes. This PR should be ready to test, so if you give it a go, it is also a nice way to ensure that stability is increased with this implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1156635454
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1157031200:132,Availability,error,error,132,"@simone-silvestri continuing our conversation on slack, this is the MWE I was able to generate. The example below gives me a bounds error when run on a GPU using this branch:. ```julia; using Oceananigans; using CUDA; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. if has_cuda_gpu(); arch = GPU(); else; arch = CPU(); end. grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; x=(0, 1), y=(0,1),; z=(0, 1),; halo=(3,3,3),; ). bathymetry(x, y) = grid_base.Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENO5(grid=grid_base)); @info model. simulation = Simulation(model, Δt=0.1,; stop_iteration=10,; ); run!(simulation); ```. I haven't been able to isolate the error, besides the fact that it seems to be coming from `v_velocity_tendency`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1157031200
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1157031200:801,Availability,error,error,801,"@simone-silvestri continuing our conversation on slack, this is the MWE I was able to generate. The example below gives me a bounds error when run on a GPU using this branch:. ```julia; using Oceananigans; using CUDA; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. if has_cuda_gpu(); arch = GPU(); else; arch = CPU(); end. grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; x=(0, 1), y=(0,1),; z=(0, 1),; halo=(3,3,3),; ). bathymetry(x, y) = grid_base.Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENO5(grid=grid_base)); @info model. simulation = Simulation(model, Δt=0.1,; stop_iteration=10,; ); run!(simulation); ```. I haven't been able to isolate the error, besides the fact that it seems to be coming from `v_velocity_tendency`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1157031200
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1157081405:250,Testability,test,tests,250,"Thanks for spotting the bug! . It was a problem of `immersed_cell` trying to interrogate the first halo at a `Face` location, launching `inactive_cell` at `i` and `i-1` (where `i-1` was out-of-bounds). (this was also the reason for the shallow water tests not passing so we caught two birds with one stone!). I didn't come across it because I always use 4 halos regardless of the advection scheme. I changed a bit the code. Now it should work without requiring the value at `Face`s in the halo (it is necessary _only_ for vector invariant flavours of WENO for which the halo must be 4 anyways, so there should be no problem!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1157081405
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1159275792:845,Energy Efficiency,energy,energy,845,"> Immersed bickley jet for different orders and `Nh = 256`; > ; > WENO(order=3) https://user-images.githubusercontent.com/33547697/174405980-1a560164-5d0d-43e3-ad25-863d7a84c3f0.mp4; > ; > WENO(order=5) https://user-images.githubusercontent.com/33547697/174405967-3a263f0f-53d4-4bfb-94e0-251ad17d2da3.mp4; > ; > WENO(order=7) https://user-images.githubusercontent.com/33547697/174405954-03ee06a4-a81d-4cae-970d-37c2a1b36b50.mp4; > ; > WENO(order=9) https://user-images.githubusercontent.com/33547697/174405913-ed1d377c-a2c8-4460-b693-d7564ca4fcbb.mp4; > ; > WENO(order=11) https://user-images.githubusercontent.com/33547697/174406116-a0654ba8-e25e-4c68-be48-57e80c97682e.mp4. These look great! It seems that as the order increases, we see smaller features after the initial instability but in all cases they then merge, demonstrating an inverse energy cascade. We can also see the free-slip boundary conditions at work. Is it possible to plot the total energy for each of them? I would think that the higher the order the better the total energy is conserved, but I don't know for sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1159275792
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1159275792:953,Energy Efficiency,energy,energy,953,"> Immersed bickley jet for different orders and `Nh = 256`; > ; > WENO(order=3) https://user-images.githubusercontent.com/33547697/174405980-1a560164-5d0d-43e3-ad25-863d7a84c3f0.mp4; > ; > WENO(order=5) https://user-images.githubusercontent.com/33547697/174405967-3a263f0f-53d4-4bfb-94e0-251ad17d2da3.mp4; > ; > WENO(order=7) https://user-images.githubusercontent.com/33547697/174405954-03ee06a4-a81d-4cae-970d-37c2a1b36b50.mp4; > ; > WENO(order=9) https://user-images.githubusercontent.com/33547697/174405913-ed1d377c-a2c8-4460-b693-d7564ca4fcbb.mp4; > ; > WENO(order=11) https://user-images.githubusercontent.com/33547697/174406116-a0654ba8-e25e-4c68-be48-57e80c97682e.mp4. These look great! It seems that as the order increases, we see smaller features after the initial instability but in all cases they then merge, demonstrating an inverse energy cascade. We can also see the free-slip boundary conditions at work. Is it possible to plot the total energy for each of them? I would think that the higher the order the better the total energy is conserved, but I don't know for sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1159275792
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1159275792:1039,Energy Efficiency,energy,energy,1039,"> Immersed bickley jet for different orders and `Nh = 256`; > ; > WENO(order=3) https://user-images.githubusercontent.com/33547697/174405980-1a560164-5d0d-43e3-ad25-863d7a84c3f0.mp4; > ; > WENO(order=5) https://user-images.githubusercontent.com/33547697/174405967-3a263f0f-53d4-4bfb-94e0-251ad17d2da3.mp4; > ; > WENO(order=7) https://user-images.githubusercontent.com/33547697/174405954-03ee06a4-a81d-4cae-970d-37c2a1b36b50.mp4; > ; > WENO(order=9) https://user-images.githubusercontent.com/33547697/174405913-ed1d377c-a2c8-4460-b693-d7564ca4fcbb.mp4; > ; > WENO(order=11) https://user-images.githubusercontent.com/33547697/174406116-a0654ba8-e25e-4c68-be48-57e80c97682e.mp4. These look great! It seems that as the order increases, we see smaller features after the initial instability but in all cases they then merge, demonstrating an inverse energy cascade. We can also see the free-slip boundary conditions at work. Is it possible to plot the total energy for each of them? I would think that the higher the order the better the total energy is conserved, but I don't know for sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1159275792
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1162289700:82,Availability,error,error,82,"I'm trying to time the performance of this branch but I'm getting a out-of-bounds error when running my simulations on GPUs (haven't tried them on CPUs). I can reproduce it using the MWE below and I'm pretty sure it's related to the stretched grid:. ```julia; using Oceananigans.Units; using CUDA; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. if has_cuda_gpu(); arch = GPU(); else; arch = CPU(); end. grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; x=(0, 1), y=(0,1),; z=0:0.25:1,; halo=(3,3,3),; ). bathymetry(x, y) = grid_base.Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid_base),; ). using Oceanostics: TimedProgressMessenger; simulation = Simulation(model, Δt=1,; stop_iteration=10,; ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1162289700
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1162289700:23,Performance,perform,performance,23,"I'm trying to time the performance of this branch but I'm getting a out-of-bounds error when running my simulations on GPUs (haven't tried them on CPUs). I can reproduce it using the MWE below and I'm pretty sure it's related to the stretched grid:. ```julia; using Oceananigans.Units; using CUDA; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. if has_cuda_gpu(); arch = GPU(); else; arch = CPU(); end. grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; x=(0, 1), y=(0,1),; z=0:0.25:1,; halo=(3,3,3),; ). bathymetry(x, y) = grid_base.Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid_base),; ). using Oceanostics: TimedProgressMessenger; simulation = Simulation(model, Δt=1,; stop_iteration=10,; ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1162289700
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1164472055:81,Integrability,depend,dependent,81,Let's regularize the advection schemes in the model constructor and compute grid-dependent parts there.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1164472055
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:21,Availability,error,error,21,"I'm getting a method error when I try to `set!` a function initial condition with an IBM grid on a GPU. The error:; ```; ERROR: MethodError: no method matching interior(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Tuple{DataType, DataType, DataType}, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:108,Availability,error,error,108,"I'm getting a method error when I try to `set!` a function initial condition with an IBM grid on a GPU. The error:; ```; ERROR: MethodError: no method matching interior(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Tuple{DataType, DataType, DataType}, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:121,Availability,ERROR,ERROR,121,"I'm getting a method error when I try to `set!` a function initial condition with an IBM grid on a GPU. The error:; ```; ERROR: MethodError: no method matching interior(::OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, ::Tuple{DataType, DataType, DataType}, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:1953,Availability,error,error,1953,"Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl/blob/063680d4650787f028a301054559a816f5450ac3/src/Fields/set!.jl#L60. As far as I can tell the difference between this and the main branch is that `copyto!(u_parent, v_parent)` throws the following bounds error on this branch, but not on main, causing it to head into the catch section with the `interior` call instead. I'm not sure why, though.; ```; ERROR: BoundsError: attempt to access 13×13×13 CuArray{Float64, 3, CUDA.Mem.DeviceBuffer} at index [3375]; Stacktrace:; [1] throw_boundserror(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] copyto!; @ ~/.julia/packages/CUDA/fAEDi/src/array.jl:343 [inlined]; [4] copyto!(dest::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, src::Array{Float64, 3}); @ CUDA ~/.julia/packages/CUDA/fAEDi/src/array.jl:350; [5] top-level scope; @ REPL[32]:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:2207,Availability,error,error,2207,"tor{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl/blob/063680d4650787f028a301054559a816f5450ac3/src/Fields/set!.jl#L60. As far as I can tell the difference between this and the main branch is that `copyto!(u_parent, v_parent)` throws the following bounds error on this branch, but not on main, causing it to head into the catch section with the `interior` call instead. I'm not sure why, though.; ```; ERROR: BoundsError: attempt to access 13×13×13 CuArray{Float64, 3, CUDA.Mem.DeviceBuffer} at index [3375]; Stacktrace:; [1] throw_boundserror(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] copyto!; @ ~/.julia/packages/CUDA/fAEDi/src/array.jl:343 [inlined]; [4] copyto!(dest::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, src::Array{Float64, 3}); @ CUDA ~/.julia/packages/CUDA/fAEDi/src/array.jl:350; [5] top-level scope; @ REPL[32]:1; [6] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. ```. MWE below that I get it from. ```; using CUDA; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, mask_immersed_field!. underlying_grid = RectilinearGrid(GPU(); size = (5",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:2354,Availability,ERROR,ERROR,2354,"eldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl/blob/063680d4650787f028a301054559a816f5450ac3/src/Fields/set!.jl#L60. As far as I can tell the difference between this and the main branch is that `copyto!(u_parent, v_parent)` throws the following bounds error on this branch, but not on main, causing it to head into the catch section with the `interior` call instead. I'm not sure why, though.; ```; ERROR: BoundsError: attempt to access 13×13×13 CuArray{Float64, 3, CUDA.Mem.DeviceBuffer} at index [3375]; Stacktrace:; [1] throw_boundserror(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] copyto!; @ ~/.julia/packages/CUDA/fAEDi/src/array.jl:343 [inlined]; [4] copyto!(dest::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, src::Array{Float64, 3}); @ CUDA ~/.julia/packages/CUDA/fAEDi/src/array.jl:350; [5] top-level scope; @ REPL[32]:1; [6] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. ```. MWE below that I get it from. ```; using CUDA; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, mask_immersed_field!. underlying_grid = RectilinearGrid(GPU(); size = (5, 5, 5), extent = (20, 20, 20)); @inline is_immersed(x, y, z) = z < -2.0; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(is_immersed)); model = NonhydrostaticModel(g",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547:2385,Security,access,access,2385,"eldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}, CPU}); ```; Stack trace says this is the `interior` call that throws the error:. https://github.com/CliMA/Oceananigans.jl/blob/063680d4650787f028a301054559a816f5450ac3/src/Fields/set!.jl#L60. As far as I can tell the difference between this and the main branch is that `copyto!(u_parent, v_parent)` throws the following bounds error on this branch, but not on main, causing it to head into the catch section with the `interior` call instead. I'm not sure why, though.; ```; ERROR: BoundsError: attempt to access 13×13×13 CuArray{Float64, 3, CUDA.Mem.DeviceBuffer} at index [3375]; Stacktrace:; [1] throw_boundserror(A::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] copyto!; @ ~/.julia/packages/CUDA/fAEDi/src/array.jl:343 [inlined]; [4] copyto!(dest::CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, src::Array{Float64, 3}); @ CUDA ~/.julia/packages/CUDA/fAEDi/src/array.jl:350; [5] top-level scope; @ REPL[32]:1; [6] top-level scope; @ ~/.julia/packages/CUDA/fAEDi/src/initialization.jl:52. ```. MWE below that I get it from. ```; using CUDA; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary, mask_immersed_field!. underlying_grid = RectilinearGrid(GPU(); size = (5, 5, 5), extent = (20, 20, 20)); @inline is_immersed(x, y, z) = z < -2.0; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBoundary(is_immersed)); model = NonhydrostaticModel(g",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171614547
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971:1586,Integrability,message,message,1586,"I'll explain quickly what is happening to document it.; In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used. . This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active. The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction); let's say the advection is centered order 4 so hypothetically it requires two halo points. ; We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!). This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray. . My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971:780,Performance,perform,performed,780,"I'll explain quickly what is happening to document it.; In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used. . This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active. The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction); let's say the advection is centered order 4 so hypothetically it requires two halo points. ; We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!). This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray. . My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971:1419,Performance,perform,performing,1419,"I'll explain quickly what is happening to document it.; In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used. . This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active. The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction); let's say the advection is centered order 4 so hypothetically it requires two halo points. ; We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!). This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray. . My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1171677971
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172381519:212,Energy Efficiency,reduce,reduce,212,"Sure, these are the results for WENO order 3rd up to 11th. Since it is a linear problem (I am just advecting with a constant velocity), the order is retained also with a dimension by dimension reconstruction (we reduce to second order only on non-linear problems).; ![weno2](https://user-images.githubusercontent.com/33547697/176909442-95600577-37e4-432f-a862-ac0436f5a10a.png); ![weno3](https://user-images.githubusercontent.com/33547697/176909448-1fcad0e9-6cbd-46e0-9791-5a8f8adb8a8f.png); ![weno4](https://user-images.githubusercontent.com/33547697/176909451-3d81adee-6a70-46bc-b11f-678a7287b905.png); ![weno5](https://user-images.githubusercontent.com/33547697/176909452-314da3b7-f869-4cd9-9222-4d4f9f115feb.png); ![weno6](https://user-images.githubusercontent.com/33547697/176909455-c96c1650-b234-4d9b-83d5-85741158c4a9.png); ; for `WENON` the order is `2N-1`) In the legend `(x)` stands for advection in x and y, `(y)` is advection in y and z and `(z)` is advection in x and z, I forgot to change the legend from the one dimensional case",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172381519
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172615024:35,Security,expose,expose,35,"Would a diagonal advection problem expose the difference between dimension-by-dimension WENO and ""true"" 2D WENO?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172615024
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172720465:0,Testability,Test,Test,0,Test nonlinear advection for 2D/3D schemes,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172720465
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554:56,Security,validat,validate,56,"> Test nonlinear advection for 2D/3D schemes. You mean, validate 2D/3D high-order momentum advection for flux form schemes?. Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence. I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554:2,Testability,Test,Test,2,"> Test nonlinear advection for 2D/3D schemes. You mean, validate 2D/3D high-order momentum advection for flux form schemes?. Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence. I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554:252,Testability,test,test,252,"> Test nonlinear advection for 2D/3D schemes. You mean, validate 2D/3D high-order momentum advection for flux form schemes?. Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence. I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172727554
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219:334,Integrability,depend,depend,334,"> yes but it has to be non-linear, advecting w velocity with a spatially constant u and v velocity doesn't cut it. Because that doesn't test a multi-dimensional implementation? That makes sense. I just wanted to clarify what was meant by ""nonlinear"". Some source refer to WENO for tracer advection as ""nonlinear"", because the weights depend on the tracer field itself. The key is to test multi-dimensional momentum advection, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219:136,Testability,test,test,136,"> yes but it has to be non-linear, advecting w velocity with a spatially constant u and v velocity doesn't cut it. Because that doesn't test a multi-dimensional implementation? That makes sense. I just wanted to clarify what was meant by ""nonlinear"". Some source refer to WENO for tracer advection as ""nonlinear"", because the weights depend on the tracer field itself. The key is to test multi-dimensional momentum advection, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219:383,Testability,test,test,383,"> yes but it has to be non-linear, advecting w velocity with a spatially constant u and v velocity doesn't cut it. Because that doesn't test a multi-dimensional implementation? That makes sense. I just wanted to clarify what was meant by ""nonlinear"". Some source refer to WENO for tracer advection as ""nonlinear"", because the weights depend on the tracer field itself. The key is to test multi-dimensional momentum advection, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172729219
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731076:390,Security,validat,validation,390,"One way to come up with a test is to ""propose"" an incompressible solution, diagnose the advection term associated with this solution, and then add that term as a forcing function to the RHS to generate a stationary problem. The resulting problem could have zero pressure gradient by construction --- I think. This is the strategy used in. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/convergence_tests/src/ForcedFlowFreeSlip.jl. (free-slip) and. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/convergence_tests/src/ForcedFlowFixedSlip.jl. (fixed-slip).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731076
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731076:514,Security,validat,validation,514,"One way to come up with a test is to ""propose"" an incompressible solution, diagnose the advection term associated with this solution, and then add that term as a forcing function to the RHS to generate a stationary problem. The resulting problem could have zero pressure gradient by construction --- I think. This is the strategy used in. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/convergence_tests/src/ForcedFlowFreeSlip.jl. (free-slip) and. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/convergence_tests/src/ForcedFlowFixedSlip.jl. (fixed-slip).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731076
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731076:26,Testability,test,test,26,"One way to come up with a test is to ""propose"" an incompressible solution, diagnose the advection term associated with this solution, and then add that term as a forcing function to the RHS to generate a stationary problem. The resulting problem could have zero pressure gradient by construction --- I think. This is the strategy used in. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/convergence_tests/src/ForcedFlowFreeSlip.jl. (free-slip) and. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/convergence_tests/src/ForcedFlowFixedSlip.jl. (fixed-slip).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731076
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603:26,Availability,error,errors,26,"I think pressure gradient errors would still creep in to such a problem, but maybe using this technique with pressure gradients ""turned off"" (one way or another, perhaps using `ShallowWaterModel`) can produce a viable validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603:218,Security,validat,validation,218,"I think pressure gradient errors would still creep in to such a problem, but maybe using this technique with pressure gradients ""turned off"" (one way or another, perhaps using `ShallowWaterModel`) can produce a viable validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603:229,Testability,test,test,229,"I think pressure gradient errors would still creep in to such a problem, but maybe using this technique with pressure gradients ""turned off"" (one way or another, perhaps using `ShallowWaterModel`) can produce a viable validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1172731603
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1175058807:55,Modifiability,refactor,refactor,55,I will move `MultiDimensionalScheme` and the advection refactor to two different PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1175058807
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177948330:109,Performance,perform,performance,109,"From a correctness and functionality stand point this PR should be ready to merge. I have some problems with performance though. It looks like with `--check-bounds=no` this PR has roughly the same wall time than main (slightly more if you have weno because of additional boundary weno schemes) but without it's 2 - 2.5X slower. (Exacerbated on the GPU). I guess it might be a matter of `@inbounds` having to be placed strategically, but I seem to miss it; @glwagner, @navidcy do you have any easy suggestion that I might have missed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177948330
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177973368:53,Deployability,patch,patch,53,"Also, before I forget, could we also bump either the patch or minor version (whatever is appropriate here) before merging?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177973368
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177983798:87,Performance,perform,performance,87,"I think the `weno_interpolants.jl` file is the culprit, @tomchor and I saw the loss of performance specifically when using the WENO scheme. I'll test the other advection schemes in the meantime to make sure that it is indeed only a problem of WENO advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177983798
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177983798:145,Testability,test,test,145,"I think the `weno_interpolants.jl` file is the culprit, @tomchor and I saw the loss of performance specifically when using the WENO scheme. I'll test the other advection schemes in the meantime to make sure that it is indeed only a problem of WENO advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177983798
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301:150,Energy Efficiency,adapt,adapting,150,@glwagner the important changes are basically the `Advection` module and `conditional_fluxes.jl` in the `ImmersedBoundaries` module. The rest is only adapting here and there (and some small bugfixes in immersed boundaries and shallow water module),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301:150,Modifiability,adapt,adapting,150,@glwagner the important changes are basically the `Advection` module and `conditional_fluxes.jl` in the `ImmersedBoundaries` module. The rest is only adapting here and there (and some small bugfixes in immersed boundaries and shallow water module),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:129,Availability,error,error,129,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:138,Availability,ERROR,ERROR,138,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:161,Availability,error,error,161,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:295,Availability,error,error,295,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:566,Availability,error,error,566,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:145,Performance,Load,LoadError,145,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:186,Security,access,access,186,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:572,Testability,log,log,572,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296:649,Testability,log,log,649,"I've ran several different simulations with this branch and a majority (but curiously not all of them) failed with the following error:. `ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`. An older version of this branch doesn't show this error and instead runs fine for all simulations. I couldn't figure out what happened yet (or why some runs failed but others didn't) so I couldn't create a MWE yet, but I thought I'd report this in case someone can understand this better than me. Here's a [more complete error log](https://pastebin.com/dCbBAgKp) (although it's only about 5% of the full log since the last few lines repeat many many times).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179751296
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179771809:170,Availability,error,error,170,This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179771809
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179771809:232,Availability,error,error,232,This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179771809
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:172,Availability,error,error,172,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:234,Availability,error,error,234,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:372,Energy Efficiency,Adapt,Adapt,372,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:372,Modifiability,Adapt,Adapt,372,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:581,Testability,Log,Logging,581,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179780897:440,Availability,error,error,440,I suspect that the problem is the grid inflation which happens in the nonhydrostatic model. You need 4 halos because it's an immersed boundary so the model inflates the grid automatically and apparently that gives out of boundaries with the advection. If you build the model from correct sized halos thus bypassing inflation the problem disappears. . I ll put a little more effort in the inflation. We can also just think about spitting an error as we do for the `HydrostaticFreeSurfaceModel`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179780897
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1180977749:499,Availability,error,error,499,"> I suspect is that is the grid inflation which happens in the nonhydrostatic model. You need 4 halos because it's an immersed boundary so the model inflates the grid automatically and apparently that gives out of boundaries with the advection. If you build the model from correct sized halos thus bypassing inflation the problem disappears. You're right! Increasing the halo to 4 makes all simulations run. > I ll put a little more effort in the inflation. We can also just think about spitting an error as we do for the `HydrostaticFreeSurfaceModel`. I think either way is good. But I think one of them need to be done before merging because the error I get from CUDA is really not helpful. Also, can you briefly explain why an extra node is needed when using IBM?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1180977749
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1180977749:648,Availability,error,error,648,"> I suspect is that is the grid inflation which happens in the nonhydrostatic model. You need 4 halos because it's an immersed boundary so the model inflates the grid automatically and apparently that gives out of boundaries with the advection. If you build the model from correct sized halos thus bypassing inflation the problem disappears. You're right! Increasing the halo to 4 makes all simulations run. > I ll put a little more effort in the inflation. We can also just think about spitting an error as we do for the `HydrostaticFreeSurfaceModel`. I think either way is good. But I think one of them need to be done before merging because the error I get from CUDA is really not helpful. Also, can you briefly explain why an extra node is needed when using IBM?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1180977749
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:1608,Integrability,message,message,1608,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:790,Performance,perform,performed,790,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:1441,Performance,perform,performing,1441,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:256,Availability,error,error,256,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:327,Availability,error,error,327,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:565,Availability,error,error,565,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:593,Availability,down,downside,593,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:922,Availability,error,error,922,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:1018,Safety,safe,safer,1018,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072:555,Usability,clear,clear,555,"I think the problem comes from the fact that you build the advection scheme _outside_ the model with `WENO(grid)` but the grid changes inside the model and this change is not recorded in the advection scheme. . What do you think about just spitting out an error then? In that way the user is forced to rebuild the grid and any error which derives from inconsistencies between model grid and preliminary grid is solved. . We can always regularize the advection scheme _inside_ the model (as I am already planning to do, and will do in #2642) and that will clear the error with advection. . The downside of inflating the grid inside the model is that we always have to make sure that _anything_ that we build outside the model is regularized when inflating the halos (functions, auxiliary fields, viscosity functions, etc). This might be a little bit unsustainable. . For this reason, I am in favour of just spitting out an error, which might be a little bit inconvenient for the user (not extremely though) but is much safer. . In general a decision has to be made, I lean towards the latter, what do you guys think? @tomchor @navidcy @glwagner @francispoulin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181850072
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181923219:43,Availability,error,error,43,"Yeah, my vote goes to just spitting out an error. It's more conservative and way easier on the developer side",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181923219
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181985040:24,Availability,error,error,24,I agree with showing an error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181985040
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1183029477:19,Availability,error,error,19,"Yes, let's spit an error for now, at least until #2642 comes along. ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1183029477
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185571576:187,Performance,perform,performance,187,"The problem is I haven't yet figured out where in `weno_interpolants.jl` the code relies on very heavy bounds checking, so running julia with or without `--check-inbounds=no` changes the performance radically. . It's probably not too hard to identify where the problem is, but I have been missing it and I also find myself in a moment in which I have very little time. On the other hand, this PR fixes a lot of problems, so all the next PRs are kind of contingent on this one. I can wait a little bit more to merge this...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185571576
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913:630,Energy Efficiency,energy,energy,630,"> > Test nonlinear advection for 2D/3D schemes; > ; > You mean, validate 2D/3D high-order momentum advection for flux form schemes?; > ; > Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence.; > ; > I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient. That's not correct. The inviscid Burgers will form a shock (indeed!) and this will result in energy dissipation but that's *not* numerical dissipation but rather a physical one!. ![Burgers-anomalousdissipation-marker](https://user-images.githubusercontent.com/7112768/179238464-c9890412-59de-43bd-9a82-24f5c7982aa8.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913:64,Security,validat,validate,64,"> > Test nonlinear advection for 2D/3D schemes; > ; > You mean, validate 2D/3D high-order momentum advection for flux form schemes?; > ; > Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence.; > ; > I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient. That's not correct. The inviscid Burgers will form a shock (indeed!) and this will result in energy dissipation but that's *not* numerical dissipation but rather a physical one!. ![Burgers-anomalousdissipation-marker](https://user-images.githubusercontent.com/7112768/179238464-c9890412-59de-43bd-9a82-24f5c7982aa8.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913:4,Testability,Test,Test,4,"> > Test nonlinear advection for 2D/3D schemes; > ; > You mean, validate 2D/3D high-order momentum advection for flux form schemes?; > ; > Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence.; > ; > I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient. That's not correct. The inviscid Burgers will form a shock (indeed!) and this will result in energy dissipation but that's *not* numerical dissipation but rather a physical one!. ![Burgers-anomalousdissipation-marker](https://user-images.githubusercontent.com/7112768/179238464-c9890412-59de-43bd-9a82-24f5c7982aa8.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913:266,Testability,test,test,266,"> > Test nonlinear advection for 2D/3D schemes; > ; > You mean, validate 2D/3D high-order momentum advection for flux form schemes?; > ; > Another issue with a vortex solution is that the momentum term is identically zero in the exact solution. So I'm not sure this test isolates convergence.; > ; > I believe inviscid Burgers will form a shock, and then be subject to numerical dissipation. If you add viscosity, then you are limited by the accuracy of the viscous term. So I'm not sure it even works to turn off the pressure gradient. That's not correct. The inviscid Burgers will form a shock (indeed!) and this will result in energy dissipation but that's *not* numerical dissipation but rather a physical one!. ![Burgers-anomalousdissipation-marker](https://user-images.githubusercontent.com/7112768/179238464-c9890412-59de-43bd-9a82-24f5c7982aa8.gif)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185575913
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185581695:45,Energy Efficiency,energy,energy,45,Interesting! But I guess that dissipation of energy still comes from a viscous term?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185581695
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185583989:95,Energy Efficiency,energy,energy,95,"> That's not correct. The inviscid Burgers will form a shock (indeed!) and this will result in energy dissipation but that's _not_ numerical dissipation but rather a physical one!. Minor comment: . The inviscid Burgers equation, copied below, has no dissiaption. $$; \partial_t u + u \partial_x u = 0.; $$. Shocks will definitely occur but there is no mechanism to dissipate. The viscous Burgers equation, copied below, does allow for dissipation because of the viscous liike term. $$; \partial_t u + u \partial_x u = \nu \partial_{xx} u.; $$. If you solve the inviscid version of the model numerically, you will certainly see energy dissipating, as your nice aniamtion shows.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185583989
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185583989:627,Energy Efficiency,energy,energy,627,"> That's not correct. The inviscid Burgers will form a shock (indeed!) and this will result in energy dissipation but that's _not_ numerical dissipation but rather a physical one!. Minor comment: . The inviscid Burgers equation, copied below, has no dissiaption. $$; \partial_t u + u \partial_x u = 0.; $$. Shocks will definitely occur but there is no mechanism to dissipate. The viscous Burgers equation, copied below, does allow for dissipation because of the viscous liike term. $$; \partial_t u + u \partial_x u = \nu \partial_{xx} u.; $$. If you solve the inviscid version of the model numerically, you will certainly see energy dissipating, as your nice aniamtion shows.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185583989
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632:139,Performance,perform,performance,139,"90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl`; I haven't gotten around to test performance for non-weno schemes but I should do it.... I ll guess I ll dedicate today to searching the issue, so we can merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632:134,Testability,test,test,134,"90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl`; I haven't gotten around to test performance for non-weno schemes but I should do it.... I ll guess I ll dedicate today to searching the issue, so we can merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185589517:47,Energy Efficiency,energy,energy,47,> Interesting! But I guess that dissipation of energy still comes from a viscous term?. No! The simulation above is from the inviscid Burgers equations. There is no viscous term!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185589517
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185593464:55,Energy Efficiency,energy,energy,55,So I am a bit confused on which term the diffusion (or energy dissipation) comes from (as what Francis said above). Is it advective redistribution through the shock?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185593464
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:143,Deployability,integrat,integration,143,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:222,Deployability,integrat,integration,222,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:32,Energy Efficiency,energy,energy,32,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:111,Energy Efficiency,energy,energy,111,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:143,Integrability,integrat,integration,143,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089:222,Integrability,integrat,integration,222,Shock is the mechanism by which energy dissipates (from what I understand). If I recall correctly to show that energy is conserved involves an integration by parts and if u or du/dx is discontinuous then you can't do that integration by parts.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185597089
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185604762:113,Energy Efficiency,energy,energy,113,"When a shock occurs, the function becomes multivalued and the equation is no longer valid. That's why discussing energy conservation after the shock is a bit weird. People usually have to add in other physics. This is an extreme case and I wonder if a smooth solution would be easier to understand?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185604762
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545:140,Performance,perform,performance,140,"> 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > ; > I ll guess I ll dedicate today to searching the issue, so we can merge. `@inbounds` in . https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545:135,Testability,test,test,135,"> 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > ; > I ll guess I ll dedicate today to searching the issue, so we can merge. `@inbounds` in . https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738:142,Performance,perform,performance,142,"> > 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > > I ll guess I ll dedicate today to searching the issue, so we can merge; > ; > `@inbounds` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46. I'm not sure that this is the deal breaker... I should have phrased is as a ""perhaps add @inbounds in.... ???""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738:137,Testability,test,test,137,"> > 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > > I ll guess I ll dedicate today to searching the issue, so we can merge; > ; > `@inbounds` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46. I'm not sure that this is the deal breaker... I should have phrased is as a ""perhaps add @inbounds in.... ???""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185618552:52,Testability,test,tests,52,perhaps resolve merge conflict also so that when/if tests pass we are good to merge?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185618552
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185636139:115,Energy Efficiency,energy,energy,115,"> When a shock occurs, the function becomes multivalued and the equation is no longer valid. That's why discussing energy conservation after the shock is a bit weird. People usually have to add in other physics. This is an extreme case and I wonder if a smooth solution would be easier to understand?. To continue the shock discussions:. The first 3 pages in [Eyink's notes](https://www.ams.jhu.edu/~eyink/Turbulence/notes/ChapterIIIa.pdf) give two arguments (an inviscid and a viscous with ν->0) for why energy dissipation is non zero for inviscid Burgers when a shock forms.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185636139
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185636139:505,Energy Efficiency,energy,energy,505,"> When a shock occurs, the function becomes multivalued and the equation is no longer valid. That's why discussing energy conservation after the shock is a bit weird. People usually have to add in other physics. This is an extreme case and I wonder if a smooth solution would be easier to understand?. To continue the shock discussions:. The first 3 pages in [Eyink's notes](https://www.ams.jhu.edu/~eyink/Turbulence/notes/ChapterIIIa.pdf) give two arguments (an inviscid and a viscous with ν->0) for why energy dissipation is non zero for inviscid Burgers when a shock forms.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185636139
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185658322:117,Energy Efficiency,energy,energy,117,"> > When a shock occurs, the function becomes multivalued and the equation is no longer valid. That's why discussing energy conservation after the shock is a bit weird. People usually have to add in other physics. This is an extreme case and I wonder if a smooth solution would be easier to understand?; > ; > To continue the shock discussions:; > ; > The first 3 pages in [Eyink's notes](https://www.ams.jhu.edu/~eyink/Turbulence/notes/ChapterIIIa.pdf) give two arguments (an inviscid and a viscous with ν->0) for why energy dissipation is non zero for inviscid Burgers when a shock forms. Thanks @navidcy for the link! Very nice presentation and the derivation seems reasonable. . However, I see that they take the limit of the viscous solution and find that as $\nu \rightarrow 0$ the dissipation is positive. I do wonder whether this is a singular problem in that we have slopes that are infinite. If you start with the pure inviscid problem in conservative form, I don't see how you can obtain this result.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185658322
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185658322:519,Energy Efficiency,energy,energy,519,"> > When a shock occurs, the function becomes multivalued and the equation is no longer valid. That's why discussing energy conservation after the shock is a bit weird. People usually have to add in other physics. This is an extreme case and I wonder if a smooth solution would be easier to understand?; > ; > To continue the shock discussions:; > ; > The first 3 pages in [Eyink's notes](https://www.ams.jhu.edu/~eyink/Turbulence/notes/ChapterIIIa.pdf) give two arguments (an inviscid and a viscous with ν->0) for why energy dissipation is non zero for inviscid Burgers when a shock forms. Thanks @navidcy for the link! Very nice presentation and the derivation seems reasonable. . However, I see that they take the limit of the viscous solution and find that as $\nu \rightarrow 0$ the dissipation is positive. I do wonder whether this is a singular problem in that we have slopes that are infinite. If you start with the pure inviscid problem in conservative form, I don't see how you can obtain this result.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185658322
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507:126,Availability,error,error,126,"I have checked thoroughly _every_ function in the advection module for a `checkbounds()` call and couldn't produce any Bounds error. This is remaining a mystery to me because it seems that the whole advection module elides bounds checking. On the other hand, I found that `main` has the same problem, on the `near_global_quarter_degree.jl` experiment this is the wall time per 10 time steps; (with `--check-bounds=no`, without `--check-bounds=no`); main -> 2.7 / 3.6 s; this PR -> 3.3 / 4.4 s. so there is for sure a problem of performance (which I will try to solve) but it does not seem to be related to bounds checking as; `2.7 / 3.6 = 3.3 / 4.4 = 0.75`. It is a must to find out where these bounds checks are eating up 25% of our computational time (do you know an easy way to profile it?).; By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507:528,Performance,perform,performance,528,"I have checked thoroughly _every_ function in the advection module for a `checkbounds()` call and couldn't produce any Bounds error. This is remaining a mystery to me because it seems that the whole advection module elides bounds checking. On the other hand, I found that `main` has the same problem, on the `near_global_quarter_degree.jl` experiment this is the wall time per 10 time steps; (with `--check-bounds=no`, without `--check-bounds=no`); main -> 2.7 / 3.6 s; this PR -> 3.3 / 4.4 s. so there is for sure a problem of performance (which I will try to solve) but it does not seem to be related to bounds checking as; `2.7 / 3.6 = 3.3 / 4.4 = 0.75`. It is a must to find out where these bounds checks are eating up 25% of our computational time (do you know an easy way to profile it?).; By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:240,Availability,error,error,240,"> By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection. I just tried with the latest commit and got this error:. ```julia; ERROR: LoadError: TaskFailedException. nested task error: UndefVarError: coeff_β_2_0 not defined; Stacktrace:; [1] left_biased_β(::Tuple{Float64, Float64}, ::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Val{0}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [2] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [3] beta_loop(::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, ::typeof(Oceananigans.Advection.left_biased_β)); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; [4] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:258,Availability,ERROR,ERROR,258,"> By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection. I just tried with the latest commit and got this error:. ```julia; ERROR: LoadError: TaskFailedException. nested task error: UndefVarError: coeff_β_2_0 not defined; Stacktrace:; [1] left_biased_β(::Tuple{Float64, Float64}, ::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Val{0}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [2] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [3] beta_loop(::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, ::typeof(Oceananigans.Advection.left_biased_β)); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; [4] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:309,Availability,error,error,309,"> By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection. I just tried with the latest commit and got this error:. ```julia; ERROR: LoadError: TaskFailedException. nested task error: UndefVarError: coeff_β_2_0 not defined; Stacktrace:; [1] left_biased_β(::Tuple{Float64, Float64}, ::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Val{0}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [2] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [3] beta_loop(::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, ::typeof(Oceananigans.Advection.left_biased_β)); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; [4] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:4558,Deployability,Continuous,ContinuousBoundaryFunction,4558,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:5066,Deployability,Continuous,ContinuousBoundaryFunction,5066,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:5464,Deployability,Continuous,ContinuousBoundaryFunction,5464,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/reconstruction_coefficients.jl:19 [inlined]; [8] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/reconstruction_coefficien",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:5863,Deployability,Continuous,ContinuousBoundaryFunction,5863,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/reconstruction_coefficients.jl:19 [inlined]; [8] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/reconstruction_coefficients.jl:19 [inlined]; [9] _left_biased_interpolate_xᶜᵃᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:8836,Deployability,Continuous,ContinuousBoundaryFunction,8836,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:9344,Deployability,Continuous,ContinuousBoundaryFunction,9344,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:9742,Deployability,Continuous,ContinuousBoundaryFunction,9742,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:199 [inlined]; [10] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:10141,Deployability,Continuous,ContinuousBoundaryFunction,10141,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:199 [inlined]; [10] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:199 [inlined]; [11] _left_biased_interpolate_xᶜᵃᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:13399,Deployability,Continuous,ContinuousBoundaryFunction,13399,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:13907,Deployability,Continuous,ContinuousBoundaryFunction,13907,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:14305,Deployability,Continuous,ContinuousBoundaryFunction,14305,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:199 [inlined]; [12] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:14704,Deployability,Continuous,ContinuousBoundaryFunction,14704,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:199 [inlined]; [12] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:199 [inlined]; [13] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/upwind_biased_advective_fluxes.jl:21 [inlined]; [14] _advective_momentum_flux_Uu(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:18092,Deployability,Continuous,ContinuousBoundaryFunction,18092,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:18600,Deployability,Continuous,ContinuousBoundaryFunction,18600,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:18998,Deployability,Continuous,ContinuousBoundaryFunction,18998,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:19397,Deployability,Continuous,ContinuousBoundaryFunction,19397,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:20946,Deployability,Continuous,ContinuousBoundaryFunction,20946,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:21454,Deployability,Continuous,ContinuousBoundaryFunction,21454,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:21852,Deployability,Continuous,ContinuousBoundaryFunction,21852,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:61 [inlined]; [15] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_flu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:22251,Deployability,Continuous,ContinuousBoundaryFunction,22251,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:61 [inlined]; [15] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/ImmersedBoundaries/conditional_fluxes.jl:61 [inlined]; [16] δxᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:25545,Deployability,Continuous,ContinuousBoundaryFunction,25545,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:26053,Deployability,Continuous,ContinuousBoundaryFunction,26053,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:26451,Deployability,Continuous,ContinuousBoundaryFunction,26451,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:26850,Deployability,Continuous,ContinuousBoundaryFunction,26850,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:28399,Deployability,Continuous,ContinuousBoundaryFunction,28399,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:28907,Deployability,Continuous,ContinuousBoundaryFunction,28907,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:29305,Deployability,Continuous,ContinuousBoundaryFunction,29305,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Operators/difference_operators.jl:21 [inlined]; [17] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Operators/difference_operators.jl:21 [inl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:29704,Deployability,Continuous,ContinuousBoundaryFunction,29704,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Operators/difference_operators.jl:21 [inlined]; [17] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Operators/difference_operators.jl:21 [inlined]; [18] div_𝐯u(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:32954,Deployability,Continuous,ContinuousBoundaryFunction,32954,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:33462,Deployability,Continuous,ContinuousBoundaryFunction,33462,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:33860,Deployability,Continuous,ContinuousBoundaryFunction,33860,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Off",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:34259,Deployability,Continuous,ContinuousBoundaryFunction,34259,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:35806,Deployability,Continuous,ContinuousBoundaryFunction,35806,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:36296,Deployability,Continuous,ContinuousBoundaryFunction,36296,"olon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:36694,Deployability,Continuous,ContinuousBoundaryFunction,36694,"yCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:37111,Deployability,Continuous,ContinuousBoundaryFunction,37111,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:38816,Deployability,Continuous,ContinuousBoundaryFunction,38816,"{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:39214,Deployability,Continuous,ContinuousBoundaryFunction,39214,"oat64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:39613,Deployability,Continuous,ContinuousBoundaryFunction,39613,"Condition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, ::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:40011,Deployability,Continuous,ContinuousBoundaryFunction,40011,"typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, ::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.Immersed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:41572,Deployability,Continuous,ContinuousBoundaryFunction,41572,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:42080,Deployability,Continuous,ContinuousBoundaryFunction,42080,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:42478,Deployability,Continuous,ContinuousBoundaryFunction,42478,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/momentum_advection_operators.jl:53 [inlined]; [19] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/momentum_advection_oper",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:42877,Deployability,Continuous,ContinuousBoundaryFunction,42877,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/momentum_advection_operators.jl:53 [inlined]; [19] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/momentum_advection_operators.jl:53 [inlined]; [20] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:61 [inlined]; [21] overdub; @ /glade/work/tomasc/.julia/packages/KernelAbstractions/3ZHln/src/macros.jl:266 [inlined]; [22] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{KernelAbstractions.CPU, Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:47501,Deployability,Continuous,ContinuousBoundaryFunction,47501,"64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, FPlane{Float64}, Nothing, Tuple{ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:b,), Tuple{Float64}}}}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:47899,Deployability,Continuous,ContinuousBoundaryFunction,47899,"{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, FPlane{Float64}, Nothing, Tuple{ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:b,), Tuple{Float64}}}}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:48298,Deployability,Continuous,ContinuousBoundaryFunction,48298,"4, NamedTuple{(:b,), Tuple{Float64}}}}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:50111,Deployability,Continuous,ContinuousBoundaryFunction,50111,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:50619,Deployability,Continuous,ContinuousBoundaryFunction,50619,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:51017,Deployability,Continuous,ContinuousBoundaryFunction,51017,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Off",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:51416,Deployability,Continuous,ContinuousBoundaryFunction,51416,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:52963,Deployability,Continuous,ContinuousBoundaryFunction,52963,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:53453,Deployability,Continuous,ContinuousBoundaryFunction,53453,"olon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:53851,Deployability,Continuous,ContinuousBoundaryFunction,53851,"yCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:54268,Deployability,Continuous,ContinuousBoundaryFunction,54268,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:55973,Deployability,Continuous,ContinuousBoundaryFunction,55973,"{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:56371,Deployability,Continuous,ContinuousBoundaryFunction,56371,"oat64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:56770,Deployability,Continuous,ContinuousBoundaryFunction,56770,"Condition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:57168,Deployability,Continuous,ContinuousBoundaryFunction,57168,"typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:62924,Deployability,Continuous,ContinuousForcing,62924,"Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Float64, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64}}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, Field{Center, Center, Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:63201,Deployability,Continuous,ContinuousForcing,63201,"t64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64}}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:63478,Deployability,Continuous,ContinuousForcing,63478,"64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64}}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:63755,Deployability,Continuous,ContinuousForcing,63755,"dTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryConditio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:69182,Deployability,Continuous,ContinuousBoundaryFunction,69182,"64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, FPlane{Float64}, Nothing, Tuple{ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:b,), Tuple{Float64}}}}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:69580,Deployability,Continuous,ContinuousBoundaryFunction,69580,"{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, FPlane{Float64}, Nothing, Tuple{ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:b,), Tuple{Float64}}}}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:69979,Deployability,Continuous,ContinuousBoundaryFunction,69979,"4, NamedTuple{(:b,), Tuple{Float64}}}}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:71792,Deployability,Continuous,ContinuousBoundaryFunction,71792,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:72300,Deployability,Continuous,ContinuousBoundaryFunction,72300,"}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:72698,Deployability,Continuous,ContinuousBoundaryFunction,72698,"igans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Off",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:73097,Deployability,Continuous,ContinuousBoundaryFunction,73097,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:74644,Deployability,Continuous,ContinuousBoundaryFunction,74644,"ffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:75134,Deployability,Continuous,ContinuousBoundaryFunction,75134,"olon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:75532,Deployability,Continuous,ContinuousBoundaryFunction,75532,"yCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:75949,Deployability,Continuous,ContinuousBoundaryFunction,75949,"gans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyᵃᶠᵃ), typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:77654,Deployability,Continuous,ContinuousBoundaryFunction,77654,"{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:78052,Deployability,Continuous,ContinuousBoundaryFunction,78052,"oat64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:78451,Deployability,Continuous,ContinuousBoundaryFunction,78451,"Condition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:78849,Deployability,Continuous,ContinuousBoundaryFunction,78849,"typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:84605,Deployability,Continuous,ContinuousForcing,84605,"Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Float64, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64}}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, Field{Center, Center, Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:84882,Deployability,Continuous,ContinuousForcing,84882,"t64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64}}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:85159,Deployability,Continuous,ContinuousForcing,85159,"64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Float64}}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:85436,Deployability,Continuous,ContinuousForcing,85436,"dTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :D, :σ, :sp_length, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Int64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryConditio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:265,Performance,Load,LoadError,265,"> By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection. I just tried with the latest commit and got this error:. ```julia; ERROR: LoadError: TaskFailedException. nested task error: UndefVarError: coeff_β_2_0 not defined; Stacktrace:; [1] left_biased_β(::Tuple{Float64, Float64}, ::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Val{0}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [2] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [3] beta_loop(::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, ::typeof(Oceananigans.Advection.left_biased_β)); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; [4] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186260385:5,Testability,test,tested,5,"Just tested it. For CPUs the time is roughly the same, and for GPUs the timing I got was consistent with your estimate of 0.75 (the difference was a bit smaller for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186260385
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190872511:27,Performance,perform,performance,27,"I d like to try to improve performance a bit first... Anyways, by next week I ll merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190872511
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190886871:60,Performance,perform,performance,60,@tomchor I guess we are hoping we can merge without the 3/4 performance penalty.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190886871
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1192981334:901,Performance,perform,performance,901,"comparison of run wall time for the bickley jet `128²` between this PR and main (on the GPU). ; ; This is running the code till 200 seconds; | | Periodic | Periodic | Bounded | Bounded | Immersed | Immersed | ; | ---- | ---- | ---- | ---- | ---- | ---- | ---- |; | **Scheme** | this PR | Main | this PR | Main | this PR | Main |; Upwind 5 | 33.8967 | 64.0005 | 50.0858 | 47.4800 | 140.9554 | 107.9684 | ; WENO 5 VI | 28.4259 | 30.8202 | 37.8422 | 34.2834 | 123.7893 | 122.7207 |; WENO 5 FF | 27.9952 | 31.9765 | 32.2018 | 36.7740 | 111.0842 | 107.0792 |; Vector Inv | 28.9798 | 27.7792 | 37.5503 | 33.1336 | 125.4214 | 119.6501 |. Looking at these timings, everything seems in the ballpark (except for the immersed boundary) so I am not sure what might be the issue... I guess we would need an in depth profiling to understand this?. I say we merge. The benefit from time step increase covers for the performance decrease. And finding the root of such a decrease might be very difficult",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1192981334
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194187328:38,Performance,perform,performance,38,What's are the possible causes of the performance difference? What code should we focus on if we want to close this performance gap in the future?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194187328
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194187328:116,Performance,perform,performance,116,What's are the possible causes of the performance difference? What code should we focus on if we want to close this performance gap in the future?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194187328
https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194587440:238,Modifiability,refactor,refactor,238,"For a future PR (probably #2642):. * Use the _order_ (not buffer size) as a type parameter, so WENO(order=5) yields a type `WENO{5}`, for example; * Improve docstrings for advection schemes (but this is contingent on the larger advection refactor in #2642)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194587440
https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984:290,Availability,ERROR,ERROR,290,"I am happy to open a PR but when I try the line you suggested , unfortunately, there is still a problem. Some good news! This fixes it for the vector invariant formulation. However, when I try the conervative form it complains about not knowing `u`. See the start of the output below. ```; ERROR: LoadError: TaskFailedException. nested task error: type NamedTuple has no field u; Stacktrace:; [1] getproperty(x::NamedTuple{(:uh, :vh, :h), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984
https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984:341,Availability,error,error,341,"I am happy to open a PR but when I try the line you suggested , unfortunately, there is still a problem. Some good news! This fixes it for the vector invariant formulation. However, when I try the conervative form it complains about not knowing `u`. See the start of the output below. ```; ERROR: LoadError: TaskFailedException. nested task error: type NamedTuple has no field u; Stacktrace:; [1] getproperty(x::NamedTuple{(:uh, :vh, :h), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984
https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984:297,Performance,Load,LoadError,297,"I am happy to open a PR but when I try the line you suggested , unfortunately, there is still a problem. Some good news! This fixes it for the vector invariant formulation. However, when I try the conervative form it complains about not knowing `u`. See the start of the output below. ```; ERROR: LoadError: TaskFailedException. nested task error: type NamedTuple has no field u; Stacktrace:; [1] getproperty(x::NamedTuple{(:uh, :vh, :h), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984
https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:629,Energy Efficiency,adapt,adapt,629,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100
https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:257,Integrability,depend,depends,257,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100
https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:629,Modifiability,adapt,adapt,629,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:20,Availability,error,errors,20,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:57,Availability,error,error,57,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:298,Availability,ERROR,ERROR,298,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:187,Integrability,depend,dependency,187,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:305,Performance,Load,LoadError,305,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:316,Performance,Load,LoadError,316,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:123,Testability,test,tests,123,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:268,Testability,Test,Testing,268,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:284,Testability,test,tests,284,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157760136:104,Availability,error,error,104,"> Is this for ShallowWaterModel?. Yes, the closure terrm for tracers was not done correctly and gave an error in the previous form. This fixes it for the `VectorInvariantForm`, but more work needs to be done for the `ConservativeForm`. I plan to talk to @simone-silvestri on Monday about this and other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157760136
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157765920:112,Availability,error,error,112,"> > Is this for ShallowWaterModel?; > ; > Yes, the closure terrm for tracers was not done correctly and gave an error in the previous form. This fixes it for the `VectorInvariantForm`, but more work needs to be done for the `ConservativeForm`. I plan to talk to @simone-silvestri on Monday about this and other things. Sounds good, I updated the PR title so no one gets alarmed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157765920
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157765920:334,Deployability,update,updated,334,"> > Is this for ShallowWaterModel?; > ; > Yes, the closure terrm for tracers was not done correctly and gave an error in the previous form. This fixes it for the `VectorInvariantForm`, but more work needs to be done for the `ConservativeForm`. I plan to talk to @simone-silvestri on Monday about this and other things. Sounds good, I updated the PR title so no one gets alarmed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157765920
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828:55,Availability,error,error,55,Usually restarting the test works for me to clear that error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828:23,Testability,test,test,23,Usually restarting the test works for me to clear that error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828:44,Usability,clear,clear,44,Usually restarting the test works for me to clear that error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157789828
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045:57,Availability,error,error,57,> Usually restarting the test works for me to clear that error. Good to know. How can I do that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045:25,Testability,test,test,25,> Usually restarting the test works for me to clear that error. Good to know. How can I do that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045:46,Usability,clear,clear,46,> Usually restarting the test works for me to clear that error. Good to know. How can I do that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157900045
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180:59,Availability,error,error,59,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180:145,Security,access,access,145,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180:27,Testability,test,test,27,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180:48,Usability,clear,clear,48,> > Usually restarting the test works for me to clear that error; > ; > Good to know. How can I do that?. I don't think you can because you need access to the Clima buildkite. But @simone-silvestri can do it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157917180
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158035473:82,Testability,test,test,82,"That explains why I have never done it. @simone-silvestri , could you restart the test when you have a minute?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158035473
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256:213,Safety,avoid,avoid,213,"Thank you @navidcy! . Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256:193,Usability,learn,learn,193,"Thank you @navidcy! . Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158802256
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707:229,Safety,avoid,avoid,229,"> Thank you @navidcy! ; > ; > ; > ; > Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this. . I don't have permission to give you permission. :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707
https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707:209,Usability,learn,learn,209,"> Thank you @navidcy! ; > ; > ; > ; > Mind if I ask how? I feel like I might have been given permission to do this last year, but just never tried it. If I don't have permission, no problem, but if I do I can learn to do this to avoid bothering others with this. . I don't have permission to give you permission. :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1158827707
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690:216,Availability,error,error,216,"By the way, WENO (and other advection schemes) are always going to be at most second order as they are implemented right now. So the _order_ might not be the correct metric to look at the performance, the truncation error is probably what we want to look at",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690:188,Performance,perform,performance,188,"By the way, WENO (and other advection schemes) are always going to be at most second order as they are implemented right now. So the _order_ might not be the correct metric to look at the performance, the truncation error is probably what we want to look at",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164483965:285,Performance,perform,performance,285,I am actually looking into implementing a multidimensional _sweep_ approach that will allow us to break the 2nd order limit. https://d-nb.info/1124132775/34; https://www.sciencedirect.com/science/article/pii/S0021999104002281. I ll see if it is too difficult or unfeasible in terms of performance,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164483965
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:246,Availability,error,error,246,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:260,Availability,error,error,260,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:280,Availability,error,error,280,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:294,Availability,error,error,294,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:52,Deployability,integrat,integrated,52,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715:52,Integrability,integrat,integrated,52,"For a single gaussian vortex in geostrophic balance integrated to `t=10` the results are the following (`N^2 = 64^2`):. ```; ╭──────────────┬───────┬─────────────┬───────────────────┬─────────────┬───────────────────╮; │ Formulation │ Order │ L₂ error(h) │ L₂ error(u or uh) │ L∞ error(h) │ L∞ error(u or uh) │; ├──────────────┼───────┼─────────────┼───────────────────┼─────────────┼───────────────────┤; │ Conservative │ 3 │ 1.66e-03 │ 9.43e-03 │ 5.05e-02 │ 3.86e-01 │; │ VI_Vorticity │ 3 │ 6.80e-04 │ 2.50e-03 │ 1.63e-02 │ 8.11e-02 │; │ VI_Velocity │ 3 │ 6.20e-04 │ 2.30e-03 │ 1.49e-02 │ 7.33e-02 │; │ Conservative │ 5 │ 1.63e-03 │ 9.03e-03 │ 4.95e-02 │ 3.73e-01 │; │ VI_Vorticity │ 5 │ 5.30e-04 │ 1.95e-03 │ 1.03e-02 │ 5.63e-02 │; │ VI_Velocity │ 5 │ 4.93e-04 │ 1.94e-03 │ 9.35e-03 │ 5.04e-02 │; │ Conservative │ 7 │ 1.63e-03 │ 8.87e-03 │ 4.93e-02 │ 3.67e-01 │; │ VI_Vorticity │ 7 │ 4.99e-04 │ 1.86e-03 │ 9.17e-03 │ 5.24e-02 │; │ VI_Velocity │ 7 │ 4.84e-04 │ 1.86e-03 │ 8.93e-03 │ 4.93e-02 │; │ Conservative │ 9 │ 1.64e-03 │ 8.63e-03 │ 4.96e-02 │ 3.62e-01 │; │ VI_Vorticity │ 9 │ 4.66e-04 │ 1.73e-03 │ 7.81e-03 │ 4.52e-02 │; │ VI_Velocity │ 9 │ 4.55e-04 │ 1.74e-03 │ 7.57e-03 │ 4.61e-02 │; ╰──────────────┴───────┴─────────────┴───────────────────┴─────────────┴───────────────────╯; ```. So, indeed, conservative formulation is not as good as the vector invariant formulation (at least in this case), especially when looking at momentum. . @francispoulin the resolution of the figures above is 400^2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164692715
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164710575:288,Availability,error,error,288,"Excellent to see the results. I agree that the conservative scheme is not getting any better with increasing the order of accuracy. The vector invariant scheme is slightly better, but there is not a bit difference when we increase the order of accuracy. I don't suppose it's the temporal error that is drowning this out? Maybe it's the pressure terms, which are of low order?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164710575
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165819827:305,Usability,clear,clear,305,"I am including the link from above [here](https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Advection/centered_second_order.jl#L30). . This shows that areas, or lenghts for shallow water, do appear but they are at the last step of the inbedded functions. It's not clear to me that points 1 and 2 are a bug since the areas do appear in the calculations. The evidence to support that is the above plots where the conservative scheme is very similar to the vector invariant scheme. Point 3 no long is relevant to the code. Point 4 is not a bug but a matter of maybe reducing the accuracy to second order, which might be the highest we can do anyhow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165819827
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165828928:62,Safety,avoid,avoid,62,"I would have rather left the volume in the flux divergence to avoid this type of confusion. In a finite volume scheme, the advection tendency is $\frac{\sum_k F_k}{V_c}$ , where there is no mention of areas because they should be embedded in the fluxes calculation. Then the cell volume $V_c$ is a 1D metric in a 1D problem, a 2D metric in a 2D problem and a 3D metric in a 3D problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165828928
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165832984:79,Usability,clear,clearer,79,"I see your point @simone-silvestri . I thought these changes would make things clearer but perhaps they have done the opposite. My apologies. If you wanted to change them back to volumes, I'm perfectly happy with that. Also, can you confirm that we don't need any extra metrics on the calculation of the momentum, as @glwagner originaly asked about it #1866 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165832984
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165836785:309,Modifiability,evolve,evolve,309,"Thanks for confirming!. So the two outstanding issues are:. - [ ] Do we want to divide by volumes instead of areas to be more general? (Cosmetic but maybe worth fixing); - [ ] Figure out how the height field should be included to achieve higher accuracy, which neither formulation is able to do.; - [ ] Do we evolve the tracer or thickness weighted tracers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165836785
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165844286:125,Modifiability,evolve,evolve,125,Another outstanding issue is the formulation of tracer evolution. At the moment we are evolving tracers but maybe we want to evolve thickness weighted tracers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165844286
https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1166146068:87,Energy Efficiency,monitor,monitoring,87,"Thanks @simone-silvestri . I agree. I changed my list to a checked boxes, to help with monitoring the progress. I can also change the main script to go back to volumes, if we decide this is what we perfer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1166146068
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165714401:16,Availability,mask,masking,16,How does tracer masking affect the pressure solver?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165714401
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:10,Availability,mask,masking,10,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:244,Availability,mask,masking,244,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:357,Availability,mask,masking,357,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:1221,Availability,mask,masking,1221,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:1295,Availability,mask,masking,1295,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:1488,Availability,mask,masking,1488,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:913,Integrability,rout,routines,913,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:217,Safety,predict,predictor,217,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683:391,Safety,avoid,avoid,391,"If tracer masking changes the pressure solver, it is likely a bug. The pressure solver finds the solution to the Poisson pressure equation, which is a Poisson equation with a RHS proportional to the divergence of the predictor velocity. Tracer masking should have no effect on dynamics and is purely a convenience for output (so we should probably move the masking step to output writers to avoid the unnecessary computational expense). However, there is a bug with immersed boundaries and high-order advection schemes (solved by #2603) that means the value of tracer fields in the immersed boundaries _does_ (spuriously and incorrectly) influence the outcome of a simulation. In addition to that, interpolation / reconstruction across immersed boundaries can in principle touch tracer values within immersed boundaries. However, as far as I know we do not ever reconstruct across immersed boundaries in any core routines except the experimental `IsopycnalSkewSymmetricDiffusivity`. #2477 solves this problem by implementing ""homogeneous"" operators that do not touch tracer values within the immersed boundaries (ie differences return 0, reconstruction returns values from ""active"" cells only). This PR could move tracer masking to output writing to save the computation. However, if the tracer masking affects the outcome of a simulation, then there is a deeper issue at hand (perhaps the issue that's solved by #2603?). Perhaps a more specific question is: why does removing the tracer masking step improve simulation outcomes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165721683
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165780914:41,Availability,mask,masking,41,"In the past, problems seem to arise when masking buoyancy as a tracer. Here is an example of a slope at rest with a uniform stratification in a 2D domain run on the main branch. This is using the nonhydrostatic model, but I've plotted the hydrostatic pressure and its horizontal derivative because it shows how masking buoyancy with a strong stratification results in really strong horizontal pressure gradients. These gradients seem to leak out along the boundary creating the numerical effects you can see in the velocity. . https://user-images.githubusercontent.com/67593861/175611052-1aa81aa0-0aa1-4e9a-bfbd-85369b07d99a.mp4. When I did this analysis a while ago, this problem seemed to be fixed by unmasking the tracers, but on the most up to date version of Oceananigans, it doesn't seem to fix the problem. As @glwagner points out, that makes it sound more like a bug. Running it with https://github.com/CliMA/Oceananigans.jl/pull/2603, seems to fix the issue, at least the issue I noticed before. I believe @tomchor has tried both https://github.com/CliMA/Oceananigans.jl/pull/2603 and unmasking and seemed to see a slight improvement with unmasking?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165780914
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165780914:311,Availability,mask,masking,311,"In the past, problems seem to arise when masking buoyancy as a tracer. Here is an example of a slope at rest with a uniform stratification in a 2D domain run on the main branch. This is using the nonhydrostatic model, but I've plotted the hydrostatic pressure and its horizontal derivative because it shows how masking buoyancy with a strong stratification results in really strong horizontal pressure gradients. These gradients seem to leak out along the boundary creating the numerical effects you can see in the velocity. . https://user-images.githubusercontent.com/67593861/175611052-1aa81aa0-0aa1-4e9a-bfbd-85369b07d99a.mp4. When I did this analysis a while ago, this problem seemed to be fixed by unmasking the tracers, but on the most up to date version of Oceananigans, it doesn't seem to fix the problem. As @glwagner points out, that makes it sound more like a bug. Running it with https://github.com/CliMA/Oceananigans.jl/pull/2603, seems to fix the issue, at least the issue I noticed before. I believe @tomchor has tried both https://github.com/CliMA/Oceananigans.jl/pull/2603 and unmasking and seemed to see a slight improvement with unmasking?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165780914
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:517,Availability,down,downwards,517,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:544,Availability,error,error,544,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:706,Availability,error,error,706,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:507,Deployability,integrat,integrate,507,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:507,Integrability,integrat,integrate,507,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793:485,Usability,clear,clear,485,"Okay, thank you very much for the clarification about hydrostatic vs. nonhydrostatic pressure! The hydrostatic pressure integral:. https://github.com/CliMA/Oceananigans.jl/blob/e76deefc1fdf115e05856a18977c593d0b5d3b0d/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L15. does indeed use tracers; in addition it involves a reconstruction / interpolation that _might_ be affecting results here. Bug perhaps? I say ""might"" and ""perhaps"" because the precise mechanism isn't clear to me. Since we integrate downwards, there's only an error in the hydrostatic pressure _below_ the immersed boundary. Hmm... Note, this particular issue is not fixed by ""unmasking"" tracers (it's just that the bug / error is different, and perhaps less innocuous). This bug is also not fixed by #2603.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1165800793
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1218827709:90,Availability,mask,masking,90,"> I m wondering if this issue is solved in the new version. It is! Although I'll move the masking from the model update to the output construction since it doesn't change model runs and it saves time. Tests should be passing, although apparently the GPU runs aren't running currently",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1218827709
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1218827709:113,Deployability,update,update,113,"> I m wondering if this issue is solved in the new version. It is! Although I'll move the masking from the model update to the output construction since it doesn't change model runs and it saves time. Tests should be passing, although apparently the GPU runs aren't running currently",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1218827709
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1218827709:201,Testability,Test,Tests,201,"> I m wondering if this issue is solved in the new version. It is! Although I'll move the masking from the model update to the output construction since it doesn't change model runs and it saves time. Tests should be passing, although apparently the GPU runs aren't running currently",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1218827709
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223170867:48,Usability,feedback,feedback,48,I don't know the details here to provide useful feedback. Sorry... :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223170867
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379:181,Deployability,update,updated,181,"> I don't know the details here to provide useful feedback. Sorry... :(. That's a good point. This PR changed from when it was first introduced and it's much simpler in scope, so I updated the PR description. If that's enough for you to give me feedback, feel free to do so :). I'm only modifying the `NonhydrostaticModel` for now, as I'm not familiar with the hydrostatic one. (Not sure if eventually the same thing should be that for that...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379:50,Usability,feedback,feedback,50,"> I don't know the details here to provide useful feedback. Sorry... :(. That's a good point. This PR changed from when it was first introduced and it's much simpler in scope, so I updated the PR description. If that's enough for you to give me feedback, feel free to do so :). I'm only modifying the `NonhydrostaticModel` for now, as I'm not familiar with the hydrostatic one. (Not sure if eventually the same thing should be that for that...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379:158,Usability,simpl,simpler,158,"> I don't know the details here to provide useful feedback. Sorry... :(. That's a good point. This PR changed from when it was first introduced and it's much simpler in scope, so I updated the PR description. If that's enough for you to give me feedback, feel free to do so :). I'm only modifying the `NonhydrostaticModel` for now, as I'm not familiar with the hydrostatic one. (Not sure if eventually the same thing should be that for that...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379:245,Usability,feedback,feedback,245,"> I don't know the details here to provide useful feedback. Sorry... :(. That's a good point. This PR changed from when it was first introduced and it's much simpler in scope, so I updated the PR description. If that's enough for you to give me feedback, feel free to do so :). I'm only modifying the `NonhydrostaticModel` for now, as I'm not familiar with the hydrostatic one. (Not sure if eventually the same thing should be that for that...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223371379
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496:126,Availability,mask,masking,126,"> We should make the changes needed for both nonhydrostatic and hydrostatic models. @glwagner the reason why I hadn't removed masking from the hydrostatic model is that I'm really not familiar with it at all. So it's harder for me to figure out where it's okay to remove it, and testing it. I just did a best guess and removed it from shallow water and nonhydrostatic models in the places I thought appropriate. It would be good to have some feedback from someone more familiar with the code though on that, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496:279,Testability,test,testing,279,"> We should make the changes needed for both nonhydrostatic and hydrostatic models. @glwagner the reason why I hadn't removed masking from the hydrostatic model is that I'm really not familiar with it at all. So it's harder for me to figure out where it's okay to remove it, and testing it. I just did a best guess and removed it from shallow water and nonhydrostatic models in the places I thought appropriate. It would be good to have some feedback from someone more familiar with the code though on that, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496:442,Usability,feedback,feedback,442,"> We should make the changes needed for both nonhydrostatic and hydrostatic models. @glwagner the reason why I hadn't removed masking from the hydrostatic model is that I'm really not familiar with it at all. So it's harder for me to figure out where it's okay to remove it, and testing it. I just did a best guess and removed it from shallow water and nonhydrostatic models in the places I thought appropriate. It would be good to have some feedback from someone more familiar with the code though on that, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223429496
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223709635:213,Availability,mask,masking,213,"@tomchor, if you want I can remove it from the hydrostatic model; it should be the same as for the nonhydrostatic. . Actually, I saw that you already removed it. I am wondering though if we don't need to keep the masking for the velocities, as those need an ""impenetrability"" condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223709635
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421:16,Availability,mask,masking,16,"We have to keep masking for velocities in the hydrostatic model. In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Models/NonhydrostaticModels/pressure_correction.jl#L12-L14",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421:109,Availability,mask,masking,109,"We have to keep masking for velocities in the hydrostatic model. In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Models/NonhydrostaticModels/pressure_correction.jl#L12-L14",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421:139,Safety,predict,predictor,139,"We have to keep masking for velocities in the hydrostatic model. In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Models/NonhydrostaticModels/pressure_correction.jl#L12-L14",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1223993421
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327:18,Availability,mask,masking,18,"> We have to keep masking for velocities in the hydrostatic model.; > ; > In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. Yes, I kept that in the nonhydrostatic model. Although I think I removed it on the hydrostatic one so I'll put it back in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327:118,Availability,mask,masking,118,"> We have to keep masking for velocities in the hydrostatic model.; > ; > In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. Yes, I kept that in the nonhydrostatic model. Although I think I removed it on the hydrostatic one so I'll put it back in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327:148,Safety,predict,predictor,148,"> We have to keep masking for velocities in the hydrostatic model.; > ; > In the nonhydrostatic model, the equivalent masking procedure acts on the predictor velocity field prior to solving for pressure:. Yes, I kept that in the nonhydrostatic model. Although I think I removed it on the hydrostatic one so I'll put it back in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224091327
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224795889:36,Testability,test,tests,36,@simone-silvestri @glwagner I think tests should be passing now. Ready for reviews,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1224795889
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1225936417:43,Availability,mask,masking,43,"Also, I don't understand why we're calling masking events at update for every `NonhydrostaticModel` regardless of it having an `ImmersedGrid` or not:. https://github.com/CliMA/Oceananigans.jl/blob/d4a45adf21918f95ca4d23ec7167e720c44c501b/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl#L14-L19. The same goes for the hydrostatic model. Why not something like. ```julia; if model.grid isa ImmersedBoundaryGrid; # call masking; end; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1225936417
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1225936417:438,Availability,mask,masking,438,"Also, I don't understand why we're calling masking events at update for every `NonhydrostaticModel` regardless of it having an `ImmersedGrid` or not:. https://github.com/CliMA/Oceananigans.jl/blob/d4a45adf21918f95ca4d23ec7167e720c44c501b/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl#L14-L19. The same goes for the hydrostatic model. Why not something like. ```julia; if model.grid isa ImmersedBoundaryGrid; # call masking; end; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1225936417
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1225936417:61,Deployability,update,update,61,"Also, I don't understand why we're calling masking events at update for every `NonhydrostaticModel` regardless of it having an `ImmersedGrid` or not:. https://github.com/CliMA/Oceananigans.jl/blob/d4a45adf21918f95ca4d23ec7167e720c44c501b/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl#L14-L19. The same goes for the hydrostatic model. Why not something like. ```julia; if model.grid isa ImmersedBoundaryGrid; # call masking; end; ```; ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1225936417
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280126525:12,Testability,test,tested,12,"@glwagner I tested this locally, tests are passing, and I believe I addressed all your comments, so this should be ready for re-review. That said, github tells me there's a requested revision by you but I can't figure out what to do about it. Could you please take a look?. @simone-silvestri @navidcy also feel free to review",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280126525
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280126525:33,Testability,test,tests,33,"@glwagner I tested this locally, tests are passing, and I believe I addressed all your comments, so this should be ready for re-review. That said, github tells me there's a requested revision by you but I can't figure out what to do about it. Could you please take a look?. @simone-silvestri @navidcy also feel free to review",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280126525
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280176328:37,Testability,test,testing,37,"I think we will need to do some more testing to make sure this won't break our near global hydrostatic setups, which are unfortunately in a tenuous position because they rely on some untested features (and we don't have regression tests for some important cases). @simone-silvestri what do you think? We may want to wait for a few more PRs (perhaps containing some of those tests) to go in first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280176328
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280176328:231,Testability,test,tests,231,"I think we will need to do some more testing to make sure this won't break our near global hydrostatic setups, which are unfortunately in a tenuous position because they rely on some untested features (and we don't have regression tests for some important cases). @simone-silvestri what do you think? We may want to wait for a few more PRs (perhaps containing some of those tests) to go in first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280176328
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280176328:374,Testability,test,tests,374,"I think we will need to do some more testing to make sure this won't break our near global hydrostatic setups, which are unfortunately in a tenuous position because they rely on some untested features (and we don't have regression tests for some important cases). @simone-silvestri what do you think? We may want to wait for a few more PRs (perhaps containing some of those tests) to go in first.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1280176328
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426160352:39,Testability,test,testing,39,"> I think we will need to do some more testing to make sure this won't break our near global hydrostatic setups, which are unfortunately in a tenuous position because they rely on some untested features (and we don't have regression tests for some important cases). @simone-silvestri what do you think? We may want to wait for a few more PRs (perhaps containing some of those tests) to go in first. @glwagner what is the status of the global hydrostatic setup tests? Do you think we've reached a point where we can merge this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426160352
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426160352:233,Testability,test,tests,233,"> I think we will need to do some more testing to make sure this won't break our near global hydrostatic setups, which are unfortunately in a tenuous position because they rely on some untested features (and we don't have regression tests for some important cases). @simone-silvestri what do you think? We may want to wait for a few more PRs (perhaps containing some of those tests) to go in first. @glwagner what is the status of the global hydrostatic setup tests? Do you think we've reached a point where we can merge this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426160352
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426160352:376,Testability,test,tests,376,"> I think we will need to do some more testing to make sure this won't break our near global hydrostatic setups, which are unfortunately in a tenuous position because they rely on some untested features (and we don't have regression tests for some important cases). @simone-silvestri what do you think? We may want to wait for a few more PRs (perhaps containing some of those tests) to go in first. @glwagner what is the status of the global hydrostatic setup tests? Do you think we've reached a point where we can merge this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426160352
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426160352:460,Testability,test,tests,460,"> I think we will need to do some more testing to make sure this won't break our near global hydrostatic setups, which are unfortunately in a tenuous position because they rely on some untested features (and we don't have regression tests for some important cases). @simone-silvestri what do you think? We may want to wait for a few more PRs (perhaps containing some of those tests) to go in first. @glwagner what is the status of the global hydrostatic setup tests? Do you think we've reached a point where we can merge this PR?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426160352
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426533974:33,Testability,test,tests,33,"I don't think we have regression tests yet but not sure, @simone-silvestri would know",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1426533974
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:69,Availability,mask,masking,69,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:161,Availability,mask,mask,161,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:379,Availability,mask,masking,379,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:434,Availability,mask,mask,434,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998
https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998:336,Integrability,interface,interface,336,"@tomchor I think we should revisit this PR. Rather than ""moving"" the masking, I think we should start by adding a feature to both output writers that defines a ""mask value"" for immersed regions. What do you think about that? I would like to open a new PR for that. And before that, I'm going to open an issue so we can discuss the user interface. Once we have a nice feature for masking output, we can consider whether or not to also mask (or not) within the time-stepping. These are separate questions, I think. If you agree with that then we can close this PR and I will open an new issue to discuss the user API.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616#issuecomment-1505661998
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1728461532:29,Availability,error,errors,29,For hydrostatic models I get errors about trying to pass double precision numbers to a kernel,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1728461532
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1729331099:457,Performance,load,loads,457,"I think the double precision numbers are coming from Nx/Ny/Nz being turned into Int64 (even if I manually set them to be Int32) when the grid is constructed. ~~I can't work out exactly where the promotion is happening though.~~ This happens because `Nx` etc. are `::Int` type in the grid, so get promoted when the grid is made, if I change them to be like the floats and be `IT` instead then the promotion doesn't happen. When I try to make the model I get loads of other things converted to `Int64` though so still doesn't work.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1729331099
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1729904063:67,Availability,error,error,67,Why is that only an issue for hydrostatic? Are you just hitting an error sooner with nonhydrostatic?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1729904063
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731452482:31,Modifiability,refactor,refactor,31,Another possibility is that we refactor the code to generalize integer types. Which is not actually a horrible idea. There's some notion that we may also benefit from index types that are `Int32`. Adding an integer type for `Nx` would allow us to also automatically convert integers to `Int32` (eg we write something like `i = inttype(grid)`).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731452482
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731460376:31,Availability,error,errors,31,> For hydrostatic models I get errors about trying to pass double precision numbers to a kernel. The Metal examples don't say anything about this btw. Can you please paste the error that you find into this issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731460376
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731460376:176,Availability,error,error,176,> For hydrostatic models I get errors about trying to pass double precision numbers to a kernel. The Metal examples don't say anything about this btw. Can you please paste the error that you find into this issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731460376
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:148,Availability,ERROR,ERROR,148,"I get this with the default free surface model (which I think can be solved fairly easily):; ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:238,Availability,error,error,238,"I get this with the default free surface model (which I think can be solved fairly easily):; ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:265,Availability,error,error,265,"I get this with the default free surface model (which I think can be solved fairly easily):; ```julia; model = HydrostaticFreeSurfaceModel(; grid); ERROR: Metal does not support Float64 values, try using Float32 instead; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] check_eltype(T::Type); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:32; [3] Metal.MtlArray{Float64, 3, Metal.MTL.MTLResourceStorageModePrivate}(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:50; [4] (Metal.MtlArray{Float64, 3})(#unused#::UndefInitializer, dims::Tuple{Int64, Int64, Int64}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:98; [5] MtlArray; @ ~/.julia/packages/Metal/lnkVP/src/array.jl:157 [inlined]; [6] Metal.MtlArray(A::Array{Float64, 3}); @ Metal ~/.julia/packages/Metal/lnkVP/src/array.jl:173; [7] arch_array(#unused#::Oceananigans.Architectures.MetalBackend, a::Array{Float64, 3}); @ Oceananigans.Architectures ~/Documents/Projects/Oceananigans.jl/src/Architectures.jl:75; [8] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}, planner_flag::UInt32); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_poisson_solver.jl:61; [9] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, Oceananigans.Architectures.MetalBackend}); @ Oceananigans.Solvers ~/Documents/Projects/Oceananigans.jl/src/Solvers/fft_based_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36336,Performance,optimiz,optimize,36336,"Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36640,Performance,optimiz,optimize,36640,"as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, wor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36980,Performance,optimiz,optimize,36980,"ion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::typeof(Metal.compile), linker::typeof(Metal.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:125; [15] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:37624,Performance,cache,cache,37624,"oplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::typeof(Metal.compile), linker::typeof(Metal.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:125; [15] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:103; [16] macro expansion; @ ~/.julia/packages/Metal/lnkVP/src/compiler/execution.jl:162 [inlined]; [17] macro expansion; @ ./lock.jl:267 [inlined]; [18] mtlfunction(f::typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.gpu_compute_hydrostatic_free_surface_Gu!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(3, 3, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, K",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:37939,Performance,cache,cache,37939,"lerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::typeof(Metal.compile), linker::typeof(Metal.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:125; [15] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::Function, linker::Function); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:103; [16] macro expansion; @ ~/.julia/packages/Metal/lnkVP/src/compiler/execution.jl:162 [inlined]; [17] macro expansion; @ ./lock.jl:267 [inlined]; [18] mtlfunction(f::typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.gpu_compute_hydrostatic_free_surface_Gu!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(3, 3, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 50)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float32, 3, Metal.MtlDeviceArray{Float32, 3, 1}}, RectilinearGrid{Float32, Periodic, Periodic, Bounded, Float32, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:35970,Security,validat,validation,35970,"tic_free_surface_Gu!; @ ./none:0; Reason: unsupported use of double value; Stacktrace:; [1] Float32; @ ./float.jl:258; [2] convert; @ ./number.jl:7; [3] setindex!; @ ~/.julia/packages/Metal/lnkVP/src/device/array.jl:105; [4] setindex!; @ ~/.julia/packages/Metal/lnkVP/src/device/array.jl:118; [5] setindex!; @ ~/.julia/packages/OffsetArrays/0MOrf/src/OffsetArrays.jl:443; [6] macro expansion; @ ~/Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36385,Security,validat,validate,36385,"Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36684,Security,validat,validate,36684,"as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, wor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:37024,Security,validat,validate,37024,"ion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:47; [13] compile(job::GPUCompiler.CompilerJob); @ Metal ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:56; [14] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, compiler::typeof(Metal.compile), linker::typeof(Metal.link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/execution.jl:125; [15] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731580137:71,Availability,error,error,71,"Found where the promotion is occurring in the former which solves that error, and get us back to the FFT transform planning error that the nonhydostatic model gives",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731580137
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731580137:124,Availability,error,error,124,"Found where the promotion is occurring in the former which solves that error, and get us back to the FFT transform planning error that the nonhydostatic model gives",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731580137
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731593651:157,Availability,error,error,157,And if I modify the default free surface model to `free_surface = ImplicitFreeSurface(gravitational_acceleration=eltype(grid)(g_Earth))` I also get the same error (the docstring is also wrong for what the default free surface model is).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731593651
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731605078:32,Availability,error,error,32,Ah yeah that also gives the fft error,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731605078
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731743139:1101,Availability,error,error,1101,"Ran the baroclinical adjustement example:; ```; using Oceananigans; using Oceananigans.Units. Lx = 1000kilometers # east-west extent [m]; Ly = 1000kilometers # north-south extent [m]; Lz = 1kilometers # depth [m]. grid = RectilinearGrid(Oceananigans.Architectures.MetalBackend(), Float32;; size = (48, 48, 8),; x = (0, Lx),; y = (-Ly/2, Ly/2),; z = (-Lz, 0),; topology = (Periodic, Bounded, Bounded)). advection = UpwindBiased(Float32); free_surface = ExplicitFreeSurface(); coriolis = BetaPlane(Float32, latitude = -45). model = HydrostaticFreeSurfaceModel(; grid,; coriolis,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = advection,; tracer_advection = advection,; free_surface); ```. This runs with none of the callbacks in about 4 seconds. This output writer works (but `TimeInterval` won't work):; ```; b = model.tracers.b; simulation.output_writers[:fields] = JLD2OutputWriter(model, (; b);; filename = filename * ""_slice"",; schedule = IterationInterval(10),; overwrite_existing = true); ```. And the timestep wizard also won't work because reductions cause a metal compiler error. https://github.com/CliMA/Oceananigans.jl/assets/26657828/c75b33ba-5b06-454b-a883-93eb659d06d6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731743139
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731743139:951,Energy Efficiency,schedul,schedule,951,"Ran the baroclinical adjustement example:; ```; using Oceananigans; using Oceananigans.Units. Lx = 1000kilometers # east-west extent [m]; Ly = 1000kilometers # north-south extent [m]; Lz = 1kilometers # depth [m]. grid = RectilinearGrid(Oceananigans.Architectures.MetalBackend(), Float32;; size = (48, 48, 8),; x = (0, Lx),; y = (-Ly/2, Ly/2),; z = (-Lz, 0),; topology = (Periodic, Bounded, Bounded)). advection = UpwindBiased(Float32); free_surface = ExplicitFreeSurface(); coriolis = BetaPlane(Float32, latitude = -45). model = HydrostaticFreeSurfaceModel(; grid,; coriolis,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = advection,; tracer_advection = advection,; free_surface); ```. This runs with none of the callbacks in about 4 seconds. This output writer works (but `TimeInterval` won't work):; ```; b = model.tracers.b; simulation.output_writers[:fields] = JLD2OutputWriter(model, (; b);; filename = filename * ""_slice"",; schedule = IterationInterval(10),; overwrite_existing = true); ```. And the timestep wizard also won't work because reductions cause a metal compiler error. https://github.com/CliMA/Oceananigans.jl/assets/26657828/c75b33ba-5b06-454b-a883-93eb659d06d6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731743139
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732203856:61,Integrability,interface,interface,61,If this will be important then we should streamline the user interface for changing to Float32. Ideally everything should take `eltype` from the grid I think without requiring tons of manual intervention.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732203856
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:667,Availability,error,errors,667,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:556,Deployability,update,updates,556,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:35,Modifiability,refactor,refactoring,35,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:343,Modifiability,variab,variable,343,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:12,Safety,avoid,avoid,12,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732648650:159,Availability,error,error,159,> And if I modify the default free surface model to `free_surface = ImplicitFreeSurface(gravitational_acceleration=eltype(grid)(g_Earth))` I also get the same error (the docstring is also wrong for what the default free surface model is). Can you raise this in a separate issue?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732648650
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563:694,Integrability,interface,interface,694,"> This output writer works (but TimeInterval won't work):. One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563
https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563:805,Modifiability,variab,variables,805,"> This output writer works (but TimeInterval won't work):. One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563
https://github.com/CliMA/Oceananigans.jl/issues/2623#issuecomment-1480040680:25,Modifiability,refactor,refactor,25,"I don't think so, we can refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2623#issuecomment-1480040680
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171400617:402,Deployability,continuous,continuous,402,"I think the immersed boundary condition should be an `ImmersedBoundaryCondition`. ```; @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]. drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); ```. I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`). we can probably add here the `getbc` method for a _continuous_ immersed boundary condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171400617
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502:430,Deployability,continuous,continuous,430,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502:848,Integrability,depend,depends,848,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502:915,Usability,simpl,simple,915,"> I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > ; > ```; > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > ; > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > ```; > ; > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > ; > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition. This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because. https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245. For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171935502
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524:506,Deployability,continuous,continuous,506,"> > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > ```; > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > ; > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > ; > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > ; > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > ; > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated. Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524:928,Integrability,depend,depends,928,"> > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > ```; > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > ; > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > ; > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > ; > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > ; > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated. Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524:995,Usability,simpl,simple,995,"> > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > ```; > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > ; > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > ; > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > ; > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > ; > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated. Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171942524
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378:546,Deployability,continuous,continuous,546,"> > > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > > ```; > > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > > ; > > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > > ; > > ; > > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > > ; > > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.; > ; > Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?. I think if its a common application, it's important to demonstrate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378:980,Integrability,depend,depends,980,"> > > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > > ```; > > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > > ; > > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > > ; > > ; > > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > > ; > > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.; > ; > Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?. I think if its a common application, it's important to demonstrate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378:1047,Usability,simpl,simple,1047,"> > > I think the immersed boundary condition should be an `ImmersedBoundaryCondition`; > > > ```; > > > @inline linear_drag(i, j, k, grid, clock, fields) = - 0.2 * fields.u[i, j, k]; > > > ; > > > drag_u = FluxBoundaryCondition(linear_drag, discrete_form=true); > > > u_immersed_bc = ImmersedBoundaryCondition(bottom = drag_u); > > > u_bcs = FieldBoundaryConditions(bottom = drag_u, immersed = u_immersed_bc); > > > ```; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > ; > > > I do not think we can use the continuous form because `ImmersedBoundaryCondition` should behave just as another `FieldBoundaryCondition` which is 3D instead of 2D and I do not see a `getbc` defined for a `3DBoundaryFunction` (they are only defined for `XBoundaryFunction`, `YBoundaryFunction` and `ZBoundaryFunction`); > > > we can probably add here the `getbc` method for a _continuous_ immersed boundary condition; > > ; > > ; > > This is a specific choice that depends on the boundary condition one is trying to implement. For ""simple"" boundary conditions, we don't need to invoke `ImmersedBoundaryCondition` because; > > https://github.com/CliMA/Oceananigans.jl/blob/95206ae73e10460beebb2ce9d5fc9945523e5724/src/ImmersedBoundaries/immersed_boundary_condition.jl#L242-L245; > > ; > > For boundary conditions that impose _only bottom drag_ but _not_ side drag, then we do need to use `ImmersedBoundaryCondition` as indicated.; > ; > Shall I leave it like this? Bottom drag is usually applied at the bottom (not the sides) so the example is relevant and useful to many applications. Is it too elaborate though?. I think if its a common application, it's important to demonstrate.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1171946378
https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1183502106:480,Safety,avoid,avoid,480,"Yep, the immersed boundary condition `ImmersedBoundaryCondition` has fields `west, east, south, north, top, bottom`, in that case the `south` immersed bc will be active (all the others will do nothing). Apparently if you construct it with the `immersed = BC` keyword (in the `FieldBoundaryConditions` constructor) that will copy the same BC for all directions, otherwise you can specify different BCs for different directions using the `ImmersedBoundaryCondition` constructor (or avoid them if, for example, you do not want side drag in that instance). For this reason the functions to be passed in the BC have to be 3D",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2632#issuecomment-1183502106
https://github.com/CliMA/Oceananigans.jl/pull/2634#issuecomment-1171937765:62,Availability,error,error,62,I guess this isn't tested because otherwise it would throw an error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2634#issuecomment-1171937765
https://github.com/CliMA/Oceananigans.jl/pull/2634#issuecomment-1171937765:19,Testability,test,tested,19,I guess this isn't tested because otherwise it would throw an error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2634#issuecomment-1171937765
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172575160:85,Testability,test,tested,85,I wonder about CPU execution though... because the `MatrixSolver` with `ILU` was not tested and that in my experience seemed always to be the fastest method,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172575160
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179:292,Performance,perform,performance,292,"These benchmarks:. https://github.com/CliMA/Oceananigans.jl/pull/2412. show a factor of 2 speed up on the CPU. In principle, the FFT is faster than a matrix multiply which may explain it? Or, perhaps the benchmarks test the wrong thing so we should re-run them. As explained on that PR, some performance is left on the table, because the fastest combination would use an FFT-based preconditioner with a matrix multiply to compute the LHS.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179:6,Testability,benchmark,benchmarks,6,"These benchmarks:. https://github.com/CliMA/Oceananigans.jl/pull/2412. show a factor of 2 speed up on the CPU. In principle, the FFT is faster than a matrix multiply which may explain it? Or, perhaps the benchmarks test the wrong thing so we should re-run them. As explained on that PR, some performance is left on the table, because the fastest combination would use an FFT-based preconditioner with a matrix multiply to compute the LHS.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179:204,Testability,benchmark,benchmarks,204,"These benchmarks:. https://github.com/CliMA/Oceananigans.jl/pull/2412. show a factor of 2 speed up on the CPU. In principle, the FFT is faster than a matrix multiply which may explain it? Or, perhaps the benchmarks test the wrong thing so we should re-run them. As explained on that PR, some performance is left on the table, because the fastest combination would use an FFT-based preconditioner with a matrix multiply to compute the LHS.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179:215,Testability,test,test,215,"These benchmarks:. https://github.com/CliMA/Oceananigans.jl/pull/2412. show a factor of 2 speed up on the CPU. In principle, the FFT is faster than a matrix multiply which may explain it? Or, perhaps the benchmarks test the wrong thing so we should re-run them. As explained on that PR, some performance is left on the table, because the fastest combination would use an FFT-based preconditioner with a matrix multiply to compute the LHS.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172613179
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064:97,Energy Efficiency,reduce,reduce,97,"Yeah, but the `ILU` preconditioner doesn't seem to be tested, which I remember was quite good to reduce the number of iterations. So in case of a large time step that would be quite efficient even if we have to solver two triangular linear systems each iteration. but anyways, maybe it's not faster, it was just I was wondering how it would compare",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064:182,Energy Efficiency,efficient,efficient,182,"Yeah, but the `ILU` preconditioner doesn't seem to be tested, which I remember was quite good to reduce the number of iterations. So in case of a large time step that would be quite efficient even if we have to solver two triangular linear systems each iteration. but anyways, maybe it's not faster, it was just I was wondering how it would compare",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064:54,Testability,test,tested,54,"Yeah, but the `ILU` preconditioner doesn't seem to be tested, which I remember was quite good to reduce the number of iterations. So in case of a large time step that would be quite efficient even if we have to solver two triangular linear systems each iteration. but anyways, maybe it's not faster, it was just I was wondering how it would compare",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172617064
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172668651:104,Testability,benchmark,benchmark,104,"Hmm, well I guess we should add that combination to. https://github.com/CliMA/Oceananigans.jl/blob/main/benchmark/benchmark_hydrostatic_model.jl. and re-run the benchmarks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172668651
https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172668651:161,Testability,benchmark,benchmarks,161,"Hmm, well I guess we should add that combination to. https://github.com/CliMA/Oceananigans.jl/blob/main/benchmark/benchmark_hydrostatic_model.jl. and re-run the benchmarks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2635#issuecomment-1172668651
https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1173386910:30,Availability,avail,available,30,A preview of the docs will be available at . https://clima.github.io/OceananigansDocumentation/previews/PR2639. (after the docs are build... it takes ~2hrs),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1173386910
https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064:407,Deployability,integrat,integrate,407,"> > I think eq 9 in https://clima.github.io/OceananigansDocumentation/previews/PR2639/numerical_implementation/poisson_solvers/ is correct; am I right?; > > if so, I seem to have trouble deriving eq 10…; > ; > OK, I see the derivation in pages 7-8 of https://www.overleaf.com/project/6042a885d8327860fae7cc5e. I think we need to include a bit more steps from this derivation here... Ageed. It seems that we integrate the continuity equation from the bottom, z=-H, to the surface, z=0, exchange the order of integration and differentiation, and then substitute in the kinetmatic boundary conditions at the top and bottom. But maybe even more detail would be helpful?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064
https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064:507,Deployability,integrat,integration,507,"> > I think eq 9 in https://clima.github.io/OceananigansDocumentation/previews/PR2639/numerical_implementation/poisson_solvers/ is correct; am I right?; > > if so, I seem to have trouble deriving eq 10…; > ; > OK, I see the derivation in pages 7-8 of https://www.overleaf.com/project/6042a885d8327860fae7cc5e. I think we need to include a bit more steps from this derivation here... Ageed. It seems that we integrate the continuity equation from the bottom, z=-H, to the surface, z=0, exchange the order of integration and differentiation, and then substitute in the kinetmatic boundary conditions at the top and bottom. But maybe even more detail would be helpful?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064
https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064:407,Integrability,integrat,integrate,407,"> > I think eq 9 in https://clima.github.io/OceananigansDocumentation/previews/PR2639/numerical_implementation/poisson_solvers/ is correct; am I right?; > > if so, I seem to have trouble deriving eq 10…; > ; > OK, I see the derivation in pages 7-8 of https://www.overleaf.com/project/6042a885d8327860fae7cc5e. I think we need to include a bit more steps from this derivation here... Ageed. It seems that we integrate the continuity equation from the bottom, z=-H, to the surface, z=0, exchange the order of integration and differentiation, and then substitute in the kinetmatic boundary conditions at the top and bottom. But maybe even more detail would be helpful?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064
https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064:507,Integrability,integrat,integration,507,"> > I think eq 9 in https://clima.github.io/OceananigansDocumentation/previews/PR2639/numerical_implementation/poisson_solvers/ is correct; am I right?; > > if so, I seem to have trouble deriving eq 10…; > ; > OK, I see the derivation in pages 7-8 of https://www.overleaf.com/project/6042a885d8327860fae7cc5e. I think we need to include a bit more steps from this derivation here... Ageed. It seems that we integrate the continuity equation from the bottom, z=-H, to the surface, z=0, exchange the order of integration and differentiation, and then substitute in the kinetmatic boundary conditions at the top and bottom. But maybe even more detail would be helpful?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1175015064
https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1185372669:63,Testability,test,tests,63,@elise-palethorpe if you are happy with this PR merge when all tests pass ;),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639#issuecomment-1185372669
https://github.com/CliMA/Oceananigans.jl/pull/2640#issuecomment-1174587288:18,Testability,test,tests,18,the matrix solver tests seem ok ;); https://buildkite.com/clima/oceananigans/builds/8008#0181cb59-5724-4983-8405-c00440044a02,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2640#issuecomment-1174587288
https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:23,Availability,error,errors,23,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246
https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:111,Availability,ERROR,ERROR,111,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246
https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:42,Integrability,message,message,42,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246
https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:118,Performance,Load,LoadError,118,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246
https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:129,Performance,Load,LoadError,129,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246
https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:99,Testability,test,tests,99,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246
https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178211104:153,Testability,test,tests,153,"> Looks great! I guess we should find an example to this this on. Do you think we should try the example of a rotating bucket flow?. I added a couple of tests and verified that a initially non divergent velocity field (gaussian) diffuses to the mean value. I guess we're ready for more complex testing, the rotating bucket sounds good!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178211104
https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178211104:294,Testability,test,testing,294,"> Looks great! I guess we should find an example to this this on. Do you think we should try the example of a rotating bucket flow?. I added a couple of tests and verified that a initially non divergent velocity field (gaussian) diffuses to the mean value. I guess we're ready for more complex testing, the rotating bucket sounds good!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178211104
https://github.com/CliMA/Oceananigans.jl/pull/2646#issuecomment-1179632808:56,Deployability,deploy,deployed,56,It renders fine. Perhaps you tried before tge docs were deployed?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2646#issuecomment-1179632808
https://github.com/CliMA/Oceananigans.jl/pull/2646#issuecomment-1179633173:58,Deployability,deploy,deployed,58,"> It renders fine. Perhaps you tried before tge docs were deployed?. Yeah, I think you're right. It's rendering now. The new video looks good to me!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2646#issuecomment-1179633173
https://github.com/CliMA/Oceananigans.jl/issues/2647#issuecomment-1181924885:30,Testability,test,test,30,"Good catch! I think we should test that, but indeed a slimmer version of that test is preferred.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2647#issuecomment-1181924885
https://github.com/CliMA/Oceananigans.jl/issues/2647#issuecomment-1181924885:78,Testability,test,test,78,"Good catch! I think we should test that, but indeed a slimmer version of that test is preferred.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2647#issuecomment-1181924885
https://github.com/CliMA/Oceananigans.jl/issues/2647#issuecomment-1184640836:300,Testability,test,test,300,"> Why though it takes 1.5hrs? Any ideas?. Not sure. It runs two models for over 3000 time steps, but the GPU should make that pretty fast. The only ""unusual"" thing I see with that example is that it's a 0d model, and maybe that doesn't play well with the GPU?. In any case, maybe it's easier to just test that a model with `ConstantCartesianCoriolis()` returns the correct tendencies instead of running two models for a whole inertial period?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2647#issuecomment-1184640836
https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1181990838:152,Energy Efficiency,reduce,reduced,152,"`Periodic` boundary conditions should fill the whole halos, while flux, value and gradient BC should fill only the first because advection schemes have reduced order approaching boundaries. Did you notice this in a bounded direction or a periodic direction? In the latter case it is definitely a bug",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1181990838
https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814:1288,Integrability,depend,dependencies,1288,"Do you have an example? . If you have a grid with `Nx = 10` and `Ny = 10` and set `h = 1.0` (and `fill_halo_regions!`) then the `h.data` will be 1 from `0:11, 0:11` and 0.0 elsewhere. Is this what you are referring to?. If x and y directions are bounded, points at `-2:-1, -2:-1` (and respective points above Nx and Ny) are never touched because both advection and diffusion are second order near the boundary. (You might want to use branch #2603 to make sure this is the case). So, for (2), I don't think we need it because those halo points should not be touched anyways.; For (1): I do not think there is an easy way to do that that does not involve writing some kernels, but you maybe reutilize the previous flux BC implementation and write something like this. ```; @kernel function _fill_height_west_and_east!(h, H, N); j, k = @index(Global, NTuple). @unroll for i in 1:H; @inbounds h[1-i, j, k] = h[i, j, k]; @inbounds h[N+i, j, k] = h[N+1-i, j, k]; end; end. @kernel function _fill_height_south_and_nort!(h, H, N); i, k = @index(Global, NTuple). @unroll for j in 1:H; @inbounds h[i, 1-j, k] = h[i, j, k]; @inbounds h[i, N+j, k] = h[i, N+1-j, k]; end; end. fill_height_west_and_east!(h, arch, dep, grid) = launch!(arch, grid, :yz, _fill_height_west_and_east!, h, grid.Hx, grid.Nx; dependencies=dep); fill_height_south_and_north!(h, arch, dep, grid) = launch!(arch, grid, :xz, _fill_height_south_and_north!, h, grid.Hy, grid.Ny; dependencies=dep); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814
https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814:1435,Integrability,depend,dependencies,1435,"Do you have an example? . If you have a grid with `Nx = 10` and `Ny = 10` and set `h = 1.0` (and `fill_halo_regions!`) then the `h.data` will be 1 from `0:11, 0:11` and 0.0 elsewhere. Is this what you are referring to?. If x and y directions are bounded, points at `-2:-1, -2:-1` (and respective points above Nx and Ny) are never touched because both advection and diffusion are second order near the boundary. (You might want to use branch #2603 to make sure this is the case). So, for (2), I don't think we need it because those halo points should not be touched anyways.; For (1): I do not think there is an easy way to do that that does not involve writing some kernels, but you maybe reutilize the previous flux BC implementation and write something like this. ```; @kernel function _fill_height_west_and_east!(h, H, N); j, k = @index(Global, NTuple). @unroll for i in 1:H; @inbounds h[1-i, j, k] = h[i, j, k]; @inbounds h[N+i, j, k] = h[N+1-i, j, k]; end; end. @kernel function _fill_height_south_and_nort!(h, H, N); i, k = @index(Global, NTuple). @unroll for j in 1:H; @inbounds h[i, 1-j, k] = h[i, j, k]; @inbounds h[i, N+j, k] = h[i, N+1-j, k]; end; end. fill_height_west_and_east!(h, arch, dep, grid) = launch!(arch, grid, :yz, _fill_height_west_and_east!, h, grid.Hx, grid.Nx; dependencies=dep); fill_height_south_and_north!(h, arch, dep, grid) = launch!(arch, grid, :xz, _fill_height_south_and_north!, h, grid.Hy, grid.Ny; dependencies=dep); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182057814
https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182107240:528,Energy Efficiency,efficient,efficientive,528,"I agree that your example does assign the first halo points correct. . We are using the main branch now and indeed we are trying to use higher order schemes near the boundary, a bad idea, and we will try and avoid that. . I looked over #2603 and can you point out where, say 3rd order upwinding switches to 1st order near the boundaries? That should help us to modify our forcing function appropriately. A more general piont is, if we never want to use the extra two halo points, why do we define them? Wouldn't it be more cost efficientive to only define them in the periodic case, and have smaller halos in the bounded case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182107240
https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182107240:208,Safety,avoid,avoid,208,"I agree that your example does assign the first halo points correct. . We are using the main branch now and indeed we are trying to use higher order schemes near the boundary, a bad idea, and we will try and avoid that. . I looked over #2603 and can you point out where, say 3rd order upwinding switches to 1st order near the boundaries? That should help us to modify our forcing function appropriately. A more general piont is, if we never want to use the extra two halo points, why do we define them? Wouldn't it be more cost efficientive to only define them in the periodic case, and have smaller halos in the bounded case?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182107240
https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702:626,Modifiability,evolve,evolve,626,"If you didn't define new advection schemes but use the implemented ones they automatically lower the order near the boundaries. The implementation is in `topologically_conditional_interpolation.jl`. If you did not define new `symmetric_left_biased_interpolation_xᶠᵃᵃ` functions you should be ok. ; Otherwise you have to add your methods in the above mentioned file. If you are using an immersed boundary, the limiting is performed in the `conditional_fluxes.jl` file in the ImmersedBoundaries module. You can always use high order and fill more halos but then you are making an assumption on the field which you are trying to evolve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702
https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702:421,Performance,perform,performed,421,"If you didn't define new advection schemes but use the implemented ones they automatically lower the order near the boundaries. The implementation is in `topologically_conditional_interpolation.jl`. If you did not define new `symmetric_left_biased_interpolation_xᶠᵃᵃ` functions you should be ok. ; Otherwise you have to add your methods in the above mentioned file. If you are using an immersed boundary, the limiting is performed in the `conditional_fluxes.jl` file in the ImmersedBoundaries module. You can always use high order and fill more halos but then you are making an assumption on the field which you are trying to evolve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702
https://github.com/CliMA/Oceananigans.jl/pull/2651#issuecomment-1183927563:4,Testability,test,test,4,Any test? Only if it's easy... Otherwise forget it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2651#issuecomment-1183927563
https://github.com/CliMA/Oceananigans.jl/pull/2651#issuecomment-1190754034:8,Testability,test,test,8,"Added a test, I ll merge when tests pass",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2651#issuecomment-1190754034
https://github.com/CliMA/Oceananigans.jl/pull/2651#issuecomment-1190754034:30,Testability,test,tests,30,"Added a test, I ll merge when tests pass",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2651#issuecomment-1190754034
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1182527618:812,Modifiability,variab,variably,812,"Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not? Meaning it considers whether a cell is part of the interior of the domain or is a halo/immersed solid cell when calculating `Δz`? Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. For example in the script below, I can retrieve `Δz` directly from `grid`, but the edges do not reflect the fact that the `z` direction is bounded. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25. julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; 5-element Vector{Float64}:; 0.25; 0.25; 0.25; 0.25; 0.25; ```. To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; ```julia ; julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; 5-element Vector{Float64}:; 0.125; 0.25; 0.25; 0.25; 0.125; ```; since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". I looked for ways to do this in that are already in the code but couldn't find anything. I wanted to ask before I started coding something from scratch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1182527618
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722:152,Energy Efficiency,sustainab,sustainable,152,"More generally though, we do need to design a function-based user interface for extracting grid metrics from any grid. This does not exist and it's not sustainable to access grid properties directly by writing things like `grid.Δzᵃᵃᶠ`. This method will also produce incorrect results for immersed boundaries that modify grid metrics, such as `PartialCellBottom` and a hypothetical cut-cell implemenation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722:66,Integrability,interface,interface,66,"More generally though, we do need to design a function-based user interface for extracting grid metrics from any grid. This does not exist and it's not sustainable to access grid properties directly by writing things like `grid.Δzᵃᵃᶠ`. This method will also produce incorrect results for immersed boundaries that modify grid metrics, such as `PartialCellBottom` and a hypothetical cut-cell implemenation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722:167,Security,access,access,167,"More generally though, we do need to design a function-based user interface for extracting grid metrics from any grid. This does not exist and it's not sustainable to access grid properties directly by writing things like `grid.Δzᵃᵃᶠ`. This method will also produce incorrect results for immersed boundaries that modify grid metrics, such as `PartialCellBottom` and a hypothetical cut-cell implemenation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1185954722
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516604529:87,Deployability,update,update,87,"Now that the spacing functions are in place, I'm going to start working on this. (I'll update the top post with the information below.). The goal here is to add grid metrics to NetCDF output. The are two main avenues to follow:. 1. We can follow Oceananigans nomenclature and conventions, which would make the output play more nicely with Oceananigans itself (and more generally in the Julia environment).; 2. We can follow standard community conventions, which would mean the output won't follow Oceananigans naming etc., but it would optimize its readability by other software. I think we should follow option 2, since if a user wants to work with the output in Oceananigans/Julia, then using JLD2 output is probably the right choice anyway. Given that most people in the community use Python, `xarray` and `xgcm` to analyze model output, I think we should optimize the output to work with that ecosystem out of the box. Based on the discussion in https://github.com/CliMA/Oceananigans.jl/issues/1334, it seems the preferred conventions to use are the [SGRID conventions](https://sgrid.github.io/sgrid/). For the more technical aspects, I'm planning on starting with `RectilinearGrids` and `LatLonGrids` in this PR since these are more straightforward. And then we can expand from there. I also think this should be presented to the user as an opt-in flag in `NetCDFWriter` constructor, as opposed to being included in every NetCDF output by default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516604529
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516604529:536,Performance,optimiz,optimize,536,"Now that the spacing functions are in place, I'm going to start working on this. (I'll update the top post with the information below.). The goal here is to add grid metrics to NetCDF output. The are two main avenues to follow:. 1. We can follow Oceananigans nomenclature and conventions, which would make the output play more nicely with Oceananigans itself (and more generally in the Julia environment).; 2. We can follow standard community conventions, which would mean the output won't follow Oceananigans naming etc., but it would optimize its readability by other software. I think we should follow option 2, since if a user wants to work with the output in Oceananigans/Julia, then using JLD2 output is probably the right choice anyway. Given that most people in the community use Python, `xarray` and `xgcm` to analyze model output, I think we should optimize the output to work with that ecosystem out of the box. Based on the discussion in https://github.com/CliMA/Oceananigans.jl/issues/1334, it seems the preferred conventions to use are the [SGRID conventions](https://sgrid.github.io/sgrid/). For the more technical aspects, I'm planning on starting with `RectilinearGrids` and `LatLonGrids` in this PR since these are more straightforward. And then we can expand from there. I also think this should be presented to the user as an opt-in flag in `NetCDFWriter` constructor, as opposed to being included in every NetCDF output by default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516604529
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516604529:859,Performance,optimiz,optimize,859,"Now that the spacing functions are in place, I'm going to start working on this. (I'll update the top post with the information below.). The goal here is to add grid metrics to NetCDF output. The are two main avenues to follow:. 1. We can follow Oceananigans nomenclature and conventions, which would make the output play more nicely with Oceananigans itself (and more generally in the Julia environment).; 2. We can follow standard community conventions, which would mean the output won't follow Oceananigans naming etc., but it would optimize its readability by other software. I think we should follow option 2, since if a user wants to work with the output in Oceananigans/Julia, then using JLD2 output is probably the right choice anyway. Given that most people in the community use Python, `xarray` and `xgcm` to analyze model output, I think we should optimize the output to work with that ecosystem out of the box. Based on the discussion in https://github.com/CliMA/Oceananigans.jl/issues/1334, it seems the preferred conventions to use are the [SGRID conventions](https://sgrid.github.io/sgrid/). For the more technical aspects, I'm planning on starting with `RectilinearGrids` and `LatLonGrids` in this PR since these are more straightforward. And then we can expand from there. I also think this should be presented to the user as an opt-in flag in `NetCDFWriter` constructor, as opposed to being included in every NetCDF output by default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516604529
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:296,Integrability,depend,depends,296,"> Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is sim",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:1066,Modifiability,variab,variably,1066,"cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_nod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:1998,Usability,simpl,simple,1998," > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_node`. If `true`, divide the metric by 2, otherwise, return the metric unchanged. However, as noted above, I'm not sure this is what you want. Perhaps there is a purpose to the convention that divides the cell sizes on the boundary by 2. However, I'm worried this could be misleading regarding how the staggered finite volume grid and its diagnostics are interpreted. Another concern is that modifying metrics prior to output will lead to difficulties in reproducible diagnostics in the future between xgcm computations and native Oceanangians computations. So in this case I hope we can keep things simple and simply save whatever `xspacings`, etc outputs, if possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:2677,Usability,simpl,simple,2677," > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_node`. If `true`, divide the metric by 2, otherwise, return the metric unchanged. However, as noted above, I'm not sure this is what you want. Perhaps there is a purpose to the convention that divides the cell sizes on the boundary by 2. However, I'm worried this could be misleading regarding how the staggered finite volume grid and its diagnostics are interpreted. Another concern is that modifying metrics prior to output will lead to difficulties in reproducible diagnostics in the future between xgcm computations and native Oceanangians computations. So in this case I hope we can keep things simple and simply save whatever `xspacings`, etc outputs, if possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561
https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:2688,Usability,simpl,simply,2688," > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_node`. If `true`, divide the metric by 2, otherwise, return the metric unchanged. However, as noted above, I'm not sure this is what you want. Perhaps there is a purpose to the convention that divides the cell sizes on the boundary by 2. However, I'm worried this could be misleading regarding how the staggered finite volume grid and its diagnostics are interpreted. Another concern is that modifying metrics prior to output will lead to difficulties in reproducible diagnostics in the future between xgcm computations and native Oceanangians computations. So in this case I hope we can keep things simple and simply save whatever `xspacings`, etc outputs, if possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561
https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236200350:42,Security,validat,validation,42,@elise-palethorpe also perhaps change the validation script name as @glwagner suggest?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236200350
https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213039:44,Security,validat,validation,44,> @elise-palethorpe also perhaps change the validation script name as @glwagner suggest?. Do we need the file at all? Can I just include mg preconditioner in `doubly_bounded_poisson.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213039
https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213216:46,Security,validat,validation,46,"> > @elise-palethorpe also perhaps change the validation script name as @glwagner suggest?; > ; > Do we need the file at all? Can I just include mg preconditioner in `doubly_bounded_poisson.jl`. Yes, do that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236213216
https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236224861:45,Testability,test,tests,45,"@elise-palethorpe, I added some proper bench tests in `doubly_bounded_poisson.jl`. Seems like the PCG `solve!` has many allocations! I don't know why... @glwagner, @simone-silvestri?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1236224861
https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1237088551:56,Availability,mask,masking,56,"Also, maybe we want to have a `dot` product that allows masking immersed regions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1237088551
https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1237533405:40,Security,validat,validation,40,"Some benches. ```Julia; julia> include(""validation/elliptic_solvers/doubly_bounded_poisson.jl""). julia> include(""doubly_bounded_poisson.jl""); [ Info: Solving the Poisson equation with an FFT-based solver...; 123.083 μs (93 allocations: 17.56 KiB); [ Info: Solving the Poisson equation with a conjugate gradient iterative solver...; 64.748 ms (80482 allocations: 25.93 MiB); [ Info: Solving the Poisson equation with the Algebraic Multigrid solver...; 9.491 ms (498 allocations: 8.46 MiB); [ Info: Solving the Poisson equation with a conjugate gradient preconditioned iterative solver w/ AMG as preconditioner...; 47.891 ms (12771 allocations: 111.97 MiB); ```. (The above are results with `@btime`... It's pretty obvious than PCG brings allocations to the roof...). ![doubly_bounded_poisson](https://user-images.githubusercontent.com/7112768/188521946-143e1b9a-935d-4703-8582-ff5d826b9f3a.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2654#issuecomment-1237533405
https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:246,Availability,error,error,246,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632
https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:341,Energy Efficiency,Adapt,Adapting,341,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632
https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:341,Modifiability,Adapt,Adapting,341,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632
https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:58,Performance,perform,performing,58,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632
https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185486066:155,Availability,down,down,155,"because we have to taper _inside_ the `R` terms, if we just taper outside it will not have the intended effect. This is because `bz` is very small (can go down to 1e-20) so calculating the slope is quite a delicate operation. In a realistic simulation (as this one) it can well be (and it happens) that bz changes of 4-5 orders of magnitude between face and centers. Especially because our horizontal mesh is very coarse. This means that the taper factor (which is always calculated at centers) does not ""see"" the actual slope that you calculate in the rotation tensor, leaving you with R factors of the order of 1e10. In this way, if you taper locally, you ensure that all elements of the tensor are tapered properly",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185486066
https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185491600:34,Availability,redundant,redundant,34,So is `taper_factor_ccc` function redundant now? Seems like it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185491600
https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185491600:34,Safety,redund,redundant,34,So is `taper_factor_ccc` function redundant now? Seems like it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185491600
https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185500762:267,Energy Efficiency,efficient,efficient,267,"> yeah, we could define `taper_factor_fcc`, `taper_factor_cfc` and `taper_factor_ccf` to have it more clean. I think If we do that and call them inside the `isopycnal_rotation_tensor_...` functions that would imply computing the slopes twice. What you did seems more efficient. I'll just add a remark in the docstring for how the tapering is done.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185500762
https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185957960:13,Usability,simpl,simply,13,"Perhaps this simply means that we should keep the name `taper_factor_ccc`, but redefine its implementation to be more stable along the lines you're suggesting?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1185957960
https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1190733412:11,Testability,test,tests,11,Merge when tests pass?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1190733412
https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1191619763:153,Testability,test,tested,153,"I ll go ahead and merge this, in the end this PR calculates the tapering factor as the minimum of the tapering at `fcc`, `cfc` and `ccf`. Haven't really tested for stability but I guess @sandreza will run 1 degree simulations which will give us an answer. If this method is less stable we can always revert to calculating the tapering _inside_ the tensor although that gives us a flux which is not formally adiabatic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2664#issuecomment-1191619763
https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326:37,Integrability,interface,interface,37,"It seems we have designed the solver interface (ie, the function signature to `precondition!`) to include the guess / solution at the current iteration. This does seem useful for some preconditioners, right? Eg, if the preconditioner is an asymptotic solution that depends on the current guess, this may be useful. I think. It's not necessary for the _specific_ case of the diagnoally dominant preconditioner though -- I agree with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326
https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326:265,Integrability,depend,depends,265,"It seems we have designed the solver interface (ie, the function signature to `precondition!`) to include the guess / solution at the current iteration. This does seem useful for some preconditioners, right? Eg, if the preconditioner is an asymptotic solution that depends on the current guess, this may be useful. I think. It's not necessary for the _specific_ case of the diagnoally dominant preconditioner though -- I agree with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2668#issuecomment-1185945326
https://github.com/CliMA/Oceananigans.jl/issues/2676#issuecomment-1192880737:47,Testability,test,test,47,"we can take out that function, we just have to test multiGPU and that part should have already been taken care of in KernelAbstraction.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2676#issuecomment-1192880737
https://github.com/CliMA/Oceananigans.jl/pull/2679#issuecomment-1194198127:49,Availability,mainten,maintenance,49,> Thanks!. Thank you all for the development and maintenance of this wonderful Julia package!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2679#issuecomment-1194198127
https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1194591286:18,Testability,test,test,18,Nice!. Is there a test we could add that might catch this bug?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1194591286
https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1195305243:276,Testability,test,tests,276,"Now I've looked harder I've realized that this issue is only for bounded domains so my original fix is incorrect for periodic domains since they are [xmin, xmax) not [xmin, xmax] like bounded domains. Fixed this now. I've changed the position of the particles in the existing tests so that they should be affected by the change if that works? For the x I put it on the edge so it gets advected out (and will have been looped round even without the fix), y near the boundary but should not get looped round, and for the z I've put it near the boundary where previously it will have been moved but should not have been.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1195305243
https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1198101796:51,Testability,test,tests,51,@jagoosw do you mind if I commit to try to fix the tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1198101796
https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1198106346:53,Testability,test,tests,53,> @jagoosw do you mind if I commit to try to fix the tests?. Not at all! They were working before but something must have changed. Thanks!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1198106346
https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1198259328:50,Testability,test,tests,50,"@jagoosw it seems like everything is ok! When the tests pass I ll merge, good job",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2682#issuecomment-1198259328
https://github.com/CliMA/Oceananigans.jl/issues/2684#issuecomment-1198677572:58,Testability,test,tests,58,Future work on the particles module is also to write some tests for immersed boundary particle tracking,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2684#issuecomment-1198677572
https://github.com/CliMA/Oceananigans.jl/pull/2687#issuecomment-1198673154:46,Testability,test,tests,46,Probably in a next PR we will want a bit more tests for Particle tracking on Immersed Boundary grids,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2687#issuecomment-1198673154
https://github.com/CliMA/Oceananigans.jl/pull/2687#issuecomment-1198703652:5,Deployability,patch,patch,5,Bump patch version before merging so that we can tag a release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2687#issuecomment-1198703652
https://github.com/CliMA/Oceananigans.jl/pull/2687#issuecomment-1198703652:55,Deployability,release,release,55,Bump patch version before merging so that we can tag a release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2687#issuecomment-1198703652
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1214292113:126,Testability,test,test,126,"@elise-palethorpe, we need to modify:. https://github.com/CliMA/Oceananigans.jl/blob/5644b347a540fa64897e3db587c39bc9a87de5ed/test/test_implicit_free_surface_solver.jl#L97",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1214292113
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1613,Availability,ERROR,ERROR,1613,"cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1865,Availability,ERROR,ERROR,1865,"elAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:418,Deployability,release,release,418,"@elise-palethorpe, I don't see the AMGX package in `Project.toml` nor in `Manifest.toml`. Btw, when I tried to add it locally on my Mac I got this:. ```Julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (Oceananigans) pkg> st; Project Oceananigans v0.77.1; Status `~/Research/OC.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:564,Energy Efficiency,Adapt,Adapt,564,"@elise-palethorpe, I don't see the AMGX package in `Project.toml` nor in `Manifest.toml`. Btw, when I tried to add it locally on my Mac I got this:. ```Julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (Oceananigans) pkg> st; Project Oceananigans v0.77.1; Status `~/Research/OC.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1535,Integrability,depend,dependencies,1535," Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Res",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1643,Integrability,depend,dependency,1643,"cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:564,Modifiability,Adapt,Adapt,564,"@elise-palethorpe, I don't see the AMGX package in `Project.toml` nor in `Manifest.toml`. Btw, when I tried to add it locally on my Mac I got this:. ```Julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (Oceananigans) pkg> st; Project Oceananigans v0.77.1; Status `~/Research/OC.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1872,Performance,Load,LoadError,1872,"elAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1883,Performance,Load,LoadError,1883,"elAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1894,Performance,Load,LoadError,1894,"elAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2153,Performance,load,loading,2153,"ns v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2252,Performance,load,loading,2252,"o v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2308,Performance,load,loading,2308," [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2368,Performance,load,loading,2368,"g; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @ none:1; during initialization of module AMGX; in expression",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2433,Performance,load,loading,2433," [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @ none:1; during initialization of module AMGX; in expression starting at /Users/navid/Research/OC.jl/src/Solvers/multigrid_so",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:3146,Performance,load,loading,3146,"g 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @ none:1; during initialization of module AMGX; in expression starting at /Users/navid/Research/OC.jl/src/Solvers/multigrid_solver.jl:5; in expression starting at /Users/navid/Research/OC.jl/src/Solvers/Solvers.jl:1; in expression starting at /Users/navid/Research/OC.jl/src/Oceananigans.jl:1; ```. Was it smooth for you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:1349,Testability,Log,Logging,1349,"); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (Oceananigans) pkg> st; Project Oceananigans v0.77.1; Status `~/Research/OC.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1223407174:14,Testability,test,tests,14,The MG solver tests fail on the curvilinear grid.; https://buildkite.com/clima/oceananigans/builds/8380#0182bd4a-b305-42af-9390-a05e5b039826. I'm wondering whether it's because the grid spacing is not uniform...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1223407174
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1237494366:33,Availability,error,error,33,"@elise-palethorpe, look at [this error](https://buildkite.com/clima/oceananigans/builds/8479#01830c59-efb2-4373-89f9-4679bbb38cfd/36-801). I think it's something related with AMGX not being finalized...?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1237494366
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241308749:200,Performance,load,load,200,"@glwagner [AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling `using AMGX` will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241308749
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241375321:5,Testability,benchmark,benchmarks,5,"Some benchmarks from running `implicit_surface_solvers_benchmark.jl` . On GPU: ; FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) ; PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time); Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time); MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time); PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time). On CPU:; FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time); PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time); Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time); MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time); PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241375321
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241429332:8,Modifiability,variab,variables,8,"We have variables `∇²eᵢⱼₖ` implying that `∇²` acts on `eᵢⱼₖ`. But that's not always the case, right?. Let's change all `∇²eᵢⱼₖ` -> `Aeᵢⱼₖ`? And add a small remark, e.g.,. ```Julia; eᵢⱼₖ = similar(template_field) # the basis vector; Aeᵢⱼₖ = similar(template_field) # A * eᵢⱼₖ; ```. I think everything should be here:; https://github.com/CliMA/Oceananigans.jl/blob/639d337b4449c7aa846b1005ce5109ba590ff786/src/Solvers/multigrid_solver.jl#L192-L233",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241429332
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577:1215,Deployability,integrat,integrated,1215,"> Some benchmarks from running `implicit_surface_solvers_benchmark.jl`; > ; > On GPU: FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time) Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time) MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time) PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time); > ; > On CPU: FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time) PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time) Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time) MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time) PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time). nice. A problem with having an iterative matrix solver algorithm (like the pcg) is going to high resolutions (or conversely large time steps). ; The matrix becomes poorly conditioned because the diagonal (which depends on `Δt²`) decreases faster than the off-diagonals (which depend on the integrated areas) and the number of iterations required to converge spike up.; This means that on a GPU both eddy-permitting and resolving simulations are dominated by the cost of the implicit solver.; Our default preconditioner (for the Heptadiagonal solver) also loses efficiency when increasing `Δt` (or increasing resolution) because it assumes that the matrix is diagonally dominant. This is a problem that the FFT solver does not have.; I would be very interesting to know if with a multigrid algorithm this problem is less severe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577:1136,Integrability,depend,depends,1136,"> Some benchmarks from running `implicit_surface_solvers_benchmark.jl`; > ; > On GPU: FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time) Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time) MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time) PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time); > ; > On CPU: FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time) PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time) Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time) MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time) PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time). nice. A problem with having an iterative matrix solver algorithm (like the pcg) is going to high resolutions (or conversely large time steps). ; The matrix becomes poorly conditioned because the diagonal (which depends on `Δt²`) decreases faster than the off-diagonals (which depend on the integrated areas) and the number of iterations required to converge spike up.; This means that on a GPU both eddy-permitting and resolving simulations are dominated by the cost of the implicit solver.; Our default preconditioner (for the Heptadiagonal solver) also loses efficiency when increasing `Δt` (or increasing resolution) because it assumes that the matrix is diagonally dominant. This is a problem that the FFT solver does not have.; I would be very interesting to know if with a multigrid algorithm this problem is less severe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577:1201,Integrability,depend,depend,1201,"> Some benchmarks from running `implicit_surface_solvers_benchmark.jl`; > ; > On GPU: FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time) Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time) MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time) PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time); > ; > On CPU: FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time) PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time) Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time) MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time) PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time). nice. A problem with having an iterative matrix solver algorithm (like the pcg) is going to high resolutions (or conversely large time steps). ; The matrix becomes poorly conditioned because the diagonal (which depends on `Δt²`) decreases faster than the off-diagonals (which depend on the integrated areas) and the number of iterations required to converge spike up.; This means that on a GPU both eddy-permitting and resolving simulations are dominated by the cost of the implicit solver.; Our default preconditioner (for the Heptadiagonal solver) also loses efficiency when increasing `Δt` (or increasing resolution) because it assumes that the matrix is diagonally dominant. This is a problem that the FFT solver does not have.; I would be very interesting to know if with a multigrid algorithm this problem is less severe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577:1215,Integrability,integrat,integrated,1215,"> Some benchmarks from running `implicit_surface_solvers_benchmark.jl`; > ; > On GPU: FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time) Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time) MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time) PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time); > ; > On CPU: FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time) PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time) Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time) MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time) PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time). nice. A problem with having an iterative matrix solver algorithm (like the pcg) is going to high resolutions (or conversely large time steps). ; The matrix becomes poorly conditioned because the diagonal (which depends on `Δt²`) decreases faster than the off-diagonals (which depend on the integrated areas) and the number of iterations required to converge spike up.; This means that on a GPU both eddy-permitting and resolving simulations are dominated by the cost of the implicit solver.; Our default preconditioner (for the Heptadiagonal solver) also loses efficiency when increasing `Δt` (or increasing resolution) because it assumes that the matrix is diagonally dominant. This is a problem that the FFT solver does not have.; I would be very interesting to know if with a multigrid algorithm this problem is less severe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577:7,Testability,benchmark,benchmarks,7,"> Some benchmarks from running `implicit_surface_solvers_benchmark.jl`; > ; > On GPU: FFT: 0.902434 seconds (1.58 M allocations: 549.219 MiB, 13.25% gc time) PCG: 37.329798 seconds (17.07 M allocations: 2.563 GiB, 1.85% gc time) Heptadiagonal: 4.323861 seconds (6.06 M allocations: 675.694 MiB, 4.72% gc time, 1.32% compilation time) MG: 4.495123 seconds (1.50 M allocations: 492.900 MiB, 2.16% gc time) PCG with FFT preconditioner: 22.673894 seconds (3.53 M allocations: 864.587 MiB, 0.77% gc time); > ; > On CPU: FFT: 6.548544 seconds (3.61 M allocations: 1.910 GiB, 14.07% gc time, 1.30% compilation time) PCG: 32.354310 seconds (20.29 M allocations: 7.041 GiB, 5.80% gc time) Heptadiagonal: 9.795938 seconds (3.51 M allocations: 1.595 GiB, 39.13% gc time) MG: 11.868795 seconds (3.85 M allocations: 3.991 GiB, 43.10% gc time) PCG with FFT preconditioner: 10.473279 seconds (5.38 M allocations: 2.654 GiB, 9.37% gc time). nice. A problem with having an iterative matrix solver algorithm (like the pcg) is going to high resolutions (or conversely large time steps). ; The matrix becomes poorly conditioned because the diagonal (which depends on `Δt²`) decreases faster than the off-diagonals (which depend on the integrated areas) and the number of iterations required to converge spike up.; This means that on a GPU both eddy-permitting and resolving simulations are dominated by the cost of the implicit solver.; Our default preconditioner (for the Heptadiagonal solver) also loses efficiency when increasing `Δt` (or increasing resolution) because it assumes that the matrix is diagonally dominant. This is a problem that the FFT solver does not have.; I would be very interesting to know if with a multigrid algorithm this problem is less severe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241929577
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241930690:12,Security,validat,validation,12,can we put `validation/implicit_free_surface/implicit_surface_solvers_benchmark.jl` in the benchmark folder?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241930690
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241930690:91,Testability,benchmark,benchmark,91,can we put `validation/implicit_free_surface/implicit_surface_solvers_benchmark.jl` in the benchmark folder?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241930690
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242544194:190,Performance,load,load,190,"> [AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling using AMGX will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?. @simone-silvestri any ideas for how to solve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242544194
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242599636:55,Security,validat,validation,55,@simone-silvestri you can run the GPU profiler on the `validation/elliptic_solvers/doubly_bounded_poisson.jl` on this branch. You can set `arch = GPU()` and it should work.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242599636
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242840455:20,Testability,benchmark,benchmarking,20,I'm not sure if I'm benchmarking correctly on the GPU. I used `@benchmark CUDA.@sync function_to_bench()`. Running the `doubly_bounded_poisson.jl` script with `N = 64` on tartarus gave me:. ### On CPU. ![solvers_benchmark_CPU](https://user-images.githubusercontent.com/7112768/189507791-e658161f-6826-4755-aa53-39d4caf93701.png). ### On GPU. ![solvers_benchmark_GPU](https://user-images.githubusercontent.com/7112768/189507968-bb71dacc-06b6-498e-8b8d-a29017fc88f3.png),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242840455
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242840455:64,Testability,benchmark,benchmark,64,I'm not sure if I'm benchmarking correctly on the GPU. I used `@benchmark CUDA.@sync function_to_bench()`. Running the `doubly_bounded_poisson.jl` script with `N = 64` on tartarus gave me:. ### On CPU. ![solvers_benchmark_CPU](https://user-images.githubusercontent.com/7112768/189507791-e658161f-6826-4755-aa53-39d4caf93701.png). ### On GPU. ![solvers_benchmark_GPU](https://user-images.githubusercontent.com/7112768/189507968-bb71dacc-06b6-498e-8b8d-a29017fc88f3.png),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242840455
https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1244923054:189,Performance,load,load,189,">[AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling using AMGX will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?. We may be able to optionally call `using AMGX` + all the `AMGX`-related functionality by using:. [`@static` + `islinux()`]( https://docs.julialang.org/en/v1/manual/handling-operating-system-variation/) + [`CUDA.has_cuda_gpu()`](https://cuda.juliagpu.org/stable/api/essentials/#CUDA.has_cuda_gpu)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1244923054
https://github.com/CliMA/Oceananigans.jl/issues/2690#issuecomment-1204110800:166,Testability,log,logic,166,"Also if we are following syntax for `Forcing` and `BoundaryConditions`, we may want to use the ordering `i, j, k, grid, clock, fields, location`, which preserves the logic: . 1. position (i, j, k, grid); 2. time (clock, iteration, time); 3. fields; 4. ""everything else""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690#issuecomment-1204110800
https://github.com/CliMA/Oceananigans.jl/issues/2690#issuecomment-1480019689:36,Security,validat,validation,36,I think we should just remove these validation experiments since we have ClimaOcean now...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2690#issuecomment-1480019689
https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216053598:26,Testability,test,tests,26,@navidcy Any idea why the tests are stuck?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216053598
https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216054364:15,Energy Efficiency,power,power,15,There was some power interruption at MIT. Now it's fixed but probably someone has to go turn on Sverdrup (where the GPU tests run on).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216054364
https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216054364:120,Testability,test,tests,120,There was some power interruption at MIT. Now it's fixed but probably someone has to go turn on Sverdrup (where the GPU tests run on).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2694#issuecomment-1216054364
https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1221624853:160,Availability,fault,fault,160,Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6. ```; /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; --;   | 🚨 Error: The command exited with status 139;   | user command error: exit status 139; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1221624853
https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1221624853:280,Availability,Error,Error,280,Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6. ```; /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; --;   | 🚨 Error: The command exited with status 139;   | user command error: exit status 139; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1221624853
https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1221624853:340,Availability,error,error,340,Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6. ```; /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; --;   | 🚨 Error: The command exited with status 139;   | user command error: exit status 139; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1221624853
https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434:170,Availability,fault,fault,170,> Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6; > ; > ```; > /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; > --; >   | 🚨 Error: The command exited with status 139; >   | user command error: exit status 139; > ```. No idea. Can you reproduce the error locally?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434
https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434:294,Availability,Error,Error,294,> Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6; > ; > ```; > /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; > --; >   | 🚨 Error: The command exited with status 139; >   | user command error: exit status 139; > ```. No idea. Can you reproduce the error locally?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434
https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434:356,Availability,error,error,356,> Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6; > ; > ```; > /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; > --; >   | 🚨 Error: The command exited with status 139; >   | user command error: exit status 139; > ```. No idea. Can you reproduce the error locally?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434
https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434:418,Availability,error,error,418,> Any idea why docs fails? https://buildkite.com/clima/oceananigans/builds/8381#0182beb4-dc53-4ca9-9d6c-76d43f05f6b6; > ; > ```; > /bin/bash: line 2: 815367 Segmentation fault (core dumped) /storage5/buildkite-agent/julia-1.6.7/bin/julia --color=yes --project=docs/ docs/make.jl; > --; >   | 🚨 Error: The command exited with status 139; >   | user command error: exit status 139; > ```. No idea. Can you reproduce the error locally?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1222426434
https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1230430646:6,Testability,Test,Tests,6,Nice! Tests are passing :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2695#issuecomment-1230430646
https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235829416:7,Usability,undo,undo,7,We can undo this. Didn't know.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235829416
https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235869936:14,Usability,undo,undoing,14,Def not worth undoing!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2699#issuecomment-1235869936
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1219154617:51,Deployability,update,update,51,"Apologies, currently using `v0.76.1`. I can try to update if you think that could solve it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1219154617
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:427,Availability,error,error,427,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:567,Energy Efficiency,reduce,reduce,567,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:775,Energy Efficiency,reduce,reduce-gpu-params,775,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:906,Integrability,depend,depend,906,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685:1121,Integrability,depend,depend,1121,"> I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?. Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg. ```; ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; ```. > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though. As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223405685
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:463,Availability,error,error,463,"> > I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:623,Energy Efficiency,reduce,reduce,623,"> > I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:831,Energy Efficiency,reduce,reduce-gpu-params,831,"> > I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:1960,Energy Efficiency,reduce,reduce,1960,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:962,Integrability,depend,depend,962,"> > I can have a go at overhauling the tracer_tendency function etc. based on https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841 suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:1192,Integrability,depend,depend,1192,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:1811,Integrability,depend,dependent,1811,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457:2033,Integrability,depend,depend,2033,"suggestion and https://github.com/CliMA/Oceananigans.jl/issues/722 but am not sure if its necessarily the best/nicest solution?; > ; > ; > ; > Why are we overhauling the tracer tendency function? The problem appears to be in `calculate_Gu`, right? Eg; > ; > ; > ; > ```; > ; > ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__ ...; > ; > ```; > ; > ; > ; > > I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the tracer_tendency function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed.; > ; > ; > ; > It's just that we support user specification of velocity forcing functions that depend on any of the tracer fields. We could discontinue support for this though.; > ; > ; > ; > As for passing T, S --- just to clarify, you mean to pass any tracers that are involved in the calculation of the buoyancy perturbation? (This could be buoyancy `b`, only `T`, only `S`, or no tracer fields at all.). Sorry I'm away from the computer with a GPU at the moment so can't check, but I think the reason I thought it would require changes to the tracer_tendency function is because it seems relatively straightforward to fix the issue with the velocity tendency functions (I hadn't realised you could have tracer dependent velocity forcing too so that may make it less straightforward), but then when I'd changed that a bit I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. And yeah sorry for the lack of clarity, I meant pass as required for buoyancy b/T/S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223763457
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:571,Availability,error,error,571,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:577,Availability,down,down,577,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:837,Availability,error,error,837,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:387,Energy Efficiency,reduce,reduce,387,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:460,Integrability,depend,depend,460,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:728,Integrability,depend,depend,728,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:1136,Modifiability,extend,extend,1136,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:1239,Safety,avoid,avoid,1239,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878:669,Usability,clear,clearly,669,"> Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. We already do ""unwrap"" data from fields on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/ea6826fd2ffaed3f0df330cc952667ec878deb6a/src/Fields/field.jl#L368. > I realised it would be much harder to reduce the parameter size of the tracer tendency function if the tracers depend on lots of other tracers. Okay, this makes sense. Solving the problem for `calculate_Gu` just bumps the error down to `calculate_tracer_tendency`, and the issue isn't tractable in that case, since it's clearly important to support tracer forcing functions that depend on other tracers (eg for biogeochemical models). Can you provide a minimum script that reproduces the error? I do think many tracers is an important use case so solving this could warrant reducing the kinds of forcing functions we support --- if that's necessary. I think there also may be solutions that don't change what we support while still solving this problem; eg we provide some features that extend model capabilities specifically for the case of large numbers of tracers. For example, we could avoid passing the tracers explicitly into the kernels. Instead, we can attach references _only_ to the relevant / used fields directly in `Forcing` (we'd have to change the user API to `DiscreteForcing` to support this, but the changes need not be major). This way one might be able to support systems of reacting tracers, as well as many ""additional"" passive tracers that are not involved in a forcing function. Or, we can explore https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1223989878
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1236299727:143,Modifiability,variab,variables,143,"Sorry for the slow replies, I am currently away. I will put together a MWE when I am back. More out of interest, is there a benefit to passing variables explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1236299727
https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1238525107:54,Modifiability,variab,variables,54,"> More out of interest, is there a benefit to passing variables explicitly?. Is this question about CUDA.jl behavior? I'm afraid I don't know, but this comment might help:. https://github.com/CliMA/Oceananigans.jl/pull/746#issuecomment-653428852. It could be worth asking on #gpu slack, or on https://github.com/JuliaGPU/CUDA.jl/issues/267.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1238525107
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568:459,Performance,perform,performance,459,"Average reduction with conditional expressions, e.g., like. https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107. induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,. ```Julia; @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); ```. Only mentioning this here in case it might something in the source code that could be affecting code performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568:147,Testability,test,test,147,"Average reduction with conditional expressions, e.g., like. https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107. induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,. ```Julia; @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); ```. Only mentioning this here in case it might something in the source code that could be affecting code performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:110,Availability,Error,Error,110,"`regrid!` fails on the GPU. ```Julia; [2022/08/20 09:49:21.564] INFO Testing field regridding...; Regridding: Error During Test at /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:382; Got exception outside of a @test; InvalidIRError: compiling kernel #gpu__regrid!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to length); Stacktrace:; [1] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:66; [2] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:70; [3] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:86; [4] gpu__regrid!; @ /g/data/v45/nc3020/.julia/packages/KernelAbstractions/1ZLga/src/macros.jl:80; [5] gpu__regrid!; @ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:10915,Integrability,depend,dependencies,10915,"nelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, typeof(Oceananigans.Fields.gpu__regrid!)})(::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; ndrange::Nothing, dependencies::Nothing, workgroupsize::Nothing, progress::Function); @ CUDAKernels /g/data/v45/nc3020/.julia/packages/CUDAKernels/YWLqR/src/CUDAKernels.jl:273; [15] launch!(::GPU, ::RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Fields._regrid!), ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:12303,Integrability,depend,dependencies,12303,"cision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Symbol, ::typeof(Oceananigans.Fields._regrid!), ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; dependencies::Nothing, include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils /g/data/v45/nc3020/Oceananigans.jl/src/Utils/kernel_launching.jl:95; [16] launch!; @ /g/data/v45/nc3020/Oceananigans.jl/src/Utils/kernel_launching.jl:79 [inlined]; [17] regrid!(a::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:6644,Performance,cache,cache,6644,", Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}}); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/cache.jl:90; [11] cufunction(f::typeof(Oceananigans.Fields.gpu__regrid!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRange",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:6853,Performance,cache,cache,6853,"ngeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}}); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/cache.jl:90; [11] cufunction(f::typeof(Oceananigans.Fields.gpu__regrid!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:4132,Security,validat,validation,4132,"eviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/validation.jl:141; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:418 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.Fields.gpu__reg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:4545,Security,validat,validate,4545,"Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/validation.jl:141; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:418 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/utils.jl:64; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(Oceananigans.Fields.gpu__regrid!), Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:69,Testability,Test,Testing,69,"`regrid!` fails on the GPU. ```Julia; [2022/08/20 09:49:21.564] INFO Testing field regridding...; Regridding: Error During Test at /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:382; Got exception outside of a @test; InvalidIRError: compiling kernel #gpu__regrid!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to length); Stacktrace:; [1] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:66; [2] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:70; [3] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:86; [4] gpu__regrid!; @ /g/data/v45/nc3020/.julia/packages/KernelAbstractions/1ZLga/src/macros.jl:80; [5] gpu__regrid!; @ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:123,Testability,Test,Test,123,"`regrid!` fails on the GPU. ```Julia; [2022/08/20 09:49:21.564] INFO Testing field regridding...; Regridding: Error During Test at /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:382; Got exception outside of a @test; InvalidIRError: compiling kernel #gpu__regrid!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to length); Stacktrace:; [1] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:66; [2] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:70; [3] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:86; [4] gpu__regrid!; @ /g/data/v45/nc3020/.julia/packages/KernelAbstractions/1ZLga/src/macros.jl:80; [5] gpu__regrid!; @ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:166,Testability,test,test,166,"`regrid!` fails on the GPU. ```Julia; [2022/08/20 09:49:21.564] INFO Testing field regridding...; Regridding: Error During Test at /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:382; Got exception outside of a @test; InvalidIRError: compiling kernel #gpu__regrid!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to length); Stacktrace:; [1] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:66; [2] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:70; [3] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:86; [4] gpu__regrid!; @ /g/data/v45/nc3020/.julia/packages/KernelAbstractions/1ZLga/src/macros.jl:80; [5] gpu__regrid!; @ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:218,Testability,test,test,218,"`regrid!` fails on the GPU. ```Julia; [2022/08/20 09:49:21.564] INFO Testing field regridding...; Regridding: Error During Test at /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:382; Got exception outside of a @test; InvalidIRError: compiling kernel #gpu__regrid!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to length); Stacktrace:; [1] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:66; [2] size; @ /g/data/v45/nc3020/Oceananigans.jl/src/Grids/grid_utils.jl:70; [3] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:86; [4] gpu__regrid!; @ /g/data/v45/nc3020/.julia/packages/KernelAbstractions/1ZLga/src/macros.jl:80; [5] gpu__regrid!; @ ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:16826,Testability,test,test,16826,"ieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, b::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:48; [19] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:422 [inlined]; [20] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [21] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:383 [inlined]; [22] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [23] top-level scope; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:164; [24] include(fname::String); @ Base.MainInclude ./client.jl:476; [25] top-level scope; @ REPL[51]:1; [26] top-level scope; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; [27] eval; @ ./boot.jl:368 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:151; [29] repl_backend_loop(backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:247; [30] start_repl_backend(backend::REPL.REPLBackend, c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:16941,Testability,Test,Test,16941,"{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:48; [19] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:422 [inlined]; [20] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [21] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:383 [inlined]; [22] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [23] top-level scope; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:164; [24] include(fname::String); @ Base.MainInclude ./client.jl:476; [25] top-level scope; @ REPL[51]:1; [26] top-level scope; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; [27] eval; @ ./boot.jl:368 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:151; [29] repl_backend_loop(backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:247; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:232; [31] run_repl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:16950,Testability,Test,Test,16950,"{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:48; [19] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:422 [inlined]; [20] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [21] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:383 [inlined]; [22] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [23] top-level scope; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:164; [24] include(fname::String); @ Base.MainInclude ./client.jl:476; [25] top-level scope; @ REPL[51]:1; [26] top-level scope; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; [27] eval; @ ./boot.jl:368 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:151; [29] repl_backend_loop(backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:247; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:232; [31] run_repl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:17033,Testability,test,test,17033,"UDA.Mem.DeviceBuffer}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:48; [19] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:422 [inlined]; [20] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [21] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:383 [inlined]; [22] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [23] top-level scope; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:164; [24] include(fname::String); @ Base.MainInclude ./client.jl:476; [25] top-level scope; @ REPL[51]:1; [26] top-level scope; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; [27] eval; @ ./boot.jl:368 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:151; [29] repl_backend_loop(backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:247; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:232; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool); @ REPL /g/data/v45/n",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:17148,Testability,Test,Test,17148,"tepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:48; [19] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:422 [inlined]; [20] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [21] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:383 [inlined]; [22] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [23] top-level scope; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:164; [24] include(fname::String); @ Base.MainInclude ./client.jl:476; [25] top-level scope; @ REPL[51]:1; [26] top-level scope; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; [27] eval; @ ./boot.jl:368 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:151; [29] repl_backend_loop(backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:247; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:232; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:369; [32] run_repl(repl::REPL.AbstractREPL, consumer:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:17157,Testability,Test,Test,17157,"tepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:48; [19] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:422 [inlined]; [20] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [21] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:383 [inlined]; [22] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [23] top-level scope; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:164; [24] include(fname::String); @ Base.MainInclude ./client.jl:476; [25] top-level scope; @ REPL[51]:1; [26] top-level scope; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; [27] eval; @ ./boot.jl:368 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:151; [29] repl_backend_loop(backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:247; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:232; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:369; [32] run_repl(repl::REPL.AbstractREPL, consumer:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:17240,Testability,test,test,17240,"setVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/regridding_fields.jl:48; [19] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:422 [inlined]; [20] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [21] macro expansion; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:383 [inlined]; [22] macro expansion; @ /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [23] top-level scope; @ /g/data/v45/nc3020/Oceananigans.jl/test/test_field.jl:164; [24] include(fname::String); @ Base.MainInclude ./client.jl:476; [25] top-level scope; @ REPL[51]:1; [26] top-level scope; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; [27] eval; @ ./boot.jl:368 [inlined]; [28] eval_user_input(ast::Any, backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:151; [29] repl_backend_loop(backend::REPL.REPLBackend); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:247; [30] start_repl_backend(backend::REPL.REPLBackend, consumer::Any); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:232; [31] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:369; [32] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /g/data/v45/nc3020/julia-1.8/usr/share/julia/stdlib/v1.8/REPL/src/REPL.jl:355; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912:489,Performance,perform,performance,489,"> Average reduction with conditional expressions, e.g., like; > ; > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > ; > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > ; > ```julia; > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > ```; > ; > Only mentioning this here in case it might something in the source code that could be affecting code performance. The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans. . We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; ```; condition = T > 3 # This should be a boolean AbstractOperation; @compute Txyz = Field(Average(T; condition)) ; ```. at the moment the best way to specify a condition is through a function; ```; @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; @compute Txyz = Field(Average(T; condition)) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912:155,Testability,test,test,155,"> Average reduction with conditional expressions, e.g., like; > ; > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > ; > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > ; > ```julia; > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > ```; > ; > Only mentioning this here in case it might something in the source code that could be affecting code performance. The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans. . We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; ```; condition = T > 3 # This should be a boolean AbstractOperation; @compute Txyz = Field(Average(T; condition)) ; ```. at the moment the best way to specify a condition is through a function; ```; @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; @compute Txyz = Field(Average(T; condition)) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1230000276:153,Availability,error,error,153,Can somebody have a look at ; https://buildkite.com/clima/oceananigans/builds/8443#0182e818-e897-4fda-ac01-56a95319fd1e/33-764. Seems like a GPU-related error with `fill_bottom_and_top_halo!`? Probably same issue as https://github.com/CliMA/Oceananigans.jl/issues/2709?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1230000276
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1230015146:49,Testability,test,tests,49,The other issue that keeps coming up in many GPU tests has to do with conditional averaging when we have immersed boundaries... https://buildkite.com/clima/oceananigans/builds/8443#0182e818-e8be-4719-bda6-acbd51410754/33-445,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1230015146
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239599513:86,Testability,test,tests,86,I think moving forward we should always try to remove as many `@allowscalar` from our tests as possible. We have far too many as is. We should always lean towards solving the underlying problem and eliminating scalar operations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239599513
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022:559,Performance,perform,performance,559,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. Agree with this. What is `T .> 3`? Is that a field? Either way, what we really want is to pass `T > 3` as @simone-silvestri says.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022:155,Testability,test,test,155,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. Agree with this. What is `T .> 3`? Is that a field? Either way, what we really want is to pass `T > 3` as @simone-silvestri says.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:1180,Availability,error,error,1180,"ons.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. I get an error... ```Julia; navidcy@tartarus:~/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.1 (2022-09-06); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 4 threads. julia> using Oceananigans.Fields: CenterField, @compute. julia> trilinear(x, y, z) = x + y + z; trilinear (generic function with 1 method). julia> arch = GPU(); GPU(). julia> grid = RectilinearGrid(arch, size = (2, 2, 2),; x = (0, 2), y = (0, 2), z = (0, 2),; topology = (Periodic, Periodic, Bounded)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 2.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 2.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [0.0, 2.0] regularly spaced with Δz=1.0. julia> T = CenterField(grid); 2×2×2 Field{Center, Center, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:3397,Availability,ERROR,ERROR,3397,"odic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 8×8×8 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:5, -2:5, -2:5) with eltype Float64 with indices -2:5×-2:5×-2:5; └── max=0.0, min=0.0, mean=0.0. julia> set!(T, trilinear); 2×2×2 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 8×8×8 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:5, -2:5, -2:5) with eltype Float64 with indices -2:5×-2:5×-2:5; └── max=4.5, min=1.5, mean=3.0. julia> @inline condition_greater_3(i, j, k, grid, f) = f[i, j, k] > 3; condition_greater_3 (generic function with 1 method). julia> @compute Txyz = Field(Average(T; condition = condition_greater_3)); ERROR: InvalidIRError: compiling kernel #partial_mapreduce_grid(typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:21984,Availability,mask,mask,21984,"ryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, typeof(condition_greater_3), Int64, Float64}; condition::Nothing, mask::Int64, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:init,), Tuple{Bool}}}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:588; [19] mean!(f::Function, r::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:26800,Availability,mask,mask,26800,"yCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, typeof(condition_greater_3), Int64, Float64}; condition::Nothing, mask::Int64); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:648; [20] mean!; @ ~/Oceananigans.jl/src/Fields/field.jl:647 [inlined]; [21] #mean!#67; @ ~/Oceananigans.jl/src/Fields/field.jl:655 [inlined]; [22] mean!; @ ~/Oceananigans.jl/src/Fields/field.jl:655 [inlined]; [23] compute!; @ ~/Oceananigans.jl/src/Fields/field_reductions.jl:75 [inlined]; [24] compute!(field::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Ba",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:17303,Energy Efficiency,reduce,reducedim,17303,"iodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, typeof(condition_greater_3), Int64, Float64}); @ GPUArrays ~/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; [17] #sum!#796; @ ./reducedim.jl:1018 [inlined]; [18] sum!(f::Function, r::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCond",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:559,Performance,perform,performance,559,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. I get an error... ```Julia; navidcy@tartarus:~/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.1 (2022-09-06); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 4 threads. julia> using Oceananigans.Fields: CenterField, @compute. julia> trilinear(x, y, z) = x + y + z; trilinear (generic function with 1 method). julia> arch = GPU(); GPU(). julia> grid = RectilinearGrid(arch, size = (2, 2, 2),; x = (0, 2), y = (0, 2), z = (0, 2),; topology = (Periodic, Periodic, Bounded)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 2.0) regularly spaced with Δx=1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:9169,Performance,cache,cache,9169,"ltiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, typeof(condition_greater_3), Int64, Float64}}}}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/cache.jl:90; [11] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Perio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:9361,Performance,cache,cache,9361,"OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, typeof(condition_greater_3), Int64, Float64}}}}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/cache.jl:90; [11] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:6853,Security,validat,validation,6853,"{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, typeof(condition_greater_3), Int64, Float64}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/validation.jl:141; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:418 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/utils.jl:68; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(CUDA.partial_mapreduce_grid), Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:7215,Security,validat,validate,7215,"eArray{Float64, 3, 1}}, typeof(identity), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, typeof(condition_greater_3), Int64, Float64}}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/validation.jl:141; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:418 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/4yHI4/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/07qaN/src/driver.jl:416 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/07qaN/src/utils.jl:68; [6] cufunction_compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:354; [7] #224; @ ~/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:347 [inlined]; [8] JuliaContext(f::CUDA.var""#224#225""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{typeof(CUDA.partial_mapreduce_grid), Tuple{typeof(identity), typeof(Base.add_sum), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.Multiplicati",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:155,Testability,test,test,155,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. I get an error... ```Julia; navidcy@tartarus:~/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.1 (2022-09-06); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 4 threads. julia> using Oceananigans.Fields: CenterField, @compute. julia> trilinear(x, y, z) = x + y + z; trilinear (generic function with 1 method). julia> arch = GPU(); GPU(). julia> grid = RectilinearGrid(arch, size = (2, 2, 2),; x = (0, 2), y = (0, 2), z = (0, 2),; topology = (Periodic, Periodic, Bounded)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 2.0) regularly spaced with Δx=1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108:110,Integrability,wrap,wrapped,110,"I guess it does if you do `interpolate` outside a kernel. To avoid scalar operations, `interpolate` has to be wrapped in a `@kernel`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108:61,Safety,avoid,avoid,61,"I guess it does if you do `interpolate` outside a kernel. To avoid scalar operations, `interpolate` has to be wrapped in a `@kernel`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277733108
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277736598:31,Testability,test,tests,31,I am also surprised that these tests are passing in julia 1.6 without complaining of scalar operations,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1277736598
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1281151236:43,Testability,test,tests,43,"Are users required to use 1.8, or just the tests?. I agree it's best to stay close to the latest especially at this still chaotic stage.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1281151236
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1281153566:244,Testability,test,tested,244,this. https://github.com/CliMA/Oceananigans.jl/blob/44db08162be84920aee5c53f7534486ae649afc0/Project.toml#L66; implies that users *need* to have 1.8... but we can relax that compat requirement and keep the note in the docs that Oceananigans is tested on 1.8. what do you think?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1281153566
https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1281156437:20,Availability,error,error,20,"We can replace this error at:; https://github.com/CliMA/Oceananigans.jl/blob/44db08162be84920aee5c53f7534486ae649afc0/src/Oceananigans.jl#L7-L9; with a warning saying `""We suggest running Oceananigans using Julia 1.8.""`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1281156437
https://github.com/CliMA/Oceananigans.jl/issues/2702#issuecomment-1282678457:27,Testability,test,tests,27,But it might be set in the tests,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2702#issuecomment-1282678457
https://github.com/CliMA/Oceananigans.jl/issues/2702#issuecomment-1282747928:75,Deployability,install,installed,75,"It's possible the seed of the random number generator is set when julia is installed? Or, some package could be setting it (I've seen this before too).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2702#issuecomment-1282747928
https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1223991142:37,Testability,test,test,37,Maybe we should propose a regression test for this...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1223991142
https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1224045899:340,Energy Efficiency,reduce,reduced,340,"The problem is in the calculation of the linear operator. ```; @inline ∫ᶻ_Ax_∂x_ηᶠᶜᶜ(i, j, k, grid, ∫ᶻ_Axᶠᶜᶜ, η) = @inbounds ∫ᶻ_Axᶠᶜᶜ[i, j, k] * ∂xᶠᶜᶜ(i, j, k, grid, η); @inline ∫ᶻ_Ay_∂y_ηᶜᶠᶜ(i, j, k, grid, ∫ᶻ_Ayᶜᶠᶜ, η) = @inbounds ∫ᶻ_Ayᶜᶠᶜ[i, j, k] * ∂yᶜᶠᶜ(i, j, k, grid, η); ```. These functions are evaluated at `k = 1` because they are reduced fields, but in the example script at `k=1` there is an immersed boundary. Hence the conditional derivatives get triggered returning a 0 where there shouldn't be any. We need to have reduced fields with the correct location (in this case for the free surface the field is located at `grid.Nz`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1224045899
https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1224045899:530,Energy Efficiency,reduce,reduced,530,"The problem is in the calculation of the linear operator. ```; @inline ∫ᶻ_Ax_∂x_ηᶠᶜᶜ(i, j, k, grid, ∫ᶻ_Axᶠᶜᶜ, η) = @inbounds ∫ᶻ_Axᶠᶜᶜ[i, j, k] * ∂xᶠᶜᶜ(i, j, k, grid, η); @inline ∫ᶻ_Ay_∂y_ηᶜᶠᶜ(i, j, k, grid, ∫ᶻ_Ayᶜᶠᶜ, η) = @inbounds ∫ᶻ_Ayᶜᶠᶜ[i, j, k] * ∂yᶜᶠᶜ(i, j, k, grid, η); ```. These functions are evaluated at `k = 1` because they are reduced fields, but in the example script at `k=1` there is an immersed boundary. Hence the conditional derivatives get triggered returning a 0 where there shouldn't be any. We need to have reduced fields with the correct location (in this case for the free surface the field is located at `grid.Nz`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1224045899
https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1225176695:30,Testability,test,test,30,Reopening this until we add a test or a regression.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2708#issuecomment-1225176695
https://github.com/CliMA/Oceananigans.jl/issues/2709#issuecomment-1261421139:43,Availability,error,error,43,"as for #2530, I also cannot reproduce this error. ```; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 2), extent=(1, 1, 1)); 1×1×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5. julia> buoyancy_bottom_bc = GradientBoundaryCondition(1e-5); GradientBoundaryCondition: 1.0e-5. julia> buoyancy_bcs = FieldBoundaryConditions(bottom=buoyancy_bottom_bc); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ├── east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ├── south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ├── north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); ├── bottom: GradientBoundaryCondition: 1.0e-5; ├── top: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing); └── immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing). julia> model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=BuoyancyTracer(),; boundary_conditions=(; b=buoyancy_bcs)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: Nothing; ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing. julia> simulation = Simulation(model; Δt=1, stop_iteration=2); Simulation of NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── Next time step: 1 second; ├── Elapsed wall time: 0 seconds; ├── Wall time per iteration: NaN years; ├── Stop time: Inf years; ├── Stop iteration : 2.0; ├── Wall time limit: Inf; ├── Callbacks: OrderedDict with 4 entries:; │ ├── stop_time_exceeded => Callback of stop_time_exc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2709#issuecomment-1261421139
https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224054533:16,Testability,test,test,16,We should add a test to prevent this (and bugs like this) from entering in the future.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224054533
https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224130725:160,Energy Efficiency,Reduce,ReducedFields,160,I agree; I also think this shows the need for a more structured definition of a `Nothing` location. We should split it into two in order to have two different `ReducedFields`:. - a _truly_ 2D field (for reductions); - a 2.5D field with an index associated with the reduced dimension (for free surface or similar fields),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224130725
https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224130725:265,Energy Efficiency,reduce,reduced,265,I agree; I also think this shows the need for a more structured definition of a `Nothing` location. We should split it into two in order to have two different `ReducedFields`:. - a _truly_ 2D field (for reductions); - a 2.5D field with an index associated with the reduced dimension (for free surface or similar fields),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224130725
https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224876067:8,Testability,test,test,8,shall I test this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1224876067
https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1225160620:168,Energy Efficiency,Reduce,ReducedFields,168,"> I agree; I also think this shows the need for a more structured definition of a `Nothing` location; > ; > We should split it into two in order to have two different `ReducedFields`:; > ; > * a _truly_ 2D field (for reductions); > * a 2.5D field with an index associated with the reduced dimension (for free surface or similar fields). We introduced `Field.indices` to solve this problem. The 2.5D field would have `indices = (:, :, grid.Nz)`. Does this work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1225160620
https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1225160620:281,Energy Efficiency,reduce,reduced,281,"> I agree; I also think this shows the need for a more structured definition of a `Nothing` location; > ; > We should split it into two in order to have two different `ReducedFields`:; > ; > * a _truly_ 2D field (for reductions); > * a 2.5D field with an index associated with the reduced dimension (for free surface or similar fields). We introduced `Field.indices` to solve this problem. The 2.5D field would have `indices = (:, :, grid.Nz)`. Does this work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1225160620
https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1225160871:13,Testability,test,test,13,Did we add a test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710#issuecomment-1225160871
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979:109,Deployability,continuous,continuous,109,`w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions. We could think to change the dependencies to all fields instead of only the prognostic ones,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979:95,Integrability,depend,dependency,95,`w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions. We could think to change the dependencies to all fields instead of only the prognostic ones,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979:169,Integrability,depend,dependencies,169,`w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions. We could think to change the dependencies to all fields instead of only the prognostic ones,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225322979
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667:111,Deployability,continuous,continuous,111,"> `w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions.; > ; > We could think to change the dependencies to all fields instead of only the prognostic ones. I wasn't aware of that. Is there a way to use `w` as a dependency here? In the MWE `w` is superfluous, but on complex bottom topography the drag on the sides should physically depend on `w`, among other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667:97,Integrability,depend,dependency,97,"> `w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions.; > ; > We could think to change the dependencies to all fields instead of only the prognostic ones. I wasn't aware of that. Is there a way to use `w` as a dependency here? In the MWE `w` is superfluous, but on complex bottom topography the drag on the sides should physically depend on `w`, among other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667:178,Integrability,depend,dependencies,178,"> `w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions.; > ; > We could think to change the dependencies to all fields instead of only the prognostic ones. I wasn't aware of that. Is there a way to use `w` as a dependency here? In the MWE `w` is superfluous, but on complex bottom topography the drag on the sides should physically depend on `w`, among other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667:297,Integrability,depend,dependency,297,"> `w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions.; > ; > We could think to change the dependencies to all fields instead of only the prognostic ones. I wasn't aware of that. Is there a way to use `w` as a dependency here? In the MWE `w` is superfluous, but on complex bottom topography the drag on the sides should physically depend on `w`, among other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667:418,Integrability,depend,depend,418,"> `w` is not a prognostic field for the hydrostatic free surface model so it cannot be used as a dependency in continuous boundary functions.; > ; > We could think to change the dependencies to all fields instead of only the prognostic ones. I wasn't aware of that. Is there a way to use `w` as a dependency here? In the MWE `w` is superfluous, but on complex bottom topography the drag on the sides should physically depend on `w`, among other things.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225760667
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:146,Deployability,integrat,integrating,146,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:758,Energy Efficiency,energy,energy,758,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:872,Energy Efficiency,energy,energy,872,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:994,Energy Efficiency,energy,energy,994,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:146,Integrability,integrat,integrating,146,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618:258,Integrability,depend,depend,258,"`w` is not prognostic in a hydrostatic model because the vertical momentum equation is replaced by hydrostatic balance. `w` is then determined by integrating the continuity equation. > but on complex bottom topography the drag on the sides should physically depend on w, among other things. It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Here though, the thinking may not be correct. The hydrostatic approximation is an asymptotic approximation predicated on `w / u ~ H / L << 1`; `w` is negligible compared to the horizontal components. This has important implications: because `w` is not prognostic, kinetic energy is `(u^2 + v^2) / 2`; one cannot derive a conservation equation from the governing equations for a kinetic energy that includes `w`. It may also make sense to omit `w` from the drag law, so that it dissipates hydrostatic kinetic energy. But I guess the most important thing is that there should be no measurable difference between `sqrt(u^2 + v^2 + w^2)` and `sqrt(u^2 + v^2)` in a hydrostatic model, so `w` shouldn't be needed to impose drag, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225870618
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225895785:500,Modifiability,flexible,flexible,500,"> It might make sense to follow @simone-silvestri's suggestion and include all fields in `field_dependencies`. That would open up more options for forcing in general, esp using `auxiliary_fields`. Just to make sure I understand correctly: you're talking about expanding the use of the already-existing keyword argument `field_dependencies` to include not only prognostic fields (which apparently is the current status), but all fields. If that's correct, I don't see why not. It'd make the code more flexible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1225895785
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1226016719:59,Energy Efficiency,sustainab,sustainable,59,"In light of #2700, let's make sure we have a good reason / sustainable strategy for adding this potentially expensive feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-1226016719
https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-2385618854:5,Testability,test,tested,5,Just tested it and it runs fine:. ```julia; julia> run!(simulation); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (11.290 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (26.266 seconds).; [ Info: Simulation is stopping after running for 41.963 seconds.; [ Info: Model iteration 10 equals or exceeds stop iteration 10.; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711#issuecomment-2385618854
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1231260263:18,Availability,error,error,18,"The out-of-bounds error comes from the precomputation of stretched coefficients:. The order is not preserved in Bounded directions, so halos larger than 1 are not necessary when time-stepping. This is why also with (1, 1, 1) would be fine if directions are not stretched. If the direction is stretched, the stretched coefficients are precomputed on every grid point. The error you see there comes from the coefficients near the boundary (which, indeed are not used) that require halo cells to be computed.; Note that a 7th order WENO would require 4 halos in Periodic directions. We could remove the pre-computation of boundary coefficients in case of Bounded directions...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1231260263
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1231260263:371,Availability,error,error,371,"The out-of-bounds error comes from the precomputation of stretched coefficients:. The order is not preserved in Bounded directions, so halos larger than 1 are not necessary when time-stepping. This is why also with (1, 1, 1) would be fine if directions are not stretched. If the direction is stretched, the stretched coefficients are precomputed on every grid point. The error you see there comes from the coefficients near the boundary (which, indeed are not used) that require halo cells to be computed.; Note that a 7th order WENO would require 4 halos in Periodic directions. We could remove the pre-computation of boundary coefficients in case of Bounded directions...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1231260263
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1233194825:96,Testability,log,logic,96,"We need halos larger than 1 in `Bounded` directions, because we should not use short-circuiting logic in GPU kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1233194825
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480024415:31,Testability,test,tested,31,> still an issue?. Yes. I just tested this on `main`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480024415
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539:115,Availability,error,error,115,"I do not really like the idea to inflate the grid inside the advection scheme though, if you want you can issue an error message",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539:121,Integrability,message,message,121,"I do not really like the idea to inflate the grid inside the advection scheme though, if you want you can issue an error message",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480025539
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480078481:20,Availability,error,error,20,"> The out-of-bounds error comes from the precomputation of stretched coefficients:; > ; > The order is not preserved in Bounded directions, so halos larger than 1 are not necessary when time-stepping. This is why also with (1, 1, 1) would be fine if directions are not stretched.; > ; > If the direction is stretched, the stretched coefficients are precomputed on every grid point. The error you see there comes from the coefficients near the boundary (which, indeed are not used) that require halo cells to be computed. Note that a 7th order WENO would require 4 halos in Periodic directions; > ; > We could remove the pre-computation of boundary coefficients in case of Bounded directions... Edit: this is wrong, high order halos are always required (also in Bounded directions) because we use `ifelse` statement to discriminate between low and high order. `ifelse` executes both branches so we need the halos for the branch that we eventually discard",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480078481
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480078481:386,Availability,error,error,386,"> The out-of-bounds error comes from the precomputation of stretched coefficients:; > ; > The order is not preserved in Bounded directions, so halos larger than 1 are not necessary when time-stepping. This is why also with (1, 1, 1) would be fine if directions are not stretched.; > ; > If the direction is stretched, the stretched coefficients are precomputed on every grid point. The error you see there comes from the coefficients near the boundary (which, indeed are not used) that require halo cells to be computed. Note that a 7th order WENO would require 4 halos in Periodic directions; > ; > We could remove the pre-computation of boundary coefficients in case of Bounded directions... Edit: this is wrong, high order halos are always required (also in Bounded directions) because we use `ifelse` statement to discriminate between low and high order. `ifelse` executes both branches so we need the halos for the branch that we eventually discard",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480078481
https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480081653:44,Availability,error,error,44,"Right so just to clarify we should throw an error in the WENO constructor when the halo isn't big enough. This is fine:. ```julia; using Oceananigans. H = 4. grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size = (10, 10, 10),; x = (0, 1),; y =(0, 1),; z = k -> k,; halo = (H, H, H)). advection = WENO(grid=grid, order=7); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717#issuecomment-1480081653
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:438,Availability,down,downside,438,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:63,Energy Efficiency,schedul,scheduled,63,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:127,Energy Efficiency,schedul,scheduled,127,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:272,Energy Efficiency,schedul,scheduled,272,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:326,Energy Efficiency,schedul,schedules,326,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961:450,Safety,avoid,avoiding,450,"I'm not sure what's best. We're _assuming_ that iteration 0 is scheduled. I guess under ordinary circumstances, iteration 0 is scheduled for `IterationInterval` and `TimeInterval` --- though this need not always be true. Also we might argue that iteration 0 should not be scheduled automatically for `SpecifiedTimes`. Perhaps schedules themselves should somehow explicitly specify whether they should be actuated at iteration 0 or not. A downside of avoiding iteration 0 is that issues / bugs with a callback are not caught until first actuation. So it may be a sensible default to actuate at iteration 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233192961
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233399368:192,Usability,intuit,intuitive,192,"I would argue that `SpecifiedTimes` shouldn't be actuated in iteration 0 since, if that is desired by the user, it's trivially easy to add zero to the list of times. I also think it's counter-intuitive to have something with `SpecifiedTimes([5, 10])` to actuate at `t=[0, 5, 10]` in practice, although I guess that's up for debate. If no one opposes this, I can open a PR to make this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233399368
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233490967:483,Energy Efficiency,sustainab,sustainable,483,"This is about more than just defining inuitive behavior, though. Executing a callback at iteration 0 might be considered a feature. However, I think that sometimes it's not desired. In reality, what we are missing is the concept of callback ""initialization"" (we are also missing the concept of callback ""finalization""). Right now, we use the hack that ""calling at iteration 0"" is tantamount to initialization. I think we should discuss how to generalize our design to something more sustainable...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1233490967
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501:98,Energy Efficiency,schedul,schedule,98,"What if we add this feature to `Callback`? I.e. ```julia; struct Callback{P, F, S, I}; func :: F; schedule :: S; parameters :: P; initialize :: I; end; ```. Then by default we set. ```julia; Callback(; ..., initialize=call_at_iteration_0); ```. where. ```julia; call_at_iteration_0(callback, simulation) = iteration(simulation) == 0 && callback(simulation); ```. so the default ""initialization"" is simply to ""call"" the callback at iteration 0 (as we currently do). Users can cancel this by setting `initialize=nothing` or providing some alternative function. Finally, rather than calling all the callbacks at iteration 0, we instead call `Callback.initialize!` for every callback inside `initalize_simulation!`:. https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Simulations/run.jl#L166. For ""finalization"" we need a bit more work, since I think we want to add the concept of finalizing a simulation as well, so we might need `Simulation.finalized`. That's probably a nice idea too though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501:398,Usability,simpl,simply,398,"What if we add this feature to `Callback`? I.e. ```julia; struct Callback{P, F, S, I}; func :: F; schedule :: S; parameters :: P; initialize :: I; end; ```. Then by default we set. ```julia; Callback(; ..., initialize=call_at_iteration_0); ```. where. ```julia; call_at_iteration_0(callback, simulation) = iteration(simulation) == 0 && callback(simulation); ```. so the default ""initialization"" is simply to ""call"" the callback at iteration 0 (as we currently do). Users can cancel this by setting `initialize=nothing` or providing some alternative function. Finally, rather than calling all the callbacks at iteration 0, we instead call `Callback.initialize!` for every callback inside `initalize_simulation!`:. https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Simulations/run.jl#L166. For ""finalization"" we need a bit more work, since I think we want to add the concept of finalizing a simulation as well, so we might need `Simulation.finalized`. That's probably a nice idea too though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1238518501
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1239596118:277,Availability,down,down,277,"I can work on this. We can build. ```julia; function finalize!(sim::Simulation); # Finalize callbacks; [cb.finalize(cb, sim) for cb in sim.callbacks]. # Finalize model; finalize!(sim.model). return nothing; end; ```. Models can then define appropriate finalizations. One layer down, we can have. ```julia; function finalize!(model::HydrostaticFreeSurfaceModel); finalize!(model.free_surface); return nothing; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1239596118
https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1243043352:315,Availability,down,down,315,"> I can work on this. We can build; > ; > ```julia; > function finalize!(sim::Simulation); > # Finalize callbacks; > [cb.finalize(cb, sim) for cb in sim.callbacks]; > ; > # Finalize model; > finalize!(sim.model); > ; > return nothing; > end; > ```; > ; > Models can then define appropriate finalizations. One layer down, we can have; > ; > ```julia; > function finalize!(model::HydrostaticFreeSurfaceModel); > finalize!(model.free_surface); > return nothing; > end; > ```. Let's do this! :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719#issuecomment-1243043352
https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1233549934:16,Testability,test,test,16,"I’ll be able to test next week, I’m on vacation the next few days. Thanks for the troubleshooting on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1233549934
https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989:127,Integrability,message,message,127,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989
https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989:2,Testability,test,tested,2,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989
https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989:23,Usability,simpl,simple,23,I tested this with the simple case from discussion #2720 and with the Bickley Jet example adding a CFL calculation to a status message. It looks like CFL is calculated correctly and the `TimeStepWizard` is functioning properly now.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239578989
https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711:48,Integrability,wrap,wrap,48,Good! I wonder if we can add a test here too to wrap this up.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711
https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711:31,Testability,test,test,31,Good! I wonder if we can add a test here too to wrap this up.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2721#issuecomment-1239590711
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238527382:206,Energy Efficiency,reduce,reduced,206,"I'll try to parse this carefully, but I do have a comment on this part:. > Now, when I print out ∫ᶻQ.u I see that all its elements are supposedly 0:. ```; julia> ∫ᶻQ.u; 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Nothing, east: Nothing, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 135×7×1 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, 1:1) with eltype Float64 with indices -2:132×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0; ```. > But this returns the right answer. ```; julia> maximum(∫ᶻQ.u.data); 8.0; ```. Crucially, `maximum(∫ᶻQ.u)` will ignore immersed cells and halo cells, but `maximum(∫ᶻQ.u.data)` does not. Does this explain what you're seeing?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238527382
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238531744:33,Energy Efficiency,reduce,reduced,33,"One problem is that `∫ᶻQ.u` is a reduced field so `maximum(∫ᶻQ.u)` excludes points at `i, j` corresponding to immersed cells at `i, j, k = 1`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238531744
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238604868:35,Energy Efficiency,reduce,reduced,35,"> One problem is that `∫ᶻQ.u` is a reduced field so `maximum(∫ᶻQ.u)` excludes points at `i, j` corresponding to immersed cells at `i, j, k = 1`. I'm wasn't setting the `u` velocity at `i, j, k = 1, 1, 1` but rather at `i, j, k = 45, 1, 3` and now, after [1638f39](https://github.com/CliMA/Oceananigans.jl/pull/2723/commits/1638f392eb6f3cb04d26796d0f785f01a4f997cf), at `i, j, k = 45, 1, 5`. Still I get. ```julia; julia> η = model.free_surface.η; 128×1×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: ZeroFlux, east: ZeroFlux, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 134×7×1 OffsetArray(::Array{Float64, 3}, -2:131, -2:4, 1:1) with eltype Float64 with indices -2:131×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; [ Info: implicit free surface solver test, norm(η): 0.0, maximum(abs, η): 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238604868
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238604868:486,Energy Efficiency,reduce,reduced,486,"> One problem is that `∫ᶻQ.u` is a reduced field so `maximum(∫ᶻQ.u)` excludes points at `i, j` corresponding to immersed cells at `i, j, k = 1`. I'm wasn't setting the `u` velocity at `i, j, k = 1, 1, 1` but rather at `i, j, k = 45, 1, 3` and now, after [1638f39](https://github.com/CliMA/Oceananigans.jl/pull/2723/commits/1638f392eb6f3cb04d26796d0f785f01a4f997cf), at `i, j, k = 45, 1, 5`. Still I get. ```julia; julia> η = model.free_surface.η; 128×1×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: ZeroFlux, east: ZeroFlux, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 134×7×1 OffsetArray(::Array{Float64, 3}, -2:131, -2:4, 1:1) with eltype Float64 with indices -2:131×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; [ Info: implicit free surface solver test, norm(η): 0.0, maximum(abs, η): 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238604868
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238604868:1011,Testability,test,test,1011,"> One problem is that `∫ᶻQ.u` is a reduced field so `maximum(∫ᶻQ.u)` excludes points at `i, j` corresponding to immersed cells at `i, j, k = 1`. I'm wasn't setting the `u` velocity at `i, j, k = 1, 1, 1` but rather at `i, j, k = 45, 1, 3` and now, after [1638f39](https://github.com/CliMA/Oceananigans.jl/pull/2723/commits/1638f392eb6f3cb04d26796d0f785f01a4f997cf), at `i, j, k = 45, 1, 5`. Still I get. ```julia; julia> η = model.free_surface.η; 128×1×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: ZeroFlux, east: ZeroFlux, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 134×7×1 OffsetArray(::Array{Float64, 3}, -2:131, -2:4, 1:1) with eltype Float64 with indices -2:131×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; [ Info: implicit free surface solver test, norm(η): 0.0, maximum(abs, η): 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238604868
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238604868:1113,Testability,test,test,1113,"> One problem is that `∫ᶻQ.u` is a reduced field so `maximum(∫ᶻQ.u)` excludes points at `i, j` corresponding to immersed cells at `i, j, k = 1`. I'm wasn't setting the `u` velocity at `i, j, k = 1, 1, 1` but rather at `i, j, k = 45, 1, 3` and now, after [1638f39](https://github.com/CliMA/Oceananigans.jl/pull/2723/commits/1638f392eb6f3cb04d26796d0f785f01a4f997cf), at `i, j, k = 45, 1, 5`. Still I get. ```julia; julia> η = model.free_surface.η; 128×1×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: ZeroFlux, east: ZeroFlux, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 134×7×1 OffsetArray(::Array{Float64, 3}, -2:131, -2:4, 1:1) with eltype Float64 with indices -2:131×-2:4×1:1; └── max=0.0, min=0.0, mean=0.0. julia> @info ""implicit free surface solver test, norm(η): $(norm(η)), maximum(abs, η): $(maximum(abs, η))""; [ Info: implicit free surface solver test, norm(η): 0.0, maximum(abs, η): 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1238604868
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938:698,Availability,error,error,698,"An update:. ```Julia; using Oceananigans. using Statistics; using Oceananigans.Units; using Oceananigans.Architectures: device_event; using Oceananigans.TimeSteppers: update_state!; using LinearAlgebra: norm. using Oceananigans.Models.HydrostaticFreeSurfaceModels:; ImplicitFreeSurface,; FreeSurface,; PCGImplicitFreeSurfaceSolver,; implicit_free_surface_step!. function set_simple_divergent_velocity!(model); # Create a divergent velocity; grid = model.grid. u, v, w = model.velocities; η = model.free_surface.η. u .= 0; v .= 0; η .= 0. # pick a surface cell at the middle of the domain; i, j, k = Int(floor(grid.Nx / 2)) + 1, Int(floor(grid.Ny / 2)) + 1, grid.Nz. inactive_cell(i, j, k, grid) && error(""The nudged cell at ($i, $j, $k) is inactive.""). if grid isa RectilinearGrid; Δy = grid.Δyᵃᶜᵃ; end. if grid isa LatitudeLongitudeGrid; Δy = grid.Δyᶜᶠᵃ; end. if grid isa ImmersedBoundaryGrid; if grid isa ImmersedBoundaryGrid && grid.underlying_grid isa RectilinearGrid; Δy = grid.underlying_grid.Δyᵃᶜᵃ; elseif grid.underlying_grid isa LatitudeLongitudeGrid; Δy = grid.underlying_grid.Δyᶜᶠᵃ; end; end. Δz = CUDA.@allowscalar grid.Δzᵃᵃᶜ. # We prescribe the value of the zonal transport in a cell, i.e., `u * Δy * Δz`. This; # way `norm(rhs)` of the free-surface solver does not depend on the grid extensd/resolution.; transport = 1e5 # m³ s⁻¹; CUDA.@allowscalar u[i, j, k] = transport / (Δy * Δz). update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-5000kilometers, 5000kilometers),; y = (0, 100kilometers),; z = (-500, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = rectilinear_grid.Lx / 20. bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938:3,Deployability,update,update,3,"An update:. ```Julia; using Oceananigans. using Statistics; using Oceananigans.Units; using Oceananigans.Architectures: device_event; using Oceananigans.TimeSteppers: update_state!; using LinearAlgebra: norm. using Oceananigans.Models.HydrostaticFreeSurfaceModels:; ImplicitFreeSurface,; FreeSurface,; PCGImplicitFreeSurfaceSolver,; implicit_free_surface_step!. function set_simple_divergent_velocity!(model); # Create a divergent velocity; grid = model.grid. u, v, w = model.velocities; η = model.free_surface.η. u .= 0; v .= 0; η .= 0. # pick a surface cell at the middle of the domain; i, j, k = Int(floor(grid.Nx / 2)) + 1, Int(floor(grid.Ny / 2)) + 1, grid.Nz. inactive_cell(i, j, k, grid) && error(""The nudged cell at ($i, $j, $k) is inactive.""). if grid isa RectilinearGrid; Δy = grid.Δyᵃᶜᵃ; end. if grid isa LatitudeLongitudeGrid; Δy = grid.Δyᶜᶠᵃ; end. if grid isa ImmersedBoundaryGrid; if grid isa ImmersedBoundaryGrid && grid.underlying_grid isa RectilinearGrid; Δy = grid.underlying_grid.Δyᵃᶜᵃ; elseif grid.underlying_grid isa LatitudeLongitudeGrid; Δy = grid.underlying_grid.Δyᶜᶠᵃ; end; end. Δz = CUDA.@allowscalar grid.Δzᵃᵃᶜ. # We prescribe the value of the zonal transport in a cell, i.e., `u * Δy * Δz`. This; # way `norm(rhs)` of the free-surface solver does not depend on the grid extensd/resolution.; transport = 1e5 # m³ s⁻¹; CUDA.@allowscalar u[i, j, k] = transport / (Δy * Δz). update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-5000kilometers, 5000kilometers),; y = (0, 100kilometers),; z = (-500, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = rectilinear_grid.Lx / 20. bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938:1279,Integrability,depend,depend,1279,"mplicitFreeSurface,; FreeSurface,; PCGImplicitFreeSurfaceSolver,; implicit_free_surface_step!. function set_simple_divergent_velocity!(model); # Create a divergent velocity; grid = model.grid. u, v, w = model.velocities; η = model.free_surface.η. u .= 0; v .= 0; η .= 0. # pick a surface cell at the middle of the domain; i, j, k = Int(floor(grid.Nx / 2)) + 1, Int(floor(grid.Ny / 2)) + 1, grid.Nz. inactive_cell(i, j, k, grid) && error(""The nudged cell at ($i, $j, $k) is inactive.""). if grid isa RectilinearGrid; Δy = grid.Δyᵃᶜᵃ; end. if grid isa LatitudeLongitudeGrid; Δy = grid.Δyᶜᶠᵃ; end. if grid isa ImmersedBoundaryGrid; if grid isa ImmersedBoundaryGrid && grid.underlying_grid isa RectilinearGrid; Δy = grid.underlying_grid.Δyᵃᶜᵃ; elseif grid.underlying_grid isa LatitudeLongitudeGrid; Δy = grid.underlying_grid.Δyᶜᶠᵃ; end; end. Δz = CUDA.@allowscalar grid.Δzᵃᵃᶜ. # We prescribe the value of the zonal transport in a cell, i.e., `u * Δy * Δz`. This; # way `norm(rhs)` of the free-surface solver does not depend on the grid extensd/resolution.; transport = 1e5 # m³ s⁻¹; CUDA.@allowscalar u[i, j, k] = transport / (Δy * Δz). update_state!(model). return nothing; end. arch = CPU(). rectilinear_grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (-5000kilometers, 5000kilometers),; y = (0, 100kilometers),; z = (-500, 0),; topology = (Bounded, Periodic, Bounded)). Lz = rectilinear_grid.Lz; width = rectilinear_grid.Lx / 20. bump(x, y) = - Lz * (1 - 0.2 * exp(-x^2 / 2width^2)). grid = ImmersedBoundaryGrid(rectilinear_grid, GridFittedBottom(bump)). free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; abstol=1e-15, reltol=0). model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface). set_simple_divergent_velocity!(model). @show model.velocities.u. events = ((device_event(arch), device_event(arch)), (device_event(arch), device_event(arch))). Δt = 900.0; implicit_free_surface_step!(model.free_surface, model, Δt, 1.5, events",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247333938
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247516012:148,Availability,ERROR,ERROR,148,"most tests fail now...... :( . Also I get; ```Julia; julia> ∫ᶻ_Axᶠᶜᶜ = Field{Face, Center, Nothing}(with_halo((3, 3, 1), grid), indices = grid.Nz); ERROR: BoundsError: attempt to access Tuple{Int64} at index [2]; Stacktrace:; [1] indexed_iterate; @ ./tuple.jl:86 [inlined]; [2] new_data(FT::DataType, grid::ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, loc::Tuple{DataType, DataType, DataType}, indices::Int64); @ Oceananigans.Grids ~/Research/OC2.jl/src/Grids/new_data.jl:59; [3] (Field{Face, Center, Nothing, O, G, I, D, T, B, S, F} where {O, G, I, D, T, B, S, F})(grid::ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, T::DataType; kw::Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:indices,), Tuple{Int64}}}); @ Oceananigans.Fields ~/Research/OC2.jl/src/Fields/field.jl:158; [4] top-level scope; @ REPL[24]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247516012
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247516012:179,Security,access,access,179,"most tests fail now...... :( . Also I get; ```Julia; julia> ∫ᶻ_Axᶠᶜᶜ = Field{Face, Center, Nothing}(with_halo((3, 3, 1), grid), indices = grid.Nz); ERROR: BoundsError: attempt to access Tuple{Int64} at index [2]; Stacktrace:; [1] indexed_iterate; @ ./tuple.jl:86 [inlined]; [2] new_data(FT::DataType, grid::ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, loc::Tuple{DataType, DataType, DataType}, indices::Int64); @ Oceananigans.Grids ~/Research/OC2.jl/src/Grids/new_data.jl:59; [3] (Field{Face, Center, Nothing, O, G, I, D, T, B, S, F} where {O, G, I, D, T, B, S, F})(grid::ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, T::DataType; kw::Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:indices,), Tuple{Int64}}}); @ Oceananigans.Fields ~/Research/OC2.jl/src/Fields/field.jl:158; [4] top-level scope; @ REPL[24]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247516012
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247516012:5,Testability,test,tests,5,"most tests fail now...... :( . Also I get; ```Julia; julia> ∫ᶻ_Axᶠᶜᶜ = Field{Face, Center, Nothing}(with_halo((3, 3, 1), grid), indices = grid.Nz); ERROR: BoundsError: attempt to access Tuple{Int64} at index [2]; Stacktrace:; [1] indexed_iterate; @ ./tuple.jl:86 [inlined]; [2] new_data(FT::DataType, grid::ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, loc::Tuple{DataType, DataType, DataType}, indices::Int64); @ Oceananigans.Grids ~/Research/OC2.jl/src/Grids/new_data.jl:59; [3] (Field{Face, Center, Nothing, O, G, I, D, T, B, S, F} where {O, G, I, D, T, B, S, F})(grid::ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, T::DataType; kw::Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol}, NamedTuple{(:indices,), Tuple{Int64}}}); @ Oceananigans.Fields ~/Research/OC2.jl/src/Fields/field.jl:158; [4] top-level scope; @ REPL[24]:1; [5] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247516012
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247523200:160,Energy Efficiency,reduce,reduced,160,"that should be ; ```; julia> ∫ᶻ_Axᶠᶜᶜ = Field{Face, Center, Nothing}(with_halo((3, 3, 1), grid), indices = (:, :, grid.Nz)); 4×4×1 Field{Face, Center, Nothing} reduced over dims = (3,) on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.0, min=0.0, mean=0.0; ```. there are a couple of things to smooth out",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247523200
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247524383:1023,Energy Efficiency,reduce,reduced,1023,"th 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=Inf. julia> set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN; ```. I am still struggling with the `mean` though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247524383
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247524383:1637,Energy Efficiency,reduce,reduced,1637,"th 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=Inf. julia> set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN; ```. I am still struggling with the `mean` though",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247524383
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247693563:43,Usability,simpl,simple,43,"now `norm` seems that it's not working for simple RectilinearGrid :); E.g., in the pgc solver, `residual_norm = norm(solver.residual)` gives zero... even when q=0 but rhs $\ne$ 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247693563
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998:1028,Energy Efficiency,reduce,reduced,1028,"iodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=0.5. julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN. julia> using Statistics: norm. julia> norm(f1); 2.29128784747",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998:1647,Energy Efficiency,reduce,reduced,1647,"paced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; └── max=0.875, min=0.125, mean=0.5. julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; └── max=-Inf, min=Inf, mean=NaN. julia> using Statistics: norm. julia> norm(f1); 2.29128784747792. julia> norm(f2); 0.0; ```. Maybe we have not set correctly the index of the residuals?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1247924998
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248088689:1072,Energy Efficiency,reduce,reduced,1072,"y spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25; > ; > julia> immersed_grid = ImmersedBoundaryGrid(grid, GridFittedBottom((x, y) -> -0.5)); > 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; > ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); > ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25; > ; > julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); > 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; > ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── boundary conditions: FieldBoundaryConditions; > │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; > └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; > └── max=0.875, min=0.125, mean=0.5; > ; > julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); > 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; > ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── boundary conditions: FieldBoundaryConditions; > │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; > └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; > └── max=-Inf, min=Inf, mean=NaN; > ; > julia> using Statistics: no",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248088689
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248088689:1709,Energy Efficiency,reduce,reduced,1709," -> -0.5)); > 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; > ├── immersed_boundary: GridFittedBottom(min(h)=-5.00e-01, max(h)=-5.00e-01); > ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25; > ; > julia> f1 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 4)), (x, y) -> x); > 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; > ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── boundary conditions: FieldBoundaryConditions; > │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; > └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 4:4) with eltype Float64 with indices -2:7×-2:7×4:4; > └── max=0.875, min=0.125, mean=0.5; > ; > julia> f2 = set!(Field((Center, Center, Nothing), immersed_grid, indices = (:, :, 1)), (x, y) -> x); > 4×4×1 Field{Center, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; > ├── grid: 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── boundary conditions: FieldBoundaryConditions; > │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; > └── data: 10×10×1 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, 1:1) with eltype Float64 with indices -2:7×-2:7×1:1; > └── max=-Inf, min=Inf, mean=NaN; > ; > julia> using Statistics: norm; > ; > julia> norm(f1); > 2.29128784747792; > ; > julia> norm(f2); > 0.0; > ```; > ; > Maybe we have not set correctly the index of the residuals?. What is expected? Isn't `indices = (:, :, 1)` below the bottom for `f2`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248088689
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736:55,Energy Efficiency,Reduce,ReducedField,55,"Yeah so this should be ok. ; The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced.; Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid; In this way a reduced field will have a ""position"" with respect to the full 3D grid. Reductions and reduced fields without a specified position are located at `index = 1` by default. I am still bugfixing a bit though. ; A problem that I am foreseeing is that the `GPU` has no information about either indices or reduced locations but only the data structure, maybe we should ship the indices with the data on the GPU? ; Also, since the underlying data is also offset we could retrieve the information on the GPU although it will probably get a bit wonky",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736:146,Energy Efficiency,reduce,reduced,146,"Yeah so this should be ok. ; The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced.; Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid; In this way a reduced field will have a ""position"" with respect to the full 3D grid. Reductions and reduced fields without a specified position are located at `index = 1` by default. I am still bugfixing a bit though. ; A problem that I am foreseeing is that the `GPU` has no information about either indices or reduced locations but only the data structure, maybe we should ship the indices with the data on the GPU? ; Also, since the underlying data is also offset we could retrieve the information on the GPU although it will probably get a bit wonky",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736:244,Energy Efficiency,reduce,reduced,244,"Yeah so this should be ok. ; The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced.; Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid; In this way a reduced field will have a ""position"" with respect to the full 3D grid. Reductions and reduced fields without a specified position are located at `index = 1` by default. I am still bugfixing a bit though. ; A problem that I am foreseeing is that the `GPU` has no information about either indices or reduced locations but only the data structure, maybe we should ship the indices with the data on the GPU? ; Also, since the underlying data is also offset we could retrieve the information on the GPU although it will probably get a bit wonky",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736:285,Energy Efficiency,reduce,reduced,285,"Yeah so this should be ok. ; The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced.; Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid; In this way a reduced field will have a ""position"" with respect to the full 3D grid. Reductions and reduced fields without a specified position are located at `index = 1` by default. I am still bugfixing a bit though. ; A problem that I am foreseeing is that the `GPU` has no information about either indices or reduced locations but only the data structure, maybe we should ship the indices with the data on the GPU? ; Also, since the underlying data is also offset we could retrieve the information on the GPU although it will probably get a bit wonky",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736:371,Energy Efficiency,reduce,reduced,371,"Yeah so this should be ok. ; The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced.; Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid; In this way a reduced field will have a ""position"" with respect to the full 3D grid. Reductions and reduced fields without a specified position are located at `index = 1` by default. I am still bugfixing a bit though. ; A problem that I am foreseeing is that the `GPU` has no information about either indices or reduced locations but only the data structure, maybe we should ship the indices with the data on the GPU? ; Also, since the underlying data is also offset we could retrieve the information on the GPU although it will probably get a bit wonky",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736:583,Energy Efficiency,reduce,reduced,583,"Yeah so this should be ok. ; The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced.; Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid; In this way a reduced field will have a ""position"" with respect to the full 3D grid. Reductions and reduced fields without a specified position are located at `index = 1` by default. I am still bugfixing a bit though. ; A problem that I am foreseeing is that the `GPU` has no information about either indices or reduced locations but only the data structure, maybe we should ship the indices with the data on the GPU? ; Also, since the underlying data is also offset we could retrieve the information on the GPU although it will probably get a bit wonky",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248131736
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:55,Energy Efficiency,Reduce,ReducedField,55,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:146,Energy Efficiency,reduce,reduced,146,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:243,Energy Efficiency,reduce,reduced,243,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:283,Energy Efficiency,reduce,reduced,283,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:545,Energy Efficiency,reduce,reduced,545,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:572,Energy Efficiency,reduce,reduced,572,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:682,Energy Efficiency,reduce,reduces,682,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:851,Energy Efficiency,reduce,reduced,851,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376:1074,Energy Efficiency,reduce,reduced,1074,"> Yeah so this should be ok. The general idea is that `ReducedField` have an `Integer` index in `field.indices` at the position at which they are reduced. Also the underlying `OffsetArray` will be have an offset reflecting the position of the reduced plane in the grid In this way a reduced field will have a ""position"" with respect to the full 3D grid. I don't totally understand. I think we want to build out support for behavior when a field is sliced at a single index. But why would we want to build this feature for fields that are _also_ reduced?. > Reductions and reduced fields without a specified position are located at `index = 1` by default. I'm opposed to this, which reduces the concepts we can express in the code. I think we retain _more flexibility_ if we interpret a `Nothing` location to mean that a field has _no location_ in the reduced direction. This is a valid mathematical concept. Otherwise, we cannot distinguish between _slices_ and _true two dimensional fields_. I think in fact that it should be invalid to specify the index of a field in the reduced direction.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248227376
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248244264:405,Energy Efficiency,reduce,reduced,405,"All of that said, I suspect that the changes in this PR are important --- it's just that we need to clarify the difference between a `Field` that is _sliced_ in a certain direction, and a `Field` with a `Nothing` location. My only point is that I don't think we should conflate these concepts. I can't figure out if this PR is conflating these or not. One consequence is: the free surface will _not_ be a reduced field. This design was the primary motivation for PR https://github.com/CliMA/Oceananigans.jl/pull/2246.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248244264
https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248423509:526,Energy Efficiency,Reduce,ReducedFields,526,"Ok, I agree with your comments.; This said then, it is better to close this PR and start from a clean slate.; I'll close this PR and open a new one which will focus on the following changes:. - Free surface will be: `Field((Center, Center, Face), grid, indices = (:, :, grid.Nz+1))`; - Changes to inner workings of PCG and MG solver to accommodate this change; - Immersed reductions for _sliced_ and _windowed_ fields (and in general conditional reductions); - Try windowed-sliced BC? (We need this for `η`). - Reductions on `ReducedFields`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723#issuecomment-1248423509
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237094696:81,Availability,error,errors,81,"The test that’s failed says on buildkite that the client was lost and there’s no errors from Julia, I’m guessing if I can get them to rerun it might be fine since the other GPU tasks ran fine?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237094696
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237094696:4,Testability,test,test,4,"The test that’s failed says on buildkite that the client was lost and there’s no errors from Julia, I’m guessing if I can get them to rerun it might be fine since the other GPU tasks ran fine?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237094696
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237427854:49,Availability,error,errored,49,It failed again so I ran it on our cluster which errored in the same way just saying `killed`. It's failing on my new test and I think I've probably not implemented the `calculate_particle_tendency_contributions!` in a GPU friendly way so will try and resolve this tomorrow. . Edit: as I closed the terminal some error about the GPU node being out of memory flashed up which may be relevant.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237427854
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237427854:313,Availability,error,error,313,It failed again so I ran it on our cluster which errored in the same way just saying `killed`. It's failing on my new test and I think I've probably not implemented the `calculate_particle_tendency_contributions!` in a GPU friendly way so will try and resolve this tomorrow. . Edit: as I closed the terminal some error about the GPU node being out of memory flashed up which may be relevant.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237427854
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237427854:118,Testability,test,test,118,It failed again so I ran it on our cluster which errored in the same way just saying `killed`. It's failing on my new test and I think I've probably not implemented the `calculate_particle_tendency_contributions!` in a GPU friendly way so will try and resolve this tomorrow. . Edit: as I closed the terminal some error about the GPU node being out of memory flashed up which may be relevant.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1237427854
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827:359,Deployability,integrat,integrate,359,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827:359,Integrability,integrat,integrate,359,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827:863,Testability,test,test,863,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827:680,Usability,clear,clear,680,"> Particle setup: particles can get a parameter called active_properties which is a tuple of named tuples of particle properties and tracers (e.g. ((property=:t, tracer=:x),).) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238507827
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1010,Deployability,release,release,1010,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1342,Deployability,integrat,integrated,1342,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1487,Deployability,integrat,integrated,1487,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1643,Deployability,update,update,1643,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:919,Integrability,depend,depending,919,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1342,Integrability,integrat,integrated,1342,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1487,Integrability,integrat,integrated,1487,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:459,Testability,test,test,459,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1116,Testability,test,test,1116,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:1869,Testability,test,tests,1869,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:2009,Testability,test,test,2009,"ate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:276,Usability,clear,clear,276,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939:664,Usability,simpl,simplest,664,"> Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!. No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point. ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif). Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1238958939
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1018,Deployability,release,release,1018,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1688,Deployability,integrat,integrated,1688,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1833,Deployability,integrat,integrated,1833,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1989,Deployability,update,update,1989,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:927,Integrability,depend,depending,927,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1688,Integrability,integrat,integrated,1688,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1833,Integrability,integrat,integrated,1833,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:461,Testability,test,test,461,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1131,Testability,test,test,1131,"lain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:1244,Testability,test,test,1244," code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:2222,Testability,test,tests,2222,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:2362,Testability,test,test,2362,"blem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles.; > ; > (I fix the tests that's failed until we've discussed the other changes since its only failed because I forgot to change `getmask` to `get_mask` in the test script). Nice! Can you paste a more minimal example directly in this PR too so it's preserved here for the future?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:278,Usability,clear,clear,278,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678:672,Usability,simpl,simplest,672,"> > Can you please restate this? I think a code example would be helpful with an explanation on what's being accomplished. Also can you explain why this can't be implemented with a Callback (or forcing function)? I.e., why do we desire this as a source code feature? Just to be clear, I'm not saying it should be one way or another, but it's good to have explicit justification for source code features (which are expensive to maintain and require resources to test)!; > ; > No problem at all, [heres](https://gist.github.com/jagoosw/213d7f2ce3707768d4ddb07f8827cdd2) an example (not sure where best to put this/if you'd want it in the examples folder). This is about the simplest version I could think of where we have a particle randomly walking around converting tracer a into tracer b. The specific use case we've been using this for is modelling kelp fronds as particles which grow (variety of particle properties change) depending on how much nutrients the particles uptake from a biogeochemical model, and also release tracer back into the model. I also envisage using this to exert drag on the flow at some point.; > ; > ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ![test](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif) [ ](https://user-images.githubusercontent.com/26657828/188803448-86bc2fe2-dbbc-447a-93c6-ff238f6dde06.gif); > ; > Although I've had this working as custom dynamics of the particles the effect of the particles tendency can only be integrated with explicit Euler, i.e. at each substep it just does `tracer[i, j, k] += value*Δt`, where as this solution allows it to be properly integrated along with the other tendencies. I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an au",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239608678
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239609992:103,Security,validat,validation,103,"> (not sure where best to put this/if you'd want it in the examples folder). The right place would be `validation/`, as we only use `examples/` for features that are widely-used and well-tested (examples are expensive, because they have to run during CI).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239609992
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239609992:187,Testability,test,tested,187,"> (not sure where best to put this/if you'd want it in the examples folder). The right place would be `validation/`, as we only use `examples/` for features that are widely-used and well-tested (examples are expensive, because they have to run during CI).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239609992
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239643533:32,Testability,test,tests,32,Is there a way for me to cancel tests so they don't have to run every commit?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1239643533
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165:123,Integrability,message,message,123,> Is there a way for me to cancel tests so they don't have to run every commit?. You can include `[skip ci]` in the commit message: https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165:34,Testability,test,tests,34,> Is there a way for me to cancel tests so they don't have to run every commit?. You can include `[skip ci]` in the commit message: https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1240860165
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1247169843:94,Testability,test,test,94,"I've spent some time trying to diagnose the GPU issue and it's quite strange, when I copy the test line by line into a REPL it doesn't cause the memory issue and runs fine. After doing that (so everything has been compiled etc.) I then ran the test and the memory usage is fine until the last test, then crashes again. I will investigate more...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1247169843
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1247169843:244,Testability,test,test,244,"I've spent some time trying to diagnose the GPU issue and it's quite strange, when I copy the test line by line into a REPL it doesn't cause the memory issue and runs fine. After doing that (so everything has been compiled etc.) I then ran the test and the memory usage is fine until the last test, then crashes again. I will investigate more...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1247169843
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1247169843:293,Testability,test,test,293,"I've spent some time trying to diagnose the GPU issue and it's quite strange, when I copy the test line by line into a REPL it doesn't cause the memory issue and runs fine. After doing that (so everything has been compiled etc.) I then ran the test and the memory usage is fine until the last test, then crashes again. I will investigate more...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1247169843
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248258123:20,Testability,test,tests,20,"So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower. I can't test it myself on a GPU right now so am going to push and hopefully it'll work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248258123
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248258123:309,Testability,test,tested,309,"So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower. I can't test it myself on a GPU right now so am going to push and hopefully it'll work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248258123
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248258123:351,Testability,test,test,351,"So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower. I can't test it myself on a GPU right now so am going to push and hopefully it'll work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248258123
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248258123:405,Testability,test,test,405,"So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower. I can't test it myself on a GPU right now so am going to push and hopefully it'll work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248258123
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675:22,Testability,test,tests,22,"> So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > ; > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!. Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675:311,Testability,test,tested,311,"> So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > ; > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!. Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675:353,Testability,test,test,353,"> So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > ; > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!. Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675:414,Testability,test,test,414,"> So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > ; > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!. Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675:579,Testability,test,tests,579,"> So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > ; > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!. Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675:652,Testability,test,tests,652,"> So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > ; > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!. Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675:792,Testability,test,test,792,"> So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > ; > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!. Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675:852,Testability,test,tests,852,"> So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > ; > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!. Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248267675
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:1379,Energy Efficiency,allocate,allocate,1379,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:24,Testability,test,tests,24,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:313,Testability,test,tested,313,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:355,Testability,test,test,355,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:414,Testability,test,test,414,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:585,Testability,test,tests,585,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:658,Testability,test,tests,658,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:798,Testability,test,test,798,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546:858,Testability,test,tests,858,"> > So I think that the tests generally are very close to the memory limit (which I think is around 1GB, not sure how that's being set). It looks like the tracer sinking isn't actually using much more memory but its enough to push it over. If I remove the output writing and speed field tracking (which don't get tested in this run anyway) from the final test it seems to keep the memory usage lower.; > > I can't test it myself on a GPU right now so am going to push and hopefully it'll work!; > ; > Interesting. I don't believe we make any attempt to manage GPU memory. However, the tests are all quite lightweight (the largest are probably the regression tests, at 16^3?) The GPU we use for CI has 24 GB total memory. Up to 16 jobs can run simultaneously. I'm not sure this is consistent with a test being just over the limit, because this would mean the tests would intermittently pass, right? It's slightly stochastic how many CI jobs are running simultaneously. I'm not really sure where this limit is coming from because I get the same behaviour on our GPU which is on a node with 40GB of memory, and it consistently fails when the memory usage of the process gets to fractionally over 1GB. I think the spike in memory usage is occurring on the line `Gp_kernel! = calculate_particle_tendency_kernel!(device(arch), workgroup, worksize)` which I wouldn't have thought would allocate much memory?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248303546
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748:18,Energy Efficiency,allocate,allocate,18,Why does the test allocate so much memory? Is it possible to design an inexpensive test? It's important that CI is absolutely as cheap as possible.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748:13,Testability,test,test,13,Why does the test allocate so much memory? Is it possible to design an inexpensive test? It's important that CI is absolutely as cheap as possible.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748:83,Testability,test,test,83,Why does the test allocate so much memory? Is it possible to design an inexpensive test? It's important that CI is absolutely as cheap as possible.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248396748
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125:114,Deployability,update,update,114,"> I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > although I imagine that could use a lot more memory if there were a large grid and small amount of particles. It seems the memory requirement of the forcing function approach is proportional to the number of _tracers_, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125:1226,Modifiability,flexible,flexible,1226,"> I couldn't think of a way to implement this as a forcing function before, but perhaps I could use a callback to update an auxiliary field with the tendencies of the particles, and then add this as a forcing function, although I imagine that could use a lot more memory if there were a large grid and small amount of particles. I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > although I imagine that could use a lot more memory if there were a large grid and small amount of particles. It seems the memory requirement of the forcing function approach is proportional to the number of _tracers_, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1248417125
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:1600,Availability,avail,available,1600," makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots more fields, but I see now that this is much less of an issue. Sorry about making this much more complicated than it should have been!. Edit: updated the gist example with how this can be implemented (requires PR #2733 branch)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:920,Deployability,integrat,integrate,920,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:2140,Deployability,update,updated,2140," makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots more fields, but I see now that this is much less of an issue. Sorry about making this much more complicated than it should have been!. Edit: updated the gist example with how this can be implemented (requires PR #2733 branch)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:920,Integrability,integrat,integrate,920,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:514,Modifiability,flexible,flexible,514,"> I'm still wondering about this solution, which may both be _more general_ (since users can effect arbitrary changes to tracer tendencies, not just source/sink terms) and is less heavy in the source code. Right now, this PR makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots mor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:1958,Performance,load,loads,1958," makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots more fields, but I see now that this is much less of an issue. Sorry about making this much more complicated than it should have been!. Edit: updated the gist example with how this can be implemented (requires PR #2733 branch)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1251870804:355,Integrability,rout,routine,355,"No worries @jagoosw ! This is a neat application!. It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1251870804
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194:317,Integrability,rout,routine,317,"Thanks!; > It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. > I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?. I suppose it might be useful to provide some functions like that to make it easier to implement. Possibly also the kernel function I put in the example gist and a wrapper like `force_nearest(particle_properties, tendency_field, particles, grid)` so there's an easy interface for people to add it to their particle dynamics function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194:515,Integrability,wrap,wrapper,515,"Thanks!; > It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. > I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?. I suppose it might be useful to provide some functions like that to make it easier to implement. Possibly also the kernel function I put in the example gist and a wrapper like `force_nearest(particle_properties, tendency_field, particles, grid)` so there's an easy interface for people to add it to their particle dynamics function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194:617,Integrability,interface,interface,617,"Thanks!; > It seems maybe that the function `get_mask` (or `nearest_cell_center`? If user facing we should come up with a good name) may nevertheless be a crucial part of any implementation, right?. > I suspect we still may want some source code features to support this application, but we may not need to add a new routine to modify the tendencies?. I suppose it might be useful to provide some functions like that to make it easier to implement. Possibly also the kernel function I put in the example gist and a wrapper like `force_nearest(particle_properties, tendency_field, particles, grid)` so there's an easy interface for people to add it to their particle dynamics function?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252314194
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856:16,Modifiability,refactor,refactoring,16,"Can we start by refactoring this PR to implement this functionality in an example script? It could perhaps go in [`validation/biogeochemistry`](https://github.com/CliMA/Oceananigans.jl/tree/main/validation/biogeochemistry). Once we have that cleaned up, we might be able to see what parts of it belong in the source code versus left to users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856:115,Security,validat,validation,115,"Can we start by refactoring this PR to implement this functionality in an example script? It could perhaps go in [`validation/biogeochemistry`](https://github.com/CliMA/Oceananigans.jl/tree/main/validation/biogeochemistry). Once we have that cleaned up, we might be able to see what parts of it belong in the source code versus left to users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856
https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856:195,Security,validat,validation,195,"Can we start by refactoring this PR to implement this functionality in an example script? It could perhaps go in [`validation/biogeochemistry`](https://github.com/CliMA/Oceananigans.jl/tree/main/validation/biogeochemistry). Once we have that cleaned up, we might be able to see what parts of it belong in the source code versus left to users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856
https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1238522691:8,Testability,benchmark,benchmark,8,"Can you benchmark compared to the (wrong, but ideal) version `dot(parent(a), parent(b))`. Ideally our implementation reaches that. That should work on GPU too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1238522691
https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1256412976:52,Availability,mask,masked,52,"I don't think it's a huge problem if we have fields masked to zero. Also, why is `dot(interior(a), interior(b))` not correct?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1256412976
https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1260787498:105,Availability,mask,masked,105,"> Also, why is dot(interior(a), interior(b)) not correct?. Won't this be incorrect if the fields are not masked? We have to explicitly exclude immersed regions when computing `dot` if masking is not guaranteed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1260787498
https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1260787498:184,Availability,mask,masking,184,"> Also, why is dot(interior(a), interior(b)) not correct?. Won't this be incorrect if the fields are not masked? We have to explicitly exclude immersed regions when computing `dot` if masking is not guaranteed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2725#issuecomment-1260787498
https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870:314,Availability,error,errors,314,That code allows two things that would not be possible with `maximum(parent(f.data))`. - it returns a `ReducedField` instead of an Array if `dims != :`; - it is possible to perform a conditional reduction which means that we can remove immersed cells from the reduction. It can be done in another way though if it errors... when do you find the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870
https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870:345,Availability,error,error,345,That code allows two things that would not be possible with `maximum(parent(f.data))`. - it returns a `ReducedField` instead of an Array if `dims != :`; - it is possible to perform a conditional reduction which means that we can remove immersed cells from the reduction. It can be done in another way though if it errors... when do you find the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870
https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870:103,Energy Efficiency,Reduce,ReducedField,103,That code allows two things that would not be possible with `maximum(parent(f.data))`. - it returns a `ReducedField` instead of an Array if `dims != :`; - it is possible to perform a conditional reduction which means that we can remove immersed cells from the reduction. It can be done in another way though if it errors... when do you find the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870
https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870:173,Performance,perform,perform,173,That code allows two things that would not be possible with `maximum(parent(f.data))`. - it returns a `ReducedField` instead of an Array if `dims != :`; - it is possible to perform a conditional reduction which means that we can remove immersed cells from the reduction. It can be done in another way though if it errors... when do you find the error?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237038870
https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237453100:23,Availability,error,error,23,"Oh... I was seeing the error in v0.76.8. I think it's fixed on `main` now... ```Julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size = (128, 1, 5), x = (-500, 500), y = (0, 1), z = (-400, 0), topology = (Bounded, Periodic, Bounded)); 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Bounded x ∈ [-500.0, 500.0] regularly spaced with Δx=7.8125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-400.0, 0.0] regularly spaced with Δz=80.0. julia> model = HydrostaticFreeSurfaceModel(; grid); HydrostaticFreeSurfaceModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on GPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (T, S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy with g=9.80665 and LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078) with -ĝ = ZDirection; ├── free surface: ImplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²; │ └── solver: FFTImplicitFreeSurfaceSolver; └── coriolis: Nothing. julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on GPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.0, min=0.0, mean=0.0. julia> maximum(model.velocities.u); 0.0. julia> maximum(abs, model.velocities.u); 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727#issuecomment-1237453100
https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238094553:34,Security,validat,validation,34,I ll try to produce a profile of `validation/elliptic_solvers/doubly_bounded_poisson.jl` with nsys and post it here,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238094553
https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238512157:47,Performance,perform,perform,47,Should we also expect the MG preconditioner to perform similarly to the FFT-based preconditioner? Those are relatively similar algorithms. How many CG iterations are we performing for either?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238512157
https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238512157:169,Performance,perform,performing,169,Should we also expect the MG preconditioner to perform similarly to the FFT-based preconditioner? Those are relatively similar algorithms. How many CG iterations are we performing for either?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2728#issuecomment-1238512157
https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1240862371:94,Energy Efficiency,sustainab,sustainable,94,"This is interesting. I like the concept of reusing the `scheme` kwarg. But I think this isn't sustainable given the future planned changes to the advection scheme API, right? Ie an ""advection scheme"" is going to be more comprehensive. Also, it doesn't make sense unless we are using vector invariant. Another possibility is to add another kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1240862371
https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1244089154:225,Testability,log,logic,225,"> Yes, I think we should probably put the high-order reconstructions in `Operators`. When we give an advection scheme to `scheme`, is there an assumption that we are using vector invariant? I'm still a little confused by the logic of the API. Maybe clarifying here will help?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1244089154
https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:272,Energy Efficiency,energy,energy,272,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272
https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:865,Modifiability,layers,layers,865,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272
https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:127,Performance,perform,performance,127,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272
https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:993,Usability,simpl,simple,993,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272
https://github.com/CliMA/Oceananigans.jl/issues/2730#issuecomment-1242314105:154,Testability,test,test,154,Just looked and this is actually implemented in `HydrostaticFreeSurfaceModels` just not in the other too. I'll change them and modify the multiple tracer test to use an auxiliary field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2730#issuecomment-1242314105
https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1252316466:18,Testability,test,test,18,Not sure why this test failed since I only changed some formatting,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1252316466
https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1252866889:24,Performance,load,load,24,Sometimes tests fail to load. Merely restarting them does the job. Did that. Let’s see.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1252866889
https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1252866889:10,Testability,test,tests,10,Sometimes tests fail to load. Merely restarting them does the job. Did that. Let’s see.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1252866889
https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1257455355:11,Deployability,update,updated,11,@jagoosw I updated the docstrings to mention auxiliary fields. I'll merge when tests pass. Thanks!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1257455355
https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1257455355:79,Testability,test,tests,79,@jagoosw I updated the docstrings to mention auxiliary fields. I'll merge when tests pass. Thanks!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2733#issuecomment-1257455355
https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244085315:47,Testability,test,test,47,"Not that I know of, so we should maybe write a test to check that it's correct?. Also, this code should use `Integral`:. https://github.com/CliMA/Oceananigans.jl/blob/13b7f2366726b3e52303dee67bab264941088554/src/AbstractOperations/metric_field_reductions.jl#L74",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244085315
https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244089259:77,Availability,error,error,77,I was trying to use Integral and was failing...! Will try again and post the error.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244089259
https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244763584:21,Safety,detect,detective,21,"OK, with the help of detective @glwagner we figured this out. The change that happened between those versions is that `with_halos = false` became the default in output writers. To post process saved buoyancy to compute $|\boldsymbol{\nabla} b|^2$ we *crucially* need the boundary conditions on $b$ to be correct in the HC example! Thus, saving output `with_halos = false` was not doing the job right... #2734 fixes this",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735#issuecomment-1244763584
https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1248734171:302,Performance,perform,performance,302,"> Shoudn't we write a kernel? Presumably that explicit 3D loop is incredibly slow?. Indeed! Unfortunately it's not embarrassingly parallel so my kernel skills are no longer sophisticated enough :) I don't know how to gather `count`, `rowval` or `colval`. The conditional preseumably also leads to poor performance (but no where near as poor as it is now!).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1248734171
https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1252872891:98,Performance,perform,performance,98,"@simone-silvestri any tips?. For conditionals, we should use `ifelse`; then there is no issue for performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1252872891
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1248631573:286,Performance,perform,performed,286,"@glwagner, @navidcy ; Poll to decide where to put `η` in `z`. . The possibilities are:; - location `Face`, index `grid.Nz+1`. Pros: natural location of `η` field (same position of the `w` velocity).; - location `Center`, index `grid.Nz`. Pros: every calculation dealing with `η` is now performed at centers (ex `Az_∇h²ᶜᶜᶜ` and `linear_operation!`. . In case of the second option should we change all the metrics to reflect the fact that we are at faces?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1248631573
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1257482155:250,Availability,down,down,250,"> @simone-silvestri, seems like the output writer is trying to save with halos despite `with_halos = false`. https://buildkite.com/clima/oceananigans/builds/8658#018376f6-45e7-4a9b-a40f-c9d5c76d5517/27-398; > ; > Is this a clue?. I tried to trace it down. What's happening is that . https://github.com/CliMA/Oceananigans.jl/blob/c08e3d8c1b2e6639a2726bc544885ebf8853e504/src/OutputWriters/netcdf_output_writer.jl#L423. returns a `data` as an array **with the halos** (wrongly probably) and then. https://github.com/CliMA/Oceananigans.jl/blob/c08e3d8c1b2e6639a2726bc544885ebf8853e504/src/OutputWriters/netcdf_output_writer.jl#L424. fallsback to . https://github.com/CliMA/Oceananigans.jl/blob/c08e3d8c1b2e6639a2726bc544885ebf8853e504/src/OutputWriters/netcdf_output_writer.jl#L489",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1257482155
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1257887145:199,Security,validat,validate,199,"You are right, I did something wrong with the output writers, I hadn't realized it is a problem of halos, I ll try to give a better look. The only thing that I had to change for output writers is to validate BC when non trivial indices are given as an argument. . That `view(field, indices...)` confused me though. I guess by changing that I had fields saved with halos?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1257887145
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258192897:464,Energy Efficiency,Reduce,ReducedField,464,"should be ready to go, the last details to address (but it's an easy change I can make quickly) are; 1) the location of the free surface; 2) the location and type of the right-hand side; 3) the location and type of the internal fields for the PCG. From what I understood we agreed on; 1) located at `Face`s on `grid.Nz+1` (I am a bit worried that this will give a problem in the outputs when we want to save the surface files with `indices = (:, :, grid.Nz)`; 2) `ReducedField` (location `Nothing`); 2) `ReducedField`s (location `Nothing`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258192897
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258192897:504,Energy Efficiency,Reduce,ReducedField,504,"should be ready to go, the last details to address (but it's an easy change I can make quickly) are; 1) the location of the free surface; 2) the location and type of the right-hand side; 3) the location and type of the internal fields for the PCG. From what I understood we agreed on; 1) located at `Face`s on `grid.Nz+1` (I am a bit worried that this will give a problem in the outputs when we want to save the surface files with `indices = (:, :, grid.Nz)`; 2) `ReducedField` (location `Nothing`); 2) `ReducedField`s (location `Nothing`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258192897
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258288022:11,Testability,test,test,11,Is there a test or example that saves output of the free surface? Perhaps that will sort out your concern at 1. above @simone-silvestri?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1258288022
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1259660901:15,Testability,test,tests,15,I think if the tests pass we are ready to merge,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1259660901
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1262814827:21,Testability,test,test,21,"We should have a new test or two for the ""index computation"", right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1262814827
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1262822892:156,Testability,test,test,156,"Here's some ideas:. ```julia; grid = RectilinearGrid(size=(4, 5, 6), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid, indices = (2, :, :)); @test indices(a * b) == (2:2, :, :). # repeat for y and z slices?. c = CenterField(grid); d = XFaceField(grid, indices=(2:3, :, :)); @test indices(c * d) == (3:3, :, :) # right?. # repeat for y and z...; ```. Those, plus maybe some tests for `UnaryOperation`, etc, cover the non-trivial cases I can think of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1262822892
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1262822892:289,Testability,test,test,289,"Here's some ideas:. ```julia; grid = RectilinearGrid(size=(4, 5, 6), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid, indices = (2, :, :)); @test indices(a * b) == (2:2, :, :). # repeat for y and z slices?. c = CenterField(grid); d = XFaceField(grid, indices=(2:3, :, :)); @test indices(c * d) == (3:3, :, :) # right?. # repeat for y and z...; ```. Those, plus maybe some tests for `UnaryOperation`, etc, cover the non-trivial cases I can think of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1262822892
https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1262822892:387,Testability,test,tests,387,"Here's some ideas:. ```julia; grid = RectilinearGrid(size=(4, 5, 6), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid, indices = (2, :, :)); @test indices(a * b) == (2:2, :, :). # repeat for y and z slices?. c = CenterField(grid); d = XFaceField(grid, indices=(2:3, :, :)); @test indices(c * d) == (3:3, :, :) # right?. # repeat for y and z...; ```. Those, plus maybe some tests for `UnaryOperation`, etc, cover the non-trivial cases I can think of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1262822892
https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252620822:405,Deployability,update,update,405,"Hi @simone-silvestri ; Thank for the suggestion.; I see the change in `flat_advective_fluxes`. I will do some test to see if I can reproduce my previous result. ; However, I think it is quite weird to keep other terms without the advection. Why don't we turn off whole u momentum calculation? Also, I think several examples still treat `flat` as a flat periodic boundary (e.g., Tilted BBL). . @glwagner I update the grid layout in the main text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252620822
https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252620822:110,Testability,test,test,110,"Hi @simone-silvestri ; Thank for the suggestion.; I see the change in `flat_advective_fluxes`. I will do some test to see if I can reproduce my previous result. ; However, I think it is quite weird to keep other terms without the advection. Why don't we turn off whole u momentum calculation? Also, I think several examples still treat `flat` as a flat periodic boundary (e.g., Tilted BBL). . @glwagner I update the grid layout in the main text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252620822
https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252888555:399,Usability,intuit,intuitive,399,"The traditional 2.5D model retains $\partial_y vu + \partial_z wu$. Even in a QG setup, background field advection is still important. ; `flat` in the previous version means no variation in the `flat` direction but it now assumes no momentum flux variation in all directions for the `flat` direction velocity. . That's why I don't think turning off $\nabla \cdot \vec{u} u$ as `flat` default is GFD intuitive. Especially, it is not clearly indicated in the documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252888555
https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252888555:432,Usability,clear,clearly,432,"The traditional 2.5D model retains $\partial_y vu + \partial_z wu$. Even in a QG setup, background field advection is still important. ; `flat` in the previous version means no variation in the `flat` direction but it now assumes no momentum flux variation in all directions for the `flat` direction velocity. . That's why I don't think turning off $\nabla \cdot \vec{u} u$ as `flat` default is GFD intuitive. Especially, it is not clearly indicated in the documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2742#issuecomment-1252888555
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:184,Availability,error,error,184,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:334,Availability,avail,available,334,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:429,Availability,error,error,429,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:457,Availability,error,error,457,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:532,Availability,error,error-messages,532,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:603,Availability,error,error,603,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:644,Availability,avail,available,644,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:782,Availability,error,error,782,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:304,Energy Efficiency,reduce,reduce,304,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:695,Energy Efficiency,Reduce,Reduce,695,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:190,Integrability,message,message,190,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:463,Integrability,message,messages,463,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367:538,Integrability,message,messages,538,"Hmmm, interesting. I found the same problem on a 1/12 degree global ocean when using several `maximum` in a progress function (I also have a stretched immersed grid). . Looking at the error message, and the size of my simulation I thought it was just a problem with the size of the field I was trying to reduce that was exceeding the available cuda threads, so I haven't given it a second thought. . This because in general that error means ([handling CUDA error messages](http://cuda-programming.blogspot.com/2013/01/handling-cuda-error-messages.html)); `Too Many Resources Requested for Launch - This error means that the number of registers available on the multiprocessor is being exceeded. Reduce the number of threads per block to solve the problem.`. But if you get the same error for that small grid, it must mean that it is not a problem with the size of the field, but we are doing something funky with stretched reductions on immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255153367
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:3786,Availability,avail,available,3786," data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated`; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:3824,Deployability,upgrade,upgraded,3824," data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated`; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:2826,Energy Efficiency,Adapt,Adapt,2826,": ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:487,Modifiability,variab,variably,487,"hmmm I cannot reproduce the bug; ```; julia> underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> . julia> . julia> const H_deep = H = underlying_grid.Lz; 2.9999999999999996. julia> const H_shelf = h = 0.5; 0.5. julia> const width_shelf = 100; 100. julia> . julia> shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); shelf (generic function with 1 method). julia> bathymetry(x, y) = shelf(x, y); bathymetry (generic function with 1 method). julia> . julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-2.99e+00, max(h)=0.00e+00); ├── underlying_grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = XFaceField(grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:1435,Modifiability,variab,variably,1435,"y=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> . julia> . julia> const H_deep = H = underlying_grid.Lz; 2.9999999999999996. julia> const H_shelf = h = 0.5; 0.5. julia> const width_shelf = 100; 100. julia> . julia> shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); shelf (generic function with 1 method). julia> bathymetry(x, y) = shelf(x, y); bathymetry (generic function with 1 method). julia> . julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-2.99e+00, max(h)=0.00e+00); ├── underlying_grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = XFaceField(grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:2826,Modifiability,Adapt,Adapt,2826,": ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:3623,Testability,Log,Logging,3623," data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0; ```; I am using ; ```; (Oceananigans) pkg> st; Project Oceananigans v0.77.4; Status `~/stable_oceananigans/Oceananigans.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.4.0; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.12.0; ⌃ [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; ⌅ [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; ⌃ [033835bb] JLD2 v0.4.22; ⌅ [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.7; [6fe1bfb0] OffsetArrays v1.12.7; [bac558e1] OrderedCollections v1.4.1; ⌃ [0e08944d] PencilArrays v0.17.6; [4a48f351] PencilFFTs v0.14.1; ⌃ [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.12; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics; Info Packages marked with ⌃ and ⌅ have new versions available, but those with ⌅ cannot be upgraded. To see why use `status --outdated`; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:120,Availability,Error,Error,120,"but I get it with a `Nothing` field in the z direction weirdly; ```; julia> u = Field((Center, Center, Nothing), grid); Error showing value of type Field{Center, Center, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:1505,Availability,ERROR,ERROR,1505,"Vector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:1517,Availability,error,error,1517,"Vector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:1715,Availability,error,error,1715,"ay{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CUDA.CuDeviceArray{Float64, 4, 1}, ::Oceananigans.Ab",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:1792,Availability,error,error,1792,"ffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA ~/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ ~/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CUDA.CuDeviceArray{Float64, 4, 1}, ::Oceananigans.AbstractOperations.ConditionalOperation{Center, Center, Nothing, Field{Center, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:20098,Availability,mask,mask,20098,"Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}; condition::Nothing, mask::Float64, kwargs::Base.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:init,), Tuple{Bool}}}); @ Oceananigans.Fields ~/stable_oceananigans/Oceananigans.jl/src/Fields/field.jl:581; [24] maximum(f::Function, c::Field{Center, Center, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:21688,Availability,mask,mask,21688,"{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/stable_oceananigans/Oceananigans.jl/src/Fields/field.jl:611; [25] maximum; @ ~/stable_oceananigans/Oceananigans.jl/src/Fields/field.jl:600 [inlined]; [26] #maximum#36; @ ~/stable_oceananigans/Oceananigans.jl/src/Fields/field.jl:620 [inlined]; [27] maximum; @ ~/stable_oceananigans/Oceananigans.jl/src/Fields/field.jl:620 [inlined]; [28] data_summary(field::Field{Center, Center, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806:16605,Energy Efficiency,reduce,reducedim,16605,"ffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}); @ GPUArrays ~/.julia/packages/GPUArrays/fqD8z/src/host/mapreduce.jl:10; [22] #maximum!#803; @ ./reducedim.jl:1018 [inlined]; [23] maximum!(f::Function, r::Field{Nothing, Nothing, Nothing, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658806
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:920,Deployability,Configurat,Configuration,920,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1410,Deployability,Configurat,Configuration,1410,"chitectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:583,Modifiability,variab,variable,583,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:624,Modifiability,config,config,624,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:684,Modifiability,config,config,684,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:720,Modifiability,Config,Config,720,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:920,Modifiability,Config,Configuration,920,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1073,Modifiability,variab,variable,1073,"different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1114,Modifiability,config,config,1114,"different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1174,Modifiability,config,config,1174," Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1210,Modifiability,Config,Config,1210,"inition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1410,Modifiability,Config,Configuration,1410,"chitectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:2380,Modifiability,variab,variably,2380,"ed MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = Field{Face, Center, Center}(rectilinear_grid); 128×128×64 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> maximum(abs, u); 0.0. julia> v = Field{Center, Face, Center}(rectilinear_grid); 128×129×64 Field{Center, Face, Center} on RectilinearGrid on GPU; ├── grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262504148:39,Availability,error,error,39,"I can confirm that I can reproduce the error using the MWE [here](https://github.com/CliMA/Oceananigans.jl/issues/2744#issue-1381826641) with CUDA 3.12. As with #2756, the same snippet appears to run fine with CUDA 3.9 though. Should we open an issue on CUDA.jl?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262504148
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:98,Availability,error,error,98,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:233,Availability,error,error,233,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:666,Availability,mask,mask,666,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:717,Availability,mask,mask,717,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:1399,Availability,error,error,1399,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906:314,Integrability,wrap,wrap,314,"I am not sure about CUDA.jl, if you try `maximum(abs, interior(w))` or `maximum(abs, w.data)` the error disappears. It must be something that lies in our implementation. We should first isolate all the conditions that lead to a code error before posting an issue. When we do a reduction over an immersed field, we wrap the field in a `ConditionalOperation`, in this case with condition `NotImmersed((i, j, k, grid) -> true)`.; a conditional operation has a `getindex` which is defined as; ```; @inline function Base.getindex(c::ConditionalOperation, i, j, k) ; return ifelse(get_condition(c.condition, i, j, k, c.grid, c), ; c.func(getindex(c.operand, i, j, k)),; c.mask); end; ```; and in this particular case, the `mask` in `-Inf` and `get_condition` is defined as; ```; @inline function get_condition(condition::NotImmersed, i, j, k, ibg, co::ConditionalOperation, args...); LX, LY, LZ = location(co); return get_condition(condition.func, i, j, k, ibg, args...) & !(immersed_peripheral_node(i, j, k, ibg, LX(), LY(), LZ())); end ; ```; (where `condition.func` always evaluates to `true`); In practice, what is happening is that where `get_condition` evaluates to `false`, the `getindex` returns `-Inf` instead of the value. ; What worries me here, is that there is an evaluation of `immersed_peripheral_node`. This is the only difference I can notice with a non-immersed field. The fact that the error appears only with specific locations makes me believe that the evaluation of `immersed_peripheral_node` might be the source of the problem.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1262535906
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807:625,Modifiability,variab,variably,625,"> Is this still an issue?. Apparently not anymore. I just tested @navidcy 's MWE are everything seems to work fine (on a Quadro GPU and CUDA 3.12 on `main`):. ```julia; julia> grid; 150×150×12 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=5.00e+01, max(h)=5.00e+01); ├── underlying_grid: 150×150×12 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-200.0, 200.0) regularly spaced with Δx=2.66667; ├── Periodic y ∈ [-200.0, 200.0) regularly spaced with Δy=2.66667; └── Bounded z ∈ [0.0, 100.0] variably spaced with min(Δz)=8.33333, max(Δz)=8.33333. julia> maximum(abs, u); 0.0. julia> maximum(abs, w); 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807
https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807:58,Testability,test,tested,58,"> Is this still an issue?. Apparently not anymore. I just tested @navidcy 's MWE are everything seems to work fine (on a Quadro GPU and CUDA 3.12 on `main`):. ```julia; julia> grid; 150×150×12 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=5.00e+01, max(h)=5.00e+01); ├── underlying_grid: 150×150×12 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-200.0, 200.0) regularly spaced with Δx=2.66667; ├── Periodic y ∈ [-200.0, 200.0) regularly spaced with Δy=2.66667; └── Bounded z ∈ [0.0, 100.0] variably spaced with min(Δz)=8.33333, max(Δz)=8.33333. julia> maximum(abs, u); 0.0. julia> maximum(abs, w); 0.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1319159807
https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527:43,Modifiability,variab,variable,43,"That was used for smoothness indicators on variable grids (the previous `stretched_smoothness` in `WENO5(grid = grid, stretched_smoothness=true)`). I temporarily removed that keyword because it assumed that WENO was order 5. (also we weren't using it because it made everything quite slow). I had the plan to reintroduce it with the upcoming advection refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527
https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527:352,Modifiability,refactor,refactor,352,"That was used for smoothness indicators on variable grids (the previous `stretched_smoothness` in `WENO5(grid = grid, stretched_smoothness=true)`). I temporarily removed that keyword because it assumed that WENO was order 5. (also we weren't using it because it made everything quite slow). I had the plan to reintroduce it with the upcoming advection refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527
https://github.com/CliMA/Oceananigans.jl/issues/2748#issuecomment-1256192855:61,Testability,test,test,61,It should have been fixed in kernel abstractions. We have to test multi GPU without it and then we can remove it,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2748#issuecomment-1256192855
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1257255335:242,Modifiability,variab,variables,242,"I agree we can make the functions a little more verbose in that sense. ; We can change `calc_ κᶜᶜᶜ` to `calc_nonlinear_ κᶜᶜᶜ` and `calc_νᶜᶜᶜ` to `calc_nonlinear_νᶜᶜᶜ`. ; (`κᶜᶜᶜ` does not exist because diffusivity is needed at faces). For the variables we can make them verbose or agree to have a _concise_ naming convention (parallel to the verbose one) that is always consistent (i.e., `U` is `velocities`, `C` is `tracers`, `b` is `bouyancy` and so on)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1257255335
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686:153,Integrability,interface,interface,153,"I'm not sure that this kind of function should be defined for all closures (not all closures even have a diffusivity). If we want to have a more uniform interface, I'd focus on `AbstractScalarDiffusivity` which is specific to closures with a single scalar diffusivity. I think there is already an interface there too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686:297,Integrability,interface,interface,297,"I'm not sure that this kind of function should be defined for all closures (not all closures even have a diffusivity). If we want to have a more uniform interface, I'd focus on `AbstractScalarDiffusivity` which is specific to closures with a single scalar diffusivity. I think there is already an interface there too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260780686
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:461,Integrability,interface,interface,461,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:550,Integrability,interface,interface,550,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:640,Integrability,interface,interface,640,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:812,Integrability,interface,interface,812,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:885,Integrability,interface,interface,885,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400:616,Usability,clear,clear,616,"These functions do not all have the same purpose. Functions like `νᶜᶜᶜ`, which are defined starting here:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L80. are designed to return the diffusivity at the specific index `i, j, k` and location `ᶜᶜᶜ`, given a closure and possibly _precalculated_ diffusivity fields. `calc_κᶜᶜᶜ` pertains to the precalculation itself, which is associated with the interface function `calculate_diffusivities!`. As you've noted, there is no standardized interface for _precalculating_ diffusivities --- because it's not clear what purpose that interface would serve. Therefore, for convenience, closures are allowed to use any code they like to precalculate the diffusivity. @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260785400
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342:54,Integrability,interface,interface,54,"I have a practical example that might demand a better interface for `calculate_diffusivities!` (or at least defining it for `ScalarDiffusivities`). I am now using quite complex formulations to calculate the viscosity for `ScalarBiharmonicDiffusivity`. Because of the staggering of the variables, the viscosity can only be calculated at `Center`s; I am using now `DiscreteDiffusionFunction`, which interpolates my formulation to the desired location in space.; This is very inefficient because I am recomputing the expensive viscosity multiple times in the same place.; It would be nice to have an option to have a precomputed diffusivity also in case of a `ScalarDiffusivity`, but provide the function to calculate the diffusivity as it is now done for `DiscreteDiffusionFunction`.; This would allow the code to be way more personalizable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342:285,Modifiability,variab,variables,285,"I have a practical example that might demand a better interface for `calculate_diffusivities!` (or at least defining it for `ScalarDiffusivities`). I am now using quite complex formulations to calculate the viscosity for `ScalarBiharmonicDiffusivity`. Because of the staggering of the variables, the viscosity can only be calculated at `Center`s; I am using now `DiscreteDiffusionFunction`, which interpolates my formulation to the desired location in space.; This is very inefficient because I am recomputing the expensive viscosity multiple times in the same place.; It would be nice to have an option to have a precomputed diffusivity also in case of a `ScalarDiffusivity`, but provide the function to calculate the diffusivity as it is now done for `DiscreteDiffusionFunction`.; This would allow the code to be way more personalizable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940:43,Integrability,interface,interface,43,"> @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?. The specific purpose atm is to make this code on Oceanostics work (currently it does not):; https://github.com/tomchor/Oceanostics.jl/blob/29a544d3decd833d9f86da05b66a7392197c3b93/src/Oceanostics.jl#L25-L39. The bigger purpose is to make it easier for users to work with viscosities and diffusivities. As far as I know there isn't a unified interface to getting these fields. I've needed that many times in the past in my scripts and had to use `if-else` statements to get ν and κ for each closure. I think it'd help users if Oceananigans could provide a standard interface for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940:116,Integrability,interface,interface,116,"> @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?. The specific purpose atm is to make this code on Oceanostics work (currently it does not):; https://github.com/tomchor/Oceanostics.jl/blob/29a544d3decd833d9f86da05b66a7392197c3b93/src/Oceanostics.jl#L25-L39. The bigger purpose is to make it easier for users to work with viscosities and diffusivities. As far as I know there isn't a unified interface to getting these fields. I've needed that many times in the past in my scripts and had to use `if-else` statements to get ν and κ for each closure. I think it'd help users if Oceananigans could provide a standard interface for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940:469,Integrability,interface,interface,469,"> @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?. The specific purpose atm is to make this code on Oceanostics work (currently it does not):; https://github.com/tomchor/Oceanostics.jl/blob/29a544d3decd833d9f86da05b66a7392197c3b93/src/Oceanostics.jl#L25-L39. The bigger purpose is to make it easier for users to work with viscosities and diffusivities. As far as I know there isn't a unified interface to getting these fields. I've needed that many times in the past in my scripts and had to use `if-else` statements to get ν and κ for each closure. I think it'd help users if Oceananigans could provide a standard interface for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940:692,Integrability,interface,interface,692,"> @tomchor, are you proposing to define an interface for _precalculating_ diffusivities? What's the purpose of that interface?. The specific purpose atm is to make this code on Oceanostics work (currently it does not):; https://github.com/tomchor/Oceanostics.jl/blob/29a544d3decd833d9f86da05b66a7392197c3b93/src/Oceanostics.jl#L25-L39. The bigger purpose is to make it easier for users to work with viscosities and diffusivities. As far as I know there isn't a unified interface to getting these fields. I've needed that many times in the past in my scripts and had to use `if-else` statements to get ν and κ for each closure. I think it'd help users if Oceananigans could provide a standard interface for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261024940
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1653,Availability,down,down,1653,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:2303,Energy Efficiency,reduce,reduces,2303,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:808,Integrability,interface,interface,808,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1226,Integrability,interface,interface,1226,"ind the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1529,Integrability,interface,interface,1529,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:1751,Integrability,interface,interface,1751,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:2209,Security,expose,exposes,2209,"on for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would then cover cases like `AnisotropicMinimumDissipation`, and move the free parameters associated with AMD from the turbulence closure struct into the viscosity struct. The first design is ""flatter"", and therefore exposes data like free parameters a bit more. The second design is more ""hierarchical"", which reduces boilerplate but is a little bit more complex. That's the trade-off I see.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:532,Usability,simpl,simple,532,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943:801,Usability,simpl,simple,801,"Well, I agree this is a discussion worth having. Users need not add a new turbulence closure in the source code --- they can be added externally (eg in a model script) easily via multiple dispatch. We've illustrated this before, but I can't find the issue (the closest is discussion https://github.com/CliMA/Oceananigans.jl/discussions/2344). > we need a computationally feasible option for our more adventurous users that want to experiment with new viscosities/diffusivities. Is the issue about what we define as ""feasible""? It's simple to add a new struct with a custom `calculate_diffusivities!`. I agree though that this could result in more boilerplate. So, the difference is really just ""how much code"" one needs to write to get to a custom `calculate_diffusivities!`. I think I would prefer a simple interface that allows users to dispatch on the type of `closure.ν`, ie something like. ```julia; calculate_diffusivities!(diffusivities, closure::ScalarDiffusivity, args...) =; calculate_diffusivities!(closure.ν, closure.κ, diffusivities, closure, args...) =; ```. Then if users have special viscosities that require computation, they can define a custom `calculate_diffusivities!(ν::MyCustomViscosity, ...)`. Another interface could un-comment these fields:. https://github.com/CliMA/Oceananigans.jl/blob/1a288c175d07b3d4262e965c7e75376d5541e24d/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L117-L121. and then users can define fields with custom `compute!` definitions. If we have an interface like the one above, we may not need a separate struct for `AnisotropicMinimumDissipation` at all. It really boils down to where we put information about the closure, such as free parameters. Right now we have an interface that encourages a new struct that subtypes `AbstractScalarDiffusivity`. An alternative is to do away with ""abstract"" scalar diffusivity, and generalize the concrete `ScalarDiffusivity` to any computed viscosity / diffusivity. This would the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261037943
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114:41,Integrability,interface,interface,41,"> As far as I know there isn't a unified interface to getting these fields. The interface for `AbstractScalarDiffusivity` is the function `viscosity(closure, diffusivities)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114
https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114:80,Integrability,interface,interface,80,"> As far as I know there isn't a unified interface to getting these fields. The interface for `AbstractScalarDiffusivity` is the function `viscosity(closure, diffusivities)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483:279,Integrability,interface,interfaces,279,"> We could also just change the signature of the `calc_` functions to pass all the fields instead of just velocities and tracers separately `fields(model)`. Yeah I like that idea. Also, is there anything that keeps us from passing `model` itself? It seems like it'd simplify the interfaces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483:266,Usability,simpl,simplify,266,"> We could also just change the signature of the `calc_` functions to pass all the fields instead of just velocities and tracers separately `fields(model)`. Yeah I like that idea. Also, is there anything that keeps us from passing `model` itself? It seems like it'd simplify the interfaces",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258413483
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517:12,Energy Efficiency,adapt,adapt,12,There is no adapt method for the model. I don't know how it would play to send the whole model to the GPU. We might have some parameter space issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517:12,Modifiability,adapt,adapt,12,There is no adapt method for the model. I don't know how it would play to send the whole model to the GPU. We might have some parameter space issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1265545180:143,Testability,test,tests,143,"I was thinking we could change `viscosity()` and `diffusivity()` to account for the different (vertical, horizontal and 3D) formulations (with tests for it, ofc). In that way `viscosity()` would return, for example, `[v, v, 0]` for a horizontal formulation, `[0, 0, v]` for a vertical formulation, and a `Number` v for a 3D formulation. I think this would be desirable from the user's perspective and it would make diagnostics easier when non-3D formulations are used. Based on @glwagner's comments I was also going to remove the extra definition of `calc_κccc()` for Smagorinsky that's currently in this PR. However, I noticed this breaks some internal functions. Before I go ahead and fix those, I wanted to check if this changed is desirable from the developers' perspective. @glwagner @simone-silvestri what do you guys think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1265545180
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1266041565:456,Usability,simpl,simple,456,"> I see. It would be nice to have this as a user API convenience, but then to be complete we must include all the other entries of the tensor. It might get a bit tedious when you want to include isopycnal diffusivities like `TwoDimensionalLeith` or GM (`IsopycnalSkewSymmetricDiffusivity`) for which we do not compute the tensor but directly the flux. I think the other tensor entries are much less frequently needed, so I'd propose we start only with the simple stuff and add the rest when needed. I was also thinking that for inner-working purposes it's best to keep the current `viscosity()` behavior (always returning a 'Number`) and create a second function that can be exported to the user which has the array behavior I described. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1266041565
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938:393,Integrability,interface,interface,393,"> Why is a vector that represents the diagonal elements of a hypothetical viscosity tensor useful?. Because I think most of the tuple closures used are `(HorizontalDiffusivity, VerticalDiffusivity)`, where the diagonal is what you need. Although that intuition might be wrong. But most of the reason for my attempted changes to `viscosity()` here is that apparently [`viscosity()` is the user interface to retrieve the viscosities regardless of closure](https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114). However, if a user uses that in the example below, the output isn't correct considering the physics:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> closure = (HorizontalScalarDiffusivity(ν=1), VerticalScalarDiffusivity(ν=2));. julia> model = NonhydrostaticModel(grid=grid, closure=closure);. julia> using Oceananigans.TurbulenceClosures: viscosity. julia> viscosity(model.closure, model.diffusivity_fields); 3.0; ```. Maybe the best way to move forward isn't to change `viscosity()`, but IMO a user-facing function to get viscosities that works as expected (i.e., returns something like `[1, 1, 2]` in the above example) would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938:251,Usability,intuit,intuition,251,"> Why is a vector that represents the diagonal elements of a hypothetical viscosity tensor useful?. Because I think most of the tuple closures used are `(HorizontalDiffusivity, VerticalDiffusivity)`, where the diagonal is what you need. Although that intuition might be wrong. But most of the reason for my attempted changes to `viscosity()` here is that apparently [`viscosity()` is the user interface to retrieve the viscosities regardless of closure](https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1261039114). However, if a user uses that in the example below, the output isn't correct considering the physics:. ```julia; julia> grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1));. julia> closure = (HorizontalScalarDiffusivity(ν=1), VerticalScalarDiffusivity(ν=2));. julia> model = NonhydrostaticModel(grid=grid, closure=closure);. julia> using Oceananigans.TurbulenceClosures: viscosity. julia> viscosity(model.closure, model.diffusivity_fields); 3.0; ```. Maybe the best way to move forward isn't to change `viscosity()`, but IMO a user-facing function to get viscosities that works as expected (i.e., returns something like `[1, 1, 2]` in the above example) would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1271046814:1370,Usability,simpl,simple,1370,"I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor. That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that. The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can be used in subsequent `AbstractOperations`. When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction. We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures. To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1271046814
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541:1830,Availability,error,error,1830,"> I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and far more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor.; > ; > That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that.; > ; > The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can then be used in subsequent `AbstractOperations` for calculations.; > ; > When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction.; > ; > We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures.; > ; > To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully). I agree with this. I'll revert `viscosity()` to its original formulation for now. My only question/suggestion is: should we check in `viscosity(::Tuple)` that the all the elements have the same formulation? That way we can throw a warning (or maybe even an error) when trying to add different formulation closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541:1433,Usability,simpl,simple,1433,"> I think what I'm asking is what you envision using this vector for. I don't see the purpose of it. One could just as easily inspect each closure in the tuple individually to see what the viscosity for each closure type is. This method is unambiguous and far more general than developing a ""vector abstraction"" for the diagonal components of a viscosity tensor.; > ; > That said, I agree that the output of `viscosity` for a closure tuple isn't useful. It's summing the viscosities together. This makes sense when the formulations are the same for each component, but not when they are different. So we should change that.; > ; > The main use case envisioned is when you have two `ScalarDiffusivity` with `ThreeDimensionalFormulation`. In that case, `viscosity` returns an object (a `BinaryOperation`) representing the sum of a the nonlinear diffusivity (a field) and the background molecular component (a number). This can then be used in subsequent `AbstractOperations` for calculations.; > ; > When the closure tuple involves multiple `ScalarDiffusivity` with heterogeneous formulations, we need a different abstraction.; > ; > We also need to deal with the case where the closure tuple contains non-scalar-diffusivity closures.; > ; > To design an abstraction, I think we should start with a use case, which can help us develop requirements for the abstraction. Once we have requirements, we can implement something minimal and simple that's easy to reason with and that will generalize to more complicated use cases we may want to consider in the future (hopefully). I agree with this. I'll revert `viscosity()` to its original formulation for now. My only question/suggestion is: should we check in `viscosity(::Tuple)` that the all the elements have the same formulation? That way we can throw a warning (or maybe even an error) when trying to add different formulation closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1272625541
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1315578507:88,Integrability,interface,interface,88,"I think the main issue here is that there is too much code, reflecting the fact that an interface for defining closures has emerged over time rather than being designed from the ground up. It could possibly benefit from a rethink. It's not as much an issue of the names of things in my opinion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1315578507
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398498518:485,Availability,error,error,485,"@glwagner this almost became stale but I think it's ready to review and possibly merge. It doesn't re-work the code like you suggest [here](https://github.com/CliMA/Oceananigans.jl/pull/2752/#issuecomment-1315578507), but it does make the functions more easily understandable on first pass by being more verbose. . It also changes the behavior of `viscosity()` and `diffusivity()`, which no longer sum over all individual closures by default when the closure is a tuple, avoiding user error (as you suggested [here](https://github.com/CliMA/Oceananigans.jl/pull/2752/#issuecomment-1273620776)). Finally it also changes the function `calc_κᶜᶜᶜ` ro `calc_nonlinear_κᶜᶜᶜ` in order to differentiate from `κᶜᶜᶜ`. Although I'm agnostic about the name and could change it to anything else. This PR used to also remove a fallback that was a bit problematic because it silently returned zero diffusivity values for closures like Smagorinsky, but it seems some other PR got around to that first before merging this one :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398498518
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398498518:471,Safety,avoid,avoiding,471,"@glwagner this almost became stale but I think it's ready to review and possibly merge. It doesn't re-work the code like you suggest [here](https://github.com/CliMA/Oceananigans.jl/pull/2752/#issuecomment-1315578507), but it does make the functions more easily understandable on first pass by being more verbose. . It also changes the behavior of `viscosity()` and `diffusivity()`, which no longer sum over all individual closures by default when the closure is a tuple, avoiding user error (as you suggested [here](https://github.com/CliMA/Oceananigans.jl/pull/2752/#issuecomment-1273620776)). Finally it also changes the function `calc_κᶜᶜᶜ` ro `calc_nonlinear_κᶜᶜᶜ` in order to differentiate from `κᶜᶜᶜ`. Although I'm agnostic about the name and could change it to anything else. This PR used to also remove a fallback that was a bit problematic because it silently returned zero diffusivity values for closures like Smagorinsky, but it seems some other PR got around to that first before merging this one :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398498518
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398858625:27,Testability,test,tests,27,"Ok, I will review! Except, tests are failing? Also should we merge main?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398858625
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398871899:29,Testability,test,tests,29,"> Ok, I will review! Except, tests are failing? Also should we merge main?. Thanks!. And yeah there was a typo in my last commit but it should be fixed as tests should be passing. I also merged main in commit [479056a](https://github.com/CliMA/Oceananigans.jl/pull/2752/commits/479056a24db8e510ba057ff79df82f567f85c03a) (yesterday) so we should be good regarding that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398871899
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398871899:155,Testability,test,tests,155,"> Ok, I will review! Except, tests are failing? Also should we merge main?. Thanks!. And yeah there was a typo in my last commit but it should be fixed as tests should be passing. I also merged main in commit [479056a](https://github.com/CliMA/Oceananigans.jl/pull/2752/commits/479056a24db8e510ba057ff79df82f567f85c03a) (yesterday) so we should be good regarding that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1398871899
https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1399749130:10,Testability,Test,Tests,10,@glwagner Tests are passing now!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1399749130
https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1257971702:44,Testability,benchmark,benchmarks,44,"Yeap, N is horizontal resolution. These are benchmarks for the baroclinic adjustment problem with hydrostatic free-surface model. Elise wants to run now some 1/4-degree near-global benches. What's the ""high-resolution problem""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1257971702
https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1257981531:255,Performance,perform,performance,255,"The preconditioner we used at high resolution is an asymptotic approximation of the inverse matrix that assumes that the original matrix is diagonally dominant. This is an increasingly worst approximation as you increase the resolution, deteriorating the performance when cells size is decreased",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1257981531
https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258832262:195,Performance,perform,performance,195,Thanks Simone! So I guess [this line](https://github.com/CliMA/Oceananigans.jl/blob/edef0fc49a1019bfba093ffa1c0bcce23535ac41/src/Solvers/sparse_preconditioners.jl#L70) explains why we only see a performance increase on GPU? I don't understand why ILU is hard to parallelise - would you mind explaining this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258832262
https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258929817:24,Usability,clear,clear,24,Thank you! That is very clear. Could you also please point me in the direction of a resourse to understand the asymptotic diagonal approximation of the inverse?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258929817
https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258975772:374,Testability,test,tests,374,"> I'm wondering why the mg preconditioner seems to have almost no effect on the heptadiagonal solver on CPU. I think this just means the multigrid preconditioning is very similar to the ILU preconditioning that is the default for the heptadigagonal solver on CPU. I believe it would outperform a non preconditioned conjugate gradient solver, perhaps I should also run those tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1258975772
https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259433162:26,Usability,clear,clear,26,> Thank you! That is very clear. Could you also please point me in the direction of a resourse to understand the asymptotic diagonal approximation of the inverse?. It is not well documented actually. You can find some (albeit simple) explanation here https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/96JC02775. There is also an explanation in the docstrings,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259433162
https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259433162:226,Usability,simpl,simple,226,> Thank you! That is very clear. Could you also please point me in the direction of a resourse to understand the asymptotic diagonal approximation of the inverse?. It is not well documented actually. You can find some (albeit simple) explanation here https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/96JC02775. There is also an explanation in the docstrings,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259433162
https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259599032:152,Testability,test,tests,152,"Looks good to me! I was thinking of doing a cleaning and unifying of all the implicit solvers, but we can think about that later. We can merge when the tests pass.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2753#issuecomment-1259599032
https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044:10,Energy Efficiency,reduce,reduce,10,Does this reduce performance or is the effect negligible? (Just curious.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044
https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044:17,Performance,perform,performance,17,Does this reduce performance or is the effect negligible? (Just curious.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044
https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615:76,Deployability,configurat,configurations,76,looking at the benchmarks in #2335 it seems that it does. But only for some configurations,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615
https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615:76,Modifiability,config,configurations,76,looking at the benchmarks in #2335 it seems that it does. But only for some configurations,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615
https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615:15,Testability,benchmark,benchmarks,15,looking at the benchmarks in #2335 it seems that it does. But only for some configurations,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615
https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261427135:28,Integrability,depend,depends,28,It's very plausible that it depends on CUDA and also Julia version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261427135
https://github.com/CliMA/Oceananigans.jl/issues/2756#issuecomment-1261674659:52,Availability,error,error,52,"Indeed, these elements seem to be necessary for the error to occur:; - Immersed grid; - Stretched coordinate",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756#issuecomment-1261674659
https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1263713946:188,Modifiability,extend,extend,188,"I decoupled the high-order reconstructions from the low-order interpolations. ; The reconstruction for advective fluxes are in `Advection/reconstruction_coefficients.jl`. You can probably extend all the instances of `symmetric_interpolate`, `left_biased_interpolate` and `right_biased_interpolate` in `flat_advective_fluxes`. Or maybe put a fallback for Flat grids in `topologically_conditional_interpolation.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1263713946
https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1276402805:22,Modifiability,extend,extend,22,"Ah, right! We have to extend the outer functions (`left_biased_interpolate`, `right_biased_interpolate`, and `symmetric_interpolate`) instead of the `inner` ones",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1276402805
https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1279818970:12,Modifiability,extend,extend,12,"you need to extend the same functions specifically for `scheme::AbstractUpwindBiasedAdvectionScheme` because of. https://github.com/CliMA/Oceananigans.jl/blob/74ce7d2248792560ea0c9286a3274c2dbacfabea/src/Advection/upwind_biased_reconstruction.jl#L92-L98. ```suggestion; @inline symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid::XFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]; @inline symmetric_interpolate_yᵃᶠᵃ(i, j, k, grid::YFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]; @inline symmetric_interpolate_zᵃᵃᶠ(i, j, k, grid::ZFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]. @inline symmetric_interpolate_xᶜᵃᵃ(i, j, k, grid::XFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, u) = @inbounds c[i, j, k]; @inline symmetric_interpolate_yᵃᶜᵃ(i, j, k, grid::YFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, v) = @inbounds c[i, j, k]; @inline symmetric_interpolate_zᵃᵃᶜ(i, j, k, grid::ZFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, w) = @inbounds c[i, j, k]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1279818970
https://github.com/CliMA/Oceananigans.jl/pull/2760#issuecomment-1263709825:57,Testability,benchmark,benchmarks,57,I will actually close this PR and write a section in the benchmarks documentation,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2760#issuecomment-1263709825
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1265543483:256,Deployability,update,updated,256,"I will try doing some digging. A first thing I notice (not sure that this will solve the problem) is that, looking at your script, it seems you are using a pretty outdated version of Oceananigans (something like 0.71 or lower). I would try running with an updated versions and see if the problem persists",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1265543483
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266167924:842,Availability,error,error,842,"No problem, you have a line in the script that would not work with the current Oceananigans version: the keyword arguments of `LinearEquationOfState` (`α`, `β`) were renamed to `thermal_expansion` and `haline_contraction` in Oceananigans 0.71.5. To update Oceananigans, you can type; ```; import Pkg; Pkg.update(""Oceananigans""); ```; this should give you version 0.75.3; If you want to try with the latest version (0.77.5) you can do; ```; Pkg.add(Pkg.PackageSpec(name = ""Oceananigans"", version = ""0.77.5"")); ```; If you are using a GPU, I would remain on 0.75.3 at the moment because in 0.77.5 there are problems with `GradientBoundaryCondition`s on the GPU.; Probably it will not fix your issue, but a lot has changed internally so it is worth the try ; (remember to change those keyword arguments before running, otherwise you will get an error)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266167924
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266167924:249,Deployability,update,update,249,"No problem, you have a line in the script that would not work with the current Oceananigans version: the keyword arguments of `LinearEquationOfState` (`α`, `β`) were renamed to `thermal_expansion` and `haline_contraction` in Oceananigans 0.71.5. To update Oceananigans, you can type; ```; import Pkg; Pkg.update(""Oceananigans""); ```; this should give you version 0.75.3; If you want to try with the latest version (0.77.5) you can do; ```; Pkg.add(Pkg.PackageSpec(name = ""Oceananigans"", version = ""0.77.5"")); ```; If you are using a GPU, I would remain on 0.75.3 at the moment because in 0.77.5 there are problems with `GradientBoundaryCondition`s on the GPU.; Probably it will not fix your issue, but a lot has changed internally so it is worth the try ; (remember to change those keyword arguments before running, otherwise you will get an error)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266167924
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266167924:305,Deployability,update,update,305,"No problem, you have a line in the script that would not work with the current Oceananigans version: the keyword arguments of `LinearEquationOfState` (`α`, `β`) were renamed to `thermal_expansion` and `haline_contraction` in Oceananigans 0.71.5. To update Oceananigans, you can type; ```; import Pkg; Pkg.update(""Oceananigans""); ```; this should give you version 0.75.3; If you want to try with the latest version (0.77.5) you can do; ```; Pkg.add(Pkg.PackageSpec(name = ""Oceananigans"", version = ""0.77.5"")); ```; If you are using a GPU, I would remain on 0.75.3 at the moment because in 0.77.5 there are problems with `GradientBoundaryCondition`s on the GPU.; Probably it will not fix your issue, but a lot has changed internally so it is worth the try ; (remember to change those keyword arguments before running, otherwise you will get an error)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266167924
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266188419:343,Deployability,release,release,343,"[17:11]fspereira@ch-fe2[/lustre/scratch5/fspereira/OCEANANIGANS/test/case1]# julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> import Pkg. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.68.7. julia> Pkg.update(""Oceananigans""); Updating registry at `~/.julia/registries/General`; No Changes to `~/.julia/environments/v1.6/Project.toml`; No Changes to `~/.julia/environments/v1.6/Manifest.toml`. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.68.7. It does not update. Do I need a different version of Julia? If I remember correctly, the website says that 1.6.7 is ok",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266188419
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266188419:508,Deployability,update,update,508,"[17:11]fspereira@ch-fe2[/lustre/scratch5/fspereira/OCEANANIGANS/test/case1]# julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> import Pkg. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.68.7. julia> Pkg.update(""Oceananigans""); Updating registry at `~/.julia/registries/General`; No Changes to `~/.julia/environments/v1.6/Project.toml`; No Changes to `~/.julia/environments/v1.6/Manifest.toml`. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.68.7. It does not update. Do I need a different version of Julia? If I remember correctly, the website says that 1.6.7 is ok",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266188419
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266188419:829,Deployability,update,update,829,"[17:11]fspereira@ch-fe2[/lustre/scratch5/fspereira/OCEANANIGANS/test/case1]# julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> import Pkg. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.68.7. julia> Pkg.update(""Oceananigans""); Updating registry at `~/.julia/registries/General`; No Changes to `~/.julia/environments/v1.6/Project.toml`; No Changes to `~/.julia/environments/v1.6/Manifest.toml`. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.68.7. It does not update. Do I need a different version of Julia? If I remember correctly, the website says that 1.6.7 is ok",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266188419
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266188419:64,Testability,test,test,64,"[17:11]fspereira@ch-fe2[/lustre/scratch5/fspereira/OCEANANIGANS/test/case1]# julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> import Pkg. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.68.7. julia> Pkg.update(""Oceananigans""); Updating registry at `~/.julia/registries/General`; No Changes to `~/.julia/environments/v1.6/Project.toml`; No Changes to `~/.julia/environments/v1.6/Manifest.toml`. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.68.7. It does not update. Do I need a different version of Julia? If I remember correctly, the website says that 1.6.7 is ok",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266188419
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266331571:409,Testability,test,test,409,"Ah I see. Well from what I see everything in the [TurbulentStatistic.jl](https://github.com/CliMA/LESbrary.jl/tree/main/src/TurbulenceStatistics) module is compatible with new versions of Oceananigans (except maybe GPU usage). Since that is what you are using, you can maybe use it locally?. This is just a quick fix to try out the new Oceananigans. ; Also, to try out if the problem persists it is enough to test some simple second-order moments. ; The ones you have in your script should do the job; ```; u, v, w = model.velocities; t = model.tracers.T. U = Average(u, dims=(1, 2)) ; V = Average(v, dims=(1, 2)); T = Average(t, dims=(1, 2)); wu = Average(w * u, dims=(1, 2)); wv = Average(w * v, dims=(1, 2)); uu = Average(u * u, dims=(1, 2)); vv = Average(v * v, dims=(1, 2)); ww = Average(w * w, dims=(1, 2)); www = Average(w * w * w, dims=(1, 2)); wT = Average(w * t, dims=(1, 2)); uv = Average(u * v, dims=(1, 2)); uT = Average(u * t, dims=(1, 2)); vT = Average(v * t, dims=(1, 2)); TT = Average(t * t, dims=(1, 2)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266331571
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266331571:419,Usability,simpl,simple,419,"Ah I see. Well from what I see everything in the [TurbulentStatistic.jl](https://github.com/CliMA/LESbrary.jl/tree/main/src/TurbulenceStatistics) module is compatible with new versions of Oceananigans (except maybe GPU usage). Since that is what you are using, you can maybe use it locally?. This is just a quick fix to try out the new Oceananigans. ; Also, to try out if the problem persists it is enough to test some simple second-order moments. ; The ones you have in your script should do the job; ```; u, v, w = model.velocities; t = model.tracers.T. U = Average(u, dims=(1, 2)) ; V = Average(v, dims=(1, 2)); T = Average(t, dims=(1, 2)); wu = Average(w * u, dims=(1, 2)); wv = Average(w * v, dims=(1, 2)); uu = Average(u * u, dims=(1, 2)); vv = Average(v * v, dims=(1, 2)); ww = Average(w * w, dims=(1, 2)); www = Average(w * w * w, dims=(1, 2)); wT = Average(w * t, dims=(1, 2)); uv = Average(u * v, dims=(1, 2)); uT = Average(u * t, dims=(1, 2)); vT = Average(v * t, dims=(1, 2)); TT = Average(t * t, dims=(1, 2)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1266331571
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267712816:608,Availability,avail,available,608,"Hi All,. I rerun the simulations using the newest version of the code, . julia>; [17:03]fspereira@ch-fe1[/lustre/scratch5/fspereira/OCEANANIGANS/test/case5]# julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> import Pkg. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.77.5. and a script based on the one available on oceananigans webpage (I only changed the grid size, constant, and set the random seed. I also tried without these changes):. [https://github.com/CliMA/Oceananigans.jl/blob/main/examples/ocean_wind_mixing_and_convection.jl](https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/blob/main/examples/ocean_wind_mixing_and_convection.jl__;!!Bt8fGhp8LhKGRg!Hq-26fs0ZjyKWL5dfg0ho6lLfmeo_jfgVK18dHbvsUBFODEetRH9g_Jail-Z6ZLUs4OLQeSzVSKFWq6Ve2_bO315jP8wE0frJVA$). Unfortunately, the new code/script led to the same reproducibility problem. I ran 4 simulations using the same script (attached) and obtained 4 different average ww profiles. . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193948250-57bde9a3-ab27-4224-a443-341599e2107e.png). [c16_128_128m.jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9711438/c16_128_128m.jl.zip). Any ideas or suggestions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267712816
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267712816:424,Deployability,release,release,424,"Hi All,. I rerun the simulations using the newest version of the code, . julia>; [17:03]fspereira@ch-fe1[/lustre/scratch5/fspereira/OCEANANIGANS/test/case5]# julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> import Pkg. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.77.5. and a script based on the one available on oceananigans webpage (I only changed the grid size, constant, and set the random seed. I also tried without these changes):. [https://github.com/CliMA/Oceananigans.jl/blob/main/examples/ocean_wind_mixing_and_convection.jl](https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/blob/main/examples/ocean_wind_mixing_and_convection.jl__;!!Bt8fGhp8LhKGRg!Hq-26fs0ZjyKWL5dfg0ho6lLfmeo_jfgVK18dHbvsUBFODEetRH9g_Jail-Z6ZLUs4OLQeSzVSKFWq6Ve2_bO315jP8wE0frJVA$). Unfortunately, the new code/script led to the same reproducibility problem. I ran 4 simulations using the same script (attached) and obtained 4 different average ww profiles. . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193948250-57bde9a3-ab27-4224-a443-341599e2107e.png). [c16_128_128m.jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9711438/c16_128_128m.jl.zip). Any ideas or suggestions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267712816
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267712816:145,Testability,test,test,145,"Hi All,. I rerun the simulations using the newest version of the code, . julia>; [17:03]fspereira@ch-fe1[/lustre/scratch5/fspereira/OCEANANIGANS/test/case5]# julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> import Pkg. julia> Pkg.status(""Oceananigans""); Status `~/.julia/environments/v1.6/Project.toml`; [9e8cae18] Oceananigans v0.77.5. and a script based on the one available on oceananigans webpage (I only changed the grid size, constant, and set the random seed. I also tried without these changes):. [https://github.com/CliMA/Oceananigans.jl/blob/main/examples/ocean_wind_mixing_and_convection.jl](https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/blob/main/examples/ocean_wind_mixing_and_convection.jl__;!!Bt8fGhp8LhKGRg!Hq-26fs0ZjyKWL5dfg0ho6lLfmeo_jfgVK18dHbvsUBFODEetRH9g_Jail-Z6ZLUs4OLQeSzVSKFWq6Ve2_bO315jP8wE0frJVA$). Unfortunately, the new code/script led to the same reproducibility problem. I ran 4 simulations using the same script (attached) and obtained 4 different average ww profiles. . ![tec_ww_time_c1](https://user-images.githubusercontent.com/80914369/193948250-57bde9a3-ab27-4224-a443-341599e2107e.png). [c16_128_128m.jl.zip](https://github.com/CliMA/Oceananigans.jl/files/9711438/c16_128_128m.jl.zip). Any ideas or suggestions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267712816
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092:2668,Deployability,update,updated,2668," Random.seed!(rng, 1414); Ξ(z) = randn(rng) * z / model.grid.Lz * (1 + z / model.grid.Lz) ; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); ```. You can try replacing these lines with something like. ```julia; Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) *. shape; Ξu = randn(size(u)...) *. shape; Ξw = randn(size(w)...) *. shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35); ```. I'd be curious to know if this works. Here are a few more tips and best practices for raising issues here:. * Please reduce your code to minimum working examples. The script that was linked contains a lot of extraneous code (including comments copy/pasted from an example) that is irrelevant to the issue we are discussing. Reducing your code to a minimum example is kind to the community and will help people answer your questions faster. * If you can, avoid linking to code and instead paste your code directly into the issue. * Use [github's markdown formatting](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) (such as triple backticks, ""```"") to format code and julia prompt instructions. * Finally, I strongly recommend using environments to manage the Oceananigans version (though I don't think this is intrinsic to the issue, it will help us rule out a lot of possible issues if we can focus on one Oceananigans version). We have written some tips in our wiki: https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments which includes a link to the official Julia documentation. * Sounds like LESbrary.jl needs to be updated!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092:1516,Energy Efficiency,reduce,reduce,1516,"ns, you could try using arrays to set the initial conditions instead. Your script contains these lines:. ```julia; rng = MersenneTwister(1234); Random.seed!(rng, 1414); Ξ(z) = randn(rng) * z / model.grid.Lz * (1 + z / model.grid.Lz) ; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); ```. You can try replacing these lines with something like. ```julia; Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) *. shape; Ξu = randn(size(u)...) *. shape; Ξw = randn(size(w)...) *. shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35); ```. I'd be curious to know if this works. Here are a few more tips and best practices for raising issues here:. * Please reduce your code to minimum working examples. The script that was linked contains a lot of extraneous code (including comments copy/pasted from an example) that is irrelevant to the issue we are discussing. Reducing your code to a minimum example is kind to the community and will help people answer your questions faster. * If you can, avoid linking to code and instead paste your code directly into the issue. * Use [github's markdown formatting](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) (such as triple backticks, ""```"") to format code and julia prompt instructions. * Finally, I strongly recommend using environments to manage the Oceananigans version (though I don't think this is intrinsic to the issue, it will help us rule out a lot of possible issues if we can focus on one Oceananigans version). We have written some tips in our wiki: https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092:1853,Safety,avoid,avoid,1853," Random.seed!(rng, 1414); Ξ(z) = randn(rng) * z / model.grid.Lz * (1 + z / model.grid.Lz) ; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z); uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z); set!(model, u=uᵢ, w=uᵢ, T=Tᵢ, S=35); ```. You can try replacing these lines with something like. ```julia; Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) *. shape; Ξu = randn(size(u)...) *. shape; Ξw = randn(size(w)...) *. shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35); ```. I'd be curious to know if this works. Here are a few more tips and best practices for raising issues here:. * Please reduce your code to minimum working examples. The script that was linked contains a lot of extraneous code (including comments copy/pasted from an example) that is irrelevant to the issue we are discussing. Reducing your code to a minimum example is kind to the community and will help people answer your questions faster. * If you can, avoid linking to code and instead paste your code directly into the issue. * Use [github's markdown formatting](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) (such as triple backticks, ""```"") to format code and julia prompt instructions. * Finally, I strongly recommend using environments to manage the Oceananigans version (though I don't think this is intrinsic to the issue, it will help us rule out a lot of possible issues if we can focus on one Oceananigans version). We have written some tips in our wiki: https://github.com/CliMA/Oceananigans.jl/wiki/Productive-Oceananigans-workflows-and-Julia-environments which includes a link to the official Julia documentation. * Sounds like LESbrary.jl needs to be updated!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1267909092
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:156,Availability,error,error,156,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:765,Availability,ERROR,ERROR,765,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:627,Deployability,Configurat,Configuration,627,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:162,Integrability,message,message,162,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:290,Modifiability,variab,variable,290,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:331,Modifiability,config,config,331,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:391,Modifiability,config,config,391,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:427,Modifiability,Config,Config,427,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:627,Modifiability,Config,Configuration,627,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:772,Performance,Load,LoadError,772,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:209,Security,authenticat,authentication,209,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:902,Testability,test,test,902,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:1007,Testability,test,test,1007,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268575815:60,Energy Efficiency,reduce,reduces,60,You can probably also omit the `shape` component. That just reduces the noise to zero at the top and the bottom.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268575815
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:311,Availability,avail,available,311,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:603,Availability,ERROR,ERROR,603,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:199,Deployability,Configurat,Configuration,199,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:199,Modifiability,Config,Configuration,199,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:362,Modifiability,variab,variable,362,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:403,Modifiability,config,config,403,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:463,Modifiability,config,config,463,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:499,Modifiability,Config,Config,499,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:610,Performance,Load,LoadError,610,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:1257,Testability,test,test,1257,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:310,Availability,error,error,310,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:346,Availability,error,error,346,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:431,Availability,error,error,431,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:478,Availability,error,error,478,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:352,Integrability,message,message,352,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017:796,Integrability,depend,depends,796,"It's probably with `w`; I forgot that `w` has a different size in the vertical direction. You can try changing the `w` initial condition with code like. ```julia; xw, yw, zw = nodes(w, reshape=true); wshape = @. zw / Lz * (1 + zw / Lz); Ξw = randn(size(w)...) .* wshape; ```. I'm not sure if this is where the error comes from. The stack trace / error message that you posted will tell you the specific line that is generating the error. Identifying the line that generates the error can be useful for debugging. If you like, you can generate a minimal example, which I can then try to run to reproduce a bug (and also to debug my own code suggestions). > Also, shouldn't we set v (last line below, I added the commented v's):. You can. This is not a question about reproducibility though --- it depends on your application. Give it a shot and see how it changes your results. Note that there will be non-zero `v` in the initial condition anyways, because it has to be projected onto an incompressible velocity field (which is not guaranteed by the random data we are using). Also, please format your code with triple backticks:. https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#quoting-code. You can add syntax annotation too appropriate for Julia.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1269248017
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273628214:77,Testability,test,tests,77,"Thank you for your answer. ; I am not sure if I understood your comment. The tests I did were obtained after set!(model,..), and before run. I wrote the T, u, v, and w fields. They were all identical; Is this what you asked me to do?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273628214
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1479,Availability,failure,failure,1479,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1174,Security,expose,exposes,1174,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:251,Testability,test,test,251,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:371,Testability,test,tests,371,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:418,Testability,test,tests,418,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:477,Testability,test,test,477,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:505,Testability,test,test,505,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:598,Testability,test,tests,598,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:637,Testability,test,tests,637,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:923,Testability,test,test,923,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1016,Testability,test,tests,1016,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1494,Testability,test,test,1494,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1739,Testability,test,test,1739,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1396,Usability,simpl,simplifying,1396,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416:1622,Usability,simpl,simplying,1622,"Okay, apologies. I just didn't quite understand what you meant when you said they _seem_ identical. Typically we would just write something like `T1 == T2`, which will return `true` or `false`, or equivalently something like `all(T1 .== T2)`. Another test is to use `isapprox` (also written `≈`) as in `all(T1 .≈ T2)`. Here's a bit more background on the reproducibility tests we currently have:. We have [""regression tests""](https://github.com/CliMA/Oceananigans.jl/tree/main/test/regression_tests) that test to ensure that output from a certain simulation remains identical across PRs, including tests that involve LES closures. These tests involve ~10 time steps. We conclude that results are ""identical"" when every grid point is within `sqrt(eps(T))`, where `T` is the floating point type (eg `Float64` or `Float32`), for example:. https://github.com/CliMA/Oceananigans.jl/blob/fc84215f76661e9f1cfb103dc18f86442cec9d89/test/regression_tests/hydrostatic_free_turbulence_regression_test.jl#L112. Many of our other tests also implicitly rely on reproducibility. I think, therefore, that we do have reproduciblity in many cases. However, it is quite possible that your case exposes some particular feature that leads to a loss of reprodicibility. I think perhaps the next step in order to make progress is to code up a ""minimal working example"" (often called an MWE), which involves relentlessly simplifying the examle until we isolate the essential complication that leads to a failure of the test. With that knowledge in hand, we can dig deeper to find the underlying cause (and hopefully fix it). Often, the process of simplying a script in order to isolate the MWE also produces some insight about the issue (and potentially about the test).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273675416
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273701074:18,Usability,clear,clear,18,"My bad. I was not clear. Yes, T1 - T2 = 0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1273701074
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1293645479:632,Availability,error,errors,632,"As pointed out by @kburns, if you're interested in bit reproducibility you may also need to set the FFTW plan (by default, FFTW is not reproducible even on identical architectures). I'm not sure this is your issue (I have doubts...) but if you want to be thorough you may want to check this. To set the plan you have to build the pressure solver manually with something like:. ```julia; using Oceananigans.Solvers: FFTBasedPoissonSolver; using FFTW. pressure_solver = FFTBasedPoissonSolver(grid, planner_flag=FFTW.ESTIMATE); model = NonhydrostaticModel(; grid, pressure_solver, other_kwargs...); ```. I'd be surprised if ""round-off errors"" accumulate enough to cause the differences you're seeing (but it does seem at least possible, especially for very long runs at relatively coarser resolutions where slight differences in the eddy diffusivity might lead to slightly different turbulent trajectories). Hope that helps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1293645479
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294008171:324,Availability,ERROR,ERROR,324,"Thank you for the suggestion @glwagner . I installed the FFT, and I can . `using Oceananigans.Solvers: FFTBasedPoissonSolver`; `using FFTW`. but when I try. `pressure_solver = FFTBasedPoissonSolver(grid, planner_flag=FFTW.ESTIMATE)`. I get. julia> pressure_solver = FFTBasedPoissonSolver(grid, planner_flag=FFTW.ESTIMATE) ; ERROR: MethodError: no method matching FFTBasedPoissonSolver(::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}; planner_flag=0x00000040); Closest candidates are:; FFTBasedPoissonSolver(::Any) at /users/fspereira/.julia/packages/Oceananigans/7G5bN/src/Solvers/fft_based_poisson_solver.jl:50 got unsupported keyword argument ""planner_flag""; FFTBasedPoissonSolver(::Any, ::Any) at /users/fspereira/.julia/packages/Oceananigans/7G5bN/src/Solvers/fft_based_poisson_solver.jl:50 got unsupported keyword argument ""planner_flag""; FFTBasedPoissonSolver(::G, ::Λ, ::S, ::B, ::T) where {G, Λ, S, B, T} at /users/fspereira/.julia/packages/Oceananigans/7G5bN/src/Solvers/fft_based_poisson_solver.jl:6 got unsupported keyword argument ""planner_flag""; Stacktrace:; [1] top-level scope; @ REPL[42]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ; ; What should I use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294008171
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294008171:43,Deployability,install,installed,43,"Thank you for the suggestion @glwagner . I installed the FFT, and I can . `using Oceananigans.Solvers: FFTBasedPoissonSolver`; `using FFTW`. but when I try. `pressure_solver = FFTBasedPoissonSolver(grid, planner_flag=FFTW.ESTIMATE)`. I get. julia> pressure_solver = FFTBasedPoissonSolver(grid, planner_flag=FFTW.ESTIMATE) ; ERROR: MethodError: no method matching FFTBasedPoissonSolver(::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}; planner_flag=0x00000040); Closest candidates are:; FFTBasedPoissonSolver(::Any) at /users/fspereira/.julia/packages/Oceananigans/7G5bN/src/Solvers/fft_based_poisson_solver.jl:50 got unsupported keyword argument ""planner_flag""; FFTBasedPoissonSolver(::Any, ::Any) at /users/fspereira/.julia/packages/Oceananigans/7G5bN/src/Solvers/fft_based_poisson_solver.jl:50 got unsupported keyword argument ""planner_flag""; FFTBasedPoissonSolver(::G, ::Λ, ::S, ::B, ::T) where {G, Λ, S, B, T} at /users/fspereira/.julia/packages/Oceananigans/7G5bN/src/Solvers/fft_based_poisson_solver.jl:6 got unsupported keyword argument ""planner_flag""; Stacktrace:; [1] top-level scope; @ REPL[42]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ; ; What should I use?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294008171
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674:206,Availability,error,error,206,"Ah sorry. I think you should use. ```julia; pressure_solver = FFTBasedPoissonSolver(grid, FFTW.ESTIMATE); ```. PS try triple backticks (```) rather than single backticks (`) for formatting blocks of code / error messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674:212,Integrability,message,messages,212,"Ah sorry. I think you should use. ```julia; pressure_solver = FFTBasedPoissonSolver(grid, FFTW.ESTIMATE); ```. PS try triple backticks (```) rather than single backticks (`) for formatting blocks of code / error messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1294054674
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1295914743:296,Usability,learn,learned,296,"It might make sense to convert this to a discussion and change the title to ""Building reproducible LES setups"". The info here could be useful for future Oceananigans users that would like to build reproducible setups (thanks for your efforts in this department @fspereira1). Of note, the lessons learned here are mostly about achieving reproducibility with Julia and FFTW (the lessons are not Oceananigans specific, and are applicable to other Julia applications). And to summarize the important points:. * Reproducible initial conditions must be constructed with care. If using random initial conditions, we have to set the seed of the random number generator, and ensure that any random arrays are constructed deterministically (for example, we can't use `rand()` inside an initial condition function because loop ordering is not deterministic in Oceananigans). There could be special concerns for random array initial conditions on GPU.; * Reproducible results from solvers that use FFTW (either 3D pressure solvers, or the 2D free surface solvers for `HydrostaticFreeSurfaceModel`) must use the `FFTW.ESTIMATE` planner flag (see solver documentation for how to do this in each case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1295914743
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1295952303:93,Deployability,update,update,93,"@glwagner This Makes sense to me. And thank you for your help. ; Also, I want to give you an update. I ran ten simulations with the same .jl file with T=4days. I got the same profiles (ww, www, T, etc). I can share the .jl file, it might useful to other users. What would be the best way?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1295952303
https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1296014219:162,Modifiability,evolve,evolves,162,"Perhaps start a git repo and post a link to it? It's best to include the julia environment you're using with the file (otherwise it will go stale as Oceananigans evolves). If you want to just post the file then you can use a [gist](https://gist.github.com), or copy/paste the code here if its short.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1296014219
https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768:65,Integrability,inject,injected,65,"Hmmm might be related to how the default boundary conditions are injected since specifying the proper default BCs for top/bottom and explicit BCs for east/west seems to work:. ```julia; using Oceananigans; using Oceananigans.BoundaryConditions: NoFluxBoundaryCondition, ImpenetrableBoundaryCondition. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0),; bottom = NoFluxBoundaryCondition(),; top = NoFluxBoundaryCondition(); ). model = NonhydrostaticModel(; grid = grid,; boundary_conditions = (v=v_bcs,); ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768
https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768:65,Security,inject,injected,65,"Hmmm might be related to how the default boundary conditions are injected since specifying the proper default BCs for top/bottom and explicit BCs for east/west seems to work:. ```julia; using Oceananigans; using Oceananigans.BoundaryConditions: NoFluxBoundaryCondition, ImpenetrableBoundaryCondition. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0),; bottom = NoFluxBoundaryCondition(),; top = NoFluxBoundaryCondition(); ). model = NonhydrostaticModel(; grid = grid,; boundary_conditions = (v=v_bcs,); ); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267074768
https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267113558:796,Availability,error,error,796,"You don't need to give the grid as an argument. You are calling; ```; FieldBoundaryConditions(default_bounded_bc = NoFluxBoundaryCondition();; west = DefaultBoundaryCondition(default_bounded_bc),; east = DefaultBoundaryCondition(default_bounded_bc),; south = DefaultBoundaryCondition(default_bounded_bc),; north = DefaultBoundaryCondition(default_bounded_bc),; bottom = DefaultBoundaryCondition(default_bounded_bc),; top = DefaultBoundaryCondition(default_bounded_bc),; immersed = DefaultBoundaryCondition(default_bounded_bc)) = ; FieldBoundaryConditions(west, east, south, north, bottom, top, immersed); ```; This should be enough; ```; v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0)); ```. But good catch, we should probably force a type on `default_bounded_bc` to avoid this error, since we also have a `FieldBoundaryConditions(grid, location, indices=default_indices(3))` method which might be confusing",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267113558
https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267113558:785,Safety,avoid,avoid,785,"You don't need to give the grid as an argument. You are calling; ```; FieldBoundaryConditions(default_bounded_bc = NoFluxBoundaryCondition();; west = DefaultBoundaryCondition(default_bounded_bc),; east = DefaultBoundaryCondition(default_bounded_bc),; south = DefaultBoundaryCondition(default_bounded_bc),; north = DefaultBoundaryCondition(default_bounded_bc),; bottom = DefaultBoundaryCondition(default_bounded_bc),; top = DefaultBoundaryCondition(default_bounded_bc),; immersed = DefaultBoundaryCondition(default_bounded_bc)) = ; FieldBoundaryConditions(west, east, south, north, bottom, top, immersed); ```; This should be enough; ```; v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0)); ```. But good catch, we should probably force a type on `default_bounded_bc` to avoid this error, since we also have a `FieldBoundaryConditions(grid, location, indices=default_indices(3))` method which might be confusing",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768#issuecomment-1267113558
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267430238:426,Modifiability,variab,variables,426,"That was the main issue we discussed in #2740 with locating the free surface at `grid.Nz+1`. . (from #2740); > Well the issue is that if we want to save the output at the surface `(:, :, grid.Nz)` we cannot include the free surface if this is defined at `grid.Nz+1` (it would not exist at `grid.Nz`). ... `grid.Nz+1` won against `grid.Nz` so, for the moment, you should define two different `OutptWriters`, one for grid-sized variables and one for the free surface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267430238
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541:691,Availability,ERROR,ERROR,691,"The issue here seems to be with `parent_index_range`. ; This should return the parent indices which are then used to `view(parent(data), parent_indices...)`. ; This will not work with sliced fields because in sliced fields the `data` has windowed indices (returned by `parent_index_range`), but the parent has indices that always start from 1. for example for a 10x10x10 grid: ; ```; julia> η.data; 16×16×1 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, 11:11) with eltype Float64 with indices -2:13×-2:13×11:11:; .; .; .; ```; ```; julia> η.data.parent; 16×16×1 Array{Float64, 3}:; .; .; .; ```; So if I try to do `view(, :, : grid.Nz+1)` it returns ; ```; julia> view(η, :, :, grid.Nz+1); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```; because ; ```; julia> parent_indices = parent_index_range.(indices(η), location(η), topology(η.grid), halo_size(η.grid)); (Colon(), Colon(), 14:14). julia> windowed_parent = view(parent(data), parent_indices...); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```. In my opinion `parent_index_range` should return here `(Colon(), Colon(), 1:1)`, but I would like to be sure before breaking everything",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541:1003,Availability,ERROR,ERROR,1003,"The issue here seems to be with `parent_index_range`. ; This should return the parent indices which are then used to `view(parent(data), parent_indices...)`. ; This will not work with sliced fields because in sliced fields the `data` has windowed indices (returned by `parent_index_range`), but the parent has indices that always start from 1. for example for a 10x10x10 grid: ; ```; julia> η.data; 16×16×1 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, 11:11) with eltype Float64 with indices -2:13×-2:13×11:11:; .; .; .; ```; ```; julia> η.data.parent; 16×16×1 Array{Float64, 3}:; .; .; .; ```; So if I try to do `view(, :, : grid.Nz+1)` it returns ; ```; julia> view(η, :, :, grid.Nz+1); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```; because ; ```; julia> parent_indices = parent_index_range.(indices(η), location(η), topology(η.grid), halo_size(η.grid)); (Colon(), Colon(), 14:14). julia> windowed_parent = view(parent(data), parent_indices...); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```. In my opinion `parent_index_range` should return here `(Colon(), Colon(), 1:1)`, but I would like to be sure before breaking everything",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541:722,Security,access,access,722,"The issue here seems to be with `parent_index_range`. ; This should return the parent indices which are then used to `view(parent(data), parent_indices...)`. ; This will not work with sliced fields because in sliced fields the `data` has windowed indices (returned by `parent_index_range`), but the parent has indices that always start from 1. for example for a 10x10x10 grid: ; ```; julia> η.data; 16×16×1 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, 11:11) with eltype Float64 with indices -2:13×-2:13×11:11:; .; .; .; ```; ```; julia> η.data.parent; 16×16×1 Array{Float64, 3}:; .; .; .; ```; So if I try to do `view(, :, : grid.Nz+1)` it returns ; ```; julia> view(η, :, :, grid.Nz+1); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```; because ; ```; julia> parent_indices = parent_index_range.(indices(η), location(η), topology(η.grid), halo_size(η.grid)); (Colon(), Colon(), 14:14). julia> windowed_parent = view(parent(data), parent_indices...); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```. In my opinion `parent_index_range` should return here `(Colon(), Colon(), 1:1)`, but I would like to be sure before breaking everything",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541:1034,Security,access,access,1034,"The issue here seems to be with `parent_index_range`. ; This should return the parent indices which are then used to `view(parent(data), parent_indices...)`. ; This will not work with sliced fields because in sliced fields the `data` has windowed indices (returned by `parent_index_range`), but the parent has indices that always start from 1. for example for a 10x10x10 grid: ; ```; julia> η.data; 16×16×1 OffsetArray(::Array{Float64, 3}, -2:13, -2:13, 11:11) with eltype Float64 with indices -2:13×-2:13×11:11:; .; .; .; ```; ```; julia> η.data.parent; 16×16×1 Array{Float64, 3}:; .; .; .; ```; So if I try to do `view(, :, : grid.Nz+1)` it returns ; ```; julia> view(η, :, :, grid.Nz+1); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```; because ; ```; julia> parent_indices = parent_index_range.(indices(η), location(η), topology(η.grid), halo_size(η.grid)); (Colon(), Colon(), 14:14). julia> windowed_parent = view(parent(data), parent_indices...); ERROR: BoundsError: attempt to access 16×16×1 Array{Float64, 3} at index [1:16, 1:16, 14:14]; ```. In my opinion `parent_index_range` should return here `(Colon(), Colon(), 1:1)`, but I would like to be sure before breaking everything",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267581541
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:110,Availability,error,error,110,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:1579,Availability,ERROR,ERROR,1579," to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new features that help us build output in a sensible way. One idea is a macro that looks something like. ```julia; us, vs, ws, Ts = @indices (:, :, Nz) u v w T; ```. This would be equivalent to writing something like. ```julia; us = Field(u, indices=(:, :, Nz)); vs = Field(v, indices=(:, :, Nz)); ws = Field(w, indices=(:, :, Nz)); Ts = Field(T, indices=(:, :, Nz)); ```. Then, if users want to output surface fields _and_ the free surface, they should use this method rather than the `indices` kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:640,Energy Efficiency,reduce,reduced,640,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:1610,Security,access,access,1610," to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new features that help us build output in a sensible way. One idea is a macro that looks something like. ```julia; us, vs, ws, Ts = @indices (:, :, Nz) u v w T; ```. This would be equivalent to writing something like. ```julia; us = Field(u, indices=(:, :, Nz)); vs = Field(v, indices=(:, :, Nz)); ws = Field(w, indices=(:, :, Nz)); Ts = Field(T, indices=(:, :, Nz)); ```. Then, if users want to output surface fields _and_ the free surface, they should use this method rather than the `indices` kwarg.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520:72,Usability,simpl,simple,72,"I'm not sure I grasp the issue. @jagoosw it might help if you include a simple example (eg some code, and the error that gets produced) that illustrates the issue. > With indices=(:, :, :) we should be able to output any field. I agree with this. Is the problem associated with trying to ""remove halos"" from output? Does it go away when we write `with_halos=true`?. In addition to problems with `parent_index_range`, it looks like there is potentially a problem with the user API (in addition to other bugs). The `indices` keyword in the output writers is a useful convenience but doesn't generalize well to being able to slice both 3D and reduced or sliced fields. Here's what we have:. * All `Field`s have `indices`. We can define fields that are essentialy _views_ into other fields, but ""sliced"" at particular indices. We can also define abstract operations that slice a portion of the domain.; * We have output writers that can compute and output sliced fields. ; * We have an `indices` kwarg for output writers that _automagically_ will _slice every output_ along the provided indices. This is convenient, but fails to cover the case that we want to slice all 3D fields, but leave fields that are _already sliced_ untouched. A few solutions:. * Throw a `BoundsError` when we attempt to ""re-slice"" a field in a way that's invalid. For example, we cannot slice a field with `k=Nz+1` at the index `k=Nz`. This is how Base julia works:. ```julia; julia> a = rand(2, 3); 2×3 Matrix{Float64}:; 0.493349 0.161279 0.244427; 0.288415 0.0111998 0.543645. julia> b = view(a, :, 4:4); ERROR: BoundsError: attempt to access 2×3 Matrix{Float64} at index [1:2, 4:4]; Stacktrace:; [1] throw_boundserror(A::Matrix{Float64}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view(::Matrix{Float64}, ::Function, ::UnitRange{Int64}); @ Base ./subarray.jl:177; [4] top-level scope; @ REPL[36]:1; ```. * Add new feature",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268590520
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:487,Availability,error,error,487,"Here's an example:. ```; using Oceananigans; grid = RectilinearGrid(arch, size=(20, 20, 20), extent=(1, 1, 1)); a_field = Oceananigans.Fields.Field{Center, Center, Center}(grid; indices=(:, :, 1:1)); model = NonhydrostaticModel(grid = grid, auxiliary_fields=(;a_field)); simulation = Simulation(model, Δt=1.0, stop_iteration=1). simulation.output_writers[:a_field] = JLD2OutputWriter(model, (model.auxiliary_fields), filename=""example.jld2"", schedule=IterationInterval(1)); ```; And the error I get:; ```; ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [4:23, 4:23, 4:23]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:227; [5] view; @ ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:286 [inlined]; [6] construct_output; @ ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/output_construction.jl:49 [inlined]; [7] construct_output(user_output::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:506,Availability,ERROR,ERROR,506,"Here's an example:. ```; using Oceananigans; grid = RectilinearGrid(arch, size=(20, 20, 20), extent=(1, 1, 1)); a_field = Oceananigans.Fields.Field{Center, Center, Center}(grid; indices=(:, :, 1:1)); model = NonhydrostaticModel(grid = grid, auxiliary_fields=(;a_field)); simulation = Simulation(model, Δt=1.0, stop_iteration=1). simulation.output_writers[:a_field] = JLD2OutputWriter(model, (model.auxiliary_fields), filename=""example.jld2"", schedule=IterationInterval(1)); ```; And the error I get:; ```; ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [4:23, 4:23, 4:23]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:227; [5] view; @ ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:286 [inlined]; [6] construct_output; @ ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/output_construction.jl:49 [inlined]; [7] construct_output(user_output::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:442,Energy Efficiency,schedul,schedule,442,"Here's an example:. ```; using Oceananigans; grid = RectilinearGrid(arch, size=(20, 20, 20), extent=(1, 1, 1)); a_field = Oceananigans.Fields.Field{Center, Center, Center}(grid; indices=(:, :, 1:1)); model = NonhydrostaticModel(grid = grid, auxiliary_fields=(;a_field)); simulation = Simulation(model, Δt=1.0, stop_iteration=1). simulation.output_writers[:a_field] = JLD2OutputWriter(model, (model.auxiliary_fields), filename=""example.jld2"", schedule=IterationInterval(1)); ```; And the error I get:; ```; ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [4:23, 4:23, 4:23]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:227; [5] view; @ ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:286 [inlined]; [6] construct_output; @ ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/output_construction.jl:49 [inlined]; [7] construct_output(user_output::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:65055,Energy Efficiency,schedul,schedule,65055,"c, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}}, outputs::NamedTuple{(:a_field,), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, array_type::Type, max_filesize::Float64, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{Symbol}, verbose::Bool, part::Int64, jld2_kw::Dict{Symbol, Any}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/jld2_output_writer.jl:179; [13] top-level scope; @ REPL[17]:1; [14] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061:537,Security,access,access,537,"Here's an example:. ```; using Oceananigans; grid = RectilinearGrid(arch, size=(20, 20, 20), extent=(1, 1, 1)); a_field = Oceananigans.Fields.Field{Center, Center, Center}(grid; indices=(:, :, 1:1)); model = NonhydrostaticModel(grid = grid, auxiliary_fields=(;a_field)); simulation = Simulation(model, Δt=1.0, stop_iteration=1). simulation.output_writers[:a_field] = JLD2OutputWriter(model, (model.auxiliary_fields), filename=""example.jld2"", schedule=IterationInterval(1)); ```; And the error I get:; ```; ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [4:23, 4:23, 4:23]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:227; [5] view; @ ~/.julia/packages/Oceananigans/p4kDj/src/Fields/field.jl:286 [inlined]; [6] construct_output; @ ~/.julia/packages/Oceananigans/p4kDj/src/OutputWriters/output_construction.jl:49 [inlined]; [7] construct_output(user_output::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeL",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268699061
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268715594:364,Availability,ERROR,ERROR,364,"The problem is these lines . https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Fields/field.jl#L243-L244. ```; julia> parent_indices = parent_index_range.(indices(a_field), location(a_field), topology(grid), halo_size(grid)); (Colon(), Colon(), 4:4). julia> windowed_parent = view(parent(a_field.data), parent_indices...); ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [1:26, 1:26, 4:4]; ```; ; `parent(a_field.data)` has a z-index that never reahes 4. The actual offset data has indices 4:4 in the z-direction, but the parent only 1:1. We can view `a_field.data` at 4:4 not `parent(a_field.data)` (or in your case even worst 4:23). ; I think the parent index of a sliced field should be ; ```; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```; (if we assume `index::UnitRange` means it is a sliced field so it does not have halos). This is not the whole story though, since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. So once we have fixed this we have to deal with the output writers which rely on `view(field, indices...)`. I guess the error here will be somewhere in this function . https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/OutputWriters/output_construction.jl#L50-L60. Here we have to interpolate the `indices` which result from line 56 with `indices(output)` that contain the indices of the (maybe) sliced field",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268715594
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268715594:1189,Availability,error,error,1189,"The problem is these lines . https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Fields/field.jl#L243-L244. ```; julia> parent_indices = parent_index_range.(indices(a_field), location(a_field), topology(grid), halo_size(grid)); (Colon(), Colon(), 4:4). julia> windowed_parent = view(parent(a_field.data), parent_indices...); ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [1:26, 1:26, 4:4]; ```; ; `parent(a_field.data)` has a z-index that never reahes 4. The actual offset data has indices 4:4 in the z-direction, but the parent only 1:1. We can view `a_field.data` at 4:4 not `parent(a_field.data)` (or in your case even worst 4:23). ; I think the parent index of a sliced field should be ; ```; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```; (if we assume `index::UnitRange` means it is a sliced field so it does not have halos). This is not the whole story though, since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. So once we have fixed this we have to deal with the output writers which rely on `view(field, indices...)`. I guess the error here will be somewhere in this function . https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/OutputWriters/output_construction.jl#L50-L60. Here we have to interpolate the `indices` which result from line 56 with `indices(output)` that contain the indices of the (maybe) sliced field",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268715594
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268715594:395,Security,access,access,395,"The problem is these lines . https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Fields/field.jl#L243-L244. ```; julia> parent_indices = parent_index_range.(indices(a_field), location(a_field), topology(grid), halo_size(grid)); (Colon(), Colon(), 4:4). julia> windowed_parent = view(parent(a_field.data), parent_indices...); ERROR: BoundsError: attempt to access 26×26×1 Array{Float64, 3} at index [1:26, 1:26, 4:4]; ```; ; `parent(a_field.data)` has a z-index that never reahes 4. The actual offset data has indices 4:4 in the z-direction, but the parent only 1:1. We can view `a_field.data` at 4:4 not `parent(a_field.data)` (or in your case even worst 4:23). ; I think the parent index of a sliced field should be ; ```; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```; (if we assume `index::UnitRange` means it is a sliced field so it does not have halos). This is not the whole story though, since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. So once we have fixed this we have to deal with the output writers which rely on `view(field, indices...)`. I guess the error here will be somewhere in this function . https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/OutputWriters/output_construction.jl#L50-L60. Here we have to interpolate the `indices` which result from line 56 with `indices(output)` that contain the indices of the (maybe) sliced field",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1268715594
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387:472,Testability,test,tests,472,"Ok! To summarize, we currently have. https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Grids/grid_utils.jl#L213. which you propose to change to. ```julia; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```. I definitely agree that the parent index range of a field with indices `4:4` is `1:1` and your code seems correct to me. This is a clear bug --- should we add this to the indices tests? (I'm not sure what the state of the tests is for indices, but this is an obvious gap.). Note that with this change, none of the methods for `parent_index_range` will use the argument `halo`. So that should be removed. (I think `loc` and `topo` are needed to support slicing into ""ensemble grids"" that have a flat direction with more than one grid point... I think.). > since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. I think @navidcy discovered a problem with `validate_indices` that may be related. But `restrict_to_interior` may also be broken for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387:515,Testability,test,tests,515,"Ok! To summarize, we currently have. https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Grids/grid_utils.jl#L213. which you propose to change to. ```julia; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```. I definitely agree that the parent index range of a field with indices `4:4` is `1:1` and your code seems correct to me. This is a clear bug --- should we add this to the indices tests? (I'm not sure what the state of the tests is for indices, but this is an obvious gap.). Note that with this change, none of the methods for `parent_index_range` will use the argument `halo`. So that should be removed. (I think `loc` and `topo` are needed to support slicing into ""ensemble grids"" that have a flat direction with more than one grid point... I think.). > since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. I think @navidcy discovered a problem with `validate_indices` that may be related. But `restrict_to_interior` may also be broken for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387
https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387:424,Usability,clear,clear,424,"Ok! To summarize, we currently have. https://github.com/CliMA/Oceananigans.jl/blob/b288527ccf34fc17ec4b31a1e9da7bd8b8d25a10/src/Grids/grid_utils.jl#L213. which you propose to change to. ```julia; parent_index_range(index::UnitRange, loc, topo, halo) = 1:(last(index) - first(index) + 1); ```. I definitely agree that the parent index range of a field with indices `4:4` is `1:1` and your code seems correct to me. This is a clear bug --- should we add this to the indices tests? (I'm not sure what the state of the tests is for indices, but this is an obvious gap.). Note that with this change, none of the methods for `parent_index_range` will use the argument `halo`. So that should be removed. (I think `loc` and `topo` are needed to support slicing into ""ensemble grids"" that have a flat direction with more than one grid point... I think.). > since the output writer is trying to view the underlying data at [4:23, 4:23, 4:23]. I think @navidcy discovered a problem with `validate_indices` that may be related. But `restrict_to_interior` may also be broken for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1269256387
https://github.com/CliMA/Oceananigans.jl/pull/2771#issuecomment-1267784624:97,Usability,simpl,simple,97,"I see. I was thinking that we could solve the issue with the sliced fields' outputwriter in that simple way, but it turns out it is a deeper problem since `view(field, indices(field)...)` does not work for sliced fields.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2771#issuecomment-1267784624
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271600560:35,Testability,test,tested,35,I can't see where/if callbacks are tested to add tests for these?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271600560
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271600560:49,Testability,test,tests,49,I can't see where/if callbacks are tested to add tests for these?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271600560
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271627269:114,Modifiability,extend,extends,114,"What do we think about the pros and cons of an alternative design that adds `state_callbacks` to `Simulation` and extends `time_step(model, dt, state_callbacks)` to accept the state callbacks as a positional argument?. It might be slightly less code and we don't have to bloat the model structs anymore. It also keeps the callback implementations in `Simulation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271627269
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713:135,Security,access,access,135,"My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713:233,Usability,clear,clearer,233,"My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271682713
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659:137,Security,access,access,137,"> My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?. Ah, I see your point and it's a good one! Let's see if anyone else has thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659:235,Usability,clear,clearer,235,"> My concern with associating it with the simulation was that, unless we pass the simulation to `time_step!` as well, the callback can't access it which might be confusing since normal callbacks are `func(sim)`. So I thought it may be clearer if callbacks associated with the model were `func(model)` instead. Not sure what the best solution is though?. Ah, I see your point and it's a good one! Let's see if anyone else has thoughts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271755659
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1272521047:920,Modifiability,evolve,evolves,920,"> One aspect of this change is that the models will no longer be concretely typed (because `OrderedDict{Symbol, Callback}` is not a concrete type). I'm not sure this matters, but it's worth noting this.; > ; > Thinking about the API issues, I wonder if there's another advantage in putting the state callbacks in `Simulation`, that we have a system in which a ""model"" is not modified after its created (eg we are not adding callbacks to it) --- that's something that we do with Simulations. With this PR, we mix the concepts of models and simulations. Which may be ok... Perhaps we could change it so you give the model a Tuple or NamedTuple of callbacks when you specify it so the API is more consistent and the model not modified after? I think it could be argued that state callbacks are part of the model rather than the simulation, like forcing functions are, since they could be an intrinsic part of how the model evolves, e.g. if it modified the tendencies. I suppose this argument could be made for some callbacks as well though so I don't know whats best!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1272521047
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278118477:784,Deployability,Update,UpdateState,784,"@navidcy @simone-silvestri any thoughts?. I thought of a few more considerations:. It may be easier to document this feature if it's in `Simulation`, because it can be explained in conjunction with ""normal"" `Callback`. Ie, ""Here are different flavors of callback users can employ to alter their simulation..."". An even more radical suggestion is to actually combine this feature with `Simulation.callbacks`. In other words, we don't nee d a separate _list_, but rather an additional identifier that says _where and how_ the callback will be employed. Right now a `Callback` has the properties `func`, `parameters`, and `schedule`. We could add a fourth property, something like `callsite`, which would be:. * `callsite=TimeStep()` when called every time-step / iteration; * `callsite=UpdateState()` when called inside `update_state()`; * and more. Another name / classification scheme might be better, that's just what floated to the top of my head.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278118477
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278118477:620,Energy Efficiency,schedul,schedule,620,"@navidcy @simone-silvestri any thoughts?. I thought of a few more considerations:. It may be easier to document this feature if it's in `Simulation`, because it can be explained in conjunction with ""normal"" `Callback`. Ie, ""Here are different flavors of callback users can employ to alter their simulation..."". An even more radical suggestion is to actually combine this feature with `Simulation.callbacks`. In other words, we don't nee d a separate _list_, but rather an additional identifier that says _where and how_ the callback will be employed. Right now a `Callback` has the properties `func`, `parameters`, and `schedule`. We could add a fourth property, something like `callsite`, which would be:. * `callsite=TimeStep()` when called every time-step / iteration; * `callsite=UpdateState()` when called inside `update_state()`; * and more. Another name / classification scheme might be better, that's just what floated to the top of my head.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278118477
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278791010:9,Usability,intuit,intuitively,9,I'd also intuitively prefer if this is part of simulation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1278791010
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279050785:638,Testability,test,testing,638,"I wonder if this would be better proposed as a custom dynamics option like with particles? . I'm just concerned that you could implement some dynamics in this way that are a core part of the model dynamics rather than a simulation of that model. For example, if you had a computationally intensive source/sink term, instead of recalculating for the tracer it's going to and from you could add a custom dynamic that calculates it once, takes from one and adds to the other (this is how PISCES implements a lot of the growth to prevent repetitive calculation of the same values, I don't know if this would be faster in this setting without testing but just as an example).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279050785
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279333832:144,Integrability,depend,depends,144,"> but that would mean passing the simulation to the time step, which is not ideal. We can create a schema where the argument to `Callback.func` depends on ""flavor"" / ""callsite"", etc, similar to how we have different ""forms"" for boundary conditions and forcing functions. > Do we need to support that accurate callback (happening at each RK substep)?. I guess as @jagoosw argues this is an important feature to support for advanced applications. There are a few different ""intra time step"" callsites we might envision (modifications to `calculate_tendencies!` differ from modifications to `update_state!`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279333832
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279336660:168,Testability,test,testing,168,"> (this is how PISCES implements a lot of the growth to prevent repetitive calculation of the same values, I don't know if this would be faster in this setting without testing but just as an example). I agree that we need this feature, but from a software design perspective one might argue that such an invasive change to model dynamics belongs in the source code itself, rather than a callback (and this of course how it works for PISCES, or any model other than Oceananigans --- since Oceananigans is the only model where we can envision such a fine-grained callback schema). I think having a callback infrastructure like this effectively allows people who implement advanced / custom applications to keep their code up to date with other changes to Oceananigans. The alternative model for software design, which is simply to create a new version of the source code for your custom application, leads to much more code duplication. So you could say that the callback feature could be important for the community to share advanced custom modifications to Oceananigans, without creating a terrible tangle in `main`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279336660
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279336660:819,Usability,simpl,simply,819,"> (this is how PISCES implements a lot of the growth to prevent repetitive calculation of the same values, I don't know if this would be faster in this setting without testing but just as an example). I agree that we need this feature, but from a software design perspective one might argue that such an invasive change to model dynamics belongs in the source code itself, rather than a callback (and this of course how it works for PISCES, or any model other than Oceananigans --- since Oceananigans is the only model where we can envision such a fine-grained callback schema). I think having a callback infrastructure like this effectively allows people who implement advanced / custom applications to keep their code up to date with other changes to Oceananigans. The alternative model for software design, which is simply to create a new version of the source code for your custom application, leads to much more code duplication. So you could say that the callback feature could be important for the community to share advanced custom modifications to Oceananigans, without creating a terrible tangle in `main`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1279336660
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1286807555:364,Testability,test,tests,364,"I've had a go at moving it to the `Simulation` and very happy to try different things until we find whatever is best. I've added a property to callbacks called substep which is by default false but if true then the callback is passed to `time_step!(model, \Delta t; callbacks)`, I made this an optional argument in case it is called elsewhere (like in some of the tests). . The callbacks then get passed on to `calculate_tendencies!` and are called after the other tendency calculations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1286807555
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1287065317:633,Testability,test,test,633,"> In case its of use this is the code I've been checking it with:; > ; > ```; > using Oceananigans; > grid = RectilinearGrid(size=(1, 1, 1), extent = (1, 1, 1)); > model = NonhydrostaticModel(grid=grid); > simulation = Simulation(model, Δt = 1, stop_iteration = 3); > test_sim(sim) = @info ""Sim? $(isa(sim, Oceananigans.Simulation))""; > test_model(model) = @info ""Model? $(isa(model, Oceananigans.AbstractModel))""; > simulation.callbacks[:inter] = Callback(test_sim); > simulation.callbacks[:intra] = Callback(test_model; callsite=TendencyCallback); > run!(simulation); > ```; > ; > And everything should return `true`. We'll need a test like this. I think there are already some tests for `Callback`, so we should add more to that list.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1287065317
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1287065317:680,Testability,test,tests,680,"> In case its of use this is the code I've been checking it with:; > ; > ```; > using Oceananigans; > grid = RectilinearGrid(size=(1, 1, 1), extent = (1, 1, 1)); > model = NonhydrostaticModel(grid=grid); > simulation = Simulation(model, Δt = 1, stop_iteration = 3); > test_sim(sim) = @info ""Sim? $(isa(sim, Oceananigans.Simulation))""; > test_model(model) = @info ""Model? $(isa(model, Oceananigans.AbstractModel))""; > simulation.callbacks[:inter] = Callback(test_sim); > simulation.callbacks[:intra] = Callback(test_model; callsite=TendencyCallback); > run!(simulation); > ```; > ; > And everything should return `true`. We'll need a test like this. I think there are already some tests for `Callback`, so we should add more to that list.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1287065317
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1287251749:291,Testability,test,test,291,"> Can the `callsite` be instantiated? Also I think the name of the types should correspond to the callsite, like this:; > ; > ```julia; > Callback(func, callsite=TendencyCallsite()); > Callback(func, callsite=TimeStepCallsite()) # default; > ```. Okay set it up like this now and will add a test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1287251749
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1297629904:9,Testability,test,tests,9,@jagoosw tests pass --- ok if I merge?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1297629904
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1297754098:11,Testability,test,tests,11,"> @jagoosw tests pass --- ok if I merge?. Yep, all good on my end!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1297754098
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725303703:82,Availability,error,erroring,82,"The whole callback page is a bit out of date, one of the example snippets is also erroring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725303703
https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725927502:362,Integrability,Message,Message,362,"Yes, that is the page that I saw.  I got there by searching the docs, not using the index.; On Sep 19, 2023 at 4:41 PM +0100, Gregory L. Wagner ***@***.***>, wrote:; > Hmm, yes I think that is an orphan page in the docs with no link...; > —; > Reply to this email directly, view it on GitHub, or unsubscribe.; > You are receiving this because you were mentioned.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1725927502
https://github.com/CliMA/Oceananigans.jl/pull/2775#issuecomment-1276358093:7,Deployability,update,update,7,Can we update also cuda to the 3.12 version?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2775#issuecomment-1276358093
https://github.com/CliMA/Oceananigans.jl/pull/2777#issuecomment-1279915232:48,Deployability,update,update,48,FYI: This changed the compat entry only. Didn’t update the SeawaterPolynomials version.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2777#issuecomment-1279915232
https://github.com/CliMA/Oceananigans.jl/pull/2778#issuecomment-1279612571:86,Performance,perform,performed,86,The problems seen in the global simulation were actually fixed by #2774. The test was performed without updating the code to the latest version. I will close this PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2778#issuecomment-1279612571
https://github.com/CliMA/Oceananigans.jl/pull/2778#issuecomment-1279612571:77,Testability,test,test,77,The problems seen in the global simulation were actually fixed by #2774. The test was performed without updating the code to the latest version. I will close this PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2778#issuecomment-1279612571
https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284165140:390,Testability,test,tested,390,"> Let's use PreconditionedConjugateGradientSolver with an FFT-based preconditioner (ie the original FFT solver) for this. Can you explain a bit the reason for this choice, just so that I can understand better? At first it seems to me that using a FFT-based preconditioner would still produce Gibbs phenomenon effects in situations where the original FFT-based solver also would, no?. FYI I tested this branch and it's returning NaNs everywhere for me, although I haven't had the time to investigate why.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284165140
https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284382130:317,Availability,error,error,317,"Is it the pressure field that has oscillations, or the velocity field?. Either way, I don't think that's important. A preconditioner should be some kind of approximate inverse for A, where we are solving for x in Ax = b --- or in other words, an approximate solver. The preconditioner does not have to be ""exact"" or ""error free"", since it's really the CG iteration that solves the problem. The idea is that the FFT-based solver yields a pressure field that is _almost_ correct. A similar strategy succeeded in this PR: https://github.com/CliMA/Oceananigans.jl/pull/2412",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284382130
https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284450132:247,Availability,error,error,247,"> Either way, I don't think that's important. A preconditioner should be some kind of approximate inverse for A, where we are solving for x in Ax = b --- or in other words, an approximate solver. The preconditioner does not have to be ""exact"" or ""error free"", since it's really the CG iteration that solves the problem. The idea is that the FFT-based solver yields a pressure field that is _almost_ correct. Ah, I see, so the idea behind using the FFT-based solver specifically as a preconditioner is because it's probably faster than other combination (if I understand correctly). Thanks!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284450132
https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284558702:249,Availability,error,error,249,"> > Either way, I don't think that's important. A preconditioner should be some kind of approximate inverse for A, where we are solving for x in Ax = b --- or in other words, an approximate solver. The preconditioner does not have to be ""exact"" or ""error free"", since it's really the CG iteration that solves the problem. The idea is that the FFT-based solver yields a pressure field that is _almost_ correct.; > ; > Ah, I see, so the idea behind using the FFT-based solver specifically as a preconditioner is because it's probably faster than other combination (if I understand correctly).; > ; > Thanks!. For sure, and we could use other preconditioners. But I suspect the FFT will be _much_ faster than any other preconditioner, which is why I think it's so interesting (and somewhat novel --- though similar approaches have been used for other problems).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2780#issuecomment-1284558702
https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1283389480:12,Testability,test,tests,12,"So a lot of tests break when I bump KernelAbstractions 0.8.4 + CUDAKernels 0.4.3.... cc @glwagner, @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1283389480
https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1284065270:40,Performance,perform,performance,40,"Nice, maybe this will also increase the performance!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1284065270
https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1284379177:174,Availability,error,errors,174,Yeah KA got rid of the force-inlining on the GPU. @lcw started the work of adding it back in a better way than before. The benefit is that we are no longer using Cassette so errors should be vastly improved.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1284379177
https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1312826687:106,Availability,error,error,106,@simone-silvestri can you have a look here? Some help with this would be great... Just have a look at the error of the tests that fail and let me know if you can understand where the root of the manner is?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1312826687
https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1312826687:119,Testability,test,tests,119,@simone-silvestri can you have a look here? Some help with this would be great... Just have a look at the error of the tests that fail and let me know if you can understand where the root of the manner is?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1312826687
https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1313872542:6,Availability,error,errors,6,"Weird errors, it looks like the GPU calculations are inaccurate",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1313872542
https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1416878499:62,Testability,test,tests,62,@vchuravy feel free to merge if you feel it's for the best... tests won't pass :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1416878499
https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1421915427:49,Deployability,update,updated,49,@navidcy should we close this pr now that KA was updated?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2782#issuecomment-1421915427
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1294926836:34,Deployability,update,update,34,"Note to self that we will need to update the docs (and also notation I think) for the Ri based diffusivity, since the ""diffusion parameter"" is actually a time-scale:. https://github.com/CliMA/Oceananigans.jl/blob/1143866d2d069075fe8fd5fa7d71b1ab18943f2d/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L148-L149",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1294926836
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1296350740:268,Testability,test,tests,268,"`test_ensemble_hydrostatic_free_surface_models.jl` fails on this PR and I can't figure out why. In particular, the case with many different Coriolises... ```julia; julia> include(""test_ensemble_hydrostatic_free_surface_models.jl""); ```; fails... This is affecting the tests on https://github.com/CliMA/ParameterEstimocean.jl/pull/295",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1296350740
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1296357722:294,Testability,test,tests,294,"> `test_ensemble_hydrostatic_free_surface_models.jl` fails on this PR and I can't figure out why. In particular, the case with many different Coriolises...; > ; > ```julia; > julia> include(""test_ensemble_hydrostatic_free_surface_models.jl""); > ```; > ; > fails...; > ; > This is affecting the tests on [CliMA/ParameterEstimocean.jl#295](https://github.com/CliMA/ParameterEstimocean.jl/pull/295). fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1296357722
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298018536:25,Availability,error,error,25,"@glwagner, regarding the error with the simulations with multiple Coriolises:; seems like adding a `@show ""hi""` *before* the `@apply_regionally correct_velocities_and_store_tendecies!(model, Δt)` in. https://github.com/CliMA/Oceananigans.jl/blob/b1997713b35f41b42a1f5cc5660d6ceb2ec3e305/src/TimeSteppers/quasi_adams_bashforth_2.jl#L95-L97. makes the error go away. Does this give a hint for what might be causing it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298018536
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298018536:350,Availability,error,error,350,"@glwagner, regarding the error with the simulations with multiple Coriolises:; seems like adding a `@show ""hi""` *before* the `@apply_regionally correct_velocities_and_store_tendecies!(model, Δt)` in. https://github.com/CliMA/Oceananigans.jl/blob/b1997713b35f41b42a1f5cc5660d6ceb2ec3e305/src/TimeSteppers/quasi_adams_bashforth_2.jl#L95-L97. makes the error go away. Does this give a hint for what might be causing it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298018536
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298402412:9,Performance,race condition,race condition,9,Probably race condition with apply regionally then. Cc @simone-silvestri,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298402412
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298424146:136,Integrability,synchroniz,synchronization,136,"Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1298424146
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299354090:138,Integrability,synchroniz,synchronization,138,"> Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`. Actually, even putting `@show ""hi""` **just before** `calculate_pressure_correction!` also does the job.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299354090
https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299382102:140,Integrability,synchroniz,synchronization,140,"> > Unlikely since that will just execute `pressure_correct_velocities!(model, Δt)` and `store_tendencies!(model)`. It might be an upstream synchronization problem in the `calculate_pressure_correction!`; > ; > Actually, even putting `@show ""hi""` **just before** `calculate_pressure_correction!` also does the job. Right, `calculate_pressure_correction!` does nothing for the free surface model so it shouldn't matter where it's placed relative to that. Is that the only place within `time_step!` that fixes it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786#issuecomment-1299382102
https://github.com/CliMA/Oceananigans.jl/pull/2789#issuecomment-1295936187:14,Deployability,update,update,14,"Ok, I sent an update that I hope improves the language a bit. Merge when you're happy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2789#issuecomment-1295936187
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1298967328:435,Performance,perform,performant,435,"That's not expected and sounds like a huge change! The only important change I can think of is when we started pre-calculating the immersed boundary (rather than allowing it to be a function):. https://github.com/CliMA/Oceananigans.jl/blob/3557db3692ff8e1978b126369230c9bacae42ae8/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L70. That adds one 2D (x, y) field. The reason is because in the majority of cases this is more performant (we think). In a model with one tracer and AMD, we have something like 16 3D fields. So 25% is a huge amount of data equivalent to four 3D fields. Any ideas @simone-silvestri ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1298967328
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299013300:0,Deployability,Update,Update,0,"Update: I've tried the newest Oceananigans version (0.78) with Julia 1.7 and the memory allocation was almost exactly the same as with Julia 1.8. So it doesn't seem like it's the Julia version. Also relevant, as per @glwagner's comment, is that I am indeed using a vertically stretched grid. I could also run a test simulation with a regular grid and see if that decreases the allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299013300
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299013300:311,Testability,test,test,311,"Update: I've tried the newest Oceananigans version (0.78) with Julia 1.7 and the memory allocation was almost exactly the same as with Julia 1.8. So it doesn't seem like it's the Julia version. Also relevant, as per @glwagner's comment, is that I am indeed using a vertically stretched grid. I could also run a test simulation with a regular grid and see if that decreases the allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299013300
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299015577:128,Availability,error,errors,128,"We will have to set up some test cases for sure. Are you directly measuring memory allocation, or is the problem ""out of memory errors""? Because the second might have to do with temporary allocations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299015577
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299015577:28,Testability,test,test,28,"We will have to set up some test cases for sure. Are you directly measuring memory allocation, or is the problem ""out of memory errors""? Because the second might have to do with temporary allocations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299015577
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285:137,Availability,error,errors,137,"> We will have to set up some test cases for sure.; > ; > Are you directly measuring memory allocation, or is the problem ""out of memory errors""? Because the second might have to do with temporary allocations. That's a good point! I've been measuring the memory usage right after defining `model` and right before calling `run!()` (the only things in between are the definition of `simulation` and a bunch of diagnostics), but I've definitely been focusing more on the errors. Here are some numbers that I think bring some clarity:. - Using Julia 1.6 and Oceananigans 0.77.5:; - Biggest grid I can run: `997×997×96 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 19712MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 25778MiB / 32768MiB; - Using Julia 1.7 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB; - Using Julia 1.8 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB. Note that although Julia 1.6 + Oceananigans 0.77 ends up with the smaller memory usage in the end, it apparently uses a lot of temporary allocations because I get an out-of-memory error when adding diagnostics with bigger grids. That said, it still manages to have the smallest ""permanent"" memory usage and allows me to run larger simulations. Interesting results. The biggest difference seems to be in the allocations required for the diagnostics (or maybe `Simulatio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285:469,Availability,error,errors,469,"> We will have to set up some test cases for sure.; > ; > Are you directly measuring memory allocation, or is the problem ""out of memory errors""? Because the second might have to do with temporary allocations. That's a good point! I've been measuring the memory usage right after defining `model` and right before calling `run!()` (the only things in between are the definition of `simulation` and a bunch of diagnostics), but I've definitely been focusing more on the errors. Here are some numbers that I think bring some clarity:. - Using Julia 1.6 and Oceananigans 0.77.5:; - Biggest grid I can run: `997×997×96 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 19712MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 25778MiB / 32768MiB; - Using Julia 1.7 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB; - Using Julia 1.8 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB. Note that although Julia 1.6 + Oceananigans 0.77 ends up with the smaller memory usage in the end, it apparently uses a lot of temporary allocations because I get an out-of-memory error when adding diagnostics with bigger grids. That said, it still manages to have the smallest ""permanent"" memory usage and allows me to run larger simulations. Interesting results. The biggest difference seems to be in the allocations required for the diagnostics (or maybe `Simulatio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285:1713,Availability,error,error,1713,"or is the problem ""out of memory errors""? Because the second might have to do with temporary allocations. That's a good point! I've been measuring the memory usage right after defining `model` and right before calling `run!()` (the only things in between are the definition of `simulation` and a bunch of diagnostics), but I've definitely been focusing more on the errors. Here are some numbers that I think bring some clarity:. - Using Julia 1.6 and Oceananigans 0.77.5:; - Biggest grid I can run: `997×997×96 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 19712MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 25778MiB / 32768MiB; - Using Julia 1.7 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB; - Using Julia 1.8 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB. Note that although Julia 1.6 + Oceananigans 0.77 ends up with the smaller memory usage in the end, it apparently uses a lot of temporary allocations because I get an out-of-memory error when adding diagnostics with bigger grids. That said, it still manages to have the smallest ""permanent"" memory usage and allows me to run larger simulations. Interesting results. The biggest difference seems to be in the allocations required for the diagnostics (or maybe `Simulation`?). I can tests without diagnostics at some point and compare the results if you agree that's useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285:30,Testability,test,test,30,"> We will have to set up some test cases for sure.; > ; > Are you directly measuring memory allocation, or is the problem ""out of memory errors""? Because the second might have to do with temporary allocations. That's a good point! I've been measuring the memory usage right after defining `model` and right before calling `run!()` (the only things in between are the definition of `simulation` and a bunch of diagnostics), but I've definitely been focusing more on the errors. Here are some numbers that I think bring some clarity:. - Using Julia 1.6 and Oceananigans 0.77.5:; - Biggest grid I can run: `997×997×96 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 19712MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 25778MiB / 32768MiB; - Using Julia 1.7 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB; - Using Julia 1.8 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB. Note that although Julia 1.6 + Oceananigans 0.77 ends up with the smaller memory usage in the end, it apparently uses a lot of temporary allocations because I get an out-of-memory error when adding diagnostics with bigger grids. That said, it still manages to have the smallest ""permanent"" memory usage and allows me to run larger simulations. Interesting results. The biggest difference seems to be in the allocations required for the diagnostics (or maybe `Simulatio",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285:2013,Testability,test,tests,2013,"or is the problem ""out of memory errors""? Because the second might have to do with temporary allocations. That's a good point! I've been measuring the memory usage right after defining `model` and right before calling `run!()` (the only things in between are the definition of `simulation` and a bunch of diagnostics), but I've definitely been focusing more on the errors. Here are some numbers that I think bring some clarity:. - Using Julia 1.6 and Oceananigans 0.77.5:; - Biggest grid I can run: `997×997×96 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 19712MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 25778MiB / 32768MiB; - Using Julia 1.7 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB; - Using Julia 1.8 and Oceanaigans 0.78.0:; - Biggest grid I can run: `941×941×90 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on GPU with 4×4×4 halo`; - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 31026MiB / 32768MiB. Note that although Julia 1.6 + Oceananigans 0.77 ends up with the smaller memory usage in the end, it apparently uses a lot of temporary allocations because I get an out-of-memory error when adding diagnostics with bigger grids. That said, it still manages to have the smallest ""permanent"" memory usage and allows me to run larger simulations. Interesting results. The biggest difference seems to be in the allocations required for the diagnostics (or maybe `Simulation`?). I can tests without diagnostics at some point and compare the results if you agree that's useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299523285
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:261,Deployability,upgrade,upgraded,261,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:649,Energy Efficiency,allocate,allocate,649,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:781,Energy Efficiency,reduce,reduce,781,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:510,Performance,perform,performed,510,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:274,Testability,test,tests,274,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134:571,Usability,simpl,simply,571,"Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?. I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1299561134
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:263,Deployability,upgrade,upgraded,263,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:756,Energy Efficiency,allocate,allocate,756,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:888,Energy Efficiency,reduce,reduce,888,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:363,Integrability,depend,dependencies,363,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:617,Performance,perform,performed,617,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:978,Performance,perform,performing,978,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:276,Testability,test,tests,276,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:678,Usability,simpl,simply,678,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300864095:280,Availability,down,down,280,"> > @tomchor can you do another one; > > ; > > * Using Julia 1.8 and Oceanigans#main; > > ?; > ; > Wasn't #2778 closed without merging?; > ; > Do you mean for me to run that branch?. @navidcy I ran it using Julia 1.8 and the branch in #2778 and indeed the memory consumption goes down. Using 80 million points (what I've been using for version 0.78) I have:. - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 21714MiB / 32768MiB. So the memory usage after adding diagnostics decrease significantly (from 31 to 21 GB), while the memory usage before looks like it's exactly the same. With branch #2778 I can then go back to running simulations at least of the same size as I did in 0.77.5.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300864095
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300864095:263,Energy Efficiency,consumption,consumption,263,"> > @tomchor can you do another one; > > ; > > * Using Julia 1.8 and Oceanigans#main; > > ?; > ; > Wasn't #2778 closed without merging?; > ; > Do you mean for me to run that branch?. @navidcy I ran it using Julia 1.8 and the branch in #2778 and indeed the memory consumption goes down. Using 80 million points (what I've been using for version 0.78) I have:. - Memory usage right after building `model`: 16576MiB / 32768MiB; - Memory usage right before running and after adding simulation and diagnostics: 21714MiB / 32768MiB. So the memory usage after adding diagnostics decrease significantly (from 31 to 21 GB), while the memory usage before looks like it's exactly the same. With branch #2778 I can then go back to running simulations at least of the same size as I did in 0.77.5.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300864095
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:128,Availability,error,error,128,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:162,Availability,ERROR,ERROR,162,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:187,Availability,error,error,187,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:357,Availability,error,error,357,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:64165,Availability,error,error,64165,"{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Float64, typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.identity5), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Float64}}}}}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, Nothing, NamedTuple{(), Tuple{}}}); ```. (error is truncated)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:13928,Deployability,Continuous,ContinuousBoundaryFunction,13928,".TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryG",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:14250,Deployability,Continuous,ContinuousBoundaryFunction,14250,".OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:14573,Deployability,Continuous,ContinuousBoundaryFunction,14573,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.Imm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:16322,Deployability,Continuous,ContinuousBoundaryFunction,16322,"ion{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:16644,Deployability,Continuous,ContinuousBoundaryFunction,16644,"lon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:16985,Deployability,Continuous,ContinuousBoundaryFunction,16985,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.Imm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:18734,Deployability,Continuous,ContinuousBoundaryFunction,18734,"ion{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:19056,Deployability,Continuous,ContinuousBoundaryFunction,19056,"lon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:19379,Deployability,Continuous,ContinuousBoundaryFunction,19379,"thing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:19701,Deployability,Continuous,ContinuousBoundaryFunction,19701,"s.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:24902,Deployability,Continuous,ContinuousForcing,24902,"t64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, WENO{3, Floa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:25183,Deployability,Continuous,ContinuousForcing,25183,"nigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, CuArray{Tuple{Float64, Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:25464,Deployability,Continuous,ContinuousForcing,25464,"igans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, CuArray{Tuple{Float64, Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:25745,Deployability,Continuous,ContinuousForcing,25745,", :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, CuArray{Tuple{Float64, Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:44213,Deployability,Continuous,ContinuousBoundaryFunction,44213,".TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryG",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:44535,Deployability,Continuous,ContinuousBoundaryFunction,44535,".OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:44858,Deployability,Continuous,ContinuousBoundaryFunction,44858,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.Imm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:46607,Deployability,Continuous,ContinuousBoundaryFunction,46607,"ion{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:46929,Deployability,Continuous,ContinuousBoundaryFunction,46929,"lon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:47270,Deployability,Continuous,ContinuousBoundaryFunction,47270,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity4)}}}, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.Imm",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:49019,Deployability,Continuous,ContinuousBoundaryFunction,49019,"ion{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:49341,Deployability,Continuous,ContinuousBoundaryFunction,49341,"lon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:49664,Deployability,Continuous,ContinuousBoundaryFunction,49664,"thing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:49986,Deployability,Continuous,ContinuousBoundaryFunction,49986,"s.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity3)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUD",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:55187,Deployability,Continuous,ContinuousForcing,55187,"t64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, WENO{3, Floa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:55468,Deployability,Continuous,ContinuousForcing,55468,"nigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, CuArray{Tuple{Float64, Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:55749,Deployability,Continuous,ContinuousForcing,55749,"igans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, CuArray{Tuple{Float64, Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:56030,Deployability,Continuous,ContinuousForcing,56030,", :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), Tuple{Float64, Int64, Float64, Float64, Float64, Float64, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, CuArray{Tuple{Float64, Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, CuArray{Tuple{Float64, Float64}, 1, CUDA.Mem.DeviceBuffer}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:212,Modifiability,variab,variable,212,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:872,Modifiability,variab,variable,872,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:926,Modifiability,Variab,Variable,926,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:1106,Modifiability,variab,variable,1106,"e the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:1184,Modifiability,Variab,Variable,1184,"ismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Ste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:169,Performance,Load,LoadError,169,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:363,Energy Efficiency,reduce,reduce,363,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:965,Energy Efficiency,allocate,allocate,965,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:761,Integrability,depend,depending,761,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:740,Performance,perform,performant,740,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:913,Performance,perform,performance,913,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301495852:66,Usability,clear,clear,66,"> You can also accumulate the time-average on the CPU. Just to be clear though, I have plenty of 3D spatial (volume) averages, but no time-averages on my runs! I know the time-averaging does take more memory because of the accumulation process, but the spatial average is kind of a surprise for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301495852
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:44,Energy Efficiency,allocate,allocates,44,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:148,Energy Efficiency,allocate,allocate,148,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:333,Energy Efficiency,reduce,reduce,333,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:107,Modifiability,variab,variables,107,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509:46,Energy Efficiency,allocate,allocates,46,"> The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way.; > ; > Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output. I find that using `Field(abstract_op, data=scratc.data)` saves a ton of space when compared to just passing `abstract_op` to the writer. Is that not expected? Also, at least for my simulation using `NetCDFWriter`, passing `Field(abstract_op)` or `abstract_op` makes no difference on memory allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509:150,Energy Efficiency,allocate,allocate,150,"> The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way.; > ; > Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output. I find that using `Field(abstract_op, data=scratc.data)` saves a ton of space when compared to just passing `abstract_op` to the writer. Is that not expected? Also, at least for my simulation using `NetCDFWriter`, passing `Field(abstract_op)` or `abstract_op` makes no difference on memory allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509:342,Energy Efficiency,reduce,reduce,342,"> The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way.; > ; > Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output. I find that using `Field(abstract_op, data=scratc.data)` saves a ton of space when compared to just passing `abstract_op` to the writer. Is that not expected? Also, at least for my simulation using `NetCDFWriter`, passing `Field(abstract_op)` or `abstract_op` makes no difference on memory allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509:109,Modifiability,variab,variables,109,"> The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way.; > ; > Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output. I find that using `Field(abstract_op, data=scratc.data)` saves a ton of space when compared to just passing `abstract_op` to the writer. Is that not expected? Also, at least for my simulation using `NetCDFWriter`, passing `Field(abstract_op)` or `abstract_op` makes no difference on memory allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:130,Energy Efficiency,allocate,allocates,130,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:3,Integrability,depend,depends,3,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903
https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903:601,Safety,avoid,avoid,601,"It depends. If you are also passing `indices` to the writer, then `Field(abstract_op, data=scratch.data)` wastes a lot because it allocates a 3D array for `abstract_op`. If you want to use indices AND scratch data, you can use `Field(abstract_op; data=scrath.data, indices)`, where `indices` is the same thing you would pass to the output writer. Generally, you should only need to worry about scratch data if you have a lot of 3D output. If you have 2D output, it's unlikely that using scratch data will help much (and will significantly complicate your scripts, so I'd say best practice would be to avoid it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302680903
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:905,Availability,avail,available,905,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:1623,Availability,avail,available,1623,"h @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure though, so I would advise against performing too many involved diagnostics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:16,Energy Efficiency,adapt,adapt,16,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:114,Energy Efficiency,adapt,adapt,114,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:569,Energy Efficiency,adapt,adapt,569,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:16,Modifiability,adapt,adapt,16,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:114,Modifiability,adapt,adapt,114,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:569,Modifiability,adapt,adapt,569,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:1182,Performance,perform,performed,1182,"h @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure though, so I would advise against performing too many involved diagnostics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:2036,Performance,perform,performing,2036,"h @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure though, so I would advise against performing too many involved diagnostics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:826,Security,access,accessible,826,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:918,Testability,log,logging,918,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302354230:189,Performance,optimiz,optimize,189,@simone-silvestri you mentioned that in this PR the pressure solver is done on a single GPU for the time being. Can https://github.com/CliMA/Oceananigans.jl/pull/2538 be a stating point to optimize that as well? That PR is really close to ready I think,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302354230
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706:129,Availability,ERROR,ERROR,129,"@simone-silvestri this doesn't seem to be working when the domain is `Bounded` in the x direction. Is this expected?:. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:24; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:25; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:28; ...; Stacktrace:; [1] NonhydrostaticModel(; grid::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706:136,Performance,Load,LoadError,136,"@simone-silvestri this doesn't seem to be working when the domain is `Bounded` in the x direction. Is this expected?:. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:24; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:25; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:28; ...; Stacktrace:; [1] NonhydrostaticModel(; grid::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523:29,Availability,error,error,29,"In addition to the bounded-x error above, interpolation methods also appear to be failing at times:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); @info grid. model = NonhydrostaticModel(grid = grid); @info """" model. u, v, w = model.velocities. ω_x = Field((@at (Center, Face, Face) ∂y(w)-∂z(v))); ```. This throws me the following error:. ```; ERROR: LoadError: MethodError: no method matching interpolate_index(::Tuple{Colon, Colon, Colon}, ::Colon, ::Type{Center}, ::Type{Center}); Closest candidates are:; interpolate_index(::UnitRange, ::Colon, ::Any, ::Any) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:80; interpolate_index(::Colon, ::Colon, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:77; interpolate_index(::Colon, ::UnitRange, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:78; ...; Stacktrace:; [1] interpolate_indices(::Oceananigans.AbstractOperations.Derivative{Center, Face, Face, typeof(Oceananigans.Operators.∂yᶜᶠᶠ), Field{Center, Center, Face, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523:454,Availability,error,error,454,"In addition to the bounded-x error above, interpolation methods also appear to be failing at times:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); @info grid. model = NonhydrostaticModel(grid = grid); @info """" model. u, v, w = model.velocities. ω_x = Field((@at (Center, Face, Face) ∂y(w)-∂z(v))); ```. This throws me the following error:. ```; ERROR: LoadError: MethodError: no method matching interpolate_index(::Tuple{Colon, Colon, Colon}, ::Colon, ::Type{Center}, ::Type{Center}); Closest candidates are:; interpolate_index(::UnitRange, ::Colon, ::Any, ::Any) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:80; interpolate_index(::Colon, ::Colon, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:77; interpolate_index(::Colon, ::UnitRange, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:78; ...; Stacktrace:; [1] interpolate_indices(::Oceananigans.AbstractOperations.Derivative{Center, Face, Face, typeof(Oceananigans.Operators.∂yᶜᶠᶠ), Field{Center, Center, Face, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523:467,Availability,ERROR,ERROR,467,"In addition to the bounded-x error above, interpolation methods also appear to be failing at times:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); @info grid. model = NonhydrostaticModel(grid = grid); @info """" model. u, v, w = model.velocities. ω_x = Field((@at (Center, Face, Face) ∂y(w)-∂z(v))); ```. This throws me the following error:. ```; ERROR: LoadError: MethodError: no method matching interpolate_index(::Tuple{Colon, Colon, Colon}, ::Colon, ::Type{Center}, ::Type{Center}); Closest candidates are:; interpolate_index(::UnitRange, ::Colon, ::Any, ::Any) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:80; interpolate_index(::Colon, ::Colon, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:77; interpolate_index(::Colon, ::UnitRange, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:78; ...; Stacktrace:; [1] interpolate_indices(::Oceananigans.AbstractOperations.Derivative{Center, Face, Face, typeof(Oceananigans.Operators.∂yᶜᶠᶠ), Field{Center, Center, Face, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523:474,Performance,Load,LoadError,474,"In addition to the bounded-x error above, interpolation methods also appear to be failing at times:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size=(4, 4, 4), extent = (1,1,1)); grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); @info grid. model = NonhydrostaticModel(grid = grid); @info """" model. u, v, w = model.velocities. ω_x = Field((@at (Center, Face, Face) ∂y(w)-∂z(v))); ```. This throws me the following error:. ```; ERROR: LoadError: MethodError: no method matching interpolate_index(::Tuple{Colon, Colon, Colon}, ::Colon, ::Type{Center}, ::Type{Center}); Closest candidates are:; interpolate_index(::UnitRange, ::Colon, ::Any, ::Any) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:80; interpolate_index(::Colon, ::Colon, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:77; interpolate_index(::Colon, ::UnitRange, ::Any...) at ~/.julia/packages/Oceananigans/F1fni/src/AbstractOperations/at.jl:78; ...; Stacktrace:; [1] interpolate_indices(::Oceananigans.AbstractOperations.Derivative{Center, Face, Face, typeof(Oceananigans.Operators.∂yᶜᶠᶠ), Field{Center, Center, Face, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, St",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303864523
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303948893:11,Testability,test,testing,11,"thanks for testing, both problems should be solved",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1303948893
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304013634:897,Availability,ERROR,ERROR,897,"> thanks for testing, both problems should be solved. Indeed they are! Thanks @simone-silvestri. One thing I should note is that this fails when `Nx` isn't even (I guess becasue the partition is in `x`):. ```julia; julia> grid_base = RectilinearGrid(topology=(Bounded, Periodic, Bounded), size=(5, 4, 4), extent = (1,1,1)); 5×4×4 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Bounded x ∈ [0.0, 1.0] regularly spaced with Δx=0.2; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion ~/.julia/packages/Oceananigans/E1180/src/MultiRegion/multi_region_grid.jl:64; ERROR: AssertionError: mod(Nx, p.div) == 0; Stacktrace:; [1] partition_size(p::XPartition{Int64}, grid::RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ Oceananigans.MultiRegion ~/.julia/packages/Oceananigans/E1180/src/MultiRegion/x_partitions.jl:24; [2] MultiRegionGrid(global_grid::RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304013634
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304013634:13,Testability,test,testing,13,"> thanks for testing, both problems should be solved. Indeed they are! Thanks @simone-silvestri. One thing I should note is that this fails when `Nx` isn't even (I guess becasue the partition is in `x`):. ```julia; julia> grid_base = RectilinearGrid(topology=(Bounded, Periodic, Bounded), size=(5, 4, 4), extent = (1,1,1)); 5×4×4 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Bounded x ∈ [0.0, 1.0] regularly spaced with Δx=0.2; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion ~/.julia/packages/Oceananigans/E1180/src/MultiRegion/multi_region_grid.jl:64; ERROR: AssertionError: mod(Nx, p.div) == 0; Stacktrace:; [1] partition_size(p::XPartition{Int64}, grid::RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ Oceananigans.MultiRegion ~/.julia/packages/Oceananigans/E1180/src/MultiRegion/x_partitions.jl:24; [2] MultiRegionGrid(global_grid::RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304013634
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304013634:904,Testability,Assert,AssertionError,904,"> thanks for testing, both problems should be solved. Indeed they are! Thanks @simone-silvestri. One thing I should note is that this fails when `Nx` isn't even (I guess becasue the partition is in `x`):. ```julia; julia> grid_base = RectilinearGrid(topology=(Bounded, Periodic, Bounded), size=(5, 4, 4), extent = (1,1,1)); 5×4×4 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Bounded x ∈ [0.0, 1.0] regularly spaced with Δx=0.2; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> grid = MultiRegionGrid(grid_base, partition = XPartition(2), devices = 2); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion ~/.julia/packages/Oceananigans/E1180/src/MultiRegion/multi_region_grid.jl:64; ERROR: AssertionError: mod(Nx, p.div) == 0; Stacktrace:; [1] partition_size(p::XPartition{Int64}, grid::RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ Oceananigans.MultiRegion ~/.julia/packages/Oceananigans/E1180/src/MultiRegion/x_partitions.jl:24; [2] MultiRegionGrid(global_grid::RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePre",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304013634
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:32,Availability,error,error,32,"Another issue! I'm getting this error when setting up a NetCDFWriter:. ```julia; caused by: MethodError: no method matching construct_output(::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:118010,Availability,error,error,118010,"CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}, Float64, typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.identity4), MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, Float64}}}}}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, Nothing, NamedTuple{(), Tuple{}}}}}); ```. Let me know if you need a MWE! (I'm assuming you can figure it out from the error alone)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:30865,Deployability,Continuous,ContinuousBoundaryFunction,30865,"U}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:31187,Deployability,Continuous,ContinuousBoundaryFunction,31187,"ct{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceana",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:31510,Deployability,Continuous,ContinuousBoundaryFunction,31510,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:32393,Deployability,Continuous,ContinuousBoundaryFunction,32393,"undaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:32715,Deployability,Continuous,ContinuousBoundaryFunction,32715,"thing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}},",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:33038,Deployability,Continuous,ContinuousBoundaryFunction,33038,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}, Field{Center, Face, Center, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Ste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:35732,Deployability,Continuous,ContinuousBoundaryFunction,35732,"ctor{Float64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:36054,Deployability,Continuous,ContinuousBoundaryFunction,36054,"y, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Bounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:36395,Deployability,Continuous,ContinuousBoundaryFunction,36395,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:37260,Deployability,Continuous,ContinuousBoundaryFunction,37260,"thing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tupl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:37582,Deployability,Continuous,ContinuousBoundaryFunction,37582,".identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, N",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:37923,Deployability,Continuous,ContinuousBoundaryFunction,37923,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}, Field{Center, Center, Face, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Ste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:40617,Deployability,Continuous,ContinuousBoundaryFunction,40617,"ctor{Float64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:40939,Deployability,Continuous,ContinuousBoundaryFunction,40939,"y, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, Bou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:41262,Deployability,Continuous,ContinuousBoundaryFunction,41262,"thing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryConditi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:41584,Deployability,Continuous,ContinuousBoundaryFunction,41584,"s.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:42459,Deployability,Continuous,ContinuousBoundaryFunction,42459,")}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:42781,Deployability,Continuous,ContinuousBoundaryFunction,42781,"2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:43104,Deployability,Continuous,ContinuousBoundaryFunction,43104,"thing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, N",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:43426,Deployability,Continuous,ContinuousBoundaryFunction,43426,"s.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}}}, NamedTuple{(:b,), Tuple{Field{Center, Center, Center, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:53224,Deployability,Continuous,ContinuousForcing,53224,"ltiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, Vector{Tuple{Float64, Float64, Float64}}}}, Nothing, true, Nothing, WENO{2,",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:53457,Deployability,Continuous,ContinuousForcing,53457,"undaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, Vector{Tuple{Float64, Float64, Float64}}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:53690,Deployability,Continuous,ContinuousForcing,53690,"e{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, Vector{Tuple{Float64, Float64, Float64}}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, No",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:53923,Deployability,Continuous,ContinuousForcing,53923,"y{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}}}, NamedTuple{(:u, :v, :w, :b), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_v), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_w), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:H, :L, :σ, :sp_length_y, :V∞, :f₀, :N²∞), NTuple{7, Float64}}, typeof(forc_b), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}}}, WENO{3, Float64, Nothing, Nothing, NTuple{4, OffsetArrays.OffsetVector{Tuple{Float64, Float64, Float64}, Vector{Tuple{Float64, Float64, Float64}}}}, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, Oceananigans.MultiRegion.MultiRegionPoissonSolver{MultiRegionGrid{Float64, Periodic, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:82603,Deployability,Continuous,ContinuousBoundaryFunction,82603,"U}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:82925,Deployability,Continuous,ContinuousBoundaryFunction,82925,"ct{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceana",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:83248,Deployability,Continuous,ContinuousBoundaryFunction,83248,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tup",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:84131,Deployability,Continuous,ContinuousBoundaryFunction,84131,"undaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:84453,Deployability,Continuous,ContinuousBoundaryFunction,84453,"thing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}},",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:84776,Deployability,Continuous,ContinuousBoundaryFunction,84776,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τˣʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(ℑxyᶠᶜᵃ)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}, Field{Center, Face, Center, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Ste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:87470,Deployability,Continuous,ContinuousBoundaryFunction,87470,"ctor{Float64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:87792,Deployability,Continuous,ContinuousBoundaryFunction,87792,"y, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Bounda",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:88133,Deployability,Continuous,ContinuousBoundaryFunction,88133,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:88998,Deployability,Continuous,ContinuousBoundaryFunction,88998,"thing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tupl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:89320,Deployability,Continuous,ContinuousBoundaryFunction,89320,".identity3)}}}, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, N",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:89661,Deployability,Continuous,ContinuousBoundaryFunction,89661,"ndition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(τʸˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τʸᶻ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxyᶜᶠᵃ), typeof(Oceananigans.Operators.identity3)}}}, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}}, Tuple{CPU, CPU}}}, Field{Center, Center, Face, Nothing, MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Ste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:92355,Deployability,Continuous,ContinuousBoundaryFunction,92355,"ctor{Float64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:92677,Deployability,Continuous,ContinuousBoundaryFunction,92677,"y, MultiRegionObject{Tuple{FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, Bou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:93000,Deployability,Continuous,ContinuousBoundaryFunction,93000,"thing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryConditi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:93322,Deployability,Continuous,ContinuousBoundaryFunction,93322,"s.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:94197,Deployability,Continuous,ContinuousBoundaryFunction,94197,")}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:94519,Deployability,Continuous,ContinuousBoundaryFunction,94519,"2)}}}, Nothing, Nothing}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Communication, Oceananigans.MultiRegion.Connectivity}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524:94842,Deployability,Continuous,ContinuousBoundaryFunction,94842,"thing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻˣ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(τᶻʸ_drag), Nothing, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}}, Tuple{CPU, CPU}}, Nothing, MultiRegionObject{Tuple{Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, Nothing}, Oceananigans.Fields.FieldBoundaryBuffers{NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, NamedTuple{(:send, :recv), Tuple{Array{Float64, 3}, Array{Float64, 3}}}, Nothing, N",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524
