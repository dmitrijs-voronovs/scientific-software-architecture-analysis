id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:193,Modifiability,config,configuration,193,"////////////////////////////////////////////////////////////////////////////////; /// Constructor used after having fit using directly ROOT::Fit::Fitter; /// will create a dummy fitter copying configuration and parameter settings",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear resources for consecutive fits",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:133,Integrability,interface,interface,133,"////////////////////////////////////////////////////////////////////////////////; /// Execute the command (Fortran Minuit compatible interface)",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:2,Usability,Simpl,Simplex,2,"//Simplex",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:23,Security,access,access,23,"// do only MINOS. need access to minimizer. For the moment re-run fitting with minos options",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:23,Security,access,access,23,"// do only HESSE. need access to minimizer. For the moment re-run fitting with hesse options",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:11,Availability,avail,available,11,"// not yet available; // fGradient = true;",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:400,Availability,error,errors,400,"////////////////////////////////////////////////////////////////////////////////; /// Computes confidence intervals at level cl. Default is 0.95; /// The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; /// For Graphs, confidence intervals are computed for each point,; /// the value of the graph at that point is set to the function value at that; /// point, and the graph y-errors (or z-errors) are set to the value of; /// the confidence interval at that point.; /// For Histograms, confidence intervals are computed for each bin center; /// The bin content of this bin is then set to the function value at the bin; /// center, and the bin error is set to the confidence interval value.; //; /// NOTE: confidence intervals are approximate for nonlinear models!; ///; /// Allowed combinations:; ///; /// Fitted object | Passed object; /// --------------------------|------------------; /// TGraph | TGraphErrors, TH1; /// TGraphErrors, AsymmErrors | TGraphErrors, TH1; /// TH1 | TGraphErrors, TH1; /// TGraph2D | TGraph2DErrors, TH2; /// TGraph2DErrors | TGraph2DErrors, TH2; /// TH2 | TGraph2DErrors, TH2; /// TH3 | TH3",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:413,Availability,error,errors,413,"////////////////////////////////////////////////////////////////////////////////; /// Computes confidence intervals at level cl. Default is 0.95; /// The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; /// For Graphs, confidence intervals are computed for each point,; /// the value of the graph at that point is set to the function value at that; /// point, and the graph y-errors (or z-errors) are set to the value of; /// the confidence interval at that point.; /// For Histograms, confidence intervals are computed for each bin center; /// The bin content of this bin is then set to the function value at the bin; /// center, and the bin error is set to the confidence interval value.; //; /// NOTE: confidence intervals are approximate for nonlinear models!; ///; /// Allowed combinations:; ///; /// Fitted object | Passed object; /// --------------------------|------------------; /// TGraph | TGraphErrors, TH1; /// TGraphErrors, AsymmErrors | TGraphErrors, TH1; /// TH1 | TGraphErrors, TH1; /// TGraph2D | TGraph2DErrors, TH2; /// TGraph2DErrors | TGraph2DErrors, TH2; /// TH2 | TGraph2DErrors, TH2; /// TH3 | TH3",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:667,Availability,error,error,667,"////////////////////////////////////////////////////////////////////////////////; /// Computes confidence intervals at level cl. Default is 0.95; /// The TObject parameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; /// For Graphs, confidence intervals are computed for each point,; /// the value of the graph at that point is set to the function value at that; /// point, and the graph y-errors (or z-errors) are set to the value of; /// the confidence interval at that point.; /// For Histograms, confidence intervals are computed for each bin center; /// The bin content of this bin is then set to the function value at the bin; /// center, and the bin error is set to the confidence interval value.; //; /// NOTE: confidence intervals are approximate for nonlinear models!; ///; /// Allowed combinations:; ///; /// Fitted object | Passed object; /// --------------------------|------------------; /// TGraph | TGraphErrors, TH1; /// TGraphErrors, AsymmErrors | TGraphErrors, TH1; /// TH1 | TGraphErrors, TH1; /// TGraph2D | TGraph2DErrors, TH2; /// TGraph2DErrors | TGraph2DErrors, TH2; /// TH2 | TGraph2DErrors, TH2; /// TH3 | TH3",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:17,Modifiability,Inherit,InheritsFrom,17,"// else if (obj->InheritsFrom(TMultiGraph::Class()) ); // ROOT::Fit::FillData(data, dynamic_cast<TMultiGraph *>(obj) );",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get the error matrix in a pointer to a NxN array.; /// excluding the fixed parameters",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Get error matrix element (return all zero if matrix is not available)",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:145,Availability,avail,available,145,"////////////////////////////////////////////////////////////////////////////////; /// Get error matrix element (return all zero if matrix is not available)",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:94,Availability,error,errors,94,"////////////////////////////////////////////////////////////////////////////////; /// Get fit errors",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:13,Modifiability,variab,variable,13,"// number of variable parameters",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:96,Availability,error,error,96,"////////////////////////////////////////////////////////////////////////////////; /// Parameter error",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:123,Availability,error,errors,123,"////////////////////////////////////////////////////////////////////////////////; /// Get all parameter info (name, value, errors)",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:3,Availability,error,error,3,"// error is step size in this case",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:93,Testability,log,log,93,"////////////////////////////////////////////////////////////////////////////////; /// Sum of log (un-needed)",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:23,Availability,error,errors,23,"// need to print minos errors and globalCC + other info",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:86,Deployability,Release,Release,86,"////////////////////////////////////////////////////////////////////////////////; /// Release a fit parameter",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:341,Testability,assert,assert,341,"//______________________________________________________________________________; // static method evaluating FCN; // void TBackCompFitter::FCN( int &, double * , double & f, double * x , int /* iflag */) {; // // get static instance of fitter; // TBackCompFitter * fitter = dynamic_cast<TBackCompFitter *>(TVirtualFitter::GetFitter());; // assert(fitter);; // if (fitter->fObjFunc == 0) fitter->RecreateFCN();; // assert(fitter->fObjFunc);; // f = (*(fitter.fObjFunc) )(x);; // }; ////////////////////////////////////////////////////////////////////////////////; /// Recreate a minimizer instance using the function and data; /// set objective function in minimizers function to re-create FCN from stored data object and fit options",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:415,Testability,assert,assert,415,"//______________________________________________________________________________; // static method evaluating FCN; // void TBackCompFitter::FCN( int &, double * , double & f, double * x , int /* iflag */) {; // // get static instance of fitter; // TBackCompFitter * fitter = dynamic_cast<TBackCompFitter *>(TVirtualFitter::GetFitter());; // assert(fitter);; // if (fitter->fObjFunc == 0) fitter->RecreateFCN();; // assert(fitter->fObjFunc);; // f = (*(fitter.fObjFunc) )(x);; // }; ////////////////////////////////////////////////////////////////////////////////; /// Recreate a minimizer instance using the function and data; /// set objective function in minimizers function to re-create FCN from stored data object and fit options",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:113,Energy Efficiency,Adapt,Adapter,113,"////////////////////////////////////////////////////////////////////////////////; /// Override setFCN to use the Adapter to Minuit2 FCN interface; /// To set the address of the minimization function",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:113,Integrability,Adapter,Adapter,113,"////////////////////////////////////////////////////////////////////////////////; /// Override setFCN to use the Adapter to Minuit2 FCN interface; /// To set the address of the minimization function",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:136,Integrability,interface,interface,136,"////////////////////////////////////////////////////////////////////////////////; /// Override setFCN to use the Adapter to Minuit2 FCN interface; /// To set the address of the minimization function",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:113,Modifiability,Adapt,Adapter,113,"////////////////////////////////////////////////////////////////////////////////; /// Override setFCN to use the Adapter to Minuit2 FCN interface; /// To set the address of the minimization function",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:641,Availability,Error,Error,641,"//______________________________________________________________________________; // bool TBackCompFitter::Scan2D(unsigned int ipar, unsigned int jpar, TGraph2D * gr,; // double xmin = 0, double xmax = 0, double ymin = 0, double ymax = 0) {; // // scan the parameters ipar between values of [xmin,xmax] and; // // jpar between values of [ymin,ymax] and; // // a graph2D must be given which will be on return filled with the scan resul; // // If the graph size is zero, a default size n = 20x20 will be used; // //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*; // if (!gr) return false;; // if (!fMinimizer) {; // Error(""Scan"",""Minimizer is not available - cannot scan before fitting"");; // return false;; // }; // unsigned int npoints = gr->GetN();; // if (npoints == 0) {; // npoints = 40;; // gr->Set(npoints);; // }; // // to be implemented; // for (unsigned int ix = 0; ix < npoints; ++ix) {; // return fMinimizer->Scan( ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; // }; ////////////////////////////////////////////////////////////////////////////////; /// Create a 2D contour around the minimum for the parameter ipar and jpar; /// if a minimum does not exist or is invalid it will return false; /// on exit a TGraph is filled with the contour points; /// the number of contour points is determined by the size of the TGraph.; /// if the size is zero a default number of points = 20 is used; /// pass optionally the confidence level, default is 0.683; /// it is assumed that ErrorDef() defines the right error definition; /// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:672,Availability,avail,available,672,"//______________________________________________________________________________; // bool TBackCompFitter::Scan2D(unsigned int ipar, unsigned int jpar, TGraph2D * gr,; // double xmin = 0, double xmax = 0, double ymin = 0, double ymax = 0) {; // // scan the parameters ipar between values of [xmin,xmax] and; // // jpar between values of [ymin,ymax] and; // // a graph2D must be given which will be on return filled with the scan resul; // // If the graph size is zero, a default size n = 20x20 will be used; // //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*; // if (!gr) return false;; // if (!fMinimizer) {; // Error(""Scan"",""Minimizer is not available - cannot scan before fitting"");; // return false;; // }; // unsigned int npoints = gr->GetN();; // if (npoints == 0) {; // npoints = 40;; // gr->Set(npoints);; // }; // // to be implemented; // for (unsigned int ix = 0; ix < npoints; ++ix) {; // return fMinimizer->Scan( ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; // }; ////////////////////////////////////////////////////////////////////////////////; /// Create a 2D contour around the minimum for the parameter ipar and jpar; /// if a minimum does not exist or is invalid it will return false; /// on exit a TGraph is filled with the contour points; /// the number of contour points is determined by the size of the TGraph.; /// if the size is zero a default number of points = 20 is used; /// pass optionally the confidence level, default is 0.683; /// it is assumed that ErrorDef() defines the right error definition; /// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:1517,Availability,Error,ErrorDef,1517,"//______________________________________________________________________________; // bool TBackCompFitter::Scan2D(unsigned int ipar, unsigned int jpar, TGraph2D * gr,; // double xmin = 0, double xmax = 0, double ymin = 0, double ymax = 0) {; // // scan the parameters ipar between values of [xmin,xmax] and; // // jpar between values of [ymin,ymax] and; // // a graph2D must be given which will be on return filled with the scan resul; // // If the graph size is zero, a default size n = 20x20 will be used; // //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*; // if (!gr) return false;; // if (!fMinimizer) {; // Error(""Scan"",""Minimizer is not available - cannot scan before fitting"");; // return false;; // }; // unsigned int npoints = gr->GetN();; // if (npoints == 0) {; // npoints = 40;; // gr->Set(npoints);; // }; // // to be implemented; // for (unsigned int ix = 0; ix < npoints; ++ix) {; // return fMinimizer->Scan( ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; // }; ////////////////////////////////////////////////////////////////////////////////; /// Create a 2D contour around the minimum for the parameter ipar and jpar; /// if a minimum does not exist or is invalid it will return false; /// on exit a TGraph is filled with the contour points; /// the number of contour points is determined by the size of the TGraph.; /// if the size is zero a default number of points = 20 is used; /// pass optionally the confidence level, default is 0.683; /// it is assumed that ErrorDef() defines the right error definition; /// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:1546,Availability,error,error,1546,"//______________________________________________________________________________; // bool TBackCompFitter::Scan2D(unsigned int ipar, unsigned int jpar, TGraph2D * gr,; // double xmin = 0, double xmax = 0, double ymin = 0, double ymax = 0) {; // // scan the parameters ipar between values of [xmin,xmax] and; // // jpar between values of [ymin,ymax] and; // // a graph2D must be given which will be on return filled with the scan resul; // // If the graph size is zero, a default size n = 20x20 will be used; // //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*; // if (!gr) return false;; // if (!fMinimizer) {; // Error(""Scan"",""Minimizer is not available - cannot scan before fitting"");; // return false;; // }; // unsigned int npoints = gr->GetN();; // if (npoints == 0) {; // npoints = 40;; // gr->Set(npoints);; // }; // // to be implemented; // for (unsigned int ix = 0; ix < npoints; ++ix) {; // return fMinimizer->Scan( ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; // }; ////////////////////////////////////////////////////////////////////////////////; /// Create a 2D contour around the minimum for the parameter ipar and jpar; /// if a minimum does not exist or is invalid it will return false; /// on exit a TGraph is filled with the contour points; /// the number of contour points is determined by the size of the TGraph.; /// if the size is zero a default number of points = 20 is used; /// pass optionally the confidence level, default is 0.683; /// it is assumed that ErrorDef() defines the right error definition; /// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:1581,Availability,error,error,1581,"//______________________________________________________________________________; // bool TBackCompFitter::Scan2D(unsigned int ipar, unsigned int jpar, TGraph2D * gr,; // double xmin = 0, double xmax = 0, double ymin = 0, double ymax = 0) {; // // scan the parameters ipar between values of [xmin,xmax] and; // // jpar between values of [ymin,ymax] and; // // a graph2D must be given which will be on return filled with the scan resul; // // If the graph size is zero, a default size n = 20x20 will be used; // //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*; // if (!gr) return false;; // if (!fMinimizer) {; // Error(""Scan"",""Minimizer is not available - cannot scan before fitting"");; // return false;; // }; // unsigned int npoints = gr->GetN();; // if (npoints == 0) {; // npoints = 40;; // gr->Set(npoints);; // }; // // to be implemented; // for (unsigned int ix = 0; ix < npoints; ++ix) {; // return fMinimizer->Scan( ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; // }; ////////////////////////////////////////////////////////////////////////////////; /// Create a 2D contour around the minimum for the parameter ipar and jpar; /// if a minimum does not exist or is invalid it will return false; /// on exit a TGraph is filled with the contour points; /// the number of contour points is determined by the size of the TGraph.; /// if the size is zero a default number of points = 20 is used; /// pass optionally the confidence level, default is 0.683; /// it is assumed that ErrorDef() defines the right error definition; /// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:7,Availability,error,error,7,"// get error level used for fitting",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:63,Availability,error,error,63,"// 2 is number of parameter we do the contour; // set required error definition in minimizer",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx:15,Availability,error,error,15,"// restore the error level used for fitting",MatchSource.CODE_COMMENT,hist/hist/src/TBackCompFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBackCompFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:757,Availability,avail,available,757,"// @(#)root/hist:$Id$; // Author: Frank Filthaut, Rene Brun 30/05/2007; /*************************************************************************; * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBinomialEfficiencyFitter; \ingroup Hist; \brief Binomial fitter for the division of two histograms. Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is; \f[; \sqrt{\frac{p(1-p)}{N}}; \f]; However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:903,Availability,error,error,903,"// @(#)root/hist:$Id$; // Author: Frank Filthaut, Rene Brun 30/05/2007; /*************************************************************************; * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBinomialEfficiencyFitter; \ingroup Hist; \brief Binomial fitter for the division of two histograms. Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is; \f[; \sqrt{\frac{p(1-p)}{N}}; \f]; However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:951,Availability,avail,available,951,"// @(#)root/hist:$Id$; // Author: Frank Filthaut, Rene Brun 30/05/2007; /*************************************************************************; * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBinomialEfficiencyFitter; \ingroup Hist; \brief Binomial fitter for the division of two histograms. Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is; \f[; \sqrt{\frac{p(1-p)}{N}}; \f]; However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:1598,Availability,avail,available,1598,"you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is; \f[; \sqrt{\frac{p(1-p)}{N}}; \f]; However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. ~~~ {.cpp}; {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:1710,Availability,error,errors,1710,"ntries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is; \f[; \sqrt{\frac{p(1-p)}{N}}; \f]; However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. ~~~ {.cpp}; {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:3038,Availability,reliab,reliable,3038," presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is; \f[; \sqrt{\frac{p(1-p)}{N}}; \f]; However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. ~~~ {.cpp}; {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");; if (status == 0) {; // if the fit was successful, display bin-by-bin efficiencies; // as well as the result of the fit; numerator->Sumw2();; TH1* hEff = dynamic_cast<TH1*>(numerator->Clone(""heff""));; hEff->Divide(hEff, denominator, 1.0, 1.0, ""B"");; hEff->Draw(""E"");; eff->Draw(""same"");; }; }; ~~~. Note that this method cannot be expected to yield reliable results when using; weighted histograms (because the likelihood computation will be incorrect). */",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:808,Modifiability,variab,variable,808,"// @(#)root/hist:$Id$; // Author: Frank Filthaut, Rene Brun 30/05/2007; /*************************************************************************; * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TBinomialEfficiencyFitter; \ingroup Hist; \brief Binomial fitter for the division of two histograms. Use when you need to calculate a selection's efficiency from two histograms,; one containing all entries, and one containing the subset of these entries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is; \f[; \sqrt{\frac{p(1-p)}{N}}; \f]; However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:1634,Usability,simpl,simply,1634,"ntries; that pass the selection, and when you have a parametrization available for; the efficiency as a function of the variable(s) under consideration. A very common problem when estimating efficiencies is that of error estimation:; when no other information is available than the total number of events N and; the selected number n, the best estimate for the selection efficiency p is n/N.; Standard binomial statistics dictates that the uncertainty (this presupposes; sufficiently high statistics that an approximation by a normal distribution is; reasonable) on p, given N, is; \f[; \sqrt{\frac{p(1-p)}{N}}; \f]; However, when p is estimated as n/N, fluctuations from the true p to its; estimate become important, especially for low numbers of events, and giving; rise to biased results. When fitting a parametrized efficiency, these problems can largely be overcome,; as a hypothesized true efficiency is available by construction. Even so, simply; using the corresponding uncertainty still presupposes that Gaussian errors; yields a reasonable approximation. When using, instead of binned efficiency; histograms, the original numerator and denominator histograms, a binned maximum; likelihood can be constructed as the product of bin-by-bin binomial probabilities; to select n out of N events. Assuming that a correct parametrization of the; efficiency is provided, this construction in general yields less biased results; (and is much less sensitive to binning details). A generic use of this method is given below (note that the method works for 2D; and 3D histograms as well):. ~~~ {.cpp}; {; TH1* denominator; // denominator histogram; TH1* numerator; // corresponding numerator histogram; TF1* eff; // efficiency parametrization; .... // set step sizes and initial parameter; .... // values for the fit function; .... // possibly also set ranges, see TF1::SetRange(); TBinomialEfficiencyFitter* f = new TBinomialEfficiencyFitter(; numerator, denominator);; Int_t status = f->Fit(eff, ""I"");",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:103,Deployability,integrat,integration,103,"////////////////////////////////////////////////////////////////////////////////; /// Set the required integration precision, see TF1::Integral()",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:103,Integrability,integrat,integration,103,"////////////////////////////////////////////////////////////////////////////////; /// Set the required integration precision, see TF1::Integral()",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:94,Security,access,access,94,"////////////////////////////////////////////////////////////////////////////////; /// Provide access to the underlying fitter object.; /// This may be useful e.g. for the retrieval of additional information (such; /// as the output covariance matrix of the fit).",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:825,Availability,error,error,825,"////////////////////////////////////////////////////////////////////////////////; /// Carry out the fit of the given function to the given histograms.; ///; /// If option ""I"" is used, the fit function will be averaged over the; /// bin (the default is to evaluate it simply at the bin center).; ///; /// If option ""R"" is used, the fit range will be taken from the fit; /// function (the default is to use the entire histogram).; ///; /// If option ""S"" a TFitResult object is returned and it can be used to obtain; /// additional fit information, like covariance or correlation matrix.; ///; /// Note that all parameter values, limits, and step sizes are copied; /// from the input fit function f1 (so they should be set before calling; /// this method. This is particularly relevant for the step sizes, taken; /// to be the ""error"" set on input, as a null step size usually fixes the; /// corresponding parameter. That is protected against, but in such cases; /// an arbitrary starting step size will be used, and the reliability of; /// the fit should be questioned). If parameters are to be fixed, this; /// should be done by specifying non-null parameter limits, with lower; /// limits larger than upper limits.; ///; /// On output, f1 contains the fitted parameters and errors, as well as; /// the number of degrees of freedom, and the goodness-of-fit estimator; /// as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437.",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:1018,Availability,reliab,reliability,1018,"////////////////////////////////////////////////////////////////////////////////; /// Carry out the fit of the given function to the given histograms.; ///; /// If option ""I"" is used, the fit function will be averaged over the; /// bin (the default is to evaluate it simply at the bin center).; ///; /// If option ""R"" is used, the fit range will be taken from the fit; /// function (the default is to use the entire histogram).; ///; /// If option ""S"" a TFitResult object is returned and it can be used to obtain; /// additional fit information, like covariance or correlation matrix.; ///; /// Note that all parameter values, limits, and step sizes are copied; /// from the input fit function f1 (so they should be set before calling; /// this method. This is particularly relevant for the step sizes, taken; /// to be the ""error"" set on input, as a null step size usually fixes the; /// corresponding parameter. That is protected against, but in such cases; /// an arbitrary starting step size will be used, and the reliability of; /// the fit should be questioned). If parameters are to be fixed, this; /// should be done by specifying non-null parameter limits, with lower; /// limits larger than upper limits.; ///; /// On output, f1 contains the fitted parameters and errors, as well as; /// the number of degrees of freedom, and the goodness-of-fit estimator; /// as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437.",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:1274,Availability,error,errors,1274,"////////////////////////////////////////////////////////////////////////////////; /// Carry out the fit of the given function to the given histograms.; ///; /// If option ""I"" is used, the fit function will be averaged over the; /// bin (the default is to evaluate it simply at the bin center).; ///; /// If option ""R"" is used, the fit range will be taken from the fit; /// function (the default is to use the entire histogram).; ///; /// If option ""S"" a TFitResult object is returned and it can be used to obtain; /// additional fit information, like covariance or correlation matrix.; ///; /// Note that all parameter values, limits, and step sizes are copied; /// from the input fit function f1 (so they should be set before calling; /// this method. This is particularly relevant for the step sizes, taken; /// to be the ""error"" set on input, as a null step size usually fixes the; /// corresponding parameter. That is protected against, but in such cases; /// an arbitrary starting step size will be used, and the reliability of; /// the fit should be questioned). If parameters are to be fixed, this; /// should be done by specifying non-null parameter limits, with lower; /// limits larger than upper limits.; ///; /// On output, f1 contains the fitted parameters and errors, as well as; /// the number of degrees of freedom, and the goodness-of-fit estimator; /// as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437.",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:267,Usability,simpl,simply,267,"////////////////////////////////////////////////////////////////////////////////; /// Carry out the fit of the given function to the given histograms.; ///; /// If option ""I"" is used, the fit function will be averaged over the; /// bin (the default is to evaluate it simply at the bin center).; ///; /// If option ""R"" is used, the fit range will be taken from the fit; /// function (the default is to use the entire histogram).; ///; /// If option ""S"" a TFitResult object is returned and it can be used to obtain; /// additional fit information, like covariance or correlation matrix.; ///; /// Note that all parameter values, limits, and step sizes are copied; /// from the input fit function f1 (so they should be set before calling; /// this method. This is particularly relevant for the step sizes, taken; /// to be the ""error"" set on input, as a null step size usually fixes the; /// corresponding parameter. That is protected against, but in such cases; /// an arbitrary starting step size will be used, and the reliability of; /// the fit should be questioned). If parameters are to be fixed, this; /// should be done by specifying non-null parameter limits, with lower; /// limits larger than upper limits.; ///; /// On output, f1 contains the fitted parameters and errors, as well as; /// the number of degrees of freedom, and the goodness-of-fit estimator; /// as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437.",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:32,Availability,error,error,32,"// assign an ARBITRARY starting error to ensure the parameter won't be fixed!",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx:3,Performance,perform,perform,3,"// perform the actual fit; // set the fit to be a binned likelihood fit; // so use as chi2 for goodness of fit Baker&Cousins LR",MatchSource.CODE_COMMENT,hist/hist/src/TBinomialEfficiencyFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TBinomialEfficiencyFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TConfidenceLevel.cxx:415,Energy Efficiency,adapt,adapted,415,// @(#)root/hist:$Id$; // Author: Christophe.Delaere@cern.ch 21/08/2002; ////////////////////////////////////////////////////////////////////////////////; /** \class TConfidenceLevel; \ingroup Hist; \brief Class to compute 95% CL limits; */; //////////////////////////////////////////////////////////////////////////////; /*************************************************************************; * C.Delaere *; * adapted from the mclimit code from Tom Junk *; * see http://cern.ch/thomasj/searchlimits/ecl.html *; *************************************************************************/,MatchSource.CODE_COMMENT,hist/hist/src/TConfidenceLevel.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TConfidenceLevel.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TConfidenceLevel.cxx:415,Modifiability,adapt,adapted,415,// @(#)root/hist:$Id$; // Author: Christophe.Delaere@cern.ch 21/08/2002; ////////////////////////////////////////////////////////////////////////////////; /** \class TConfidenceLevel; \ingroup Hist; \brief Class to compute 95% CL limits; */; //////////////////////////////////////////////////////////////////////////////; /*************************************************************************; * C.Delaere *; * adapted from the mclimit code from Tom Junk *; * see http://cern.ch/thomasj/searchlimits/ecl.html *; *************************************************************************/,MatchSource.CODE_COMMENT,hist/hist/src/TConfidenceLevel.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TConfidenceLevel.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:1751,Availability,error,error,1751,"(\ref EFF05c); - [VI. Further operations](\ref EFF06); - [VI.1 Information about the internal histograms](\ref EFF061); - [VI.2 Fitting](\ref EFF062); - [VI.3 Draw a TEfficiency object](\ref EFF063); - [VI.4 TEfficiency object's axis customisation](\ref EFF064). \anchor EFF01; ## I. Overview; This class handles the calculation of efficiencies and their uncertainties. It; provides several statistical methods for calculating frequentist and Bayesian; confidence intervals as well as a function for combining several efficiencies. Efficiencies have a lot of applications and meanings but in principle, they can; be described by the fraction of good/passed events k out of sample containing; N events. One is usually interested in the dependency of the efficiency on other; (binned) variables. The number of passed and total events is therefore stored; internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; Then the efficiency, as well as its upper and lower error, can be calculated for each bin; individually. As the efficiency can be regarded as a parameter of a binomial distribution, the; number of passed and total events must always be integer numbers. Therefore a; filling with weights is not possible. However, you can assign a global weight to each; TEfficiency object (TEfficiency::SetWeight).; It is necessary to create one TEfficiency object; for each weight if you investigate a process involving different weights. This; procedure needs more effort but enables you to re-use the filled object in cases; where you want to change one or more weights. This would not be possible if all; events with different weights were filled in the same histogram. \anchor EFF02; ## II. Creating a TEfficiency object; If you start a new analysis, it is highly recommended to use the TEfficiency class; from the beginning. You can then use one of the constructors for fixed or; variable bin size and your desired dimension. These constructors append the; creat",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:8922,Availability,error,error,8922," \alpha}{N + \alpha + \beta}; \f]. Optionally the mode can also be used as a value for the estimated efficiency. This can be done by calling; SetBit(kPosteriorMode) or TEfficiency::SetPosteriorMode. In this case, the estimated efficiency is:. \f[; \hat{\varepsilon} = \frac{k + \alpha -1}{N + \alpha + \beta - 2}; \f]. In the case of a uniform prior distribution, B(x,1,1), the posterior mode is k/n, equivalent to the frequentist; estimate (the maximum likelihood value). The statistic options also specify which confidence interval is used for calculating; the uncertainties of the efficiency. The following properties define the error; calculation:; - **fConfLevel:** desired confidence level: 0 < fConfLevel < 1 (TEfficiency::GetConfidenceLevel / TEfficiency::SetConfidenceLevel); - **fStatisticOption** defines which method is used to calculate the boundaries of the confidence interval (TEfficiency::SetStatisticOption); - **fBeta_alpha, fBeta_beta:** parameters for the prior distribution which is only used in the bayesian case (TEfficiency::GetBetaAlpha / TEfficiency::GetBetaBeta / TEfficiency::SetBetaAlpha / TEfficiency::SetBetaBeta); - **kIsBayesian:** flag whether bayesian statistics are used or not (TEfficiency::UsesBayesianStat); - **kShortestInterval:** flag whether shortest interval (instead of central one) are used in case of Bayesian statistics (TEfficiency::UsesShortestInterval). Normally shortest interval should be used in combination with the mode (see TEfficiency::UsesPosteriorMode); - **fWeight:** global weight for this TEfficiency object which is used during combining or merging with other TEfficiency objects(TEfficiency::GetWeight / TEfficiency::SetWeight). In the following table, the implemented confidence intervals are listed; with their corresponding statistic option. For more details on the calculation,; please have a look at the mentioned functions. | name | statistic option | function | kIsBayesian | parameters |; |------------------|-----------------",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:15991,Deployability,continuous,continuously,15991,"ffrey95.gif ""Bayesian with Jeffrey Prior"". The average (over all possible true efficiencies) coverage probability for; different number of total events is shown in the next picture. \image html av_cov.png ""Average Coverage"". \anchor EFF05; ## V. Merging and combining TEfficiency objects; In many applications, the efficiency should be calculated for an inhomogeneous; sample in the sense that it contains events with different weights. In order; to be able to determine the correct overall efficiency, it is necessary to; use for each subsample (= all events with the same weight) a different; TEfficiency object. After finishing your analysis you can then construct the; overall efficiency with its uncertainty. This procedure has the advantage that you can change the weight of one; subsample easily without rerunning the whole analysis. On the other hand, more; effort is needed to handle several TEfficiency objects instead of one; histogram. In the case of many different or even continuously distributed; weights, this approach becomes cumbersome. One possibility to overcome this; problem is the usage of binned weights. \anchor EFF05a; ### Example; In particle physics weights arises from the fact that you want to; normalise your results to a certain reference value. A very common formula for; calculating weights is. \f{eqnarray*}{; w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; &-& \sigma ...\ cross\ section \\; &-& L ...\ luminosity \\; &-& N_{gen}\ ... number\ of\ generated\ events \\; &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; \f}. The reason for different weights can therefore be:; - different processes; - other integrated luminosity; - varying trigger efficiency; - different sample sizes; - ...; - or even combination of them. Depending on the actual meaning of different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do n",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:16660,Deployability,integrat,integrated,16660,"hen construct the; overall efficiency with its uncertainty. This procedure has the advantage that you can change the weight of one; subsample easily without rerunning the whole analysis. On the other hand, more; effort is needed to handle several TEfficiency objects instead of one; histogram. In the case of many different or even continuously distributed; weights, this approach becomes cumbersome. One possibility to overcome this; problem is the usage of binned weights. \anchor EFF05a; ### Example; In particle physics weights arises from the fact that you want to; normalise your results to a certain reference value. A very common formula for; calculating weights is. \f{eqnarray*}{; w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; &-& \sigma ...\ cross\ section \\; &-& L ...\ luminosity \\; &-& N_{gen}\ ... number\ of\ generated\ events \\; &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; \f}. The reason for different weights can therefore be:; - different processes; - other integrated luminosity; - varying trigger efficiency; - different sample sizes; - ...; - or even combination of them. Depending on the actual meaning of different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do not represent real alternative hypotheses,; you should merge the different TEfficiency objects. That means especially for; the Bayesian case that the prior probability should be the same for all merged; TEfficiency objects. The merging can be done by invoking one of the following; operations:; - eff1.Add(eff2); - eff1 += eff2; - eff1 = eff1 + eff2. The result of the merging is stored in the TEfficiency object which is marked; bold above. The contents of the internal histograms of both TEfficiency; objects are added and a new weight is assigned. The statistic options are not; changed. \f[; \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; \f]",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:17822,Deployability,integrat,integrated,17822,"different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do not represent real alternative hypotheses,; you should merge the different TEfficiency objects. That means especially for; the Bayesian case that the prior probability should be the same for all merged; TEfficiency objects. The merging can be done by invoking one of the following; operations:; - eff1.Add(eff2); - eff1 += eff2; - eff1 = eff1 + eff2. The result of the merging is stored in the TEfficiency object which is marked; bold above. The contents of the internal histograms of both TEfficiency; objects are added and a new weight is assigned. The statistic options are not; changed. \f[; \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; \f]. \anchor EFF05b; ### Example:; If you use two samples with different numbers of generated events for the same; process and you want to normalise both to the same integrated luminosity and; trigger efficiency, the different weights then arise just from the fact that; you have different numbers of events. The TEfficiency objects should be merged; because the samples do not represent true alternatives. You expect the same; result as if you would have a big sample with all events in it. \f[; w_{1} = \frac{\sigma L}{\epsilon N_{1}}, w_{2} = \frac{\sigma L}{\epsilon N_{2}} \Rightarrow w_{new} = \frac{\sigma L}{\epsilon (N_{1} + N_{2})} = \frac{1}{\frac{1}{w_{1}} + \frac{1}{w_{2}}}; \f]. \anchor EFF052; ### V.2 When should I use combining?; You should combine TEfficiency objects whenever the weights represent; alternatives processes for the efficiency. As the combination of two TEfficiency; objects is not always consistent with the representation by two internal; histograms, the result is not stored in a TEfficiency object but a TGraphAsymmErrors; is returned which shows the estimated combined efficiency and its uncertainty; for each bin.; A",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:21724,Deployability,update,update,21724,"}w_{1}}{N_{1}w_{1} + N_{2}w_{2}}\\; p_{2} = \frac{\sigma_{2}}{\sigma_{1} + \sigma_{2}} = \frac{N_{2}w_{2}}{N_{1}w_{1} + N_{2}w_{2}}; \f]. \anchor EFF06; ## VI. Further operations. \anchor EFF061; ### VI.1 Information about the internal histograms; The methods TEfficiency::GetPassedHistogram and TEfficiency::GetTotalHistogram; return a constant pointer to the internal histograms. They can be used to; obtain information about the internal histograms (e.g., the binning, number of passed / total events in a bin, mean values...).; One can obtain a clone of the internal histograms by calling TEfficiency::GetCopyPassedHisto or TEfficiency::GetCopyTotalHisto.; The returned histograms are completely independent from the current; TEfficiency object. By default, they are not attached to a directory to; avoid the duplication of data and the user is responsible for deleting them. ~~~~~~~~~~~~~~~{.cpp}; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");. //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");. //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();. //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directory and write the file; //clone->SetDirectory(gDirectory);; //pFile->Write();. //delete histogram object; delete clone;; clone = 0;; ~~~~~~~~~~~~~~~. It is also possible to set the internal total or passed histogram by using the; methods TEfficiency::SetPassedHistogram or TEfficiency::SetTotalHistogram. In order to ensure the validity of the TEfficiency object, the consistency of the; new histogram and the stored histogram is checked. It might be; impossible sometimes to change the histograms in a consistent way. Therefore one can force; the replacement by passing the ""f"" option. Then the user has to ensure that the; other internal histogram is replaced as well and that the TEfficiency object is; in a",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:25097,Deployability,Update,Update,25097," a threshold function; TF1* f2 = new TF1(""thres"",""0.8"",0,10);; f2->SetLineColor(kRed);; //add it to the list of functions; //use add first because the parameters of the last function will be displayed; pEff->GetListOfFunctions()->AddFirst(f2);. pEff->Draw(""AP"");; }; End_Macro. \anchor EFF063; ### VI.3 Draw a TEfficiency object; A TEfficiency object can be drawn by calling the usual TEfficiency::Draw method.; At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; method. For 2-dimensional TEfficiency objects, you can pass the same options as; for a TH2::Draw object. \anchor EFF064; ### VI.4 TEfficiency object's axis customisation; The axes of a TEfficiency object can be accessed and customised by calling the; GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; methods.; Note that in order to access the painted graph via GetPaintedGraph(), one should either; call Paint or, better, gPad->Update(). Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);; c1->Divide(2,1);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<10000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }; c1->cd(1);; pEff->Draw(""AP"");; c1->cd(2);; pEff->Draw(""AP"");; gPad->Update();; pEff->GetPaintedGraph()->GetXaxis()->SetTitleSize(0.05);; pEff->GetPaintedGraph()->GetXaxis()->SetLabelFont(42);; pEff->GetPaintedGraph()->GetXaxis()->SetLabelSize(0.05);; pEff->GetPaintedGraph()->GetYaxis()->SetTitleOffset(0.85);; pEff->GetP",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:25789,Deployability,Update,Update,25789," TEfficiency::Draw method.; At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; method. For 2-dimensional TEfficiency objects, you can pass the same options as; for a TH2::Draw object. \anchor EFF064; ### VI.4 TEfficiency object's axis customisation; The axes of a TEfficiency object can be accessed and customised by calling the; GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; methods.; Note that in order to access the painted graph via GetPaintedGraph(), one should either; call Paint or, better, gPad->Update(). Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);; c1->Divide(2,1);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<10000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }; c1->cd(1);; pEff->Draw(""AP"");; c1->cd(2);; pEff->Draw(""AP"");; gPad->Update();; pEff->GetPaintedGraph()->GetXaxis()->SetTitleSize(0.05);; pEff->GetPaintedGraph()->GetXaxis()->SetLabelFont(42);; pEff->GetPaintedGraph()->GetXaxis()->SetLabelSize(0.05);; pEff->GetPaintedGraph()->GetYaxis()->SetTitleOffset(0.85);; pEff->GetPaintedGraph()->GetYaxis()->SetTitleSize(0.05);; pEff->GetPaintedGraph()->GetYaxis()->SetLabelFont(42);; pEff->GetPaintedGraph()->GetYaxis()->SetLabelSize(0.05);; pEff->GetPaintedGraph()->GetXaxis()->SetRangeUser(3,7);; }; End_Macro. */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor; ///; /// Should not be used explicitly",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:1485,Integrability,depend,dependency,1485,"rent methods](\ref EFF041); - [V. Merging and combining TEfficiency objects](\ref EFF05); - [Example](\ref EFF05a); - [V.1 When should I use merging?](\ref EFF051); - [Example](\ref EFF05b); - [V.2 When should I use combining?](\ref EFF052); - [Example](\ref EFF05c); - [VI. Further operations](\ref EFF06); - [VI.1 Information about the internal histograms](\ref EFF061); - [VI.2 Fitting](\ref EFF062); - [VI.3 Draw a TEfficiency object](\ref EFF063); - [VI.4 TEfficiency object's axis customisation](\ref EFF064). \anchor EFF01; ## I. Overview; This class handles the calculation of efficiencies and their uncertainties. It; provides several statistical methods for calculating frequentist and Bayesian; confidence intervals as well as a function for combining several efficiencies. Efficiencies have a lot of applications and meanings but in principle, they can; be described by the fraction of good/passed events k out of sample containing; N events. One is usually interested in the dependency of the efficiency on other; (binned) variables. The number of passed and total events is therefore stored; internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; Then the efficiency, as well as its upper and lower error, can be calculated for each bin; individually. As the efficiency can be regarded as a parameter of a binomial distribution, the; number of passed and total events must always be integer numbers. Therefore a; filling with weights is not possible. However, you can assign a global weight to each; TEfficiency object (TEfficiency::SetWeight).; It is necessary to create one TEfficiency object; for each weight if you investigate a process involving different weights. This; procedure needs more effort but enables you to re-use the filled object in cases; where you want to change one or more weights. This would not be possible if all; events with different weights were filled in the same histogram. \anchor EFF02; ## II. Creating a TEfficie",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:6670,Integrability,depend,depends,6670,"gram is filled).; The x, y and z variables determine the bin which is filled. For lower dimensions, the z- or even the y-value may be omitted. Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<10000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }. pEff->Draw(""AP"");; }; End_Macro. You can also set the number of passed or total events for a bin directly by; using the TEfficiency::SetPassedEvents or TEfficiency::SetTotalEvents method. \anchor EFF04; ## IV. Statistic options; The calculation of the estimated efficiency depends on the chosen statistic; option. Let k denotes the number of passed events and N the number of total; events. \anchor EFF04a; ### Frequentist methods; The expectation value of the number of passed events is given by the true; efficiency times the total number of events. One can estimate the efficiency; by replacing the expected number of passed events by the observed number of; passed events. \f[; k = \epsilon \times N \Rightarrow \hat{\varepsilon} = \frac{k}{N}; \f]. \anchor EFF04b; ### Bayesian methods; In Bayesian statistics a likelihood-function (how probable is it to get the; observed data assuming a true efficiency) and a prior probability (what is the; probability that a certain true efficiency is actually realised) are used to; determine a posterior probability by using Bayes theorem. At the moment, only; beta distributions (have 2 free parameters) are supported as prior; probabilities. \f{eqnarray*}{; P(\epsilon | k ; N) &=& \frac{1}{norm} \times P(k | \eps",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:16660,Integrability,integrat,integrated,16660,"hen construct the; overall efficiency with its uncertainty. This procedure has the advantage that you can change the weight of one; subsample easily without rerunning the whole analysis. On the other hand, more; effort is needed to handle several TEfficiency objects instead of one; histogram. In the case of many different or even continuously distributed; weights, this approach becomes cumbersome. One possibility to overcome this; problem is the usage of binned weights. \anchor EFF05a; ### Example; In particle physics weights arises from the fact that you want to; normalise your results to a certain reference value. A very common formula for; calculating weights is. \f{eqnarray*}{; w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; &-& \sigma ...\ cross\ section \\; &-& L ...\ luminosity \\; &-& N_{gen}\ ... number\ of\ generated\ events \\; &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; \f}. The reason for different weights can therefore be:; - different processes; - other integrated luminosity; - varying trigger efficiency; - different sample sizes; - ...; - or even combination of them. Depending on the actual meaning of different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do not represent real alternative hypotheses,; you should merge the different TEfficiency objects. That means especially for; the Bayesian case that the prior probability should be the same for all merged; TEfficiency objects. The merging can be done by invoking one of the following; operations:; - eff1.Add(eff2); - eff1 += eff2; - eff1 = eff1 + eff2. The result of the merging is stored in the TEfficiency object which is marked; bold above. The contents of the internal histograms of both TEfficiency; objects are added and a new weight is assigned. The statistic options are not; changed. \f[; \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; \f]",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:16777,Integrability,Depend,Depending,16777," On the other hand, more; effort is needed to handle several TEfficiency objects instead of one; histogram. In the case of many different or even continuously distributed; weights, this approach becomes cumbersome. One possibility to overcome this; problem is the usage of binned weights. \anchor EFF05a; ### Example; In particle physics weights arises from the fact that you want to; normalise your results to a certain reference value. A very common formula for; calculating weights is. \f{eqnarray*}{; w &=& \frac{\sigma L}{N_{gen} \epsilon_{trig}} \\; &-& \sigma ...\ cross\ section \\; &-& L ...\ luminosity \\; &-& N_{gen}\ ... number\ of\ generated\ events \\; &-& \epsilon_{trig}\ ...\ (known)\ trigger\ efficiency \\; \f}. The reason for different weights can therefore be:; - different processes; - other integrated luminosity; - varying trigger efficiency; - different sample sizes; - ...; - or even combination of them. Depending on the actual meaning of different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do not represent real alternative hypotheses,; you should merge the different TEfficiency objects. That means especially for; the Bayesian case that the prior probability should be the same for all merged; TEfficiency objects. The merging can be done by invoking one of the following; operations:; - eff1.Add(eff2); - eff1 += eff2; - eff1 = eff1 + eff2. The result of the merging is stored in the TEfficiency object which is marked; bold above. The contents of the internal histograms of both TEfficiency; objects are added and a new weight is assigned. The statistic options are not; changed. \f[; \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; \f]. \anchor EFF05b; ### Example:; If you use two samples with different numbers of generated events for the same; process and you want to normalise both to the same integrated luminosity an",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:17822,Integrability,integrat,integrated,17822,"different weights in your case, you; should either merge or combine them to get the overall efficiency. \anchor EFF051; ### V.1 When should I use merging?; If the weights are artificial and do not represent real alternative hypotheses,; you should merge the different TEfficiency objects. That means especially for; the Bayesian case that the prior probability should be the same for all merged; TEfficiency objects. The merging can be done by invoking one of the following; operations:; - eff1.Add(eff2); - eff1 += eff2; - eff1 = eff1 + eff2. The result of the merging is stored in the TEfficiency object which is marked; bold above. The contents of the internal histograms of both TEfficiency; objects are added and a new weight is assigned. The statistic options are not; changed. \f[; \frac{1}{w_{new}} = \frac{1}{w_{1}} + \frac{1}{w_{2}}; \f]. \anchor EFF05b; ### Example:; If you use two samples with different numbers of generated events for the same; process and you want to normalise both to the same integrated luminosity and; trigger efficiency, the different weights then arise just from the fact that; you have different numbers of events. The TEfficiency objects should be merged; because the samples do not represent true alternatives. You expect the same; result as if you would have a big sample with all events in it. \f[; w_{1} = \frac{\sigma L}{\epsilon N_{1}}, w_{2} = \frac{\sigma L}{\epsilon N_{2}} \Rightarrow w_{new} = \frac{\sigma L}{\epsilon (N_{1} + N_{2})} = \frac{1}{\frac{1}{w_{1}} + \frac{1}{w_{2}}}; \f]. \anchor EFF052; ### V.2 When should I use combining?; You should combine TEfficiency objects whenever the weights represent; alternatives processes for the efficiency. As the combination of two TEfficiency; objects is not always consistent with the representation by two internal; histograms, the result is not stored in a TEfficiency object but a TGraphAsymmErrors; is returned which shows the estimated combined efficiency and its uncertainty; for each bin.; A",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:1533,Modifiability,variab,variables,1533,"rent methods](\ref EFF041); - [V. Merging and combining TEfficiency objects](\ref EFF05); - [Example](\ref EFF05a); - [V.1 When should I use merging?](\ref EFF051); - [Example](\ref EFF05b); - [V.2 When should I use combining?](\ref EFF052); - [Example](\ref EFF05c); - [VI. Further operations](\ref EFF06); - [VI.1 Information about the internal histograms](\ref EFF061); - [VI.2 Fitting](\ref EFF062); - [VI.3 Draw a TEfficiency object](\ref EFF063); - [VI.4 TEfficiency object's axis customisation](\ref EFF064). \anchor EFF01; ## I. Overview; This class handles the calculation of efficiencies and their uncertainties. It; provides several statistical methods for calculating frequentist and Bayesian; confidence intervals as well as a function for combining several efficiencies. Efficiencies have a lot of applications and meanings but in principle, they can; be described by the fraction of good/passed events k out of sample containing; N events. One is usually interested in the dependency of the efficiency on other; (binned) variables. The number of passed and total events is therefore stored; internally in two histograms (TEfficiency::fTotalHistogram and TEfficiency::fPassedHistogram).; Then the efficiency, as well as its upper and lower error, can be calculated for each bin; individually. As the efficiency can be regarded as a parameter of a binomial distribution, the; number of passed and total events must always be integer numbers. Therefore a; filling with weights is not possible. However, you can assign a global weight to each; TEfficiency object (TEfficiency::SetWeight).; It is necessary to create one TEfficiency object; for each weight if you investigate a process involving different weights. This; procedure needs more effort but enables you to re-use the filled object in cases; where you want to change one or more weights. This would not be possible if all; events with different weights were filled in the same histogram. \anchor EFF02; ## II. Creating a TEfficie",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:2668,Modifiability,variab,variable,2668,"and TEfficiency::fPassedHistogram).; Then the efficiency, as well as its upper and lower error, can be calculated for each bin; individually. As the efficiency can be regarded as a parameter of a binomial distribution, the; number of passed and total events must always be integer numbers. Therefore a; filling with weights is not possible. However, you can assign a global weight to each; TEfficiency object (TEfficiency::SetWeight).; It is necessary to create one TEfficiency object; for each weight if you investigate a process involving different weights. This; procedure needs more effort but enables you to re-use the filled object in cases; where you want to change one or more weights. This would not be possible if all; events with different weights were filled in the same histogram. \anchor EFF02; ## II. Creating a TEfficiency object; If you start a new analysis, it is highly recommended to use the TEfficiency class; from the beginning. You can then use one of the constructors for fixed or; variable bin size and your desired dimension. These constructors append the; created TEfficiency object to the current directory. So it will be written; automatically to a file during the next TFile::Write command. Example: create a two-dimensional TEfficiency object with; - name = ""eff""; - title = ""my efficiency""; - axis titles: x, y and LaTeX-formatted epsilon as a label for Z axis; - 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge; from the first bin) up to 10 (upper edge of last bin); - 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower; edge from the first bin) up to 5 (upper edge of last bin). TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);. If you already have two histograms filled with the number of passed and total; events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; t",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:5691,Modifiability,variab,variables,5691,"Eff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");. //h_pass and h_total are valid and consistent histograms; if(TEfficiency::CheckConsistency(h_pass,h_total)); {; pEff = new TEfficiency(h_pass,h_total);; //this will attach the TEfficiency object to the current directory; pEff->SetDirectory(gDirectory);; //now all objects in gDirectory will be written to ""myfile.root""; pFile->Write();; }; ~~~~~~~~~~~~~~~. In case you already have two filled histograms and you only want to; plot them as a graph, you should rather use TGraphAsymmErrors::TGraphAsymmErrors(const TH1* pass,const TH1* total,Option_t* opt); to create a graph object. \anchor EFF03; ## III. Filling with events; You can fill the TEfficiency object by calling the TEfficiency::Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z) method.; The ""bPassed"" boolean flag indicates whether the current event is good; (both histograms are filled) or not (only TEfficiency::fTotalHistogram is filled).; The x, y and z variables determine the bin which is filled. For lower dimensions, the z- or even the y-value may be omitted. Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<10000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }. pEff->Draw(""AP"");; }; End_Macro. You can also set the number of passed or total events for a bin directly by; using the TEfficiency::SetPassedEvents or TEfficiency::SetTotalEvents method. \anchor EFF04; ## IV. Statistic options; The calculation of the estimated efficiency depends on the chosen statistic; op",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:6214,Modifiability,variab,variable,6214,"plot them as a graph, you should rather use TGraphAsymmErrors::TGraphAsymmErrors(const TH1* pass,const TH1* total,Option_t* opt); to create a graph object. \anchor EFF03; ## III. Filling with events; You can fill the TEfficiency object by calling the TEfficiency::Fill(Bool_t bPassed,Double_t x,Double_t y,Double_t z) method.; The ""bPassed"" boolean flag indicates whether the current event is good; (both histograms are filled) or not (only TEfficiency::fTotalHistogram is filled).; The x, y and z variables determine the bin which is filled. For lower dimensions, the z- or even the y-value may be omitted. Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<10000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }. pEff->Draw(""AP"");; }; End_Macro. You can also set the number of passed or total events for a bin directly by; using the TEfficiency::SetPassedEvents or TEfficiency::SetTotalEvents method. \anchor EFF04; ## IV. Statistic options; The calculation of the estimated efficiency depends on the chosen statistic; option. Let k denotes the number of passed events and N the number of total; events. \anchor EFF04a; ### Frequentist methods; The expectation value of the number of passed events is given by the true; efficiency times the total number of events. One can estimate the efficiency; by replacing the expected number of passed events by the observed number of; passed events. \f[; k = \epsilon \times N \Rightarrow \hat{\varepsilon} = \frac{k}{N}; \f]. \anchor EFF04b; ### Bayesian methods; In Ba",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:11960,Modifiability,variab,variable,11960,"Interval | false | total events, passed events, confidence level |; | Jeffrey | kBJeffrey | TEfficiency::Bayesian | true | total events, passed events, confidence level, fBeta_alpha = 0.5, fBeta_beta = 0.5 |; | Uniform prior | kBUniform |TEfficiency::Bayesian | true |total events, passed events, confidence level, fBeta_alpha = 1, fBeta_beta = 1 |; | custom prior | kBBayesian |TEfficiency::Bayesian | true |total events, passed events, confidence level, fBeta_alpha, fBeta_beta |. The following example demonstrates the effect of different statistic options and; confidence levels. Begin_Macro(source); {; //canvas only needed for the documentation; TCanvas* c1 = new TCanvas(""c1"","""",600,400);; c1->Divide(2);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""different confidence levels;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<1000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }. //set style attributes; pEff->SetFillStyle(3004);; pEff->SetFillColor(kRed);. //copy current TEfficiency object and set new confidence level; TEfficiency* pCopy = new TEfficiency(*pEff);; pCopy->SetConfidenceLevel(0.90);. //set style attributes; pCopy->SetFillStyle(3005);; pCopy->SetFillColor(kBlue);. c1->cd(1);. //add legend; TLegend* leg1 = new TLegend(0.3,0.1,0.7,0.5);; leg1->AddEntry(pEff,""68.3%"",""F"");; leg1->AddEntry(pCopy,""90%"",""F"");. pEff->Draw(""A4"");; pCopy->Draw(""same4"");; leg1->Draw(""same"");. //use same confidence level but different statistic methods; TEfficiency* pEff2 = new TEfficiency(*pEff);; TEfficiency* pCopy2 = new TEfficiency(*pEff);. pEff2->SetStatisticOption(TEfficiency::kFNormal);; pCopy2->SetStatisticOption(TEfficiency::kFAC);. pEff2->SetTitle(""different statistic",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:23721,Modifiability,variab,variable,23721,"Efficiency object is; in a valid state. \anchor EFF062; ### VI.2 Fitting; The efficiency can be fitted using the TEfficiency::Fit function which internally uses; the TBinomialEfficiencyFitter::Fit method.; As this method is using a maximum-likelihood-fit, it is necessary to initialise; the given fit function with reasonable start values.; The resulting fit function is attached to the list of associated functions and; will be drawn automatically during the next TEfficiency::Draw command.; The list of associated function can be modified by using the pointer returned; by TEfficiency::GetListOfFunctions. Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for (int i=0; i<10000; ++i) {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }. //create a function for fitting and do the fit; TF1* f1 = new TF1(""f1"",""gaus"",0,10);; f1->SetParameters(1,5,2);; pEff->Fit(f1);. //create a threshold function; TF1* f2 = new TF1(""thres"",""0.8"",0,10);; f2->SetLineColor(kRed);; //add it to the list of functions; //use add first because the parameters of the last function will be displayed; pEff->GetListOfFunctions()->AddFirst(f2);. pEff->Draw(""AP"");; }; End_Macro. \anchor EFF063; ### VI.3 Draw a TEfficiency object; A TEfficiency object can be drawn by calling the usual TEfficiency::Draw method.; At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; method. For 2-dimensional TEfficiency objects, you can pass the same ",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:25538,Modifiability,variab,variable,25538," TEfficiency::Draw method.; At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; method. For 2-dimensional TEfficiency objects, you can pass the same options as; for a TH2::Draw object. \anchor EFF064; ### VI.4 TEfficiency object's axis customisation; The axes of a TEfficiency object can be accessed and customised by calling the; GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; methods.; Note that in order to access the painted graph via GetPaintedGraph(), one should either; call Paint or, better, gPad->Update(). Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);; c1->Divide(2,1);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<10000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }; c1->cd(1);; pEff->Draw(""AP"");; c1->cd(2);; pEff->Draw(""AP"");; gPad->Update();; pEff->GetPaintedGraph()->GetXaxis()->SetTitleSize(0.05);; pEff->GetPaintedGraph()->GetXaxis()->SetLabelFont(42);; pEff->GetPaintedGraph()->GetXaxis()->SetLabelSize(0.05);; pEff->GetPaintedGraph()->GetYaxis()->SetTitleOffset(0.85);; pEff->GetPaintedGraph()->GetYaxis()->SetTitleSize(0.05);; pEff->GetPaintedGraph()->GetYaxis()->SetLabelFont(42);; pEff->GetPaintedGraph()->GetYaxis()->SetLabelSize(0.05);; pEff->GetPaintedGraph()->GetXaxis()->SetRangeUser(3,7);; }; End_Macro. */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor; ///; /// Should not be used explicitly",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:3884,Safety,avoid,avoid,3884," file during the next TFile::Write command. Example: create a two-dimensional TEfficiency object with; - name = ""eff""; - title = ""my efficiency""; - axis titles: x, y and LaTeX-formatted epsilon as a label for Z axis; - 10 bins with constant bin width (= 1) along X axis starting at 0 (lower edge; from the first bin) up to 10 (upper edge of last bin); - 20 bins with constant bin width (= 0.5) along Y axis starting at -5 (lower; edge from the first bin) up to 5 (upper edge of last bin). TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;y;#epsilon"",10,0,10,20,-5,5);. If you already have two histograms filled with the number of passed and total; events, you will use the constructor TEfficiency(const TH1& passed,const TH1& total); to construct the TEfficiency object. The histograms ""passed"" and ""total"" have; to fulfill the conditions mentioned in TEfficiency::CheckConsistency, otherwise the construction will fail.; As the histograms already exist, the new TEfficiency is by default **not** attached; to the current directory to avoid duplication of data. If you want to store the; new object anyway, you can either write it directly by calling TObject::Write or attach it to a directory using TEfficiency::SetDirectory.; This also applies to TEfficiency objects created by the copy constructor TEfficiency::TEfficiency(const TEfficiency& rEff). \anchor EFF02a; ### Example 1. ~~~~~~~~~~~~~~~{.cpp}; TEfficiency* pEff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");. //h_pass and h_total are valid and consistent histograms; if(TEfficiency::CheckConsistency(h_pass,h_total)); {; pEff = new TEfficiency(h_pass,h_total);; // this will write the TEfficiency object to ""myfile.root""; // AND pEff will be attached to the current directory; pEff->Write();; }; ~~~~~~~~~~~~~~~. \anchor EFF02b; ### Example 2. ~~~~~~~~~~~~~~~{.cpp}; TEfficiency* pEff = 0;; TFile* pFile = new TFile(""myfile.root"",""recreate"");. //h_pass and h_total are valid and consistent histograms; if(TEfficiency:",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:21528,Safety,avoid,avoid,21528,"ghts to be used in the; combination should be the probability that an; electron comes from the corresponding process. \f[; p_{1} = \frac{\sigma_{1}}{\sigma_{1} + \sigma_{2}} = \frac{N_{1}w_{1}}{N_{1}w_{1} + N_{2}w_{2}}\\; p_{2} = \frac{\sigma_{2}}{\sigma_{1} + \sigma_{2}} = \frac{N_{2}w_{2}}{N_{1}w_{1} + N_{2}w_{2}}; \f]. \anchor EFF06; ## VI. Further operations. \anchor EFF061; ### VI.1 Information about the internal histograms; The methods TEfficiency::GetPassedHistogram and TEfficiency::GetTotalHistogram; return a constant pointer to the internal histograms. They can be used to; obtain information about the internal histograms (e.g., the binning, number of passed / total events in a bin, mean values...).; One can obtain a clone of the internal histograms by calling TEfficiency::GetCopyPassedHisto or TEfficiency::GetCopyTotalHisto.; The returned histograms are completely independent from the current; TEfficiency object. By default, they are not attached to a directory to; avoid the duplication of data and the user is responsible for deleting them. ~~~~~~~~~~~~~~~{.cpp}; //open a root file which contains a TEfficiency object; TFile* pFile = new TFile(""myfile.root"",""update"");. //get TEfficiency object with name ""my_eff""; TEfficiency* pEff = (TEfficiency*)pFile->Get(""my_eff"");. //get clone of total histogram; TH1* clone = pEff->GetCopyTotalHisto();. //change clone...; //save changes of clone directly; clone->Write();; //or append it to the current directory and write the file; //clone->SetDirectory(gDirectory);; //pFile->Write();. //delete histogram object; delete clone;; clone = 0;; ~~~~~~~~~~~~~~~. It is also possible to set the internal total or passed histogram by using the; methods TEfficiency::SetPassedHistogram or TEfficiency::SetTotalHistogram. In order to ensure the validity of the TEfficiency object, the consistency of the; new histogram and the stored histogram is checked. It might be; impossible sometimes to change the histograms in a consistent way. Ther",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:24843,Security,access,accessed,24843,"x,5,4);; pEff->Fill(bPassed,x);; }. //create a function for fitting and do the fit; TF1* f1 = new TF1(""f1"",""gaus"",0,10);; f1->SetParameters(1,5,2);; pEff->Fit(f1);. //create a threshold function; TF1* f2 = new TF1(""thres"",""0.8"",0,10);; f2->SetLineColor(kRed);; //add it to the list of functions; //use add first because the parameters of the last function will be displayed; pEff->GetListOfFunctions()->AddFirst(f2);. pEff->Draw(""AP"");; }; End_Macro. \anchor EFF063; ### VI.3 Draw a TEfficiency object; A TEfficiency object can be drawn by calling the usual TEfficiency::Draw method.; At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; method. For 2-dimensional TEfficiency objects, you can pass the same options as; for a TH2::Draw object. \anchor EFF064; ### VI.4 TEfficiency object's axis customisation; The axes of a TEfficiency object can be accessed and customised by calling the; GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; methods.; Note that in order to access the painted graph via GetPaintedGraph(), one should either; call Paint or, better, gPad->Update(). Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);; c1->Divide(2,1);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<10000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }; c1->cd(1);; pEff->Draw(""AP"");; c1->cd(2);; pEff->Draw(""AP"");; gPad->Update();; pEff->GetPaintedGraph()->GetXaxis()->SetTitleSize(0.05);; pEff->GetPa",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:25001,Security,access,access,25001," a threshold function; TF1* f2 = new TF1(""thres"",""0.8"",0,10);; f2->SetLineColor(kRed);; //add it to the list of functions; //use add first because the parameters of the last function will be displayed; pEff->GetListOfFunctions()->AddFirst(f2);. pEff->Draw(""AP"");; }; End_Macro. \anchor EFF063; ### VI.3 Draw a TEfficiency object; A TEfficiency object can be drawn by calling the usual TEfficiency::Draw method.; At the moment drawing is only supported for 1- and 2-dimensional TEfficiency objects.; In the 1-dimensional case, you can use the same options as for the TGraphAsymmErrors::Draw; method. For 2-dimensional TEfficiency objects, you can pass the same options as; for a TH2::Draw object. \anchor EFF064; ### VI.4 TEfficiency object's axis customisation; The axes of a TEfficiency object can be accessed and customised by calling the; GetPaintedGraph method and then GetXaxis() or GetYaxis() and the corresponding TAxis; methods.; Note that in order to access the painted graph via GetPaintedGraph(), one should either; call Paint or, better, gPad->Update(). Begin_Macro(source); {; //canvas only needed for this documentation; TCanvas* c1 = new TCanvas(""example"","""",600,400);; c1->SetFillStyle(1001);; c1->SetFillColor(kWhite);; c1->Divide(2,1);. //create one-dimensional TEfficiency object with fixed bin size; TEfficiency* pEff = new TEfficiency(""eff"",""my efficiency;x;#epsilon"",20,0,10);; TRandom3 rand3;. bool bPassed;; double x;; for(int i=0; i<10000; ++i); {; //simulate events with variable under investigation; x = rand3.Uniform(10);; //check selection: bPassed = DoesEventPassSelection(x); bPassed = rand3.Rndm() < TMath::Gaus(x,5,4);; pEff->Fill(bPassed,x);; }; c1->cd(1);; pEff->Draw(""AP"");; c1->cd(2);; pEff->Draw(""AP"");; gPad->Update();; pEff->GetPaintedGraph()->GetXaxis()->SetTitleSize(0.05);; pEff->GetPaintedGraph()->GetXaxis()->SetLabelFont(42);; pEff->GetPaintedGraph()->GetXaxis()->SetLabelSize(0.05);; pEff->GetPaintedGraph()->GetYaxis()->SetTitleOffset(0.85);; pEff->GetP",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:390,Integrability,depend,depends,390,"////////////////////////////////////////////////////////////////////////////////; /// Constructor using two existing histograms as input; ///; ///Input: passed - contains the events fulfilling some criteria; /// total - contains all investigated events; ///; ///Notes: - both histograms have to fulfill the conditions of CheckConsistency; /// - dimension of the resulting efficiency object depends; /// on the dimension of the given histograms; /// - Clones of both histograms are stored internally; /// - The function SetName(total.GetName() + ""_clone"") is called to set; /// the names of the new object and the internal histograms..; /// - The created TEfficiency object is NOT appended to a directory. It; /// will not be written to disk during the next TFile::Write() command; /// in order to prevent duplication of data. If you want to save this; /// TEfficiency object anyway, you can either append it to a; /// directory by calling SetDirectory(TDirectory*) or write it; /// explicitly to disk by calling Write().",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:131,Modifiability,variab,variable,131,"////////////////////////////////////////////////////////////////////////////////; /// Create 1-dimensional TEfficiency object with variable bin size.; ///; /// Constructor creates two new and empty histograms with a given binning; ///; /// Input:; ///; /// - `name`: the common part of the name for both histograms (no blanks); /// fTotalHistogram has name: name + ""_total""; /// fPassedHistogram has name: name + ""_passed""; /// - `title`: the common part of the title for both histogram; /// fTotalHistogram has title: title + "" (total)""; /// fPassedHistogram has title: title + "" (passed)""; /// It is possible to label the axis by passing a title with; /// the following format: ""title;xlabel;ylabel"".; /// - `nbins`: number of bins on the x-axis; /// - `xbins`: array of length (nbins + 1) with low-edges for each bin; /// xbins[nbinsx] ... lower edge for overflow bin",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:131,Modifiability,variab,variable,131,"////////////////////////////////////////////////////////////////////////////////; /// Create 2-dimensional TEfficiency object with variable bin size.; ///; /// Constructor creates two new and empty histograms with a given binning.; ///; /// Input:; ///; /// - `name`: the common part of the name for both histograms(no blanks); /// fTotalHistogram has name: name + ""_total""; /// fPassedHistogram has name: name + ""_passed""; /// - `title`: the common part of the title for both histogram; /// fTotalHistogram has title: title + "" (total)""; /// fPassedHistogram has title: title + "" (passed)""; /// It is possible to label the axis by passing a title with; /// the following format: ""title;xlabel;ylabel;zlabel"".; /// - `nbinsx`: number of bins on the x-axis; /// - `xbins`: array of length (nbins + 1) with low-edges for each bin; /// xbins[nbinsx] ... lower edge for overflow x-bin; /// - `nbinsy`: number of bins on the y-axis; /// - `ybins`: array of length (nbins + 1) with low-edges for each bin; /// ybins[nbinsy] ... lower edge for overflow y-bin",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:131,Modifiability,variab,variable,131,"////////////////////////////////////////////////////////////////////////////////; /// Create 3-dimensional TEfficiency object with variable bin size.; ///; /// Constructor creates two new and empty histograms with a given binning.; ///; /// Input:; ///; /// - `name`: the common part of the name for both histograms(no blanks); /// fTotalHistogram has name: name + ""_total""; /// fPassedHistogram has name: name + ""_passed""; /// - `title`: the common part of the title for both histogram; /// fTotalHistogram has title: title + "" (total)""; /// fPassedHistogram has title: title + "" (passed)""; /// It is possible to label the axis by passing a title with; /// the following format: ""title;xlabel;ylabel;zlabel"".; /// - `nbinsx`: number of bins on the x-axis; /// - `xbins`: array of length (nbins + 1) with low-edges for each bin; /// xbins[nbinsx] ... lower edge for overflow x-bin; /// - `nbinsy`: number of bins on the y-axis; /// - `ybins`: array of length (nbins + 1) with low-edges for each bin; /// xbins[nbinsx] ... lower edge for overflow y-bin; /// - `nbinsz`: number of bins on the z-axis; /// - `zbins`: array of length (nbins + 1) with low-edges for each bin; /// xbins[nbinsx] ... lower edge for overflow z-bin",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:49,Testability,log,logic,49,"//delete all function in fFunctions; // use same logic as in TH1 destructor; // (see TH1::~TH1 code in TH1.cxx)",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:3,Availability,toler,tolerance,3,"// tolerance",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:178,Integrability,depend,depending,178,"////////////////////////////////////////////////////////////////////////////////; /**; Calculates the boundaries for a Bayesian confidence interval (shortest or central interval depending on the option). \param[in] total number of total events; \param[in] passed 0 <= number of passed events <= total; \param[in] level confidence level; \param[in] alpha shape parameter > 0 for the prior distribution (fBeta_alpha); \param[in] beta shape parameter > 0 for the prior distribution (fBeta_beta); \param[in] bUpper; - true - upper boundary is returned; - false - lower boundary is returned; \param[in] bShortest ??. Note: In the case central confidence interval is calculated.; when passed = 0 (or passed = total) the lower (or upper); interval values will be larger than 0 (or smaller than 1). Calculation:. The posterior probability in bayesian statistics is given by:; \f[; P(\varepsilon |k,N) \propto L(\varepsilon|k,N) \times Prior(\varepsilon); \f]; As an efficiency can be interpreted as probability of a positive outcome of; a Bernoullli trial the likelihood function is given by the binomial; distribution:; \f[; L(\varepsilon|k,N) = Binomial(N,k) \varepsilon ^{k} (1 - \varepsilon)^{N-k}; \f]; At the moment only beta distributions are supported as prior probabilities; of the efficiency (\f$ B(\alpha,\beta)\f$ is the beta function):; \f[; Prior(\varepsilon) = \frac{1}{B(\alpha,\beta)} \varepsilon ^{\alpha - 1} (1 - \varepsilon)^{\beta - 1}; \f]; The posterior probability is therefore again given by a beta distribution:; \f[; P(\varepsilon |k,N) \propto \varepsilon ^{k + \alpha - 1} (1 - \varepsilon)^{N - k + \beta - 1}; \f]; In case of central intervals; the lower boundary for the equal-tailed confidence interval is given by the; inverse cumulative (= quantile) function for the quantile \f$ \frac{1 - level}{2} \f$.; The upper boundary for the equal-tailed confidence interval is given by the; inverse cumulative (= quantile) function for the quantile \f$ \frac{1 + level}{2} \f$.; He",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:22,Performance,perform,perform,22,"// for the other case perform a minimization; // make a function of the length of the posterior interval as a function of lower bound",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:521,Testability,test,test,521,"////////////////////////////////////////////////////////////////////////////////; /**; Calculates the boundaries for the frequentist Clopper-Pearson interval. This interval is recommended by the PDG. \param[in] total number of total events; \param[in] passed 0 <= number of passed events <= total; \param[in] level confidence level; \param[in] bUpper true - upper boundary is returned; ;false - lower boundary is returned. Calculation:. The lower boundary of the Clopper-Pearson interval is the ""exact"" inversion; of the test:; \f{eqnarray*}{; P(x \geq passed; total) &=& \frac{1 - level}{2}\\; P(x \geq passed; total) &=& 1 - P(x \leq passed - 1; total)\\; &=& 1 - \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed} (1 - t)^{passed - 1} dt\\; &=& 1 - \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed - 1} (1 - t)^{total - passed} dt\\; &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed - 1} (1 - t)^{total - passed} dt\\; &=& I_{\varepsilon}(passed,total - passed + 1); \f}; The lower boundary is therefore given by the \f$ \frac{1 - level}{2}\f$ quantile; of the beta distribution. The upper boundary of the Clopper-Pearson interval is the ""exact"" inversion; of the test:; \f{eqnarray*}{; P(x \leq passed; total) &=& \frac{1 - level}{2}\\; P(x \leq passed; total) &=& \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed - 1} (1 - t)^{passed} dt\\; &=& \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed} (1 - t)^{total - passed - 1} dt\\; &=& 1 - \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed - 1} dt\\; \Rightarrow 1 - \frac{1 - level}{2} &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed -1} dt\\; \frac{1 + level}{2} &=& I_{\varepsilon}(passed + 1,total - passed); \f}; The upper boundary is therefore given by the \f$\frac{1 + level}{2}\f$ quantile; of the beta distribution. Note: The connection between the binomial distribution and the regularized; incomplete beta function \f$ I_{\varepsilon}(\alpha,\beta)\",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:1185,Testability,test,test,1185,"//////////////////////////////////////////////////////////; /**; Calculates the boundaries for the frequentist Clopper-Pearson interval. This interval is recommended by the PDG. \param[in] total number of total events; \param[in] passed 0 <= number of passed events <= total; \param[in] level confidence level; \param[in] bUpper true - upper boundary is returned; ;false - lower boundary is returned. Calculation:. The lower boundary of the Clopper-Pearson interval is the ""exact"" inversion; of the test:; \f{eqnarray*}{; P(x \geq passed; total) &=& \frac{1 - level}{2}\\; P(x \geq passed; total) &=& 1 - P(x \leq passed - 1; total)\\; &=& 1 - \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed} (1 - t)^{passed - 1} dt\\; &=& 1 - \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed - 1} (1 - t)^{total - passed} dt\\; &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed - 1} (1 - t)^{total - passed} dt\\; &=& I_{\varepsilon}(passed,total - passed + 1); \f}; The lower boundary is therefore given by the \f$ \frac{1 - level}{2}\f$ quantile; of the beta distribution. The upper boundary of the Clopper-Pearson interval is the ""exact"" inversion; of the test:; \f{eqnarray*}{; P(x \leq passed; total) &=& \frac{1 - level}{2}\\; P(x \leq passed; total) &=& \frac{1}{norm} * \int_{0}^{1 - \varepsilon} t^{total - passed - 1} (1 - t)^{passed} dt\\; &=& \frac{1}{norm} * \int_{\varepsilon}^{1} t^{passed} (1 - t)^{total - passed - 1} dt\\; &=& 1 - \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed - 1} dt\\; \Rightarrow 1 - \frac{1 - level}{2} &=& \frac{1}{norm} * \int_{0}^{\varepsilon} t^{passed} (1 - t)^{total - passed -1} dt\\; \frac{1 + level}{2} &=& I_{\varepsilon}(passed + 1,total - passed); \f}; The upper boundary is therefore given by the \f$\frac{1 + level}{2}\f$ quantile; of the beta distribution. Note: The connection between the binomial distribution and the regularized; incomplete beta function \f$ I_{\varepsilon}(\alpha,\beta)\f$ has been used.; */",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:22,Availability,error,errors,22,"//fill efficiency and errors",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:9,Availability,error,error,9,"//did an error occurred ?",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:639,Availability,error,error,639,"////////////////////////////////////////////////////////////////////////////////; /// Draws the current TEfficiency object; ///; /// \param[in] opt; /// - 1-dimensional case: same options as TGraphAsymmErrors::Draw(); /// but as default ""AP"" is used; /// - 2-dimensional case: by default use an histogram and in this case same options as TH2::Draw(); /// if using instad option ""GRAPH"" a TGraph2DAsymmErrors is used and; /// the same options as for TGraph2D applies; /// - 3-dimensional case: not yet supported; ///; /// Specific TEfficiency drawing options:; /// - E0 - plot bins where the total number of passed events is zero; /// (the error interval will be [0,1] )",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:329,Deployability,release,released,329,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when the drawn class is clicked with the locator; /// If Left button clicked on one of the line end points, this point; /// follows the cursor until button is released.; ///; /// if Middle button clicked, the line is moved parallel to itself; /// until the button is released.; /// Forward the call to the underlying graph",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:437,Deployability,release,released,437,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when the drawn class is clicked with the locator; /// If Left button clicked on one of the line end points, this point; /// follows the cursor until button is released.; ///; /// if Middle button clicked, the line is moved parallel to itself; /// until the button is released.; /// Forward the call to the underlying graph",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:697,Deployability,update,update,697,"////////////////////////////////////////////////////////////////////////////////; /// Returns a cloned version of fPassedHistogram; ///; /// Notes:; /// - The histogram is filled with unit weights. You might want to scale; /// it with the global weight GetWeight().; /// - The returned object is owned by the user who has to care about the; /// deletion of the new TH1 object.; /// - This histogram is by default NOT attached to the current directory; /// to avoid duplication of data. If you want to store it automatically; /// during the next TFile::Write() command, you have to attach it to; /// the corresponding directory.; ///; /// ~~~~~~~{.cpp}; /// TFile* pFile = new TFile(""passed.root"",""update"");; /// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; /// TH1* copy = pEff->GetCopyPassedHisto();; /// copy->SetDirectory(gDirectory);; /// pFile->Write();; /// ~~~~~~~",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:459,Safety,avoid,avoid,459,"////////////////////////////////////////////////////////////////////////////////; /// Returns a cloned version of fPassedHistogram; ///; /// Notes:; /// - The histogram is filled with unit weights. You might want to scale; /// it with the global weight GetWeight().; /// - The returned object is owned by the user who has to care about the; /// deletion of the new TH1 object.; /// - This histogram is by default NOT attached to the current directory; /// to avoid duplication of data. If you want to store it automatically; /// during the next TFile::Write() command, you have to attach it to; /// the corresponding directory.; ///; /// ~~~~~~~{.cpp}; /// TFile* pFile = new TFile(""passed.root"",""update"");; /// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; /// TH1* copy = pEff->GetCopyPassedHisto();; /// copy->SetDirectory(gDirectory);; /// pFile->Write();; /// ~~~~~~~",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:695,Deployability,update,update,695,"////////////////////////////////////////////////////////////////////////////////; /// Returns a cloned version of fTotalHistogram; ///; /// Notes:; /// - The histogram is filled with unit weights. You might want to scale; /// it with the global weight GetWeight().; /// - The returned object is owned by the user who has to care about the; /// deletion of the new TH1 object.; /// - This histogram is by default NOT attached to the current directory; /// to avoid duplication of data. If you want to store it automatically; /// during the next TFile::Write() command, you have to attach it to; /// the corresponding directory.; ///; /// ~~~~~~~{.cpp}; /// TFile* pFile = new TFile(""total.root"",""update"");; /// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; /// TH1* copy = pEff->GetCopyTotalHisto();; /// copy->SetDirectory(gDirectory);; /// pFile->Write();; /// ~~~~~~~",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:458,Safety,avoid,avoid,458,"////////////////////////////////////////////////////////////////////////////////; /// Returns a cloned version of fTotalHistogram; ///; /// Notes:; /// - The histogram is filled with unit weights. You might want to scale; /// it with the global weight GetWeight().; /// - The returned object is owned by the user who has to care about the; /// deletion of the new TH1 object.; /// - This histogram is by default NOT attached to the current directory; /// to avoid duplication of data. If you want to store it automatically; /// during the next TFile::Write() command, you have to attach it to; /// the corresponding directory.; ///; /// ~~~~~~~{.cpp}; /// TFile* pFile = new TFile(""total.root"",""update"");; /// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; /// TH1* copy = pEff->GetCopyTotalHisto();; /// copy->SetDirectory(gDirectory);; /// pFile->Write();; /// ~~~~~~~",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:181,Integrability,depend,depends,181,"////////////////////////////////////////////////////////////////////////////////; /// Returns the efficiency in the given global bin; ///; /// Note:; /// - The estimated efficiency depends on the chosen statistic option:; /// for frequentist ones:; /// \f$ \hat{\varepsilon} = \frac{passed}{total} \f$; /// for bayesian ones the expectation value of the resulting posterior; /// distribution is returned:; /// \f$ \hat{\varepsilon} = \frac{passed + \alpha}{total + \alpha + \beta} \f$; /// If the bit kPosteriorMode is set (or the method TEfficiency::UsePosteriorMode() has been called ) the; /// mode (most probable value) of the posterior is returned:; /// \f$ \hat{\varepsilon} = \frac{passed + \alpha -1}{total + \alpha + \beta -2} \f$; /// - If the denominator is equal to 0, an efficiency of 0 is returned.; /// - When \f$ passed + \alpha < 1 \f$ or \f$ total - passed + \beta < 1 \f$ the above; /// formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:104,Availability,error,error,104,"////////////////////////////////////////////////////////////////////////////////; /// Returns the lower error on the efficiency in the given global bin; ///; /// The result depends on the current confidence level fConfLevel and the; /// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; /// more details.; ///; /// Note: If the histograms are filled with weights, only bayesian methods and the; /// normal approximation are supported.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:173,Integrability,depend,depends,173,"////////////////////////////////////////////////////////////////////////////////; /// Returns the lower error on the efficiency in the given global bin; ///; /// The result depends on the current confidence level fConfLevel and the; /// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; /// more details.; ///; /// Note: If the histograms are filled with weights, only bayesian methods and the; /// normal approximation are supported.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:19,Availability,error,errors,19,"// avoid to return errors which makes eff-err < 0",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:3,Safety,avoid,avoid,3,"// avoid to return errors which makes eff-err < 0",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:104,Availability,error,error,104,"////////////////////////////////////////////////////////////////////////////////; /// Returns the upper error on the efficiency in the given global bin; ///; /// The result depends on the current confidence level fConfLevel and the; /// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; /// more details.; ///; /// Note: If the histograms are filled with weights, only bayesian methods and the; /// normal approximation are supported.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:173,Integrability,depend,depends,173,"////////////////////////////////////////////////////////////////////////////////; /// Returns the upper error on the efficiency in the given global bin; ///; /// The result depends on the current confidence level fConfLevel and the; /// chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; /// more details.; ///; /// Note: If the histograms are filled with weights, only bayesian methods and the; /// normal approximation are supported.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:562,Deployability,update,updated,562,"////////////////////////////////////////////////////////////////////////////////; /// Paints this TEfficiency object; ///; /// For details on the possible option see Draw(Option_t*); ///; /// Note for 1D classes; /// In 1D the TEfficiency uses a TGraphAsymmErrors for drawing; /// The TGraph is created only the first time Paint is used. The user can manipulate the; /// TGraph via the method TEfficiency::GetPaintedGraph(); /// The TGraph creates behing an histogram for the axis. The histogram is created also only the first time.; /// If the axis needs to be updated because in the meantime the class changed use this trick; /// which will trigger a re-calculation of the axis of the graph; /// TEfficiency::GetPaintedGraph()->Set(0); ///; /// Note that in order to access the painted graph via GetPaintedGraph() you need either to call Paint or better; /// gPad->Update();; ///",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:867,Deployability,Update,Update,867,"////////////////////////////////////////////////////////////////////////////////; /// Paints this TEfficiency object; ///; /// For details on the possible option see Draw(Option_t*); ///; /// Note for 1D classes; /// In 1D the TEfficiency uses a TGraphAsymmErrors for drawing; /// The TGraph is created only the first time Paint is used. The user can manipulate the; /// TGraph via the method TEfficiency::GetPaintedGraph(); /// The TGraph creates behing an histogram for the axis. The histogram is created also only the first time.; /// If the axis needs to be updated because in the meantime the class changed use this trick; /// which will trigger a re-calculation of the axis of the graph; /// TEfficiency::GetPaintedGraph()->Set(0); ///; /// Note that in order to access the painted graph via GetPaintedGraph() you need either to call Paint or better; /// gPad->Update();; ///",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:769,Security,access,access,769,"////////////////////////////////////////////////////////////////////////////////; /// Paints this TEfficiency object; ///; /// For details on the possible option see Draw(Option_t*); ///; /// Note for 1D classes; /// In 1D the TEfficiency uses a TGraphAsymmErrors for drawing; /// The TGraph is created only the first time Paint is used. The user can manipulate the; /// TGraph via the method TEfficiency::GetPaintedGraph(); /// The TGraph creates behing an histogram for the axis. The histogram is created also only the first time.; /// If the axis needs to be updated because in the meantime the class changed use this trick; /// which will trigger a re-calculation of the axis of the graph; /// TEfficiency::GetPaintedGraph()->Set(0); ///; /// Note that in order to access the painted graph via GetPaintedGraph() you need either to call Paint or better; /// gPad->Update();; ///",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:3,Deployability,update,update,3,"// update existing graph already created",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:31,Modifiability,variab,variable,31,"//create arrays containing the variable binning",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:11,Modifiability,variab,variable,11,"//creating variable binning; //TEfficiency pointer has efficiency name + counter",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:2,Modifiability,variab,variable,2,"//variable bin size -> use n,*bins constructor",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:36,Availability,avail,available,36,"// doing this I get h1->fN which is available only for a TH1D",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:208,Deployability,update,updated,208,"////////////////////////////////////////////////////////////////////////////////; /// Sets the number of passed events in the given global bin; ///; /// returns ""true"" if the number of passed events has been updated; /// otherwise ""false"" ist returned; ///; /// Note: - requires: 0 <= events <= fTotalHistogram->GetBinContent(bin)",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:532,Usability,clear,cleared,532,"////////////////////////////////////////////////////////////////////////////////; /// Sets the histogram containing the passed events; ///; /// The given histogram is cloned and stored internally as histogram containing; /// the passed events. The given histogram has to be consistent with the current; /// fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)).; /// The method returns whether the fPassedHistogram has been replaced (true) or; /// not (false).; ///; /// Note: The list of associated functions fFunctions is cleared.; ///; /// Option:; /// - ""f"": force the replacement without checking the consistency; /// This can lead to inconsistent histograms and useless results; /// or unexpected behaviour. But sometimes it might be the only; /// way to change the histograms. If you use this option, you; /// should ensure that the fTotalHistogram is replaced by a; /// consistent one (with respect to rPassed) as well.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:206,Deployability,update,updated,206,"////////////////////////////////////////////////////////////////////////////////; /// Sets the number of total events in the given global bin; ///; /// returns ""true"" if the number of total events has been updated; /// otherwise ""false"" ist returned; ///; /// Note: - requires: fPassedHistogram->GetBinContent(bin) <= events",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:518,Usability,clear,cleared,518,"////////////////////////////////////////////////////////////////////////////////; /// Sets the histogram containing all events; ///; /// The given histogram is cloned and stored internally as histogram containing; /// all events. The given histogram has to be consistent with the current; /// fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; /// The method returns whether the fTotalHistogram has been replaced (true) or; /// not (false).; ///; /// Note: The list of associated functions fFunctions is cleared.; ///; /// Option:; /// - ""f"": force the replacement without checking the consistency; /// This can lead to inconsistent histograms and useless results; /// or unexpected behaviour. But sometimes it might be the only; /// way to change the histograms. If you use this option, you; /// should ensure that the fPassedHistogram is replaced by a; /// consistent one (with respect to rTotal) as well.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h:350,Deployability,integrat,integration,350,"// @(#)root/mathcore:$Id$; // Author: L. Moneta Nov 2010; /**********************************************************************; * *; * Copyright (c) 2010 LCG ROOT Math Team, CERN/PH-SFT *; * *; * *; **********************************************************************/; // helper class for binomial Neyman intervals; // author Jordan Tucker; // integration in CMSSW: Luca Lista; // modified and integrated in ROOT: Lorenzo Moneta",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiencyHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h:400,Deployability,integrat,integrated,400,"// @(#)root/mathcore:$Id$; // Author: L. Moneta Nov 2010; /**********************************************************************; * *; * Copyright (c) 2010 LCG ROOT Math Team, CERN/PH-SFT *; * *; * *; **********************************************************************/; // helper class for binomial Neyman intervals; // author Jordan Tucker; // integration in CMSSW: Luca Lista; // modified and integrated in ROOT: Lorenzo Moneta",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiencyHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h:350,Integrability,integrat,integration,350,"// @(#)root/mathcore:$Id$; // Author: L. Moneta Nov 2010; /**********************************************************************; * *; * Copyright (c) 2010 LCG ROOT Math Team, CERN/PH-SFT *; * *; * *; **********************************************************************/; // helper class for binomial Neyman intervals; // author Jordan Tucker; // integration in CMSSW: Luca Lista; // modified and integrated in ROOT: Lorenzo Moneta",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiencyHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h:400,Integrability,integrat,integrated,400,"// @(#)root/mathcore:$Id$; // Author: L. Moneta Nov 2010; /**********************************************************************; * *; * Copyright (c) 2010 LCG ROOT Math Team, CERN/PH-SFT *; * *; * *; **********************************************************************/; // helper class for binomial Neyman intervals; // author Jordan Tucker; // integration in CMSSW: Luca Lista; // modified and integrated in ROOT: Lorenzo Moneta",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiencyHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h:3,Performance,Cache,Cache,3,"// Cache the likelihood ratio L(\rho)/L(\hat{\rho}), too.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiencyHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h:102,Energy Efficiency,allocate,allocated,102,"// Construct nrho acceptance sets in rho = [0,1] given ntot trials; // and put the results in already-allocated x_l and x_r.",MatchSource.CODE_COMMENT,hist/hist/src/TEfficiencyHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiencyHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:72,Availability,error,error,72,"// formula functions; // if ndim is not 1 set xmin max to zero to avoid error in ctor",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:66,Safety,avoid,avoid,66,"// formula functions; // if ndim is not 1 set xmin max to zero to avoid error in ctor",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:9,Integrability,wrap,wrapping,9,"// class wrapping evaluation of TF1(x) - y0",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:9,Integrability,wrap,wrapping,9,"// class wrapping evaluation of -TF1(x)",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:9,Integrability,wrap,wrapping,9,"// class wrapping evaluation of -TF1(x) for multi-dimension",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:73,Deployability,integrat,integration,73,"// class wrapping function evaluation directly in 1D interface (used for integration); // and implementing the methods for the momentum calculations",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:9,Integrability,wrap,wrapping,9,"// class wrapping function evaluation directly in 1D interface (used for integration); // and implementing the methods for the momentum calculations",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:53,Integrability,interface,interface,53,"// class wrapping function evaluation directly in 1D interface (used for integration); // and implementing the methods for the momentum calculations",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:73,Integrability,integrat,integration,73,"// class wrapping function evaluation directly in 1D interface (used for integration); // and implementing the methods for the momentum calculations",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:2701,Energy Efficiency,power,power,2701,"iable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa->SetParName(0,""Constant"");; ~~~~. * Example b:. ~~~~{.cpp}; auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; ~~~~. ``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``. #### Case 2: inline expression using TMath functions with parameters. Begin_Macro(source); {; auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; fb2->SetParameters(0.2,1.3);; fb2->Draw();; }; End_Macro. \anchor F3; ### 3 - A lambda expression with variables and parameters. \since **6.00/00:**; TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda; functions and still maintain the capability of storing the function in a file which cannot be done with; function pointer or lambda written not as expression, but as code (see items below). Example on how using lambda to define a sum of two functions.; Note that is necessary to provide the number of parameters. ~~~~{.cpp}; TF1 f1(""f1"",""sin(x)"",0,10);; TF1 f2(""f2"",""cos(x)"",0,10);; TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; ~~~~. \anchor F4; ### 4 - A general C function with parameters. Consider the macro myfunc.C below:. ~~~~{.cpp}; // Macro myfunc.C; Double_t myfunction(Double_t *x, Double_t *par); {; Float_t xx =x[0];; Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; return f;; }; void myfunc(); {; auto f1 = new TF1(""myfunc"",myfunction,0,10,2);; f1->SetParameters(2,1);; f1->SetParNames(""constant"",""coefficient"");; f1->Draw();; }; void myfit(); {; auto h1 = new TH1F(""h1"",""test"",100,0,10);; h1->FillRandom(""myfunc"",20000);; TF1 *f1 = (TF1 *)gROOT->GetFunction(""myfunc"");; f1->SetParameters(800,1);; h1->",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:538,Modifiability,variab,variable,538,"////////////////////////////////////////////////////////////////////////////////; /** \class TF1; \ingroup Functions; \brief 1-Dim function class. ## TF1: 1-Dim function class. A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function based on a TFormula expression or a precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1 and TGraph drawing functions. The following types of functions can be created:. 1. [Expression using variable x and no parameters](\ref F1); 2. [Expression using variable x with parameters](\ref F2); 3. [Lambda Expression with variable x and parameters](\ref F3); 4. [A general C function with parameters](\ref F4); 5. [A general C++ function object (functor) with parameters](\ref F5); 6. [A member function with parameters of a general C++ class](\ref F6). \anchor F1; ### 1 - Expression using variable x and no parameters. #### Case 1: inline expression using standard C++ functions/operators. Begin_Macro(source); {; auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();; }; End_Macro. #### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters. Begin_Macro(source); {; auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();; }; End_Macro. #### Case 3: inline expression using a user defined CLING function by name. ~~~~{.cpp}; Double_t myFunc(double x) { return x+sin(x); }; ....; auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();; ~~~~. \anchor F2; ### 2 - Expression using variable x with parameters. #### Case 1: inline expression using standard C++ functions/operators. * Example a:. ~~~~{.cpp}; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; ~~~~. This creates a function of variable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:599,Modifiability,variab,variable,599,"////////////////////////////////////////////////////////////////////////////////; /** \class TF1; \ingroup Functions; \brief 1-Dim function class. ## TF1: 1-Dim function class. A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function based on a TFormula expression or a precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1 and TGraph drawing functions. The following types of functions can be created:. 1. [Expression using variable x and no parameters](\ref F1); 2. [Expression using variable x with parameters](\ref F2); 3. [Lambda Expression with variable x and parameters](\ref F3); 4. [A general C function with parameters](\ref F4); 5. [A general C++ function object (functor) with parameters](\ref F5); 6. [A member function with parameters of a general C++ class](\ref F6). \anchor F1; ### 1 - Expression using variable x and no parameters. #### Case 1: inline expression using standard C++ functions/operators. Begin_Macro(source); {; auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();; }; End_Macro. #### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters. Begin_Macro(source); {; auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();; }; End_Macro. #### Case 3: inline expression using a user defined CLING function by name. ~~~~{.cpp}; Double_t myFunc(double x) { return x+sin(x); }; ....; auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();; ~~~~. \anchor F2; ### 2 - Expression using variable x with parameters. #### Case 1: inline expression using standard C++ functions/operators. * Example a:. ~~~~{.cpp}; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; ~~~~. This creates a function of variable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:664,Modifiability,variab,variable,664,"////////////////////////////////////////////////////////////////////////////////; /** \class TF1; \ingroup Functions; \brief 1-Dim function class. ## TF1: 1-Dim function class. A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function based on a TFormula expression or a precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1 and TGraph drawing functions. The following types of functions can be created:. 1. [Expression using variable x and no parameters](\ref F1); 2. [Expression using variable x with parameters](\ref F2); 3. [Lambda Expression with variable x and parameters](\ref F3); 4. [A general C function with parameters](\ref F4); 5. [A general C++ function object (functor) with parameters](\ref F5); 6. [A member function with parameters of a general C++ class](\ref F6). \anchor F1; ### 1 - Expression using variable x and no parameters. #### Case 1: inline expression using standard C++ functions/operators. Begin_Macro(source); {; auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();; }; End_Macro. #### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters. Begin_Macro(source); {; auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();; }; End_Macro. #### Case 3: inline expression using a user defined CLING function by name. ~~~~{.cpp}; Double_t myFunc(double x) { return x+sin(x); }; ....; auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();; ~~~~. \anchor F2; ### 2 - Expression using variable x with parameters. #### Case 1: inline expression using standard C++ functions/operators. * Example a:. ~~~~{.cpp}; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; ~~~~. This creates a function of variable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:933,Modifiability,variab,variable,933,"////////////////////////////////////////////////////////////////////////////////; /** \class TF1; \ingroup Functions; \brief 1-Dim function class. ## TF1: 1-Dim function class. A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function based on a TFormula expression or a precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1 and TGraph drawing functions. The following types of functions can be created:. 1. [Expression using variable x and no parameters](\ref F1); 2. [Expression using variable x with parameters](\ref F2); 3. [Lambda Expression with variable x and parameters](\ref F3); 4. [A general C function with parameters](\ref F4); 5. [A general C++ function object (functor) with parameters](\ref F5); 6. [A member function with parameters of a general C++ class](\ref F6). \anchor F1; ### 1 - Expression using variable x and no parameters. #### Case 1: inline expression using standard C++ functions/operators. Begin_Macro(source); {; auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();; }; End_Macro. #### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters. Begin_Macro(source); {; auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();; }; End_Macro. #### Case 3: inline expression using a user defined CLING function by name. ~~~~{.cpp}; Double_t myFunc(double x) { return x+sin(x); }; ....; auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();; ~~~~. \anchor F2; ### 2 - Expression using variable x with parameters. #### Case 1: inline expression using standard C++ functions/operators. * Example a:. ~~~~{.cpp}; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; ~~~~. This creates a function of variable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1568,Modifiability,variab,variable,1568,"ters](\ref F1); 2. [Expression using variable x with parameters](\ref F2); 3. [Lambda Expression with variable x and parameters](\ref F3); 4. [A general C function with parameters](\ref F4); 5. [A general C++ function object (functor) with parameters](\ref F5); 6. [A member function with parameters of a general C++ class](\ref F6). \anchor F1; ### 1 - Expression using variable x and no parameters. #### Case 1: inline expression using standard C++ functions/operators. Begin_Macro(source); {; auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();; }; End_Macro. #### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters. Begin_Macro(source); {; auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();; }; End_Macro. #### Case 3: inline expression using a user defined CLING function by name. ~~~~{.cpp}; Double_t myFunc(double x) { return x+sin(x); }; ....; auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();; ~~~~. \anchor F2; ### 2 - Expression using variable x with parameters. #### Case 1: inline expression using standard C++ functions/operators. * Example a:. ~~~~{.cpp}; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; ~~~~. This creates a function of variable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa->SetParName(0,""Constant"");; ~~~~. * Example b:. ~~~~{.cpp}; auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; ~~~~. ``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``. #### Case 2: inline expression using TMath functions with parameters. Begin_Macro(source); {; auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; fb2->SetParameters(0.2,1.3);; fb2->Draw();; }; End_Macro. \anchor F3; ### 3 - A lambda expression with variables an",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1776,Modifiability,variab,variable,1776,"ion object (functor) with parameters](\ref F5); 6. [A member function with parameters of a general C++ class](\ref F6). \anchor F1; ### 1 - Expression using variable x and no parameters. #### Case 1: inline expression using standard C++ functions/operators. Begin_Macro(source); {; auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();; }; End_Macro. #### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters. Begin_Macro(source); {; auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();; }; End_Macro. #### Case 3: inline expression using a user defined CLING function by name. ~~~~{.cpp}; Double_t myFunc(double x) { return x+sin(x); }; ....; auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();; ~~~~. \anchor F2; ### 2 - Expression using variable x with parameters. #### Case 1: inline expression using standard C++ functions/operators. * Example a:. ~~~~{.cpp}; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; ~~~~. This creates a function of variable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa->SetParName(0,""Constant"");; ~~~~. * Example b:. ~~~~{.cpp}; auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; ~~~~. ``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``. #### Case 2: inline expression using TMath functions with parameters. Begin_Macro(source); {; auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; fb2->SetParameters(0.2,1.3);; fb2->Draw();; }; End_Macro. \anchor F3; ### 3 - A lambda expression with variables and parameters. \since **6.00/00:**; TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda; functions and still maintain the capability of storing the ",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:2551,Modifiability,variab,variables,2551,"2; ### 2 - Expression using variable x with parameters. #### Case 1: inline expression using standard C++ functions/operators. * Example a:. ~~~~{.cpp}; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; ~~~~. This creates a function of variable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa->SetParName(0,""Constant"");; ~~~~. * Example b:. ~~~~{.cpp}; auto fb = new TF1(""fb"",""gaus(0)*expo(3)"",0,10);; ~~~~. ``gaus(0)`` is a substitute for ``[0]*exp(-0.5*((x-[1])/[2])**2)`` and ``(0)`` means start numbering parameters at ``0``. ``expo(3)`` is a substitute for ``exp([3]+[4]*x)``. #### Case 2: inline expression using TMath functions with parameters. Begin_Macro(source); {; auto fb2 = new TF1(""fa3"",""TMath::Landau(x,[0],[1],0)"",-5,10);; fb2->SetParameters(0.2,1.3);; fb2->Draw();; }; End_Macro. \anchor F3; ### 3 - A lambda expression with variables and parameters. \since **6.00/00:**; TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda; functions and still maintain the capability of storing the function in a file which cannot be done with; function pointer or lambda written not as expression, but as code (see items below). Example on how using lambda to define a sum of two functions.; Note that is necessary to provide the number of parameters. ~~~~{.cpp}; TF1 f1(""f1"",""sin(x)"",0,10);; TF1 f2(""f2"",""cos(x)"",0,10);; TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; ~~~~. \anchor F4; ### 4 - A general C function with parameters. Consider the macro myfunc.C below:. ~~~~{.cpp}; // Macro myfunc.C; Double_t myfunction(Double_t *x, Double_t *par); {; Float_t xx =x[0];; Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; return f;; }; void myfunc(); {; auto f1 = new TF1(""myfunc"",myfunction,0,10,2);; f1->SetParameters(2",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3649,Testability,test,test,3649,"s and parameters. \since **6.00/00:**; TF1 supports using lambda expressions in the formula. This allows, by using a full C++ syntax the full power of lambda; functions and still maintain the capability of storing the function in a file which cannot be done with; function pointer or lambda written not as expression, but as code (see items below). Example on how using lambda to define a sum of two functions.; Note that is necessary to provide the number of parameters. ~~~~{.cpp}; TF1 f1(""f1"",""sin(x)"",0,10);; TF1 f2(""f2"",""cos(x)"",0,10);; TF1 fsum(""f1"",""[&](double *x, double *p){ return p[0]*f1(x) + p[1]*f2(x); }"",0,10,2);; ~~~~. \anchor F4; ### 4 - A general C function with parameters. Consider the macro myfunc.C below:. ~~~~{.cpp}; // Macro myfunc.C; Double_t myfunction(Double_t *x, Double_t *par); {; Float_t xx =x[0];; Double_t f = TMath::Abs(par[0]*sin(par[1]*xx)/xx);; return f;; }; void myfunc(); {; auto f1 = new TF1(""myfunc"",myfunction,0,10,2);; f1->SetParameters(2,1);; f1->SetParNames(""constant"",""coefficient"");; f1->Draw();; }; void myfit(); {; auto h1 = new TH1F(""h1"",""test"",100,0,10);; h1->FillRandom(""myfunc"",20000);; TF1 *f1 = (TF1 *)gROOT->GetFunction(""myfunc"");; f1->SetParameters(800,1);; h1->Fit(""myfunc"");; }; ~~~~. In an interactive session you can do:. ~~~~; Root > .L myfunc.C; Root > myfunc();; Root > myfit();; ~~~~. TF1 objects can reference other TF1 objects of type A or B defined above. This excludes CLing or compiled functions. However, there is a restriction. A function cannot reference a basic function if the basic function is a polynomial polN. Example:. ~~~~{.cpp}; {; auto fcos = new TF1 (""fcos"", ""[0]*cos(x)"", 0., 10.);; fcos->SetParNames( ""cos"");; fcos->SetParameter( 0, 1.1);. auto fsin = new TF1 (""fsin"", ""[0]*sin(x)"", 0., 10.);; fsin->SetParNames( ""sin"");; fsin->SetParameter( 0, 2.1);. auto fsincos = new TF1 (""fsc"", ""fcos+fsin"");. auto fs2 = new TF1 (""fs2"", ""fsc+fsc"");; }; ~~~~. \anchor F5; ### 5 - A general C++ function object (functor) with pa",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:274,Usability,simpl,simple,274,"////////////////////////////////////////////////////////////////////////////////; /** \class TF1; \ingroup Functions; \brief 1-Dim function class. ## TF1: 1-Dim function class. A TF1 object is a 1-Dim function defined between a lower and upper limit.; The function may be a simple function based on a TFormula expression or a precompiled user function.; The function may have associated parameters.; TF1 graphics function is via the TH1 and TGraph drawing functions. The following types of functions can be created:. 1. [Expression using variable x and no parameters](\ref F1); 2. [Expression using variable x with parameters](\ref F2); 3. [Lambda Expression with variable x and parameters](\ref F3); 4. [A general C function with parameters](\ref F4); 5. [A general C++ function object (functor) with parameters](\ref F5); 6. [A member function with parameters of a general C++ class](\ref F6). \anchor F1; ### 1 - Expression using variable x and no parameters. #### Case 1: inline expression using standard C++ functions/operators. Begin_Macro(source); {; auto fa1 = new TF1(""fa1"",""sin(x)/x"",0,10);; fa1->Draw();; }; End_Macro. #### Case 2: inline expression using a ROOT function (e.g. from TMath) without parameters. Begin_Macro(source); {; auto fa2 = new TF1(""fa2"",""TMath::DiLog(x)"",0,10);; fa2->Draw();; }; End_Macro. #### Case 3: inline expression using a user defined CLING function by name. ~~~~{.cpp}; Double_t myFunc(double x) { return x+sin(x); }; ....; auto fa3 = new TF1(""fa3"",""myFunc(x)"",-3,5);; fa3->Draw();; ~~~~. \anchor F2; ### 2 - Expression using variable x with parameters. #### Case 1: inline expression using standard C++ functions/operators. * Example a:. ~~~~{.cpp}; auto fa = new TF1(""fa"",""[0]*x*sin([1]*x)"",-3,3);; ~~~~. This creates a function of variable x with 2 parameters. The parameters must be initialized via:. ~~~~{.cpp}; fa->SetParameter(0,value_first_parameter);; fa->SetParameter(1,value_second_parameter);; ~~~~. Parameters may be given a name:. ~~~~{.cpp}; fa",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:22,Modifiability,extend,extend,22,"// (note: may want to extend this in the future?)",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:22,Usability,simpl,simply,22,"// or if no constant, simply copy parameters from function2",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:22,Modifiability,extend,extend,22,"// (note: may want to extend functionality in the future)",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3,Modifiability,inherit,inherit,3,"// inherit default parameters from normSum; // Parameter names",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:177,Availability,avail,available,177,"////////////////////////////////////////////////////////////////////////////////; /// Same constructor as above (for TFormula based function) but passing an option strings; /// available options; /// VEC - vectorize the formula expressions (not possible for lambda based expressions); /// NL - function is not stores in the global list of functions; /// GL - function will be always stored in the global list of functions ,; /// independently of the global setting of TF1::DefaultAddToGlobalList; ///////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:648,Integrability,interface,interface,648,"////////////////////////////////////////////////////////////////////////////////; /// Constructor using a pointer to a real function.; ///; /// \param[in] name object name; /// \param[in] fcn pointer to function; /// \param[in] xmin,xmax x axis limits; /// \param[in] npar is the number of free parameters used by the function; /// \param[in] ndim number of dimensions; /// \param[in] addToGlobList boolean marking if it should be added to global list; ///; /// This constructor creates a function of type C when invoked; /// with the normal C++ compiler.; ///; /// see test program test/stress.cxx (function stress1) for an example.; /// note the interface with an intermediate pointer.; ///; /// \warning A function created with this constructor cannot be Cloned.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:570,Testability,test,test,570,"////////////////////////////////////////////////////////////////////////////////; /// Constructor using a pointer to a real function.; ///; /// \param[in] name object name; /// \param[in] fcn pointer to function; /// \param[in] xmin,xmax x axis limits; /// \param[in] npar is the number of free parameters used by the function; /// \param[in] ndim number of dimensions; /// \param[in] addToGlobList boolean marking if it should be added to global list; ///; /// This constructor creates a function of type C when invoked; /// with the normal C++ compiler.; ///; /// see test program test/stress.cxx (function stress1) for an example.; /// note the interface with an intermediate pointer.; ///; /// \warning A function created with this constructor cannot be Cloned.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:583,Testability,test,test,583,"////////////////////////////////////////////////////////////////////////////////; /// Constructor using a pointer to a real function.; ///; /// \param[in] name object name; /// \param[in] fcn pointer to function; /// \param[in] xmin,xmax x axis limits; /// \param[in] npar is the number of free parameters used by the function; /// \param[in] ndim number of dimensions; /// \param[in] addToGlobList boolean marking if it should be added to global list; ///; /// This constructor creates a function of type C when invoked; /// with the normal C++ compiler.; ///; /// see test program test/stress.cxx (function stress1) for an example.; /// note the interface with an intermediate pointer.; ///; /// \warning A function created with this constructor cannot be Cloned.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:654,Integrability,interface,interface,654,"////////////////////////////////////////////////////////////////////////////////; /// Constructor using a pointer to (const) real function.; ///; /// \param[in] name object name; /// \param[in] fcn pointer to function; /// \param[in] xmin,xmax x axis limits; /// \param[in] npar is the number of free parameters used by the function; /// \param[in] ndim number of dimensions; /// \param[in] addToGlobList boolean marking if it should be added to global list; ///; /// This constructor creates a function of type C when invoked; /// with the normal C++ compiler.; ///; /// see test program test/stress.cxx (function stress1) for an example.; /// note the interface with an intermediate pointer.; ///; /// \warning A function created with this constructor cannot be Cloned.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:576,Testability,test,test,576,"////////////////////////////////////////////////////////////////////////////////; /// Constructor using a pointer to (const) real function.; ///; /// \param[in] name object name; /// \param[in] fcn pointer to function; /// \param[in] xmin,xmax x axis limits; /// \param[in] npar is the number of free parameters used by the function; /// \param[in] ndim number of dimensions; /// \param[in] addToGlobList boolean marking if it should be added to global list; ///; /// This constructor creates a function of type C when invoked; /// with the normal C++ compiler.; ///; /// see test program test/stress.cxx (function stress1) for an example.; /// note the interface with an intermediate pointer.; ///; /// \warning A function created with this constructor cannot be Cloned.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:589,Testability,test,test,589,"////////////////////////////////////////////////////////////////////////////////; /// Constructor using a pointer to (const) real function.; ///; /// \param[in] name object name; /// \param[in] fcn pointer to function; /// \param[in] xmin,xmax x axis limits; /// \param[in] npar is the number of free parameters used by the function; /// \param[in] ndim number of dimensions; /// \param[in] addToGlobList boolean marking if it should be added to global list; ///; /// This constructor creates a function of type C when invoked; /// with the normal C++ compiler.; ///; /// see test program test/stress.cxx (function stress1) for an example.; /// note the interface with an intermediate pointer.; ///; /// \warning A function created with this constructor cannot be Cloned.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:175,Modifiability,parameteriz,parameterized,175,"////////////////////////////////////////////////////////////////////////////////; /// Constructor using the Functor class.; ///; /// \param[in] name object name; /// \param f parameterized functor; /// \param xmin and; /// \param xmax define the plotting range of the function; /// \param[in] npar is the number of free parameters used by the function; /// \param[in] ndim number of dimensions; /// \param[in] addToGlobList boolean marking if it should be added to global list; ///; /// This constructor can be used only in compiled code; ///; /// WARNING! A function created with this constructor cannot be Cloned.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:107,Safety,avoid,avoid,107,"////////////////////////////////////////////////////////////////////////////////; /// Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ); /// After having called this static method, all the functions created afterwards will follow the; /// desired behaviour.; ///; /// By default the functions are added automatically; /// It returns the previous status (true if the functions are added automatically)",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:209,Security,sanitiz,sanitized,209,"////////////////////////////////////////////////////////////////////////////////; /// Helper functions for NSUM parsing; // Defines the formula that a given term uses, if not already defined,; // and appends ""sanitized"" formula to `fullFormula` string",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:67,Security,sanitiz,sanitized,67,"// `originalFunc` is the real formula and `cleanedFunc` is the; // sanitized version that will not confuse the TF1NormSum; // constructor",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:10,Security,sanitiz,sanitized,10,"// append sanitized term to `fullFormula`",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:131,Performance,cache,cached,131,"////////////////////////////////////////////////////////////////////////////////; /// Copy this F1 to a new F1.; /// Note that the cached integral with its related arrays are not copied; /// (they are also set as transient data members)",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1062,Availability,error,error,1062,"////////////////////////////////////////////////////////////////////////////////; /// Returns the first derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - f(x-h)}{2h}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1106,Availability,error,error,1106,"////////////////////////////////////////////////////////////////////////////////; /// Returns the first derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - f(x-h)}{2h}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1123,Availability,error,error,1123,"////////////////////////////////////////////////////////////////////////////////; /// Returns the first derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - f(x-h)}{2h}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1145,Availability,error,error,1145,"////////////////////////////////////////////////////////////////////////////////; /// Returns the first derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - f(x-h)}{2h}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1186,Availability,error,error,1186,"////////////////////////////////////////////////////////////////////////////////; /// Returns the first derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - f(x-h)}{2h}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1413,Availability,error,error,1413,"////////////////////////////////////////////////////////////////////////////////; /// Returns the first derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - f(x-h)}{2h}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:51,Integrability,wrap,wrapper,51,"// no need to set parameters used a non-parametric wrapper to avoid allocating; // an array with parameter values",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:62,Safety,avoid,avoid,62,"// no need to set parameters used a non-parametric wrapper to avoid allocating; // an array with parameter values",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1074,Availability,error,error,1074,"////////////////////////////////////////////////////////////////////////////////; /// Returns the second derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1118,Availability,error,error,1118,"////////////////////////////////////////////////////////////////////////////////; /// Returns the second derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1135,Availability,error,error,1135,"////////////////////////////////////////////////////////////////////////////////; /// Returns the second derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1157,Availability,error,error,1157,"////////////////////////////////////////////////////////////////////////////////; /// Returns the second derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1198,Availability,error,error,1198,"////////////////////////////////////////////////////////////////////////////////; /// Returns the second derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1425,Availability,error,error,1425,"////////////////////////////////////////////////////////////////////////////////; /// Returns the second derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:51,Integrability,wrap,wrapper,51,"// no need to set parameters used a non-parametric wrapper to avoid allocating; // an array with parameter values",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:62,Safety,avoid,avoid,62,"// no need to set parameters used a non-parametric wrapper to avoid allocating; // an array with parameter values",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1088,Availability,error,error,1088,"////////////////////////////////////////////////////////////////////////////////; /// Returns the third derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1132,Availability,error,error,1132,"////////////////////////////////////////////////////////////////////////////////; /// Returns the third derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1149,Availability,error,error,1149,"////////////////////////////////////////////////////////////////////////////////; /// Returns the third derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1171,Availability,error,error,1171,"////////////////////////////////////////////////////////////////////////////////; /// Returns the third derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1212,Availability,error,error,1212,"////////////////////////////////////////////////////////////////////////////////; /// Returns the third derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1439,Availability,error,error,1439,"////////////////////////////////////////////////////////////////////////////////; /// Returns the third derivative of the function at point x,; /// computed by Richardson's extrapolation method (use 2 derivative estimates; /// to compute a third, more accurate estimation); /// first, derivatives with steps h and h/2 are computed by central difference formulas; /// \f[; /// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; /// \f]; /// the final estimate; /// \f[; /// D = \frac{4D(h/2) - D(h)}{3}; /// \f]; /// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; ///; /// if the argument params is null, the current function parameters are used,; /// otherwise the parameters in params are used.; ///; /// the argument eps may be specified to control the step size (precision).; /// the step size is taken as eps*(xmax-xmin).; /// the default value (0.001) should be good enough for the vast majority; /// of functions. Give a smaller value if your function has many changes; /// of the second derivative in the function range.; ///; /// Getting the error via TF1::DerivativeError:; /// (total error = roundoff error + interpolation error); /// the estimate of the roundoff error is taken as follows:; /// \f[; /// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; /// \f]; /// where k is the double precision, ai are coefficients used in; /// central difference formulas; /// interpolation error is decreased by making the step size h smaller.; ///; /// \author Anna Kreshuk",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:51,Integrability,wrap,wrapper,51,"// no need to set parameters used a non-parametric wrapper to avoid allocating; // an array with parameter values",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:62,Safety,avoid,avoid,62,"// no need to set parameters used a non-parametric wrapper to avoid allocating; // an array with parameter values",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:116,Availability,error,error,116,"////////////////////////////////////////////////////////////////////////////////; /// Static function returning the error of the last call to the of Derivative's; /// functions",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:278,Modifiability,variab,variables,278,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate this function.; ///; /// Computes the value of this function (general case for a 3-d function); /// at point x,y,z.; /// For a 1-d function give y=0 and z=0; /// The current value of variables x,y,z is passed through x, y and z.; /// The parameters used will be the ones in the array params if params is given; /// otherwise parameters will be taken from the stored data members fParams",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:749,Testability,log,logx,749,"////////////////////////////////////////////////////////////////////////////////; /// Returns the maximum value of the function; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx.; /// This way, the step size can be controlled via the SetNpx() function.; /// If the function is unimodal or if its extrema are far apart, setting; /// the fNpx to a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX and TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:788,Testability,log,log,788,"////////////////////////////////////////////////////////////////////////////////; /// Returns the maximum value of the function; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx.; /// This way, the step size can be controlled via the SetNpx() function.; /// If the function is unimodal or if its extrema are far apart, setting; /// the fNpx to a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX and TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:841,Testability,log,log,841,"////////////////////////////////////////////////////////////////////////////////; /// Returns the maximum value of the function; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx.; /// This way, the step size can be controlled via the SetNpx() function.; /// If the function is unimodal or if its extrema are far apart, setting; /// the fNpx to a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX and TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:778,Testability,log,logx,778,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the maximum value of the function; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx.; /// This way, the step size can be controlled via the SetNpx() function.; /// If the function is unimodal or if its extrema are far apart, setting; /// the fNpx to a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:817,Testability,log,log,817,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the maximum value of the function; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx.; /// This way, the step size can be controlled via the SetNpx() function.; /// If the function is unimodal or if its extrema are far apart, setting; /// the fNpx to a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:870,Testability,log,log,870,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the maximum value of the function; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx.; /// This way, the step size can be controlled via the SetNpx() function.; /// If the function is unimodal or if its extrema are far apart, setting; /// the fNpx to a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:778,Testability,log,logx,778,"////////////////////////////////////////////////////////////////////////////////; /// Returns the minimum value of the function on the (xmin, xmax) interval; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX and TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:817,Testability,log,log,817,"////////////////////////////////////////////////////////////////////////////////; /// Returns the minimum value of the function on the (xmin, xmax) interval; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX and TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:870,Testability,log,log,870,"////////////////////////////////////////////////////////////////////////////////; /// Returns the minimum value of the function on the (xmin, xmax) interval; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX and TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:264,Integrability,interface,interface,264,"////////////////////////////////////////////////////////////////////////////////; /// Find the minimum of a function of whatever dimension.; /// While GetMinimum works only for 1D function , GetMinimumNDim works for all dimensions; /// since it uses the minimizer interface; /// vector x at beginning will contained the initial point, on exit will contain the result",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:10,Integrability,wrap,wrapper,10,"// create wrapper class from TF1 (cannot use Functor, t.b.i.)",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:46,Integrability,depend,depending,46,"// use range for step size or give some value depending on x if range is not defined",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:7,Modifiability,variab,variable,7,"// set variable names",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:812,Testability,log,logx,812,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the minimum value of the function; /// on the (xmin, xmax) interval; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:851,Testability,log,log,851,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the minimum value of the function; /// on the (xmin, xmax) interval; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:904,Testability,log,log,904,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the minimum value of the function; /// on the (xmin, xmax) interval; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:957,Testability,log,logx,957,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; /// in other words it can find the roots of the function when fy=0 and successive calls; /// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:996,Testability,log,log,996,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; /// in other words it can find the roots of the function when fy=0 and successive calls; /// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1049,Testability,log,log,1049,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X value corresponding to the function value fy for (xmin<x<xmax).; /// in other words it can find the roots of the function when fy=0 and successive calls; /// by changing the next call to [xmin+eps,xmax] where xmin is the previous root.; ///; /// Method:; /// First, the grid search is used to bracket the maximum; /// with the step size = (xmax-xmin)/fNpx. This way, the step size; /// can be controlled via the SetNpx() function. If the function is; /// unimodal or if its extrema are far apart, setting the fNpx to; /// a small value speeds the algorithm up many times.; /// Then, Brent's method is applied on the bracketed interval; /// epsilon (default = 1.E-10) controls the relative accuracy (if |x| > 1 ); /// and absolute (if |x| < 1) and maxiter (default = 100) controls the maximum number; /// of iteration of the Brent algorithm; /// If the flag logx is set the grid search is done in log step size; /// This is done automatically if the log scale is set in the current Pad; ///; /// NOTE: see also TF1::GetMaximumX, TF1::GetMinimumX",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:420,Modifiability,variab,variable,420,"////////////////////////////////////////////////////////////////////////////////; /// Compute Quantiles for density distribution of this function; ///; /// Quantile x_p of a probability distribution Function F is defined as; /// \f[; /// F(x_{p}) = \int_{xmin}^{x_{p}} f dx = p with 0 <= p <= 1.; /// \f]; /// For instance the median \f$ x_{\frac{1}{2}} \f$ of a distribution is defined as that value; /// of the random variable for which the distribution function equals 0.5:; /// \f[; /// F(x_{\frac{1}{2}}) = \prod(x < x_{\frac{1}{2}}) = \frac{1}{2}; /// \f]; ///; /// \param[in] n maximum size of array xp and size of array p; /// \param[out] xp array filled with n quantiles evaluated at p. Memory has to be preallocated by caller.; /// \param[in] p array of cumulative probabilities where quantiles should be evaluated.; /// It is assumed to contain at least n values.; /// \return n, the number of quantiles computed (same as input argument n); ///; /// Getting quantiles from two histograms and storing results in a TGraph,; /// a so-called QQ-plot; ///; /// TGraph *gr = new TGraph(nprob);; /// f1->GetQuantiles(nprob,gr->GetX(),p);; /// f2->GetQuantiles(nprob,gr->GetY(),p);; /// gr->Draw(""alp"");; ///; /// \author Eddy Offermann; /// \warning Function leads to undefined behavior if xp or p are null or; /// their size does not match with n",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:114,Energy Efficiency,efficient,efficient,114,"// LM: change to use fNpx; // should we change code to use a root finder ?; // It should be more precise and more efficient",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:12,Availability,toler,tolerance,12,"// LM use a tolerance 1.E-12 (integral precision)",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:198,Testability,log,log,198,"////////////////////////////////////////////////////////////////////////////////; ///; /// Compute the cumulative function at fNpx points between fXmin and fXmax.; /// Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:219,Testability,log,log,219,"////////////////////////////////////////////////////////////////////////////////; ///; /// Compute the cumulative function at fNpx points between fXmin and fXmax.; /// Option can be used to force a log scale (option = ""log""), linear (option = ""lin"") or automatic if empty.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3,Performance,perform,perform,3,"// perform a log binning if specified by user (option=""Log"") or if some conditions are met; // and the user explicitly does not specify a Linear binning option",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:13,Testability,log,log,13,"// perform a log binning if specified by user (option=""Log"") or if some conditions are met; // and the user explicitly does not specify a Linear binning option",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:55,Testability,Log,Log,55,"// perform a log binning if specified by user (option=""Log"") or if some conditions are met; // and the user explicitly does not specify a Linear binning option",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:660,Deployability,integrat,integrated,660,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:368,Integrability,depend,depending,368,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:660,Integrability,integrat,integrated,660,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:458,Testability,LOG,LOG,458,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:481,Testability,log,log,481,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1309,Testability,log,log,1309,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1331,Testability,log,log,1331,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1404,Testability,LOG,LOG,1404,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1502,Testability,log,log,1502,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape.; ///; /// @param rng Random number generator. By default (or when passing a nullptr) the global gRandom is used; /// @param option Option string which controls the binning used to compute the integral. Default mode is automatic depending of; /// xmax, xmin and Npx (function points).; /// Possible values are:; /// - ""LOG"" to force usage of log scale for tabulating the integral; /// - ""LIN"" to force usage of linear scale when tabulating the integral; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find the corresponding X value.; ///; /// The user can provide as optional parameter a Random number generator.; /// By default gRandom is used; ///; /// If the ratio fXmax/fXmin > fNpx the integral is tabulated in log scale in x; /// A log scale for the intergral is also always used if a user specifies the ""LOG"" option; /// Instead if a user requestes a ""LIN"" option the integral binning is never done in log scale; /// whatever the fXmax/fXmin ratio is; ///; /// Note that the parabolic approximation is very good as soon as the number of bins is greater than 50.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:222,Deployability,integrat,integrated,222,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape in [xmin,xmax]; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find; /// the corresponding X value.; ///; /// The parabolic approximation is very good as soon as the number; /// of bins is greater than 50.; ///; /// @param xmin minimum value for generated random numbers; /// @param xmax maximum value for generated random numbers; /// @param rng (optional) random number generator pointer; /// @param option (optional) : `LOG` or `LIN` to force the usage of a log or linear scale for computing the cumulative integral table; ///; /// IMPORTANT NOTE; ///; /// The integral of the function is computed at fNpx points. If the function; /// has sharp peaks, you should increase the number of points (SetNpx); /// such that the peak is correctly tabulated at several points.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:222,Integrability,integrat,integrated,222,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape in [xmin,xmax]; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find; /// the corresponding X value.; ///; /// The parabolic approximation is very good as soon as the number; /// of bins is greater than 50.; ///; /// @param xmin minimum value for generated random numbers; /// @param xmax maximum value for generated random numbers; /// @param rng (optional) random number generator pointer; /// @param option (optional) : `LOG` or `LIN` to force the usage of a log or linear scale for computing the cumulative integral table; ///; /// IMPORTANT NOTE; ///; /// The integral of the function is computed at fNpx points. If the function; /// has sharp peaks, you should increase the number of points (SetNpx); /// such that the peak is correctly tabulated at several points.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1016,Testability,LOG,LOG,1016,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape in [xmin,xmax]; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find; /// the corresponding X value.; ///; /// The parabolic approximation is very good as soon as the number; /// of bins is greater than 50.; ///; /// @param xmin minimum value for generated random numbers; /// @param xmax maximum value for generated random numbers; /// @param rng (optional) random number generator pointer; /// @param option (optional) : `LOG` or `LIN` to force the usage of a log or linear scale for computing the cumulative integral table; ///; /// IMPORTANT NOTE; ///; /// The integral of the function is computed at fNpx points. If the function; /// has sharp peaks, you should increase the number of points (SetNpx); /// such that the peak is correctly tabulated at several points.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1054,Testability,log,log,1054,"////////////////////////////////////////////////////////////////////////////////; /// Return a random number following this function shape in [xmin,xmax]; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// For each bin the integral is approximated by a parabola.; /// The parabola coefficients are stored as non persistent data members; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Evaluate the parabolic curve in the selected bin to find; /// the corresponding X value.; ///; /// The parabolic approximation is very good as soon as the number; /// of bins is greater than 50.; ///; /// @param xmin minimum value for generated random numbers; /// @param xmax maximum value for generated random numbers; /// @param rng (optional) random number generator pointer; /// @param option (optional) : `LOG` or `LIN` to force the usage of a log or linear scale for computing the cumulative integral table; ///; /// IMPORTANT NOTE; ///; /// The integral of the function is computed at fNpx points. If the function; /// has sharp peaks, you should increase the number of points (SetNpx); /// such that the peak is correctly tabulated at several points.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:298,Availability,error,errors,298,"////////////////////////////////////////////////////////////////////////////////; /// Compute the gradient (derivative) wrt a parameter ipar; ///; /// \param ipar index of parameter for which the derivative is computed; /// \param x point, where the derivative is computed; /// \param eps - if the errors of parameters have been computed, the step used in; /// numerical differentiation is eps*parameter_error.; ///; /// if the errors have not been computed, step=eps is used; /// default value of eps = 0.01; /// Method is the same as in Derivative() function; ///; /// If a parameter is fixed, the gradient on this parameter = 0",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:428,Availability,error,errors,428,"////////////////////////////////////////////////////////////////////////////////; /// Compute the gradient (derivative) wrt a parameter ipar; ///; /// \param ipar index of parameter for which the derivative is computed; /// \param x point, where the derivative is computed; /// \param eps - if the errors of parameters have been computed, the step used in; /// numerical differentiation is eps*parameter_error.; ///; /// if the errors have not been computed, step=eps is used; /// default value of eps = 0.01; /// Method is the same as in Derivative() function; ///; /// If a parameter is fixed, the gradient on this parameter = 0",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:534,Availability,error,errors,534,"////////////////////////////////////////////////////////////////////////////////; /// Compute the gradient wrt parameters; /// If the TF1 object is based on a formula expression (TFormula); /// and TFormula::GenerateGradientPar() has been successfully called; /// automatic differentiation using CLAD is used instead of the default; /// numerical differentiation; ///; /// \param x point, were the gradient is computed; /// \param grad used to return the computed gradient, assumed to be of at least fNpar size; /// \param eps if the errors of parameters have been computed, the step used in; /// numerical differentiation is eps*parameter_error.; ///; /// if the errors have not been computed, step=eps is used; /// default value of eps = 0.01; /// Method is the same as in Derivative() function; ///; /// If a parameter is fixed, the gradient on this parameter = 0",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:664,Availability,error,errors,664,"////////////////////////////////////////////////////////////////////////////////; /// Compute the gradient wrt parameters; /// If the TF1 object is based on a formula expression (TFormula); /// and TFormula::GenerateGradientPar() has been successfully called; /// automatic differentiation using CLAD is used instead of the default; /// numerical differentiation; ///; /// \param x point, were the gradient is computed; /// \param grad used to return the computed gradient, assumed to be of at least fNpar size; /// \param eps if the errors of parameters have been computed, the step used in; /// numerical differentiation is eps*parameter_error.; ///; /// if the errors have not been computed, step=eps is used; /// default value of eps = 0.01; /// Method is the same as in Derivative() function; ///; /// If a parameter is fixed, the gradient on this parameter = 0",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:194,Availability,toler,tolerance,194,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:227,Deployability,integrat,integrator,227,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:261,Deployability,Integrat,IntegratorOneDimOptions,261,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:369,Deployability,integrat,integrator,369,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:605,Deployability,integrat,integration,605,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:643,Deployability,integrat,integration,643,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:692,Deployability,Integrat,IntegratorOneDimOptions,692,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:738,Deployability,Integrat,IntegratorName,738,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:766,Deployability,integrat,integrator,766,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1160,Deployability,integrat,integrators,1160,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1211,Deployability,install,installed,1211,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1745,Deployability,integrat,integration,1745,"ar : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new double[np];; /// double *w=new double[np];; /// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; /// double r3 = g->IntegralFast(np,x,w,0,5);; /// double r4 = g->IntegralFast(np,x,w,0,1000);; /// double r5 = g->IntegralFast(np,x,w,0,10000);; /// double r6 = g->IntegralFast(np,x,w,0,100000);; /// printf(""g->Integral(0,5) = %g\n"",r1);; /// printf(""g->Integral(0,1000) = %g\n"",r2);; /// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; /// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; /// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; /// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; /// delete [] x;; /// delete [] w;; /// }; /// ~~~; ///; /// This example produces the following results:; ///; /// ~~~ {.cpp}; /// g->Integral(0,5) = 1.25331; /// g->Integral(0,1000) = 1.25319; /// g->IntegralFast(n,x,w,0,5) = 1.25331; /// g->IntegralFast(n,x,w,0,1000) = 1.25331; /// g->IntegralFast(n,x,w,0,10000) = 1.25331; /// g->IntegralFast(n,x,w,0,100000)= 1.253; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1801,Deployability,integrat,integrate,1801,"ar : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new double[np];; /// double *w=new double[np];; /// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; /// double r3 = g->IntegralFast(np,x,w,0,5);; /// double r4 = g->IntegralFast(np,x,w,0,1000);; /// double r5 = g->IntegralFast(np,x,w,0,10000);; /// double r6 = g->IntegralFast(np,x,w,0,100000);; /// printf(""g->Integral(0,5) = %g\n"",r1);; /// printf(""g->Integral(0,1000) = %g\n"",r2);; /// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; /// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; /// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; /// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; /// delete [] x;; /// delete [] w;; /// }; /// ~~~; ///; /// This example produces the following results:; ///; /// ~~~ {.cpp}; /// g->Integral(0,5) = 1.25331; /// g->Integral(0,1000) = 1.25319; /// g->IntegralFast(n,x,w,0,5) = 1.25331; /// g->IntegralFast(n,x,w,0,1000) = 1.25331; /// g->IntegralFast(n,x,w,0,10000) = 1.25331; /// g->IntegralFast(n,x,w,0,100000)= 1.253; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:402,Energy Efficiency,adapt,adaptive,402,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:905,Energy Efficiency,Adapt,Adaptive,905,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:946,Energy Efficiency,adapt,adaptive,946,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:975,Energy Efficiency,Adapt,AdaptiveSingular,975,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1024,Energy Efficiency,adapt,adaptive,1024,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1111,Energy Efficiency,adapt,adaptive,1111,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:227,Integrability,integrat,integrator,227,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:261,Integrability,Integrat,IntegratorOneDimOptions,261,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:369,Integrability,integrat,integrator,369,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:605,Integrability,integrat,integration,605,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:643,Integrability,integrat,integration,643,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:692,Integrability,Integrat,IntegratorOneDimOptions,692,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:738,Integrability,Integrat,IntegratorName,738,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:766,Integrability,integrat,integrator,766,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1160,Integrability,integrat,integrators,1160,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1745,Integrability,integrat,integration,1745,"ar : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new double[np];; /// double *w=new double[np];; /// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; /// double r3 = g->IntegralFast(np,x,w,0,5);; /// double r4 = g->IntegralFast(np,x,w,0,1000);; /// double r5 = g->IntegralFast(np,x,w,0,10000);; /// double r6 = g->IntegralFast(np,x,w,0,100000);; /// printf(""g->Integral(0,5) = %g\n"",r1);; /// printf(""g->Integral(0,1000) = %g\n"",r2);; /// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; /// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; /// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; /// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; /// delete [] x;; /// delete [] w;; /// }; /// ~~~; ///; /// This example produces the following results:; ///; /// ~~~ {.cpp}; /// g->Integral(0,5) = 1.25331; /// g->Integral(0,1000) = 1.25319; /// g->IntegralFast(n,x,w,0,5) = 1.25331; /// g->IntegralFast(n,x,w,0,1000) = 1.25331; /// g->IntegralFast(n,x,w,0,10000) = 1.25331; /// g->IntegralFast(n,x,w,0,100000)= 1.253; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1801,Integrability,integrat,integrate,1801,"ar : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new double[np];; /// double *w=new double[np];; /// g->CalcGaussLegendreSamplingPoints(np,x,w,1e-15);; /// double r3 = g->IntegralFast(np,x,w,0,5);; /// double r4 = g->IntegralFast(np,x,w,0,1000);; /// double r5 = g->IntegralFast(np,x,w,0,10000);; /// double r6 = g->IntegralFast(np,x,w,0,100000);; /// printf(""g->Integral(0,5) = %g\n"",r1);; /// printf(""g->Integral(0,1000) = %g\n"",r2);; /// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; /// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; /// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; /// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; /// delete [] x;; /// delete [] w;; /// }; /// ~~~; ///; /// This example produces the following results:; ///; /// ~~~ {.cpp}; /// g->Integral(0,5) = 1.25331; /// g->Integral(0,1000) = 1.25319; /// g->IntegralFast(n,x,w,0,5) = 1.25331; /// g->IntegralFast(n,x,w,0,1000) = 1.25331; /// g->IntegralFast(n,x,w,0,10000) = 1.25331; /// g->IntegralFast(n,x,w,0,100000)= 1.253; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:402,Modifiability,adapt,adaptive,402,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:905,Modifiability,Adapt,Adaptive,905,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:946,Modifiability,adapt,adaptive,946,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:975,Modifiability,Adapt,AdaptiveSingular,975,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1024,Modifiability,adapt,adaptive,1024,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1111,Modifiability,adapt,adaptive,1111,"////////////////////////////////////////////////////////////////////////////////; /// Return Integral of function between a and b using the given parameter values and; /// relative and absolute tolerance.; ///; /// The default integrator defined in ROOT::Math::IntegratorOneDimOptions::DefaultIntegrator() is used; /// If ROOT contains the MathMore library the default integrator is set to be; /// the adaptive ROOT::Math::GSLIntegrator (based on QUADPACK) or otherwise the; /// ROOT::Math::GaussIntegrator is used; /// See the reference documentation of these classes for more information about the; /// integration algorithms; /// To change integration algorithm just do :; /// ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegrator(IntegratorName);; /// Valid integrator names are:; /// - Gauss : for ROOT::Math::GaussIntegrator; /// - GaussLegendre : for ROOT::Math::GaussLegendreIntegrator; /// - Adaptive : for ROOT::Math::GSLIntegrator adaptive method (QAG); /// - AdaptiveSingular : for ROOT::Math::GSLIntegrator adaptive singular method (QAGS); /// - NonAdaptive : for ROOT::Math::GSLIntegrator non adaptive (QNG); ///; /// In order to use the GSL integrators one needs to have the MathMore library installed; ///; /// Note 1:; ///; /// Values of the function f(x) at the interval end-points A and B are not; /// required. The subprogram may therefore be used when these values are; /// undefined.; ///; /// Note 2:; ///; /// Instead of TF1::Integral, you may want to use the combination of; /// TF1::CalcGaussLegendreSamplingPoints and TF1::IntegralFast.; /// See an example with the following script:; ///; /// ~~~ {.cpp}; /// void gint() {; /// TF1 *g = new TF1(""g"",""gaus"",-5,5);; /// g->SetParameters(1,0,1);; /// //default gaus integration method uses 6 points; /// //not suitable to integrate on a large domain; /// double r1 = g->Integral(0,5);; /// double r2 = g->Integral(0,1000);; ///; /// //try with user directives computing more points; /// Int_t np = 1000;; /// double *x=new",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:93,Availability,Error,Error,93,"////////////////////////////////////////////////////////////////////////////////; /// Return Error on Integral of a parametric function between a and b; /// due to the parameter uncertainties and their covariance matrix from the fit.; /// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dim",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1040,Availability,error,error,1040,"////////////////////////////////////////////////////////////////////////////////; /// Return Error on Integral of a parametric function between a and b; /// due to the parameter uncertainties and their covariance matrix from the fit.; /// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dim",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1445,Availability,error,error,1445," input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1673,Availability,error,error,1673," input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1451,Integrability,message,message,1451," input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1650,Integrability,rout,routine,1650," input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:458,Performance,perform,performed,458,"////////////////////////////////////////////////////////////////////////////////; /// Return Error on Integral of a parametric function between a and b; /// due to the parameter uncertainties and their covariance matrix from the fit.; /// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dim",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1309,Performance,multi-thread,multi-threading,1309," input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:93,Availability,Error,Error,93,"////////////////////////////////////////////////////////////////////////////////; /// Return Error on Integral of a parametric function with dimension larger than one; /// between a[] and b[] due to the parameters uncertainties.; /// For a TF1 with dimension larger than 1 (for example a TF2 or TF3); /// TF1::IntegralMultiple is used for the integral calculation; ///; /// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect res",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1177,Availability,error,error,1177,"of a parametric function with dimension larger than one; /// between a[] and b[] due to the parameters uncertainties.; /// For a TF1 with dimension larger than 1 (for example a TF2 or TF3); /// TF1::IntegralMultiple is used for the integral calculation; ///; /// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full ",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1582,Availability,error,error,1582,"nput a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1810,Availability,error,error,1810,"nput a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1588,Integrability,message,message,1588,"nput a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1787,Integrability,rout,routine,1787,"nput a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:593,Performance,perform,performed,593,"////////////////////////////////////////////////////////////////////////////////; /// Return Error on Integral of a parametric function with dimension larger than one; /// between a[] and b[] due to the parameters uncertainties.; /// For a TF1 with dimension larger than 1 (for example a TF2 or TF3); /// TF1::IntegralMultiple is used for the integral calculation; ///; /// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect res",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1446,Performance,multi-thread,multi-threading,1446,"nput a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; /// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; /// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:130,Integrability,interface,interface,130,"////////////////////////////////////////////////////////////////////////////////; /// See more general prototype below.; /// This interface kept for back compatibility; /// It is recommended to use the other interface where one can specify also epsabs and the maximum number of; /// points",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:208,Integrability,interface,interface,208,"////////////////////////////////////////////////////////////////////////////////; /// See more general prototype below.; /// This interface kept for back compatibility; /// It is recommended to use the other interface where one can specify also epsabs and the maximum number of; /// points",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:356,Deployability,integrat,integration,356,"////////////////////////////////////////////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not t",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:656,Deployability,integrat,integration,656,"////////////////////////////////////////////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not t",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1649,Deployability,Integrat,IntegratorMultiDimOptions,1649,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1717,Deployability,integrat,integrators,1717,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1750,Deployability,integrat,integrators,1750,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1769,Deployability,integrat,integrators,1769,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1897,Deployability,integrat,integration,1897,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1447,Energy Efficiency,adapt,adaptive,1447,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1516,Energy Efficiency,Adapt,AdaptiveIntegratorMultiDim,1516,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:356,Integrability,integrat,integration,356,"////////////////////////////////////////////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not t",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:656,Integrability,integrat,integration,656,"////////////////////////////////////////////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not t",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1649,Integrability,Integrat,IntegratorMultiDimOptions,1649,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1717,Integrability,integrat,integrators,1717,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1750,Integrability,integrat,integrators,1750,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1769,Integrability,integrat,integrators,1769,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1897,Integrability,integrat,integration,1897,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1447,Modifiability,adapt,adaptive,1447,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1516,Modifiability,Adapt,AdaptiveIntegratorMultiDim,1516,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1036,Performance,perform,performed,1036,"///////////////////////////////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too ",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1167,Performance,perform,performed,1167,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:19,Availability,toler,tolerance,19,"// use default abs tolerance = relative tolerance",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:40,Availability,toler,tolerance,40,"// use default abs tolerance = relative tolerance",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:46,Testability,log,log,46,"// This can happen when switching from lin to log scale.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3,Performance,Optimiz,Optimize,3,"// Optimize the computation of the scale in Y in case the min/max of the; // function oscillate around a constant value",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:6,Testability,log,logx,6,"// If logx, we must bin in logx and not in x; // otherwise in case of several decades, one gets wrong results.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:27,Testability,log,logx,27,"// If logx, we must bin in logx and not in x; // otherwise in case of several decades, one gets wrong results.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3,Deployability,update,update,3,"// update saved histogram in case it was deleted or if it is the first time the method is called; // for example when called from TF1::GetHistogram()",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:86,Deployability,Release,Release,86,"////////////////////////////////////////////////////////////////////////////////; /// Release parameter number ipar during a fit operation.; /// After releasing it, the parameter; /// can vary freely in the fit. The parameter limits are reset to 0,0.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:165,Security,access,accessed,165,"////////////////////////////////////////////////////////////////////////////////; /// Static function setting the current function.; /// the current function may be accessed in static C-like functions; /// when fitting or painting a function.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:137,Availability,error,errors,137,"////////////////////////////////////////////////////////////////////////////////; /// Set the result from the fit; /// parameter values, errors, chi2, etc...; /// Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed; /// This is useful in the case of a combined fit with different functions, and the FitResult contains the global result; /// By default it is assume that indpar = {0,1,2,....,fNpar-1}.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:11,Availability,error,errors,11,"// in case errors are not present do not set them",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:13,Performance,cache,cached,13,"//invalidate cached integral since parameters have changed",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error for parameter number ipar",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:90,Availability,error,errors,90,"////////////////////////////////////////////////////////////////////////////////; /// Set errors for all active parameters; /// when calling this function, the array errors must have at least fNpar values",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:166,Availability,error,errors,166,"////////////////////////////////////////////////////////////////////////////////; /// Set errors for all active parameters; /// when calling this function, the array errors must have at least fNpar values",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:17,Deployability,update,updates,17,"// automatically updates sub-functions",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3,Usability,clear,clear,3,"// clear vector contents",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:43,Safety,safe,safe,43,"// should not be necessary, but just to be safe",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:180,Testability,test,tested,180,"////////////////////////////////////////////////////////////////////////////////; /// Static function to set the global flag to reject points; /// the fgRejectPoint global flag is tested by all fit functions; /// if TRUE the point is not included in the fit.; /// This flag can be set by a user in a fitting function.; /// The fgRejectPoint flag is reset by the TH1 and TGraph fitting functions.",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:3,Integrability,wrap,wrapped,3,"// wrapped function in interface for integral calculation; // using abs value of integral",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:23,Integrability,interface,interface,23,"// wrapped function in interface for integral calculation; // using abs value of integral",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:103,Deployability,integrat,integrator,103,"// calculate now integral of x^n f(x); // wrapped the member function EvalNum in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:42,Integrability,wrap,wrapped,42,"// calculate now integral of x^n f(x); // wrapped the member function EvalNum in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:81,Integrability,interface,interface,81,"// calculate now integral of x^n f(x); // wrapped the member function EvalNum in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:103,Integrability,integrat,integrator,103,"// calculate now integral of x^n f(x); // wrapped the member function EvalNum in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:105,Deployability,integrat,integrator,105,"// calculate now integral of xf(x); // wrapped the member function EvalFirstMom in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:39,Integrability,wrap,wrapped,39,"// calculate now integral of xf(x); // wrapped the member function EvalFirstMom in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:83,Integrability,interface,interface,83,"// calculate now integral of xf(x); // wrapped the member function EvalFirstMom in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:105,Integrability,integrat,integrator,105,"// calculate now integral of xf(x); // wrapped the member function EvalFirstMom in interface required by integrator using the functor class",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:40,Integrability,wrap,wrapper,40,"// use different mean value in function wrapper",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:263,Integrability,interface,interface,263,"//______________________________________________________________________________; // some useful static utility functions to compute sampling points for IntegralFast; ////////////////////////////////////////////////////////////////////////////////; /// Type safe interface (static method); /// The number of sampling points are taken from the TGraph",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:258,Safety,safe,safe,258,"//______________________________________________________________________________; // some useful static utility functions to compute sampling points for IntegralFast; ////////////////////////////////////////////////////////////////////////////////; /// Type safe interface (static method); /// The number of sampling points are taken from the TGraph",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:96,Integrability,interface,interface,96,"////////////////////////////////////////////////////////////////////////////////; /// Type safe interface (static method); /// A TGraph is created with new with num points and the pointer to the; /// graph is returned by the function. It is the responsibility of the; /// user to delete the object.; /// if num is invalid (<=0) NULL is returned",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:91,Safety,safe,safe,91,"////////////////////////////////////////////////////////////////////////////////; /// Type safe interface (static method); /// A TGraph is created with new with num points and the pointer to the; /// graph is returned by the function. It is the responsibility of the; /// user to delete the object.; /// if num is invalid (<=0) NULL is returned",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:108,Integrability,interface,interface,108,"////////////////////////////////////////////////////////////////////////////////; /// Type: unsafe but fast interface filling the arrays x and w (static method); ///; /// Given the number of sampling points this routine fills the arrays x and w; /// of length num, containing the abscissa and weight of the Gauss-Legendre; /// n-point quadrature formula.; ///; /// Gauss-Legendre:; /** \f[; W(x)=1 -1<x<1 \\; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; \f]; **/; /// num is the number of sampling points (>0); /// x and w are arrays of size num; /// eps is the relative precision; ///; /// If num<=0 or eps<=0 no action is done.; ///; /// Reference: Numerical Recipes in C, Second Edition",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:212,Integrability,rout,routine,212,"////////////////////////////////////////////////////////////////////////////////; /// Type: unsafe but fast interface filling the arrays x and w (static method); ///; /// Given the number of sampling points this routine fills the arrays x and w; /// of length num, containing the abscissa and weight of the Gauss-Legendre; /// n-point quadrature formula.; ///; /// Gauss-Legendre:; /** \f[; W(x)=1 -1<x<1 \\; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; \f]; **/; /// num is the number of sampling points (>0); /// x and w are arrays of size num; /// eps is the relative precision; ///; /// If num<=0 or eps<=0 no action is done.; ///; /// Reference: Numerical Recipes in C, Second Edition",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:92,Safety,unsafe,unsafe,92,"////////////////////////////////////////////////////////////////////////////////; /// Type: unsafe but fast interface filling the arrays x and w (static method); ///; /// Given the number of sampling points this routine fills the arrays x and w; /// of length num, containing the abscissa and weight of the Gauss-Legendre; /// n-point quadrature formula.; ///; /// Gauss-Legendre:; /** \f[; W(x)=1 -1<x<1 \\; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; \f]; **/; /// num is the number of sampling points (>0); /// x and w are arrays of size num; /// eps is the relative precision; ///; /// If num<=0 or eps<=0 no action is done.; ///; /// Reference: Numerical Recipes in C, Second Edition",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:194,Energy Efficiency,efficient,efficient,194,"/** \class TF1Parameters; TF1 Parameters class; */; ////////////////////////////////////////////////////////////////////////////////; /// Returns the parameter number given a name; /// not very efficient but list of parameters is typically small; /// could use a map if needed",MatchSource.CODE_COMMENT,hist/hist/src/TF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF12.cxx:311,Deployability,update,updated,311,"////////////////////////////////////////////////////////////////////////////////; /// Set the value of the constant for the TF2; ///; /// constant in X when projecting along Y; /// constant in Y when projecting along X; /// The function title is set to include the value of the constant; /// The current pad is updated",MatchSource.CODE_COMMENT,hist/hist/src/TF12.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF12.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:243,Availability,avail,available,243,"/** \class TF1Convolution; \ingroup Functions; \brief Class wrapping convolution of two functions. Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$. The convolution is performed by default using FFTW if it is available .; One can pass optionally the range of the convolution (by default the first function range is used).; Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); a spill over will occur on the other side (e.g right side).; If no function range is given by default the function1 range + 10% is used; One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; */",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:60,Integrability,wrap,wrapping,60,"/** \class TF1Convolution; \ingroup Functions; \brief Class wrapping convolution of two functions. Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$. The convolution is performed by default using FFTW if it is available .; One can pass optionally the range of the convolution (by default the first function range is used).; Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); a spill over will occur on the other side (e.g right side).; If no function range is given by default the function1 range + 10% is used; One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; */",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:105,Integrability,wrap,wrapping,105,"/** \class TF1Convolution; \ingroup Functions; \brief Class wrapping convolution of two functions. Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$. The convolution is performed by default using FFTW if it is available .; One can pass optionally the range of the convolution (by default the first function range is used).; Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); a spill over will occur on the other side (e.g right side).; If no function range is given by default the function1 range + 10% is used; One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; */",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:202,Performance,perform,performed,202,"/** \class TF1Convolution; \ingroup Functions; \brief Class wrapping convolution of two functions. Class wrapping convolution of two functions: evaluation of \f$\int f(x)g(x-t)dx\f$. The convolution is performed by default using FFTW if it is available .; One can pass optionally the range of the convolution (by default the first function range is used).; Note that when using Discrete Fourier Transform (as FFTW), it is a circular transform, so the functions should be; approximately zero at the end of the range. If they are significantly different than zero on one side (e.g. the left side); a spill over will occur on the other side (e.g right side).; If no function range is given by default the function1 range + 10% is used; One should use also a not too small number of points for the DFT (a minimum of 1000). By default 10000 points are used.; */",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:40,Availability,error,error,40,"// functions must be 1d- if not flag an error",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:143,Modifiability,variab,variable,143,"////////////////////////////////////////////////////////////////////////////////; /// Copy constructor (necessary to hold unique_ptr as member variable).",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:86,Performance,Perform,Perform,86,"////////////////////////////////////////////////////////////////////////////////; /// Perform the FFT of the two functions.",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:86,Performance,Perform,Perform,86,"////////////////////////////////////////////////////////////////////////////////; /// Perform FFT convolution.",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:86,Performance,Perform,Perform,86,"////////////////////////////////////////////////////////////////////////////////; /// Perform numerical convolution.; ///",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:23,Performance,cache,cache,23,"/// Could in principle cache the integral in a Graph as it is done for the FFTW",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:194,Safety,avoid,avoid,194,"////////////////////////////////////////////////////////////////////////////////; /// Set the fraction of extra range used when doing an FFT convolution.; /// The extra range is often needed to avoid mirroring effect of the resulting convolution; /// function at the borders.; /// By default an extra range of 0.1 is used.",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:258,Modifiability,extend,extended,258,"////////////////////////////////////////////////////////////////////////////////; /// Set the actual range used for the convolution.; /// In case a or b are -inf or +inf and FFT convolution is used, then the; /// range of the first function will be used and extended by the default extra range fraction.",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update the two component functions of the convolution.",MatchSource.CODE_COMMENT,hist/hist/src/TF1Convolution.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:139,Availability,error,error,139,"// calculate the eror on an integral from a to b of a parametetric function f when the parameters; // are estimated from a fit and have an error represented by the covariance matrix of the fit.; // The latest fit result is used; // need to create the gradient functions w.r.t to the parameters; // loop on all parameters",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:14,Availability,error,errors,14,"// check that errors are provided",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:43,Availability,error,errors,43,"// loop on the parameter and calculate the errors",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:7,Availability,toler,tolerance,7,"// use tolerance factor of 10 smaller than parameter errors",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:53,Availability,error,errors,53,"// use tolerance factor of 10 smaller than parameter errors",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:24,Availability,error,error,24,"// check that parameter error is not zero - otherwise skip it; // should check the limits",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:55,Deployability,integrat,integration,55,"//if (ifail) Warning(""TF1Helper::IntegralError"",""n-dim integration failed code=%d I = %g, relerr =%g, ncall = %d, maxpts = %d, epsrel = %g, epsabs = %g, "",ifail,integral,relerr,nfnevl,maxpts,epsrel,epsabs);",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:55,Integrability,integrat,integration,55,"//if (ifail) Warning(""TF1Helper::IntegralError"",""n-dim integration failed code=%d I = %g, relerr =%g, ncall = %d, maxpts = %d, epsrel = %g, epsabs = %g, "",ifail,integral,relerr,nfnevl,maxpts,epsrel,epsabs);",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:176,Availability,error,error,176,"// std::cout << "" ipar "" << i << "" sigma "" << sqrt(covMatrix(i,i)) << "" rel "" << sqrt(covMatrix(i,i))/std::abs(func->GetParameter(i)) << "" integral "" << integral << "" +/- "" << error << "" "" <<; // error/std::abs(integral) << std::endl;; // estimate numerical error (neglect correlations)",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:196,Availability,error,error,196,"// std::cout << "" ipar "" << i << "" sigma "" << sqrt(covMatrix(i,i)) << "" rel "" << sqrt(covMatrix(i,i))/std::abs(func->GetParameter(i)) << "" integral "" << integral << "" +/- "" << error << "" "" <<; // error/std::abs(integral) << std::endl;; // estimate numerical error (neglect correlations)",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:258,Availability,error,error,258,"// std::cout << "" ipar "" << i << "" sigma "" << sqrt(covMatrix(i,i)) << "" rel "" << sqrt(covMatrix(i,i))/std::abs(func->GetParameter(i)) << "" integral "" << integral << "" +/- "" << error << "" "" <<; // error/std::abs(integral) << std::endl;; // estimate numerical error (neglect correlations)",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:25,Availability,error,error,25,"//std::cout << ""integral error is "" << result << "" num error is "" << numError << std::endl;",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx:55,Availability,error,error,55,"//std::cout << ""integral error is "" << result << "" num error is "" << numError << std::endl;",MatchSource.CODE_COMMENT,hist/hist/src/TF1Helper.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Helper.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1NormSum.cxx:143,Modifiability,variab,variable,143,"////////////////////////////////////////////////////////////////////////////////; /// Copy constructor (necessary to hold unique_ptr as member variable)",MatchSource.CODE_COMMENT,hist/hist/src/TF1NormSum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1NormSum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1NormSum.cxx:3,Deployability,update,update,3,"// update function integral if not equal",MatchSource.CODE_COMMENT,hist/hist/src/TF1NormSum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1NormSum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1NormSum.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update the component functions of the normalized sum",MatchSource.CODE_COMMENT,hist/hist/src/TF1NormSum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1NormSum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:148,Modifiability,variab,variables,148,"/** \class TF2; \ingroup Functions; \brief A 2-Dim function with parameters. The following types of functions can be created:. 1. [Expression using variables x and y](\ref TF2a); 2. [Expression using a user defined function](\ref TF2b); 3. [Lambda Expression with x and y variables and parameters](\ref TF2c). \anchor TF2a; ### Expression using variables x and y. Begin_Macro (source); {; auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; f2->Draw();; }; End_Macro. \anchor TF2b; ### Expression using a user defined function. ~~~~{.cpp}; Double_t func(Double_t *val, Double_t *par); {; Float_t x = val[0];; Float_t y = val[1];; Double_t f = x*x-y*y;; return f;; }. void fplot(); {; auto f = new TF2(""f"",func,-1,1,-1,1);; f->Draw(""surf1"");; }; ~~~~. \anchor TF2c; ### Lambda Expression with x and y variables and parameters. ~~~~{.cpp}; root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); (TF2 &) Name: f2 Title: f2; root [1] f2.SetParameter(0, 1.); root [2] f2.Eval(1., 2.); (double) 3.0000000; ~~~~. See TF1 class for the list of functions formats; */; ////////////////////////////////////////////////////////////////////////////////; /// TF2 default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:272,Modifiability,variab,variables,272,"/** \class TF2; \ingroup Functions; \brief A 2-Dim function with parameters. The following types of functions can be created:. 1. [Expression using variables x and y](\ref TF2a); 2. [Expression using a user defined function](\ref TF2b); 3. [Lambda Expression with x and y variables and parameters](\ref TF2c). \anchor TF2a; ### Expression using variables x and y. Begin_Macro (source); {; auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; f2->Draw();; }; End_Macro. \anchor TF2b; ### Expression using a user defined function. ~~~~{.cpp}; Double_t func(Double_t *val, Double_t *par); {; Float_t x = val[0];; Float_t y = val[1];; Double_t f = x*x-y*y;; return f;; }. void fplot(); {; auto f = new TF2(""f"",func,-1,1,-1,1);; f->Draw(""surf1"");; }; ~~~~. \anchor TF2c; ### Lambda Expression with x and y variables and parameters. ~~~~{.cpp}; root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); (TF2 &) Name: f2 Title: f2; root [1] f2.SetParameter(0, 1.); root [2] f2.Eval(1., 2.); (double) 3.0000000; ~~~~. See TF1 class for the list of functions formats; */; ////////////////////////////////////////////////////////////////////////////////; /// TF2 default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:345,Modifiability,variab,variables,345,"/** \class TF2; \ingroup Functions; \brief A 2-Dim function with parameters. The following types of functions can be created:. 1. [Expression using variables x and y](\ref TF2a); 2. [Expression using a user defined function](\ref TF2b); 3. [Lambda Expression with x and y variables and parameters](\ref TF2c). \anchor TF2a; ### Expression using variables x and y. Begin_Macro (source); {; auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; f2->Draw();; }; End_Macro. \anchor TF2b; ### Expression using a user defined function. ~~~~{.cpp}; Double_t func(Double_t *val, Double_t *par); {; Float_t x = val[0];; Float_t y = val[1];; Double_t f = x*x-y*y;; return f;; }. void fplot(); {; auto f = new TF2(""f"",func,-1,1,-1,1);; f->Draw(""surf1"");; }; ~~~~. \anchor TF2c; ### Lambda Expression with x and y variables and parameters. ~~~~{.cpp}; root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); (TF2 &) Name: f2 Title: f2; root [1] f2.SetParameter(0, 1.); root [2] f2.Eval(1., 2.); (double) 3.0000000; ~~~~. See TF1 class for the list of functions formats; */; ////////////////////////////////////////////////////////////////////////////////; /// TF2 default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:804,Modifiability,variab,variables,804,"/** \class TF2; \ingroup Functions; \brief A 2-Dim function with parameters. The following types of functions can be created:. 1. [Expression using variables x and y](\ref TF2a); 2. [Expression using a user defined function](\ref TF2b); 3. [Lambda Expression with x and y variables and parameters](\ref TF2c). \anchor TF2a; ### Expression using variables x and y. Begin_Macro (source); {; auto f2 = new TF2(""f2"",""sin(x)*sin(y)/(x*y)"",0,5,0,5);; f2->Draw();; }; End_Macro. \anchor TF2b; ### Expression using a user defined function. ~~~~{.cpp}; Double_t func(Double_t *val, Double_t *par); {; Float_t x = val[0];; Float_t y = val[1];; Double_t f = x*x-y*y;; return f;; }. void fplot(); {; auto f = new TF2(""f"",func,-1,1,-1,1);; f->Draw(""surf1"");; }; ~~~~. \anchor TF2c; ### Lambda Expression with x and y variables and parameters. ~~~~{.cpp}; root [0] TF2 f2(""f2"", [](double* x, double*p) { return x[0] + x[1] * p[0]; }, 0., 1., 0., 1., 1); (TF2 &) Name: f2 Title: f2; root [1] f2.SetParameter(0, 1.); root [2] f2.Eval(1., 2.); (double) 3.0000000; ~~~~. See TF1 class for the list of functions formats; */; ////////////////////////////////////////////////////////////////////////////////; /// TF2 default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:465,Performance,perform,performed,465,"////////////////////////////////////////////////////////////////////////////////; /// Return minimum/maximum value of the function; ///; /// To find the minimum on a range, first set this range via the SetRange function.; /// If a vector x of coordinate is passed it will be used as starting point for the minimum.; /// In addition on exit x will contain the coordinate values at the minimuma; ///; /// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided into fNpx and fNpy; /// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; /// by SetNpx and SetNpy functions; ///; /// Then, a minimization is used with starting values found by the grid search; /// The minimizer algorithm used (by default Minuit) can be changed by callinga; /// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); /// Other option for the minimizer can be set using the static method of the MinimizerOptions class",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:346,Performance,perform,performed,346,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X and Y values corresponding to the minimum value of the function; ///; /// Return the minimum value of the function; /// To find the minimum on a range, first set this range via the SetRange function; ///; /// Method:; /// First, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided into fNpx and fNpy; /// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; /// by SetNpx and SetNpy functions; /// Then, a minimization is used with starting values found by the grid search; /// The minimizer algorithm used (by default Minuit) can be changed by callinga; /// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); /// Other option for the minimizer can be set using the static method of the MinimizerOptions class; ///; /// Note that this method will always do first a grid search in contrast to GetMinimum",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:459,Performance,perform,performed,459,"////////////////////////////////////////////////////////////////////////////////; /// Return minimum/maximum value of the function; ///; /// To find the minimum on a range, first set this range via the SetRange function; /// If a vector x of coordinate is passed it will be used as starting point for the minimum.; /// In addition on exit x will contain the coordinate values at the minimuma; /// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided into fNpx and fNpy; /// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; /// by SetNpx and SetNpy functions; /// Then, a minimization is used with starting values found by the grid search; /// The minimizer algorithm used (by default Minuit) can be changed by callinga; /// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); /// Other option for the minimizer can be set using the static method of the MinimizerOptions class",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:201,Deployability,integrat,integrated,201,"////////////////////////////////////////////////////////////////////////////////; /// Return 2 random numbers following this function shape; ///; /// The distribution contained in this TF2 function is integrated; /// over the cell contents.; /// It is normalized to 1.; /// Getting the two random numbers implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which cell in the normalized integral r1 corresponds to; /// - make a linear interpolation in the returned cell; ///; ///; /// IMPORTANT NOTE; ///; /// The integral of the function is computed at fNpx * fNpy points.; /// If the function has sharp peaks, you should increase the number of; /// points (SetNpx, SetNpy) such that the peak is correctly tabulated; /// at several points.",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:201,Integrability,integrat,integrated,201,"////////////////////////////////////////////////////////////////////////////////; /// Return 2 random numbers following this function shape; ///; /// The distribution contained in this TF2 function is integrated; /// over the cell contents.; /// It is normalized to 1.; /// Getting the two random numbers implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which cell in the normalized integral r1 corresponds to; /// - make a linear interpolation in the returned cell; ///; ///; /// IMPORTANT NOTE; ///; /// The integral of the function is computed at fNpx * fNpy points.; /// If the function has sharp peaks, you should increase the number of; /// points (SetNpx, SetNpy) such that the peak is correctly tabulated; /// at several points.",MatchSource.CODE_COMMENT,hist/hist/src/TF2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx:460,Performance,perform,performed,460,"////////////////////////////////////////////////////////////////////////////////; /// Return minimum/maximum value of the function; ///; /// To find the minimum on a range, first set this range via the SetRange function; /// If a vector x of coordinate is passed it will be used as starting point for the minimum.; /// In addition on exit x will contain the coordinate values at the minimuma; /// If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided into fNpx and fNpy; /// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; /// by SetNpx and SetNpy functions; ///; /// Then, a minimization is used with starting values found by the grid search; /// The minimizer algorithm used (by default Minuit) can be changed by callinga; /// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); /// Other option for the minimizer can be set using the static method of the MinimizerOptions class",MatchSource.CODE_COMMENT,hist/hist/src/TF3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx:361,Performance,perform,performed,361,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X, Y and Z values corresponding to the minimum value of the function; /// on its range.; ///; /// Returns the function value at the minimum.; /// To find the minimum on a subrange, use the SetRange() function first.; ///; /// Method:; /// First, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided; /// into fNpx,fNpy and fNpz sub-ranges. If the function is ""good"" (or ""bad""),; /// these values can be changed by SetNpx(), SetNpy() and SetNpz() functions.; /// Then, Minuit minimization is used with starting values found by the grid search; ///; /// Note that this method will always do first a grid search in contrast to GetMinimum",MatchSource.CODE_COMMENT,hist/hist/src/TF3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx:201,Deployability,integrat,integrated,201,"////////////////////////////////////////////////////////////////////////////////; /// Return 3 random numbers following this function shape; ///; /// The distribution contained in this TF3 function is integrated; /// over the cell contents.; /// It is normalized to 1.; /// Getting the three random numbers implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which cell in the normalized integral r1 corresponds to; /// - make a linear interpolation in the returned cell; ///; /// IMPORTANT NOTE; ///; /// The integral of the function is computed at fNpx * fNpy * fNpz points.; /// If the function has sharp peaks, you should increase the number of; /// points (SetNpx, SetNpy, SetNpz) such that the peak is correctly tabulated; /// at several points.",MatchSource.CODE_COMMENT,hist/hist/src/TF3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx:201,Integrability,integrat,integrated,201,"////////////////////////////////////////////////////////////////////////////////; /// Return 3 random numbers following this function shape; ///; /// The distribution contained in this TF3 function is integrated; /// over the cell contents.; /// It is normalized to 1.; /// Getting the three random numbers implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which cell in the normalized integral r1 corresponds to; /// - make a linear interpolation in the returned cell; ///; /// IMPORTANT NOTE; ///; /// The integral of the function is computed at fNpx * fNpy * fNpz points.; /// If the function has sharp peaks, you should increase the number of; /// points (SetNpx, SetNpy, SetNpz) such that the peak is correctly tabulated; /// at several points.",MatchSource.CODE_COMMENT,hist/hist/src/TF3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx:38,Modifiability,Extend,Extends,38,/** \class TFitResult; \ingroup Hist; Extends the ROOT::Fit::Result class with a TNamed inheritance; providing easy possibility for I/O; */,MatchSource.CODE_COMMENT,hist/hist/src/TFitResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx:88,Modifiability,inherit,inheritance,88,/** \class TFitResult; \ingroup Hist; Extends the ROOT::Fit::Result class with a TNamed inheritance; providing easy possibility for I/O; */,MatchSource.CODE_COMMENT,hist/hist/src/TFitResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx:149,Availability,error,errors,149,"////////////////////////////////////////////////////////////////////////////////; /// Print result of the fit, by default chi2, parameter values and errors.; /// if option ""V"" is given print also error matrix and correlation",MatchSource.CODE_COMMENT,hist/hist/src/TFitResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx:196,Availability,error,error,196,"////////////////////////////////////////////////////////////////////////////////; /// Print result of the fit, by default chi2, parameter values and errors.; /// if option ""V"" is given print also error matrix and correlation",MatchSource.CODE_COMMENT,hist/hist/src/TFitResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx:505,Availability,Error,ErrorDef,505,"////////////////////////////////////////////////////////////////////////////////; /// Create a 2D contour around the minimum for the parameter ipar and jpar; /// if a minimum does not exist or is invalid it will return false; /// on exit a TGraph is filled with the contour points; /// the number of contour points is determined by the size of the TGraph.; /// if the size is zero a default number of points = 20 is used; /// pass optionally the confidence level, default is 0.683; /// it is assumed that ErrorDef() defines the right error definition; /// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level",MatchSource.CODE_COMMENT,hist/hist/src/TFitResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx:534,Availability,error,error,534,"////////////////////////////////////////////////////////////////////////////////; /// Create a 2D contour around the minimum for the parameter ipar and jpar; /// if a minimum does not exist or is invalid it will return false; /// on exit a TGraph is filled with the contour points; /// the number of contour points is determined by the size of the TGraph.; /// if the size is zero a default number of points = 20 is used; /// pass optionally the confidence level, default is 0.683; /// it is assumed that ErrorDef() defines the right error definition; /// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level",MatchSource.CODE_COMMENT,hist/hist/src/TFitResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx:569,Availability,error,error,569,"////////////////////////////////////////////////////////////////////////////////; /// Create a 2D contour around the minimum for the parameter ipar and jpar; /// if a minimum does not exist or is invalid it will return false; /// on exit a TGraph is filled with the contour points; /// the number of contour points is determined by the size of the TGraph.; /// if the size is zero a default number of points = 20 is used; /// pass optionally the confidence level, default is 0.683; /// it is assumed that ErrorDef() defines the right error definition; /// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level",MatchSource.CODE_COMMENT,hist/hist/src/TFitResult.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResult.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResultPtr.cxx:179,Testability,assert,assert,179,"////////////////////////////////////////////////////////////////////////////////; /// Implement the de-reference operator to make the class acts as a pointer to a TFitResult; /// assert in case the class does not contain a pointer to TFitResult",MatchSource.CODE_COMMENT,hist/hist/src/TFitResultPtr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResultPtr.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResultPtr.cxx:170,Testability,assert,assert,170,"////////////////////////////////////////////////////////////////////////////////; /// Implement the -> operator to make the class acts as a pointer to a TFitResult.; /// assert in case the class does not contain a pointer to TFitResult",MatchSource.CODE_COMMENT,hist/hist/src/TFitResultPtr.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFitResultPtr.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:231,Availability,avail,available,231,"/** \class TFormula TFormula.h ""inc/TFormula.h""; \ingroup Hist; The Formula class. This is a new version of the TFormula class based on Cling.; This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6. This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch. ### Example of valid expressions:. - `sin(x)/x`; - `[0]*sin(x) + [1]*exp(-[2]*x)`; - `x + y**2`; - `x^2 + y^2`; - `[0]*pow([1],4)`; - `2*pi*sqrt(x/y)`; - `gaus(0)*expo(3) + ypol3(5)*x`; - `gausn(0)*expo(3) + ypol3(5)*x`; - `gaus(x, [0..2]) + expo(y, [3..4])`. In the last examples above:. - `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)`; and (0) means start numbering parameters at 0; - `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))`; and (0) means start numbering parameters at 0; - `expo(3)` is a substitute for `exp([3]+[4]*x)`; - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; (`PolN` stands for Polynomial of degree N); - `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`; - `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`. See below the [full list of predefined functions](\ref FormulaFuncs) which can be used as shortcuts in; TFormula. `TMath` functions can be part of the expression, eg:. - `TMath::Landau(x)*sin(x)`; - `TMath::Erf(x)`. Formula may contain constants, eg:. - `sqrt2`; - `e`; - `pi`; - `ln10`; - `infinity`. and more. Formulas may also contain other user-defined ROOT functions defined with a; TFormula, eg, where `f1` is defined on one x-dimension and 2 parameters:. - `f1(x, [omega], [phi])`; - `f1([0..1])`; - `f1([1], [0])`; - `f1(y)`. To replace only parameter names",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:313,Availability,avail,available,313,"/** \class TFormula TFormula.h ""inc/TFormula.h""; \ingroup Hist; The Formula class. This is a new version of the TFormula class based on Cling.; This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6. This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch. ### Example of valid expressions:. - `sin(x)/x`; - `[0]*sin(x) + [1]*exp(-[2]*x)`; - `x + y**2`; - `x^2 + y^2`; - `[0]*pow([1],4)`; - `2*pi*sqrt(x/y)`; - `gaus(0)*expo(3) + ypol3(5)*x`; - `gausn(0)*expo(3) + ypol3(5)*x`; - `gaus(x, [0..2]) + expo(y, [3..4])`. In the last examples above:. - `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)`; and (0) means start numbering parameters at 0; - `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))`; and (0) means start numbering parameters at 0; - `expo(3)` is a substitute for `exp([3]+[4]*x)`; - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; (`PolN` stands for Polynomial of degree N); - `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`; - `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`. See below the [full list of predefined functions](\ref FormulaFuncs) which can be used as shortcuts in; TFormula. `TMath` functions can be part of the expression, eg:. - `TMath::Landau(x)*sin(x)`; - `TMath::Erf(x)`. Formula may contain constants, eg:. - `sqrt2`; - `e`; - `pi`; - `ln10`; - `infinity`. and more. Formulas may also contain other user-defined ROOT functions defined with a; TFormula, eg, where `f1` is defined on one x-dimension and 2 parameters:. - `f1(x, [omega], [phi])`; - `f1([0..1])`; - `f1([1], [0])`; - `f1(y)`. To replace only parameter names",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:386,Availability,avail,available,386,"/** \class TFormula TFormula.h ""inc/TFormula.h""; \ingroup Hist; The Formula class. This is a new version of the TFormula class based on Cling.; This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as; `ROOT::v5::TFormula`. Some of the TFormula member functions available in version 5, such as; `Analyze` and `AnalyzeFunction` are not available in the new TFormula.; On the other hand formula expressions which were valid in version 5 are still valid in TFormula version 6. This class has been implemented during Google Summer of Code 2013 by Maciej Zimnoch. ### Example of valid expressions:. - `sin(x)/x`; - `[0]*sin(x) + [1]*exp(-[2]*x)`; - `x + y**2`; - `x^2 + y^2`; - `[0]*pow([1],4)`; - `2*pi*sqrt(x/y)`; - `gaus(0)*expo(3) + ypol3(5)*x`; - `gausn(0)*expo(3) + ypol3(5)*x`; - `gaus(x, [0..2]) + expo(y, [3..4])`. In the last examples above:. - `gaus(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)`; and (0) means start numbering parameters at 0; - `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))`; and (0) means start numbering parameters at 0; - `expo(3)` is a substitute for `exp([3]+[4]*x)`; - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; (`PolN` stands for Polynomial of degree N); - `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`; - `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`. See below the [full list of predefined functions](\ref FormulaFuncs) which can be used as shortcuts in; TFormula. `TMath` functions can be part of the expression, eg:. - `TMath::Landau(x)*sin(x)`; - `TMath::Erf(x)`. Formula may contain constants, eg:. - `sqrt2`; - `e`; - `pi`; - `ln10`; - `infinity`. and more. Formulas may also contain other user-defined ROOT functions defined with a; TFormula, eg, where `f1` is defined on one x-dimension and 2 parameters:. - `f1(x, [omega], [phi])`; - `f1([0..1])`; - `f1([1], [0])`; - `f1(y)`. To replace only parameter names",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3963,Availability,avail,available,3963," `x,y,z,t` or; `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas. This class is not anymore the base class for the function classes `TF1`, but it has now; a data member of TF1 which can be accessed via `TF1::GetFormula`. TFormula supports gradient and hessian calculations through clad.; To calculate the gradient one needs to first declare a `CladStorage` of the; same size as the number of parameters and then pass the variables and the; created `CladStorage`:. ```; TFormula f(""f"", ""x*[0] - y*[1]"");; Double_t p[] = {40, 30};; Double_t x[] = {1, 2};; f.SetParameters(p);; TFormula::CladStorage grad(2);; f.GradientPar(x, grad);; ```. The process is similar for hessians, except that the size of the created; CladStorage should be the square of the number of parameters because; `HessianPar` returns a flattened matrix:. ```; TFormula::CladStorage hess(4);; f.HessianPar(x, hess);; ```. \anchor FormulaFuncs; ### List of predefined functions. The list of available predefined functions which can be used as shortcuts is the following:; 1. One Dimensional functions:; - `gaus` is a substitute for `[Constant]*exp(-0.5*((x-[Mean])/[Sigma])*((x-[Mean])/[Sigma]))`; - `landau` is a substitute for `[Constant]*TMath::Landau (x,[MPV],[Sigma],false)`; - `expo` is a substitute for `exp([Constant]+[Slope]*x)`; - `crystalball` is substitute for `[Constant]*ROOT::Math::crystalball_function (x,[Alpha],[N],[Sigma],[Mean])`; - `breitwigner` is a substitute for `[p0]*ROOT::Math::breitwigner_pdf (x,[p2],[p1])`; - `pol0,1,2,...N` is a substitute for a polynomial of degree `N` :; `([p0]+[p1]*x+[p2]*pow(x,2)+....[pN]*pow(x,N)`; - `cheb0,1,2,...N` is a substitute for a Chebyshev polynomial of degree `N`:; `ROOT::Math::Chebyshev10(x,[p0],[p1],[p2],...[pN])`. Note the maximum N allowed here is 10.; 2. Two Dimensional functions:; - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.; - `bigaus` is ",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:6913,Availability,error,error,6913,"ula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this way parameters can be used identically; to variables. See below for an example that uses only parameters to model a; function. ```; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");. tf.EvalPar(nullptr, params);; ```. ### A note on operators. All operators of C/C++ are allowed in a TFormula with a few caveats. The operators `|`, `&`, `%` can be used but will raise an error if used in; conjunction with a variable or a parameter. Variables and parameters are treated; as doubles internally for which these operators are not defined.; This means the following command will run successfully; ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; but not; ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```. The operator `^` is defined to mean exponentiation instead of the C/C++; interpretation xor. `**` is added, also meaning exponentiation. The operators `++` and `@` are added, and are shorthand for the a linear; function. That means the expression `x@2` will be expanded to; ```[n]*x + [n+1]*2``` where n is the first previously unused parameter number. \class TFormulaFunction; Helper class for TFormula. \class TFormulaVariable; Another helper class for TFormula. \class TFormulaParamOrder; Functor defining the parameter order; */; // prefix used for function name passed to Cling",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:2017,Modifiability,variab,variable,2017," at 0; - `gausn(0)` is a substitute for `[0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2]))`; and (0) means start numbering parameters at 0; - `expo(3)` is a substitute for `exp([3]+[4]*x)`; - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; (`PolN` stands for Polynomial of degree N); - `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`; - `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`. See below the [full list of predefined functions](\ref FormulaFuncs) which can be used as shortcuts in; TFormula. `TMath` functions can be part of the expression, eg:. - `TMath::Landau(x)*sin(x)`; - `TMath::Erf(x)`. Formula may contain constants, eg:. - `sqrt2`; - `e`; - `pi`; - `ln10`; - `infinity`. and more. Formulas may also contain other user-defined ROOT functions defined with a; TFormula, eg, where `f1` is defined on one x-dimension and 2 parameters:. - `f1(x, [omega], [phi])`; - `f1([0..1])`; - `f1([1], [0])`; - `f1(y)`. To replace only parameter names, the dimension variable can be dropped.; Alternatively, to change only the dimension variable, the parameters can be; dropped. Note that if a parameter is dropped or keeps its old name, its old; value will be copied to the new function. The syntax used in the examples; above also applies to the predefined parametrized functions like `gaus` and; `expo`. Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`. Examples:. `sin(x*(x&lt;0.5 || x&gt;1))`. If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`. one can assign a name to the formula. By default the name of the object = title = formula itself. `TFormula new(""new"",""x*old"")`. is equivalent to:. `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`. The class supports unlimited number of variables and parameters.; By default the names which can be used for the variables are `x,y,z",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:2087,Modifiability,variab,variable,2087,"*pi)*[2]))`; and (0) means start numbering parameters at 0; - `expo(3)` is a substitute for `exp([3]+[4]*x)`; - `pol3(5)` is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; (`PolN` stands for Polynomial of degree N); - `gaus(x, [0..2])` is a more explicit way of writing `gaus(0)`; - `expo(y, [3..4])` is a substitute for `exp([3]+[4]*y)`. See below the [full list of predefined functions](\ref FormulaFuncs) which can be used as shortcuts in; TFormula. `TMath` functions can be part of the expression, eg:. - `TMath::Landau(x)*sin(x)`; - `TMath::Erf(x)`. Formula may contain constants, eg:. - `sqrt2`; - `e`; - `pi`; - `ln10`; - `infinity`. and more. Formulas may also contain other user-defined ROOT functions defined with a; TFormula, eg, where `f1` is defined on one x-dimension and 2 parameters:. - `f1(x, [omega], [phi])`; - `f1([0..1])`; - `f1([1], [0])`; - `f1(y)`. To replace only parameter names, the dimension variable can be dropped.; Alternatively, to change only the dimension variable, the parameters can be; dropped. Note that if a parameter is dropped or keeps its old name, its old; value will be copied to the new function. The syntax used in the examples; above also applies to the predefined parametrized functions like `gaus` and; `expo`. Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`. Examples:. `sin(x*(x&lt;0.5 || x&gt;1))`. If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`. one can assign a name to the formula. By default the name of the object = title = formula itself. `TFormula new(""new"",""x*old"")`. is equivalent to:. `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`. The class supports unlimited number of variables and parameters.; By default the names which can be used for the variables are `x,y,z,t` or; `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas. This class is",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:2911,Modifiability,variab,variables,2911,"(x, [omega], [phi])`; - `f1([0..1])`; - `f1([1], [0])`; - `f1(y)`. To replace only parameter names, the dimension variable can be dropped.; Alternatively, to change only the dimension variable, the parameters can be; dropped. Note that if a parameter is dropped or keeps its old name, its old; value will be copied to the new function. The syntax used in the examples; above also applies to the predefined parametrized functions like `gaus` and; `expo`. Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`. Examples:. `sin(x*(x&lt;0.5 || x&gt;1))`. If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`. one can assign a name to the formula. By default the name of the object = title = formula itself. `TFormula new(""new"",""x*old"")`. is equivalent to:. `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`. The class supports unlimited number of variables and parameters.; By default the names which can be used for the variables are `x,y,z,t` or; `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas. This class is not anymore the base class for the function classes `TF1`, but it has now; a data member of TF1 which can be accessed via `TF1::GetFormula`. TFormula supports gradient and hessian calculations through clad.; To calculate the gradient one needs to first declare a `CladStorage` of the; same size as the number of parameters and then pass the variables and the; created `CladStorage`:. ```; TFormula f(""f"", ""x*[0] - y*[1]"");; Double_t p[] = {40, 30};; Double_t x[] = {1, 2};; f.SetParameters(p);; TFormula::CladStorage grad(2);; f.GradientPar(x, grad);; ```. The process is similar for hessians, except that the size of the created; CladStorage should be the square of the number of parameters because; `HessianPar` returns a flattened matrix:. ```; TFormula::CladStorage hess(4);; f.HessianPar(x, hess);; ```. \anchor F",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:2985,Modifiability,variab,variables,2985," parameter names, the dimension variable can be dropped.; Alternatively, to change only the dimension variable, the parameters can be; dropped. Note that if a parameter is dropped or keeps its old name, its old; value will be copied to the new function. The syntax used in the examples; above also applies to the predefined parametrized functions like `gaus` and; `expo`. Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`. Examples:. `sin(x*(x&lt;0.5 || x&gt;1))`. If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`. one can assign a name to the formula. By default the name of the object = title = formula itself. `TFormula new(""new"",""x*old"")`. is equivalent to:. `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`. The class supports unlimited number of variables and parameters.; By default the names which can be used for the variables are `x,y,z,t` or; `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas. This class is not anymore the base class for the function classes `TF1`, but it has now; a data member of TF1 which can be accessed via `TF1::GetFormula`. TFormula supports gradient and hessian calculations through clad.; To calculate the gradient one needs to first declare a `CladStorage` of the; same size as the number of parameters and then pass the variables and the; created `CladStorage`:. ```; TFormula f(""f"", ""x*[0] - y*[1]"");; Double_t p[] = {40, 30};; Double_t x[] = {1, 2};; f.SetParameters(p);; TFormula::CladStorage grad(2);; f.GradientPar(x, grad);; ```. The process is similar for hessians, except that the size of the created; CladStorage should be the square of the number of parameters because; `HessianPar` returns a flattened matrix:. ```; TFormula::CladStorage hess(4);; f.HessianPar(x, hess);; ```. \anchor FormulaFuncs; ### List of predefined functions. The list of available predefined fu",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3427,Modifiability,variab,variables,3427,"re also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`. Examples:. `sin(x*(x&lt;0.5 || x&gt;1))`. If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`. one can assign a name to the formula. By default the name of the object = title = formula itself. `TFormula new(""new"",""x*old"")`. is equivalent to:. `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`. The class supports unlimited number of variables and parameters.; By default the names which can be used for the variables are `x,y,z,t` or; `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas. This class is not anymore the base class for the function classes `TF1`, but it has now; a data member of TF1 which can be accessed via `TF1::GetFormula`. TFormula supports gradient and hessian calculations through clad.; To calculate the gradient one needs to first declare a `CladStorage` of the; same size as the number of parameters and then pass the variables and the; created `CladStorage`:. ```; TFormula f(""f"", ""x*[0] - y*[1]"");; Double_t p[] = {40, 30};; Double_t x[] = {1, 2};; f.SetParameters(p);; TFormula::CladStorage grad(2);; f.GradientPar(x, grad);; ```. The process is similar for hessians, except that the size of the created; CladStorage should be the square of the number of parameters because; `HessianPar` returns a flattened matrix:. ```; TFormula::CladStorage hess(4);; f.HessianPar(x, hess);; ```. \anchor FormulaFuncs; ### List of predefined functions. The list of available predefined functions which can be used as shortcuts is the following:; 1. One Dimensional functions:; - `gaus` is a substitute for `[Constant]*exp(-0.5*((x-[Mean])/[Sigma])*((x-[Mean])/[Sigma]))`; - `landau` is a substitute for `[Constant]*TMath::Landau (x,[MPV],[Sigma],false)`; - `expo` is a substitute for `exp([Constant]+[Slope]*x)`; - `crystalball` is substitute for `[Constant]*ROOT::Math::crystalball_",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:5392,Modifiability,variab,variables,5392,",[Alpha],[N],[Sigma],[Mean])`; - `breitwigner` is a substitute for `[p0]*ROOT::Math::breitwigner_pdf (x,[p2],[p1])`; - `pol0,1,2,...N` is a substitute for a polynomial of degree `N` :; `([p0]+[p1]*x+[p2]*pow(x,2)+....[pN]*pow(x,N)`; - `cheb0,1,2,...N` is a substitute for a Chebyshev polynomial of degree `N`:; `ROOT::Math::Chebyshev10(x,[p0],[p1],[p2],...[pN])`. Note the maximum N allowed here is 10.; 2. Two Dimensional functions:; - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.; - `bigaus` is a substitute for `[Constant]*ROOT::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.; 3. Three Dimensional functions:; - `xyzgaus` is for a 3d Gaussians without correlations:; `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`. ### An expanded note on variables and parameters. In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer. ```; TFormula("""", ""x[0] * x[1] + 10""); ```. Parameters are similar and can take any name. It is specified using brackets; e.g. `[expected_mass]` or `[0]`. ```; TFormula("""", ""exp([expected_mass])-1""); ```. Variables and parameters can be combined in the same TFormula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:5435,Modifiability,variab,variable,5435," (x,[p2],[p1])`; - `pol0,1,2,...N` is a substitute for a polynomial of degree `N` :; `([p0]+[p1]*x+[p2]*pow(x,2)+....[pN]*pow(x,N)`; - `cheb0,1,2,...N` is a substitute for a Chebyshev polynomial of degree `N`:; `ROOT::Math::Chebyshev10(x,[p0],[p1],[p2],...[pN])`. Note the maximum N allowed here is 10.; 2. Two Dimensional functions:; - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.; - `bigaus` is a substitute for `[Constant]*ROOT::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.; 3. Three Dimensional functions:; - `xyzgaus` is for a 3d Gaussians without correlations:; `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`. ### An expanded note on variables and parameters. In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer. ```; TFormula("""", ""x[0] * x[1] + 10""); ```. Parameters are similar and can take any name. It is specified using brackets; e.g. `[expected_mass]` or `[0]`. ```; TFormula("""", ""exp([expected_mass])-1""); ```. Variables and parameters can be combined in the same TFormula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this ",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:5773,Modifiability,Variab,Variables,5773,"Dimensional functions:; - `xygaus` is a substitute for `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.; - `bigaus` is a substitute for `[Constant]*ROOT::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.; 3. Three Dimensional functions:; - `xyzgaus` is for a 3d Gaussians without correlations:; `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`. ### An expanded note on variables and parameters. In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer. ```; TFormula("""", ""x[0] * x[1] + 10""); ```. Parameters are similar and can take any name. It is specified using brackets; e.g. `[expected_mass]` or `[0]`. ```; TFormula("""", ""exp([expected_mass])-1""); ```. Variables and parameters can be combined in the same TFormula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this way parameters can be used identically; to variables. See below for an example that uses only parameters to model a; function. ```; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");. tf.EvalPar(nullptr, params);; ```. ### A note on operators. All operators of C",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:6186,Modifiability,variab,variables,6186,"ussians without correlations:; `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`. ### An expanded note on variables and parameters. In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer. ```; TFormula("""", ""x[0] * x[1] + 10""); ```. Parameters are similar and can take any name. It is specified using brackets; e.g. `[expected_mass]` or `[0]`. ```; TFormula("""", ""exp([expected_mass])-1""); ```. Variables and parameters can be combined in the same TFormula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this way parameters can be used identically; to variables. See below for an example that uses only parameters to model a; function. ```; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");. tf.EvalPar(nullptr, params);; ```. ### A note on operators. All operators of C/C++ are allowed in a TFormula with a few caveats. The operators `|`, `&`, `%` can be used but will raise an error if used in; conjunction with a variable or a parameter. Variables and parameters are treated; as doubles internally for which these operators are not defined.; This means the following command will run successfully; ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; but not; ```root -l -q",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:6320,Modifiability,variab,variables,6320,"0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`. ### An expanded note on variables and parameters. In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer. ```; TFormula("""", ""x[0] * x[1] + 10""); ```. Parameters are similar and can take any name. It is specified using brackets; e.g. `[expected_mass]` or `[0]`. ```; TFormula("""", ""exp([expected_mass])-1""); ```. Variables and parameters can be combined in the same TFormula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this way parameters can be used identically; to variables. See below for an example that uses only parameters to model a; function. ```; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");. tf.EvalPar(nullptr, params);; ```. ### A note on operators. All operators of C/C++ are allowed in a TFormula with a few caveats. The operators `|`, `&`, `%` can be used but will raise an error if used in; conjunction with a variable or a parameter. Variables and parameters are treated; as doubles internally for which these operators are not defined.; This means the following command will run successfully; ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; but not; ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```. The operator `^` is defined to mean exponentiati",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:6535,Modifiability,variab,variables,6535,"`x[1]`, `x[2]`; that is `x[N]` where N is an integer. ```; TFormula("""", ""x[0] * x[1] + 10""); ```. Parameters are similar and can take any name. It is specified using brackets; e.g. `[expected_mass]` or `[0]`. ```; TFormula("""", ""exp([expected_mass])-1""); ```. Variables and parameters can be combined in the same TFormula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this way parameters can be used identically; to variables. See below for an example that uses only parameters to model a; function. ```; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");. tf.EvalPar(nullptr, params);; ```. ### A note on operators. All operators of C/C++ are allowed in a TFormula with a few caveats. The operators `|`, `&`, `%` can be used but will raise an error if used in; conjunction with a variable or a parameter. Variables and parameters are treated; as doubles internally for which these operators are not defined.; This means the following command will run successfully; ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; but not; ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```. The operator `^` is defined to mean exponentiation instead of the C/C++; interpretation xor. `**` is added, also meaning exponentiation. The operators `++` and `@` are added, and are shorthand for the a linear; function. That means the expression `x@2` will be expan",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:6950,Modifiability,variab,variable,6950,"ula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this way parameters can be used identically; to variables. See below for an example that uses only parameters to model a; function. ```; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");. tf.EvalPar(nullptr, params);; ```. ### A note on operators. All operators of C/C++ are allowed in a TFormula with a few caveats. The operators `|`, `&`, `%` can be used but will raise an error if used in; conjunction with a variable or a parameter. Variables and parameters are treated; as doubles internally for which these operators are not defined.; This means the following command will run successfully; ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; but not; ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```. The operator `^` is defined to mean exponentiation instead of the C/C++; interpretation xor. `**` is added, also meaning exponentiation. The operators `++` and `@` are added, and are shorthand for the a linear; function. That means the expression `x@2` will be expanded to; ```[n]*x + [n+1]*2``` where n is the first previously unused parameter number. \class TFormulaFunction; Helper class for TFormula. \class TFormulaVariable; Another helper class for TFormula. \class TFormulaParamOrder; Functor defining the parameter order; */; // prefix used for function name passed to Cling",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:6975,Modifiability,Variab,Variables,6975,"ula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this way parameters can be used identically; to variables. See below for an example that uses only parameters to model a; function. ```; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");. tf.EvalPar(nullptr, params);; ```. ### A note on operators. All operators of C/C++ are allowed in a TFormula with a few caveats. The operators `|`, `&`, `%` can be used but will raise an error if used in; conjunction with a variable or a parameter. Variables and parameters are treated; as doubles internally for which these operators are not defined.; This means the following command will run successfully; ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; but not; ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```. The operator `^` is defined to mean exponentiation instead of the C/C++; interpretation xor. `**` is added, also meaning exponentiation. The operators `++` and `@` are added, and are shorthand for the a linear; function. That means the expression `x@2` will be expanded to; ```[n]*x + [n+1]*2``` where n is the first previously unused parameter number. \class TFormulaFunction; Helper class for TFormula. \class TFormulaVariable; Another helper class for TFormula. \class TFormulaParamOrder; Functor defining the parameter order; */; // prefix used for function name passed to Cling",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3195,Security,access,accessed,3195,"meter is dropped or keeps its old name, its old; value will be copied to the new function. The syntax used in the examples; above also applies to the predefined parametrized functions like `gaus` and; `expo`. Comparisons operators are also supported `(&amp;&amp;, ||, ==, &lt;=, &gt;=, !)`. Examples:. `sin(x*(x&lt;0.5 || x&gt;1))`. If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. `TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1)))`. one can assign a name to the formula. By default the name of the object = title = formula itself. `TFormula new(""new"",""x*old"")`. is equivalent to:. `TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))"")`. The class supports unlimited number of variables and parameters.; By default the names which can be used for the variables are `x,y,z,t` or; `x[0],x[1],x[2],x[3],....x[N]` for N-dimensional formulas. This class is not anymore the base class for the function classes `TF1`, but it has now; a data member of TF1 which can be accessed via `TF1::GetFormula`. TFormula supports gradient and hessian calculations through clad.; To calculate the gradient one needs to first declare a `CladStorage` of the; same size as the number of parameters and then pass the variables and the; created `CladStorage`:. ```; TFormula f(""f"", ""x*[0] - y*[1]"");; Double_t p[] = {40, 30};; Double_t x[] = {1, 2};; f.SetParameters(p);; TFormula::CladStorage grad(2);; f.GradientPar(x, grad);; ```. The process is similar for hessians, except that the size of the created; CladStorage should be the square of the number of parameters because; `HessianPar` returns a flattened matrix:. ```; TFormula::CladStorage hess(4);; f.HessianPar(x, hess);; ```. \anchor FormulaFuncs; ### List of predefined functions. The list of available predefined functions which can be used as shortcuts is the following:; 1. One Dimensional functions:; - `gaus` is a substitute for `[Constant]*exp(-0.5*((x-[Mean])/[Sigma])*((x",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:5861,Usability,simpl,simple,5861,"-[MeanY])/[SigmaY]),2))`, a 2d Gaussian without correlation.; - `bigaus` is a substitute for `[Constant]*ROOT::Math::bigaussian_pdf (x,y,[SigmaX],[SigmaY],[Rho],[MeanX],[MeanY])`, a 2d gaussian including a correlation parameter.; 3. Three Dimensional functions:; - `xyzgaus` is for a 3d Gaussians without correlations:; `[Constant]*exp(-0.5*pow(((x-[MeanX])/[SigmaX]),2 )- 0.5*pow(((y-[MeanY])/[SigmaY]),2 )- 0.5*pow(((z-[MeanZ])/[SigmaZ]),2))`. ### An expanded note on variables and parameters. In a TFormula, a variable is a defined by a name `x`, `y`, `z` or `t` or an; index like `x[0]`, `x[1]`, `x[2]`; that is `x[N]` where N is an integer. ```; TFormula("""", ""x[0] * x[1] + 10""); ```. Parameters are similar and can take any name. It is specified using brackets; e.g. `[expected_mass]` or `[0]`. ```; TFormula("""", ""exp([expected_mass])-1""); ```. Variables and parameters can be combined in the same TFormula. Here we consider; a very simple case where we have an exponential decay after some time t and a; number of events with timestamps for which we want to evaluate this function. ```; TFormula tf ("""", ""[0]*exp(-[1]*t)"");; tf.SetParameter(0, 1);; tf.SetParameter(1, 0.5);. for (auto & event : events) {; tf.Eval(event.t);; }; ```. The distinction between variables and parameters arose from the TFormula's; application in fitting. There parameters are fitted to the data provided; through variables. In other applications this distinction can go away. Parameter values can be provided dynamically using `TFormula::EvalPar`; instead of `TFormula::Eval`. In this way parameters can be used identically; to variables. See below for an example that uses only parameters to model a; function. ```; Int_t params[2] = {1, 2}; // {vel_x, vel_y}; TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");. tf.EvalPar(nullptr, params);; ```. ### A note on operators. All operators of C/C++ are allowed in a TFormula with a few caveats. The operators `|`, `&`, `%` can be used but will raise an error if u",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:28,Security,hash,hash,28,"// set the cling name using hash of the static formulae map",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:12,Safety,avoid,avoid,12,"// add ; to avoid printing",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3,Usability,clear,clear,3,"// clear if a formula was already existing",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:146,Modifiability,variab,variables,146,"////////////////////////////////////////////////////////////////////////////////; /// Clear the formula setting expression to empty and reset the variables and; /// parameters containers.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear the formula setting expression to empty and reset the variables and; /// parameters containers.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:22,Availability,failure,failure,22,"// Returns nullptr on failure.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:269,Availability,failure,failure,269,"////////////////////////////////////////////////////////////////////////////////; /// Sets TMethodCall to function inside Cling environment.; /// TFormula uses it to execute function.; /// After call, TFormula should be ready to evaluate formula.; /// Returns false on failure.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:18,Performance,optimiz,optimization,18,"// add pragma for optimization of the formula",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:42,Performance,load,loaded,42,"// Now that all libraries and headers are loaded, Declare() a performant version; // of the same code:",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:62,Performance,perform,performant,62,"// Now that all libraries and headers are loaded, Declare() a performant version; // of the same code:",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:115,Modifiability,variab,variables,115,"////////////////////////////////////////////////////////////////////////////////; /// Fill structures with default variables, constants and function shortcuts",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:160,Testability,log,loge,160,"// const pair<TString,Double_t> defconsts[] = { {""pi"",TMath::Pi()}, {""sqrt2"",TMath::Sqrt2()},; // {""infinity"",TMath::Infinity()}, {""ln10"",TMath::Ln10()},; // {""loge"",TMath::LogE()}, {""true"",1},{""false"",0} };",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:173,Testability,Log,LogE,173,"// const pair<TString,Double_t> defconsts[] = { {""pi"",TMath::Pi()}, {""sqrt2"",TMath::Sqrt2()},; // {""infinity"",TMath::Infinity()}, {""ln10"",TMath::Ln10()},; // {""loge"",TMath::LogE()}, {""true"",1},{""false"",0} };",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:16,Modifiability,variab,variables,16,"// add also the variables defined like x[0],x[1],x[2],...; // support up to x[9] - if needed extend that to higher value; // const int maxdim = 10;; // for (int i = 0; i < maxdim; ++i) {; // TString xvar = TString::Format(""x[%d]"",i);; // fVars[xvar] = TFormulaVariable(xvar,0,i);; // fClingVariables.push_back(0);; // }",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:93,Modifiability,extend,extend,93,"// add also the variables defined like x[0],x[1],x[2],...; // support up to x[9] - if needed extend that to higher value; // const int maxdim = 10;; // for (int i = 0; i < maxdim; ++i) {; // TString xvar = TString::Format(""x[%d]"",i);; // fVars[xvar] = TFormulaVariable(xvar,0,i);; // fClingVariables.push_back(0);; // }",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:166,Modifiability,variab,variable,166,"////////////////////////////////////////////////////////////////////////////////; /// Handling polN; /// If before 'pol' exist any name, this name will be treated as variable used in polynomial; /// eg.; /// varpol2(5) will be replaced with: [5] + [6]*var + [7]*var^2; /// Empty name is treated like variable x.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:300,Modifiability,variab,variable,300,"////////////////////////////////////////////////////////////////////////////////; /// Handling polN; /// If before 'pol' exist any name, this name will be treated as variable used in polynomial; /// eg.; /// varpol2(5) will be replaced with: [5] + [6]*var + [7]*var^2; /// Empty name is treated like variable x.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:170,Modifiability,variab,variable,170,"////////////////////////////////////////////////////////////////////////////////; /// Handling parametrized functions; /// Function can be normalized, and have different variable then x.; /// Variables should be placed in brackets after function name.; /// No brackets are treated like [x].; /// Normalized function has char 'n' after name, eg.; /// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); ///; /// Adding function is easy, just follow these rules, and add to; /// `TFormula::FillParametrizedFunctions` defined further below:; ///; /// - Key for function map is pair of name and dimension of function; /// - value of key is a pair function body and normalized function body; /// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; /// Count starts from 0.; /// - [num] stands for parameter number.; /// If user pass to function argument 5, num will stand for (5 + num) parameter.; ///",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:192,Modifiability,Variab,Variables,192,"////////////////////////////////////////////////////////////////////////////////; /// Handling parametrized functions; /// Function can be normalized, and have different variable then x.; /// Variables should be placed in brackets after function name.; /// No brackets are treated like [x].; /// Normalized function has char 'n' after name, eg.; /// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); ///; /// Adding function is easy, just follow these rules, and add to; /// `TFormula::FillParametrizedFunctions` defined further below:; ///; /// - Key for function map is pair of name and dimension of function; /// - value of key is a pair function body and normalized function body; /// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; /// Count starts from 0.; /// - [num] stands for parameter number.; /// If user pass to function argument 5, num will stand for (5 + num) parameter.; ///",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:749,Modifiability,variab,variable,749,"////////////////////////////////////////////////////////////////////////////////; /// Handling parametrized functions; /// Function can be normalized, and have different variable then x.; /// Variables should be placed in brackets after function name.; /// No brackets are treated like [x].; /// Normalized function has char 'n' after name, eg.; /// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); ///; /// Adding function is easy, just follow these rules, and add to; /// `TFormula::FillParametrizedFunctions` defined further below:; ///; /// - Key for function map is pair of name and dimension of function; /// - value of key is a pair function body and normalized function body; /// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; /// Count starts from 0.; /// - [num] stands for parameter number.; /// If user pass to function argument 5, num will stand for (5 + num) parameter.; ///",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:784,Modifiability,variab,variable,784,"////////////////////////////////////////////////////////////////////////////////; /// Handling parametrized functions; /// Function can be normalized, and have different variable then x.; /// Variables should be placed in brackets after function name.; /// No brackets are treated like [x].; /// Normalized function has char 'n' after name, eg.; /// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); ///; /// Adding function is easy, just follow these rules, and add to; /// `TFormula::FillParametrizedFunctions` defined further below:; ///; /// - Key for function map is pair of name and dimension of function; /// - value of key is a pair function body and normalized function body; /// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; /// Count starts from 0.; /// - [num] stands for parameter number.; /// If user pass to function argument 5, num will stand for (5 + num) parameter.; ///",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:798,Modifiability,variab,variable,798,"////////////////////////////////////////////////////////////////////////////////; /// Handling parametrized functions; /// Function can be normalized, and have different variable then x.; /// Variables should be placed in brackets after function name.; /// No brackets are treated like [x].; /// Normalized function has char 'n' after name, eg.; /// gausn[var](0) will be replaced with [0]*exp(-0.5*((var-[1])/[2])^2)/(sqrt(2*pi)*[2]); ///; /// Adding function is easy, just follow these rules, and add to; /// `TFormula::FillParametrizedFunctions` defined further below:; ///; /// - Key for function map is pair of name and dimension of function; /// - value of key is a pair function body and normalized function body; /// - {Vn} is a place where variable appear, n represents n-th variable from variable list.; /// Count starts from 0.; /// - [num] stands for parameter number.; /// If user pass to function argument 5, num will stand for (5 + num) parameter.; ///",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:147,Modifiability,variab,variables,147,"// check if also last character is not alphanumeric or is not an operator and not a parenthesis ( or [.; // Parenthesis [] are used to express the variables",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:54,Modifiability,variab,variables,54,"// in case of [..] found, assume they specify all the variables. Use it to get function dimension",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:21,Modifiability,variab,variable,21,"// we will miss last variable",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:21,Modifiability,variab,variable,21,"// replace {Vn} with variable names",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3,Deployability,update,update,3,"// update i to reflect change in body string",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3,Deployability,update,update,3,"// update parameter counters in case of many functions (e.g. gaus(0)+gaus(3) )",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:152,Modifiability,variab,variables,152,"////////////////////////////////////////////////////////////////////////////////; /// Handling user functions (and parametrized functions); /// to take variables and optionally parameters as arguments",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:20,Modifiability,variab,variables,20,"// loop through all variables and parameters, filling in argSubstitutions",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:28,Modifiability,variab,variable,28,"// Get new name (for either variable or parameter)",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3,Modifiability,variab,variable,3,"// variable",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:17,Modifiability,variab,variables,17,"// Try to assume variables are implicit (need all arguments to be; // parameters); // loop to check if all arguments are parameters",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:52,Modifiability,variab,variable,52,"// Treat parameters as implicit; // loop to replace variable names",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:6,Availability,down,down,6,"// go down one; // handle scientific notation cases (1.e-2 ^ 3 )",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3,Deployability,update,update,3,"// update the expression with the new formula",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:25,Modifiability,variab,variable,25,"// save formula to parse variable and parameters for Cling",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:214,Modifiability,variab,variable,214,"////////////////////////////////////////////////////////////////////////////////; /// Extracts functors from formula, and put them in fFuncs.; /// Simple grammar:; /// - `<function>` := name(arg1,arg2...); /// - `<variable>` := name; /// - `<parameter>` := [number]; /// - `<name>` := String containing lower and upper letters, numbers, underscores; /// - `<number>` := Integer number; /// Operators are omitted.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:147,Usability,Simpl,Simple,147,"////////////////////////////////////////////////////////////////////////////////; /// Extracts functors from formula, and put them in fFuncs.; /// Simple grammar:; /// - `<function>` := name(arg1,arg2...); /// - `<variable>` := name; /// - `<parameter>` := [number]; /// - `<name>` := String containing lower and upper letters, numbers, underscores; /// - `<number>` := Integer number; /// Operators are omitted.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:131,Modifiability,variab,variable,131,"// std::cout << ""investigating character : "" << i << "" "" << formula[i] << "" of formula "" << formula <<; // std::endl;; // look for variable and function names. They start in C++ with alphanumeric characters",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:150,Modifiability,variab,variables,150,"// Replacing user formula the old way (as opposed to 'HandleFunctionArguments'); // Note this is only for replacing functions that do; // not specify variables and/or parameters in brackets; // (the other case is done by `HandleFunctionArguments`)",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:31,Safety,avoid,avoid,31,"// start from higher number to avoid overlap",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:222,Modifiability,variab,variable,222,"////////////////////////////////////////////////////////////////////////////////; /// Iterates through functors in fFuncs and performs the appropriate action.; /// If functor has 0 arguments (has only name) can be:; /// - variable; /// * will be replaced with x[num], where x is an array containing value of this variable under num.; /// - pre-defined formula; /// * will be replaced with formulas body; /// - constant; /// * will be replaced with constant value; /// - parameter; /// * will be replaced with p[num], where p is an array containing value of this parameter under num.; /// If has arguments it can be :; /// - function shortcut, eg. sin; /// * will be replaced with fullname of function, eg. sin -> TMath::Sin; /// - function from cling environment, eg. TMath::BreitWigner(x,y,z); /// * first check if function exists, and has same number of arguments, then accept it and set as found.; /// If all functors after iteration are matched with corresponding action,; /// it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:313,Modifiability,variab,variable,313,"////////////////////////////////////////////////////////////////////////////////; /// Iterates through functors in fFuncs and performs the appropriate action.; /// If functor has 0 arguments (has only name) can be:; /// - variable; /// * will be replaced with x[num], where x is an array containing value of this variable under num.; /// - pre-defined formula; /// * will be replaced with formulas body; /// - constant; /// * will be replaced with constant value; /// - parameter; /// * will be replaced with p[num], where p is an array containing value of this parameter under num.; /// If has arguments it can be :; /// - function shortcut, eg. sin; /// * will be replaced with fullname of function, eg. sin -> TMath::Sin; /// - function from cling environment, eg. TMath::BreitWigner(x,y,z); /// * first check if function exists, and has same number of arguments, then accept it and set as found.; /// If all functors after iteration are matched with corresponding action,; /// it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:126,Performance,perform,performs,126,"////////////////////////////////////////////////////////////////////////////////; /// Iterates through functors in fFuncs and performs the appropriate action.; /// If functor has 0 arguments (has only name) can be:; /// - variable; /// * will be replaced with x[num], where x is an array containing value of this variable under num.; /// - pre-defined formula; /// * will be replaced with formulas body; /// - constant; /// * will be replaced with constant value; /// - parameter; /// * will be replaced with p[num], where p is an array containing value of this parameter under num.; /// If has arguments it can be :; /// - function shortcut, eg. sin; /// * will be replaced with fullname of function, eg. sin -> TMath::Sin; /// - function from cling environment, eg. TMath::BreitWigner(x,y,z); /// * first check if function exists, and has same number of arguments, then accept it and set as found.; /// If all functors after iteration are matched with corresponding action,; /// it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:23,Modifiability,variab,variables,23,"// looking for default variables defined in fVars",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:22,Modifiability,variab,variable,22,"// this set the cling variable",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:3,Modifiability,variab,variable,3,"// variable dimensions (0 for x, 1 for y, 2, for z)",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:37,Modifiability,variab,variables,37,"// we need to be sure that all other variables are added with position less",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:39,Modifiability,variab,variable,39,"// remove the ""{.. }"" added around the variable",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:133,Modifiability,variab,variables,133,"// check for observables defined as x[0],x[1],....; // maybe could use a regular expression here; // only in case match with defined variables is not successful",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:22,Modifiability,variab,variables,22,"// we need to add the variables in fVars all of them before x[n]",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:39,Modifiability,variab,variable,39,"// remove the ""{.. }"" added around the variable",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:29,Modifiability,variab,variables,29,"// assume a function without variables is always 1-dimensional ???; // if (hasParameters && !hasVariables) {; // fNdim = 1;; // AddVariable(""x"", 0);; // hasVariables = true;; // }; // does not make sense to vectorize function which is of FNDim=0",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:21,Modifiability,variab,variables,21,"// when there are no variables but only parameter we still need to ad; //Bool_t hasBoth = hasVariables && hasParameters;",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:62,Modifiability,variab,variables,62,"// valid input formula - try to put into Cling (in case of no variables but only parameter we need to add the standard signature)",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:28,Security,hash,hash,28,"// set the cling name using hash of the static formulae map",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:44,Availability,failure,failure,44,"// needed in case of lazy initialization of failure compiling the expression",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:22,Availability,Error,Error,22,"// In case of a Cling Error check components which are not found in Cling; // check that all formula components are matched otherwise emit an error",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:142,Availability,error,error,142,"// In case of a Cling Error check components which are not found in Cling; // check that all formula components are matched otherwise emit an error",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:28,Modifiability,variab,variables,28,"// clean up un-used default variables in case formula is valid; //if (fClingInitialized && fReadyToExecute) {; //don't check fClingInitialized in case of lazy execution",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:23,Modifiability,variab,variable,23,"// std::cout << ""Erase variable "" << itvar->first << std::endl;",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:91,Modifiability,variab,variable,91,"////////////////////////////////////////////////////////////////////////////////; /// Adds variable to known variables, and reprocess formula.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:109,Modifiability,variab,variables,109,"////////////////////////////////////////////////////////////////////////////////; /// Adds variable to known variables, and reprocess formula.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:94,Modifiability,variab,variable,94,"// If the position is not defined in the Cling vectors, make space for it; // but normally is variable is defined in fVars a slot should be also present in fClingVariables",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:100,Modifiability,variab,variables,100,"////////////////////////////////////////////////////////////////////////////////; /// Adds multiple variables.; /// First argument is an array of pairs<TString,Double>, where; /// first argument is name of variable,; /// second argument represents value.; /// size - number of variables passed in first argument",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:206,Modifiability,variab,variable,206,"////////////////////////////////////////////////////////////////////////////////; /// Adds multiple variables.; /// First argument is an array of pairs<TString,Double>, where; /// first argument is name of variable,; /// second argument represents value.; /// size - number of variables passed in first argument",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:277,Modifiability,variab,variables,277,"////////////////////////////////////////////////////////////////////////////////; /// Adds multiple variables.; /// First argument is an array of pairs<TString,Double>, where; /// first argument is name of variable,; /// second argument represents value.; /// size - number of variables passed in first argument",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:181,Security,hash,hashes,181,"////////////////////////////////////////////////////////////////////////////////; /// Set the name of the formula. We need to allow the list of function to; /// properly handle the hashes.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:49,Security,hash,hashes,49,"// Here we need to remove and re-add to keep the hashes consistent with; // the underlying names.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:105,Modifiability,variab,variables,105,"////////////////////////////////////////////////////////////////////////////////; ///; /// Sets multiple variables.; /// First argument is an array of pairs<TString,Double>, where; /// first argument is name of variable,; /// second argument represents value.; /// size - number of variables passed in first argument",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:211,Modifiability,variab,variable,211,"////////////////////////////////////////////////////////////////////////////////; ///; /// Sets multiple variables.; /// First argument is an array of pairs<TString,Double>, where; /// first argument is name of variable,; /// second argument represents value.; /// size - number of variables passed in first argument",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:282,Modifiability,variab,variables,282,"////////////////////////////////////////////////////////////////////////////////; ///; /// Sets multiple variables.; /// First argument is an array of pairs<TString,Double>, where; /// first argument is name of variable,; /// second argument represents value.; /// size - number of variables passed in first argument",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:94,Modifiability,variab,variable,94,"////////////////////////////////////////////////////////////////////////////////; /// Returns variable value.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:94,Modifiability,variab,variable,94,"////////////////////////////////////////////////////////////////////////////////; /// Returns variable number (positon in array) given its name.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:94,Modifiability,variab,variable,94,"////////////////////////////////////////////////////////////////////////////////; /// Returns variable name given its position in the array.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:49,Modifiability,variab,variable,49,"// need to loop on the map to find corresponding variable",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:91,Modifiability,variab,variable,91,"////////////////////////////////////////////////////////////////////////////////; /// Sets variable value.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:188,Availability,error,error,188,"////////////////////////////////////////////////////////////////////////////////; /// Return parameter index given a name (return -1 for not existing parameters); /// non need to print an error",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:30,Safety,avoid,avoid,30,"// change whitespace to \s to avoid problems in parsing",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:177,Security,hash,hasher,177,"// Check if the gradient request was made as part of another TFormula.; // This can happen when we create multiple TFormula objects with the same; // formula. In that case, the hasher will give identical id and we can; // reuse the already generated gradient function.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:176,Security,hash,hasher,176,"// Check if the hessian request was made as part of another TFormula.; // This can happen when we create multiple TFormula objects with the same; // formula. In that case, the hasher will give identical id and we can; // reuse the already generated hessian function.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:163,Modifiability,variab,variables,163,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate formula.; /// If formula is not ready to execute(missing parameters/variables),; /// print these which are not known.; /// If parameter has default value, and has not been set, appropriate warning is shown.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:83,Safety,safe,safe,83,"// try recompiling the formula. We need to lock because this is not anymore thread safe",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:83,Safety,safe,safe,83,"// try recompiling the formula. We need to lock because this is not anymore thread safe",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:212,Availability,failure,failure,212,"// R__HAS_VECCORE; //////////////////////////////////////////////////////////////////////////////; /// Re-initialize eval method; ///; /// This function is called by DoEval and DoEvalVector in case of a previous failure; /// or in case of reading from a file; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:51,Safety,avoid,avoid,51,"// when reading we initialize the formula later to avoid problem of recursive Jitting",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:2,Testability,assert,assert,2,"//assert(fParams.size() == paramMap.size() );",MatchSource.CODE_COMMENT,hist/hist/src/TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormulaPrimitive_v5.cxx:2,Testability,log,logical,2,"//logical",MatchSource.CODE_COMMENT,hist/hist/src/TFormulaPrimitive_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormulaPrimitive_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormulaPrimitive_v5.cxx:7,Testability,log,logical,7,"//; // logical; //",MatchSource.CODE_COMMENT,hist/hist/src/TFormulaPrimitive_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormulaPrimitive_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormulaPrimitive_v5.cxx:17,Security,access,access,17,"//Disable direct access to TMath::Landau for now because of the default parameter.; //AddFormula(new TFormulaPrimitive(""TMath::Landau"",""TMath::Landau"",(TFormulaPrimitive::GenFunc1110)TMath::Landau));",MatchSource.CODE_COMMENT,hist/hist/src/TFormulaPrimitive_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormulaPrimitive_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2340,Deployability,update,updated,2340,"hen, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions.; */; ////////////////////////////////////////////////////////////////////////////////; /// Formula default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2239,Modifiability,inherit,inheriting,2239,"hen, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions.; */; ////////////////////////////////////////////////////////////////////////////////; /// Formula default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:1980,Performance,perform,performance,1980,"esult of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2490,Performance,perform,performant,2490,"en, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions.; */; ////////////////////////////////////////////////////////////////////////////////; /// Formula default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2425,Security,access,access,2425,"en, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions.; */; ////////////////////////////////////////////////////////////////////////////////; /// Formula default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2501,Security,access,access,2501,"en, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and frequent case, TFormula is aware; of all TMath functions.; */; ////////////////////////////////////////////////////////////////////////////////; /// Formula default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:1552,Testability,log,logic,1552,"po(3) is a substitute for `exp([3]+[4]*x)`. pol3(5) is a substitute for `par[5]+par[6]*x+par[7]*x**2+par[8]*x**3`; (here Pol3 stands for Polynomial of degree 3). TMath functions can be part of the expression, eg:. - `TMath::Landau(x)*sin(x)`; - `TMath::Erf(x)`. Comparisons operators are also supported (&&, ||, ==, <=, >=, !); Examples:. sin(x*(x<0.5 || x>1)). If the result of a comparison is TRUE, the result is 1, otherwise 0. Already predefined names can be given. For example, if the formula. TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFA",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2054,Usability,simpl,simple,2054,"example, if the formula. TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShift) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. ### CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. ### WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a specia",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:40,Availability,error,error,40,"// need to the replacement here for the error message before",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:46,Integrability,message,message,46,"// need to the replacement here for the error message before",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:4,Availability,Error,Error,4,"/*; Error(""Compile"",; ""TFormula can only call interpreted and compiled function that returns a numerical type %s returns a %s\n"",; method->GetMethodName(), method->GetMethod()->GetReturnTypeName());; */",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:19,Modifiability,extend,extended,19,"//; // MI change - extended space of functions; // not forward compatible change; //",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:288,Availability,error,errors,288,////////////////////////////////////////////////////////////////////////////////; /// Analyze a sub-expression in one formula.; ///; /// Expressions in one formula are recursively analyzed.; /// Result of analysis is stored in the object tables.; ///; /// ### Table of function codes and errors; ///; /// ~~~ {.cpp}; /// * functions :; ///; /// + 1 pow 20; /// - 2 sq 21; /// * 3 sqrt 22; /// / 4 strstr 23; /// % 5 min 24; /// max 25; /// log 30; /// cos 10 exp 31; /// sin 11 log10 32; /// tan 12; /// acos 13 abs 41; /// asin 14 sign 42; /// atan 15 int 43; /// atan2 16; /// fmod 17 rndm 50; ///; /// cosh 70 acosh 73; /// sinh 71 asinh 74; /// tanh 72 atanh 75; ///; /// expo 100 gaus 110 gausn (see note below); /// expo(0) 100 0 gaus(0) 110 0 gausn(0); /// expo(1) 100 1 gaus(1) 110 1 gausn(1); /// xexpo 100 x xgaus 110 x xgausn; /// yexpo 101 x ygaus 111 x ygausn; /// zexpo 102 x zgaus 112 x zgausn; /// xyexpo 105 x xygaus 115 x xygausn; /// yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); /// xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); ///; /// landau 120 x landaun (see note below); /// landau(0) 120 0 landaun(0); /// landau(1) 120 1 landaun(1); /// xlandau 120 x xlandaun; /// ylandau 121 x ylandaun; /// zlandau 122 x zlandaun; /// xylandau 125 x xylandaun; /// ylandau(5) 121 5 ylandaun(5); /// xylandau(2) 125 2 xylandaun(2); ///; /// pol0 130 x pol1 130 1xx; /// pol0(0) 130 0 pol1(0) 130 100; /// pol0(1) 130 1 pol1(1) 130 101; /// xpol0 130 x xpol1 130 101; /// ypol0 131 x ypol1 131 101; /// zpol0 132 x zpol1 132 1xx; /// ypol0(5) 131 5 ypol1(5) 131 105; ///; /// pi 40; ///; /// && 60 < 64; /// || 61 > 65; /// == 62 <= 66; /// != 63 => 67; /// ! 68; /// ==(string) 76 & 78; /// !=(string) 77 | 79; /// <<(shift) 80 >>(shift) 81; /// ? : 82; ///; /// * constants (kConstants) :; ///; /// c0 141 1 c1 141 2 etc..; ///; /// * strings (kStringConst):; ///; /// sX 143 x; ///; /// * variables (kFormulaVar) :; ///; /// x 144 0 y 144 1 z 144 2 t 144 3; ///; /// * parameters :; ///; /// [,MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:3428,Availability,Error,Errors,3428,"ration are used to implement lazy evaluation of; /// && and ||. When the left hand of the expression if false; /// (respectively true), the evaluation of the right is entirely skipped; /// (since it would not change the value of the expression).; ///; /// && 142 11 (one operation on right) 142 21 (2 operations on right); /// || 142 12 (one operation on right) 142 22 (2 operations on right); ///; /// * functions calls (kFunctionCall) :; ///; /// f0 145 0 f1 145 1 etc..; ///; /// ### Errors :; ///; /// 1 : Division By Zero; /// 2 : Invalid Floating Point Operation; /// 4 : Empty String; /// 5 : invalid syntax; /// 6 : Too many operators; /// 7 : Too many parameters; /// 10 : z specified but not x and y; /// 11 : z and y specified but not x; /// 12 : y specified but not x; /// 13 : z and x specified but not y; /// 20 : non integer value for parameter number; /// 21 : atan2 requires two arguments; /// 22 : pow requires two arguments; /// 23 : degree of polynomial not specified; /// 24 : Degree of polynomial must be positive; /// 25 : Degree of polynomial must be less than 20; /// 26 : Unknown name; /// 27 : Too many constants in expression; /// 28 : strstr requires two arguments; /// 29 : interpreted or compiled function have to return a numerical type; /// 30 : Bad numerical expression; /// 31 : Part of the variable exist but some of it is not accessible or useable; /// 40 : '(' is expected; /// 41 : ')' is expected; /// 42 : '[' is expected; /// 43 : ']' is expected; ///; /// \image html TFormula_analyze.png; ///; /// ### Special functions; ///; /// By default, the formula is assigned fNumber=0. However, the following; /// formula built with simple functions are assigned fNumber:; ///; /// ""gaus"" 100 (or gausn); /// ""xygaus"" 110; /// ""expo"" 200; /// ""polN"" 300+N; /// ""landau"" 400; /// ""xylandau"" 410; ///; /// Note that expressions like gaus(0), expo(1) will force fNumber=0; ///; /// ### Warning when deriving a class from TFormula; ///; /// If you overload this member ",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:1897,Modifiability,variab,variables,1897,"us 115 x xygausn; /// yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); /// xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); ///; /// landau 120 x landaun (see note below); /// landau(0) 120 0 landaun(0); /// landau(1) 120 1 landaun(1); /// xlandau 120 x xlandaun; /// ylandau 121 x ylandaun; /// zlandau 122 x zlandaun; /// xylandau 125 x xylandaun; /// ylandau(5) 121 5 ylandaun(5); /// xylandau(2) 125 2 xylandaun(2); ///; /// pol0 130 x pol1 130 1xx; /// pol0(0) 130 0 pol1(0) 130 100; /// pol0(1) 130 1 pol1(1) 130 101; /// xpol0 130 x xpol1 130 101; /// ypol0 131 x ypol1 131 101; /// zpol0 132 x zpol1 132 1xx; /// ypol0(5) 131 5 ypol1(5) 131 105; ///; /// pi 40; ///; /// && 60 < 64; /// || 61 > 65; /// == 62 <= 66; /// != 63 => 67; /// ! 68; /// ==(string) 76 & 78; /// !=(string) 77 | 79; /// <<(shift) 80 >>(shift) 81; /// ? : 82; ///; /// * constants (kConstants) :; ///; /// c0 141 1 c1 141 2 etc..; ///; /// * strings (kStringConst):; ///; /// sX 143 x; ///; /// * variables (kFormulaVar) :; ///; /// x 144 0 y 144 1 z 144 2 t 144 3; ///; /// * parameters :; ///; /// [1] 140 1; /// [2] 140 2; /// etc.; /// ~~~; ///; /// ### Special cases for normalized gaussian or landau distributions; ///; /// the expression ""gaus"" is a substitute for; ///; /// [0]*exp(-0.5*((x-[1])/[2])**2); ///; /// to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; /// the expression ""gausn"" is a substitute for; ///; /// [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); ///; /// WARNING: gaus and gausn are mutually exclusive in the same expression.; ///; /// In the same way the expression ""landau"" is a substitute for; ///; /// [0]*TMath::Landau(x,[1],[2],kFALSE); ///; /// to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; /// the expression ""landaun"" is a substitute for; ///; /// [0]*TMath::Landau(x,[1],[2],kTRUE); ///; /// WARNING: landau and landaun are mutually exclusive in the same expression.; ///; /// ### Boolean optimization (kBoolOptmize) :; ///; /// Those p",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:4267,Modifiability,variab,variable,4267,"ration are used to implement lazy evaluation of; /// && and ||. When the left hand of the expression if false; /// (respectively true), the evaluation of the right is entirely skipped; /// (since it would not change the value of the expression).; ///; /// && 142 11 (one operation on right) 142 21 (2 operations on right); /// || 142 12 (one operation on right) 142 22 (2 operations on right); ///; /// * functions calls (kFunctionCall) :; ///; /// f0 145 0 f1 145 1 etc..; ///; /// ### Errors :; ///; /// 1 : Division By Zero; /// 2 : Invalid Floating Point Operation; /// 4 : Empty String; /// 5 : invalid syntax; /// 6 : Too many operators; /// 7 : Too many parameters; /// 10 : z specified but not x and y; /// 11 : z and y specified but not x; /// 12 : y specified but not x; /// 13 : z and x specified but not y; /// 20 : non integer value for parameter number; /// 21 : atan2 requires two arguments; /// 22 : pow requires two arguments; /// 23 : degree of polynomial not specified; /// 24 : Degree of polynomial must be positive; /// 25 : Degree of polynomial must be less than 20; /// 26 : Unknown name; /// 27 : Too many constants in expression; /// 28 : strstr requires two arguments; /// 29 : interpreted or compiled function have to return a numerical type; /// 30 : Bad numerical expression; /// 31 : Part of the variable exist but some of it is not accessible or useable; /// 40 : '(' is expected; /// 41 : ')' is expected; /// 42 : '[' is expected; /// 43 : ']' is expected; ///; /// \image html TFormula_analyze.png; ///; /// ### Special functions; ///; /// By default, the formula is assigned fNumber=0. However, the following; /// formula built with simple functions are assigned fNumber:; ///; /// ""gaus"" 100 (or gausn); /// ""xygaus"" 110; /// ""expo"" 200; /// ""polN"" 300+N; /// ""landau"" 400; /// ""xylandau"" 410; ///; /// Note that expressions like gaus(0), expo(1) will force fNumber=0; ///; /// ### Warning when deriving a class from TFormula; ///; /// If you overload this member ",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2885,Performance,optimiz,optimization,2885,"x 144 0 y 144 1 z 144 2 t 144 3; ///; /// * parameters :; ///; /// [1] 140 1; /// [2] 140 2; /// etc.; /// ~~~; ///; /// ### Special cases for normalized gaussian or landau distributions; ///; /// the expression ""gaus"" is a substitute for; ///; /// [0]*exp(-0.5*((x-[1])/[2])**2); ///; /// to obtain a standard normalized gaussian, use ""gausn"" instead of ""gaus""; /// the expression ""gausn"" is a substitute for; ///; /// [0]*exp(-0.5*((x-[1])/[2])**2)/(sqrt(2*pi)*[2])); ///; /// WARNING: gaus and gausn are mutually exclusive in the same expression.; ///; /// In the same way the expression ""landau"" is a substitute for; ///; /// [0]*TMath::Landau(x,[1],[2],kFALSE); ///; /// to obtain a standard normalized landau, use ""landaun"" instead of ""landau""; /// the expression ""landaun"" is a substitute for; ///; /// [0]*TMath::Landau(x,[1],[2],kTRUE); ///; /// WARNING: landau and landaun are mutually exclusive in the same expression.; ///; /// ### Boolean optimization (kBoolOptmize) :; ///; /// Those pseudo operation are used to implement lazy evaluation of; /// && and ||. When the left hand of the expression if false; /// (respectively true), the evaluation of the right is entirely skipped; /// (since it would not change the value of the expression).; ///; /// && 142 11 (one operation on right) 142 21 (2 operations on right); /// || 142 12 (one operation on right) 142 22 (2 operations on right); ///; /// * functions calls (kFunctionCall) :; ///; /// f0 145 0 f1 145 1 etc..; ///; /// ### Errors :; ///; /// 1 : Division By Zero; /// 2 : Invalid Floating Point Operation; /// 4 : Empty String; /// 5 : invalid syntax; /// 6 : Too many operators; /// 7 : Too many parameters; /// 10 : z specified but not x and y; /// 11 : z and y specified but not x; /// 12 : y specified but not x; /// 13 : z and x specified but not y; /// 20 : non integer value for parameter number; /// 21 : atan2 requires two arguments; /// 22 : pow requires two arguments; /// 23 : degree of polynomial not specified; ///",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:4304,Security,access,accessible,4304,"ration are used to implement lazy evaluation of; /// && and ||. When the left hand of the expression if false; /// (respectively true), the evaluation of the right is entirely skipped; /// (since it would not change the value of the expression).; ///; /// && 142 11 (one operation on right) 142 21 (2 operations on right); /// || 142 12 (one operation on right) 142 22 (2 operations on right); ///; /// * functions calls (kFunctionCall) :; ///; /// f0 145 0 f1 145 1 etc..; ///; /// ### Errors :; ///; /// 1 : Division By Zero; /// 2 : Invalid Floating Point Operation; /// 4 : Empty String; /// 5 : invalid syntax; /// 6 : Too many operators; /// 7 : Too many parameters; /// 10 : z specified but not x and y; /// 11 : z and y specified but not x; /// 12 : y specified but not x; /// 13 : z and x specified but not y; /// 20 : non integer value for parameter number; /// 21 : atan2 requires two arguments; /// 22 : pow requires two arguments; /// 23 : degree of polynomial not specified; /// 24 : Degree of polynomial must be positive; /// 25 : Degree of polynomial must be less than 20; /// 26 : Unknown name; /// 27 : Too many constants in expression; /// 28 : strstr requires two arguments; /// 29 : interpreted or compiled function have to return a numerical type; /// 30 : Bad numerical expression; /// 31 : Part of the variable exist but some of it is not accessible or useable; /// 40 : '(' is expected; /// 41 : ')' is expected; /// 42 : '[' is expected; /// 43 : ']' is expected; ///; /// \image html TFormula_analyze.png; ///; /// ### Special functions; ///; /// By default, the formula is assigned fNumber=0. However, the following; /// formula built with simple functions are assigned fNumber:; ///; /// ""gaus"" 100 (or gausn); /// ""xygaus"" 110; /// ""expo"" 200; /// ""polN"" 300+N; /// ""landau"" 400; /// ""xylandau"" 410; ///; /// Note that expressions like gaus(0), expo(1) will force fNumber=0; ///; /// ### Warning when deriving a class from TFormula; ///; /// If you overload this member ",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:440,Testability,log,log,440,///////////; /// Analyze a sub-expression in one formula.; ///; /// Expressions in one formula are recursively analyzed.; /// Result of analysis is stored in the object tables.; ///; /// ### Table of function codes and errors; ///; /// ~~~ {.cpp}; /// * functions :; ///; /// + 1 pow 20; /// - 2 sq 21; /// * 3 sqrt 22; /// / 4 strstr 23; /// % 5 min 24; /// max 25; /// log 30; /// cos 10 exp 31; /// sin 11 log10 32; /// tan 12; /// acos 13 abs 41; /// asin 14 sign 42; /// atan 15 int 43; /// atan2 16; /// fmod 17 rndm 50; ///; /// cosh 70 acosh 73; /// sinh 71 asinh 74; /// tanh 72 atanh 75; ///; /// expo 100 gaus 110 gausn (see note below); /// expo(0) 100 0 gaus(0) 110 0 gausn(0); /// expo(1) 100 1 gaus(1) 110 1 gausn(1); /// xexpo 100 x xgaus 110 x xgausn; /// yexpo 101 x ygaus 111 x ygausn; /// zexpo 102 x zgaus 112 x zgausn; /// xyexpo 105 x xygaus 115 x xygausn; /// yexpo(5) 102 5 ygaus(5) 111 5 ygausn(5); /// xyexpo(2) 105 2 xygaus(2) 115 2 xygausn(2); ///; /// landau 120 x landaun (see note below); /// landau(0) 120 0 landaun(0); /// landau(1) 120 1 landaun(1); /// xlandau 120 x xlandaun; /// ylandau 121 x ylandaun; /// zlandau 122 x zlandaun; /// xylandau 125 x xylandaun; /// ylandau(5) 121 5 ylandaun(5); /// xylandau(2) 125 2 xylandaun(2); ///; /// pol0 130 x pol1 130 1xx; /// pol0(0) 130 0 pol1(0) 130 100; /// pol0(1) 130 1 pol1(1) 130 101; /// xpol0 130 x xpol1 130 101; /// ypol0 131 x ypol1 131 101; /// zpol0 132 x zpol1 132 1xx; /// ypol0(5) 131 5 ypol1(5) 131 105; ///; /// pi 40; ///; /// && 60 < 64; /// || 61 > 65; /// == 62 <= 66; /// != 63 => 67; /// ! 68; /// ==(string) 76 & 78; /// !=(string) 77 | 79; /// <<(shift) 80 >>(shift) 81; /// ? : 82; ///; /// * constants (kConstants) :; ///; /// c0 141 1 c1 141 2 etc..; ///; /// * strings (kStringConst):; ///; /// sX 143 x; ///; /// * variables (kFormulaVar) :; ///; /// x 144 0 y 144 1 z 144 2 t 144 3; ///; /// * parameters :; ///; /// [1] 140 1; /// [2] 140 2; /// etc.; /// ~~~; ///; /// ### Special case,MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:4609,Usability,simpl,simple,4609," : Too many parameters; /// 10 : z specified but not x and y; /// 11 : z and y specified but not x; /// 12 : y specified but not x; /// 13 : z and x specified but not y; /// 20 : non integer value for parameter number; /// 21 : atan2 requires two arguments; /// 22 : pow requires two arguments; /// 23 : degree of polynomial not specified; /// 24 : Degree of polynomial must be positive; /// 25 : Degree of polynomial must be less than 20; /// 26 : Unknown name; /// 27 : Too many constants in expression; /// 28 : strstr requires two arguments; /// 29 : interpreted or compiled function have to return a numerical type; /// 30 : Bad numerical expression; /// 31 : Part of the variable exist but some of it is not accessible or useable; /// 40 : '(' is expected; /// 41 : ')' is expected; /// 42 : '[' is expected; /// 43 : ']' is expected; ///; /// \image html TFormula_analyze.png; ///; /// ### Special functions; ///; /// By default, the formula is assigned fNumber=0. However, the following; /// formula built with simple functions are assigned fNumber:; ///; /// ""gaus"" 100 (or gausn); /// ""xygaus"" 110; /// ""expo"" 200; /// ""polN"" 300+N; /// ""landau"" 400; /// ""xylandau"" 410; ///; /// Note that expressions like gaus(0), expo(1) will force fNumber=0; ///; /// ### Warning when deriving a class from TFormula; ///; /// If you overload this member function, you also HAVE TO; /// never call the constructor:; ///; /// ~~~ {.cpp}; /// TFormula::TFormula(const char *name,const char *expression); /// ~~~; ///; /// and write your own constructor; ///; /// ~~~ {.cpp}; /// MyClass::MyClass(const char *name,const char *expression) : TFormula(); /// ~~~; ///; /// which has to call the TFormula default constructor and whose implementation; /// should be similar to the implementation of the normal TFormula constructor; ///; /// This is necessary because the normal TFormula constructor call indirectly; /// the virtual member functions Analyze, DefaultString, DefaultValue; /// and DefaultVariable.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:12,Usability,simpl,simple,12,"// Look for simple operators",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:17,Security,authoriz,authorized,17,"// Character not authorized within a template parameter",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:126,Availability,error,error,126,"// The previous implementation allowed a '.' in the exponent.; // That information was ignored (by sscanf), we now make it an error; // hasDot = kFALSE;",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:32,Modifiability,variab,variable,32,"// Check if chaine is a defined variable.; // Note that DefinedVariable can be overloaded",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:3,Availability,Error,Error,3,"// Error message already issued",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Integrability,message,message,9,"// Error message already issued",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:29,Availability,error,error,29,"// The '||err' is to grab an error coming from AnalyzeFunction",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:3,Availability,error,errors,3,"// errors!",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Availability,error,errors,9,"// if no errors, copy local parameters to formula objects",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:29,Energy Efficiency,allocate,allocated,29,"// Here we shrink the arrays allocated like this:; // fExpr = new TString[gMAXOP];; // fConst = new Double_t[gMAXCONST];; // fParams = new Double_t[gMAXPAR];; // fNames = new TString[gMAXPAR];; // fOper = new Int_t[gMAXOP];; // fParams and fNames may be already 0, so we have to check.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:132,Modifiability,variab,variables,132,"////////////////////////////////////////////////////////////////////////////////; /// Check if expression is in the list of defined variables.; ///; /// This member function can be overloaded in derived classes; ///; /// If you overload this member function, you also HAVE TO; /// never call the constructor:; ///; /// ~~~ {.cpp}; /// TFormula::TFormula(const char *name,const char *expression); /// ~~~; ///; /// and write your own constructor; ///; /// ~~~ {.cpp}; /// MyClass::MyClass(const char *name,const char *expression) : TFormula(); /// ~~~; ///; /// which has to call the TFormula default constructor and whose implementation; /// should be similar to the implementation of the normal TFormula constructor; ///; /// This is necessary because the normal TFormula constructor call indirectly; /// the virtual member functions Analyze, DefaultString, DefaultValue; /// and DefaultVariable.; ///; /// The expected returns values are; /// - -2 : the name has been recognized but won't be usable; /// - -1 : the name has not been recognized; /// - >=0 : the name has been recognized, return the action parameter.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:994,Usability,usab,usable,994,"////////////////////////////////////////////////////////////////////////////////; /// Check if expression is in the list of defined variables.; ///; /// This member function can be overloaded in derived classes; ///; /// If you overload this member function, you also HAVE TO; /// never call the constructor:; ///; /// ~~~ {.cpp}; /// TFormula::TFormula(const char *name,const char *expression); /// ~~~; ///; /// and write your own constructor; ///; /// ~~~ {.cpp}; /// MyClass::MyClass(const char *name,const char *expression) : TFormula(); /// ~~~; ///; /// which has to call the TFormula default constructor and whose implementation; /// should be similar to the implementation of the normal TFormula constructor; ///; /// This is necessary because the normal TFormula constructor call indirectly; /// the virtual member functions Analyze, DefaultString, DefaultValue; /// and DefaultVariable.; ///; /// The expected returns values are; /// - -2 : the name has been recognized but won't be usable; /// - -1 : the name has not been recognized; /// - >=0 : the name has been recognized, return the action parameter.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:17,Modifiability,extend,extended,17,"// MI change; // extended defined variable (MI); //",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:34,Modifiability,variab,variable,34,"// MI change; // extended defined variable (MI); //",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:140,Modifiability,variab,variables,140,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate this formula.; ///; /// The current value of variables x,y,z,t is passed through x, y, z and t.; /// The parameters used will be the ones in the array params if params is given; /// otherwise parameters will be taken from the stored data members fParams",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:140,Modifiability,variab,variables,140,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate this formula.; ///; /// The current value of variables x,y,z,t is passed through the pointer x.; /// The parameters used will be the ones in the array params if params is given; /// otherwise parameters will be taken from the stored data members fParams; ///; /// \image html TFormula_eval.png",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:21,Performance,optimiz,optimizer,21,"// boolean operation optimizer",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:10,Usability,simpl,simplification,10,/* aucune simplification ! (sic) */,MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:510,Integrability,depend,depend,510,"////////////////////////////////////////////////////////////////////////////////; /// Reconstruct the formula expression from the internal TFormula member variables; ///; /// This function uses the internal member variables of TFormula to; /// construct the mathematical expression associated with the TFormula; /// instance. This function can be used to get an expanded version of the; /// expression originally assigned to the TFormula instance, i.e. that; /// the string returned by GetExpFormula() doesn't depend on other; /// TFormula object names.; ///; /// if option contains ""p"" the returned string will contain the formula; /// expression with symbolic parameters, eg [0] replaced by the actual value; /// of the parameter. Example:; /// if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; /// and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; /// ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))""",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:155,Modifiability,variab,variables,155,"////////////////////////////////////////////////////////////////////////////////; /// Reconstruct the formula expression from the internal TFormula member variables; ///; /// This function uses the internal member variables of TFormula to; /// construct the mathematical expression associated with the TFormula; /// instance. This function can be used to get an expanded version of the; /// expression originally assigned to the TFormula instance, i.e. that; /// the string returned by GetExpFormula() doesn't depend on other; /// TFormula object names.; ///; /// if option contains ""p"" the returned string will contain the formula; /// expression with symbolic parameters, eg [0] replaced by the actual value; /// of the parameter. Example:; /// if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; /// and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; /// ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))""",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:214,Modifiability,variab,variables,214,"////////////////////////////////////////////////////////////////////////////////; /// Reconstruct the formula expression from the internal TFormula member variables; ///; /// This function uses the internal member variables of TFormula to; /// construct the mathematical expression associated with the TFormula; /// instance. This function can be used to get an expanded version of the; /// expression originally assigned to the TFormula instance, i.e. that; /// the string returned by GetExpFormula() doesn't depend on other; /// TFormula object names.; ///; /// if option contains ""p"" the returned string will contain the formula; /// expression with symbolic parameters, eg [0] replaced by the actual value; /// of the parameter. Example:; /// if expression in formula is: ""[0]*(x>-[1])+[2]*exp(-[3]*x)""; /// and parameters are 3.25,-4.01,4.44,-0.04, GetExpFormula(""p"") will return:; /// ""(3.25*(x>+4.01))+(4.44*exp(+0.04*x))""",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:11,Performance,optimiz,optimization,11,"// Boolean optimization breakpoint",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:2,Usability,Simpl,Simple,2,"//Simple name (parameter,pol0,landau, etc)",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:13,Modifiability,variab,variables,13,"//constants, variables x,y,z,t, pi",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:64,Performance,Optimiz,Optimize,64,"// skip the implied multiplication.; // For consistency and for Optimize to work correctly; // we need to remove the ""-1"" string in fExpr",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:21,Performance,optimiz,optimizer,21,"// boolean operation optimizer",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:5,Modifiability,variab,variable,5,"// a variable",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:10,Modifiability,variab,variable,10,"// a tree variable",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:376,Modifiability,variab,variables,376,"////////////////////////////////////////////////////////////////////////////////; /// MI include; ///; /// Optimize formula; /// - Minimize the number of operands; /// 1. several operands are glued together; /// 2. some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); /// 3. maximize number of standard calls minimizing number of jumps in Eval cases; /// 4. variables, parameters and constants are mapped - using fOperOfssets0; /// Eval procedure use direct acces to data (only one corresponding case statement in eval procedure); /// ~~~ {.cpp}; /// pdata[operand={Var,Par,Const}][offset]; /// pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; /// ~~~; /// - The fastest evaluation function is chosen at the end; /// 1. fOptimal := pointer to the fastest function for given evaluation string; /// ~~~ {.cpp}; /// switch(GetActionOptimized(0)){; /// case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; /// case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; /// case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; /// case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; /// case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; /// }; /// ~~~; /// 2. ex.; /// - fOptimal = TFormula::EvalPrimitive0 - if it return only variable, constant or parameter; /// - = TFormula::EvalPrimitive1 - if only one unary operation; /// - = TFormula::EvalPrimitive2 - if only one binary operation",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:1406,Modifiability,variab,variable,1406,"////////////////////////////////////////////////////////////////////////////////; /// MI include; ///; /// Optimize formula; /// - Minimize the number of operands; /// 1. several operands are glued together; /// 2. some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); /// 3. maximize number of standard calls minimizing number of jumps in Eval cases; /// 4. variables, parameters and constants are mapped - using fOperOfssets0; /// Eval procedure use direct acces to data (only one corresponding case statement in eval procedure); /// ~~~ {.cpp}; /// pdata[operand={Var,Par,Const}][offset]; /// pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; /// ~~~; /// - The fastest evaluation function is chosen at the end; /// 1. fOptimal := pointer to the fastest function for given evaluation string; /// ~~~ {.cpp}; /// switch(GetActionOptimized(0)){; /// case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; /// case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; /// case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; /// case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; /// case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; /// }; /// ~~~; /// 2. ex.; /// - fOptimal = TFormula::EvalPrimitive0 - if it return only variable, constant or parameter; /// - = TFormula::EvalPrimitive1 - if only one unary operation; /// - = TFormula::EvalPrimitive2 - if only one binary operation",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:107,Performance,Optimiz,Optimize,107,"////////////////////////////////////////////////////////////////////////////////; /// MI include; ///; /// Optimize formula; /// - Minimize the number of operands; /// 1. several operands are glued together; /// 2. some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); /// 3. maximize number of standard calls minimizing number of jumps in Eval cases; /// 4. variables, parameters and constants are mapped - using fOperOfssets0; /// Eval procedure use direct acces to data (only one corresponding case statement in eval procedure); /// ~~~ {.cpp}; /// pdata[operand={Var,Par,Const}][offset]; /// pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; /// ~~~; /// - The fastest evaluation function is chosen at the end; /// 1. fOptimal := pointer to the fastest function for given evaluation string; /// ~~~ {.cpp}; /// switch(GetActionOptimized(0)){; /// case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; /// case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; /// case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; /// case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; /// case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; /// }; /// ~~~; /// 2. ex.; /// - fOptimal = TFormula::EvalPrimitive0 - if it return only variable, constant or parameter; /// - = TFormula::EvalPrimitive1 - if only one unary operation; /// - = TFormula::EvalPrimitive2 - if only one binary operation",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:7,Performance,optimiz,optimize,7,"//; // optimize booleans; //",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Performance,optimiz,optimized,9,"// to be optimized",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Performance,optimiz,optimized,9,"// to be optimized",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Performance,optimiz,optimized,9,"// to be optimized",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Performance,optimiz,optimized,9,"// to be optimized",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Performance,optimiz,optimized,9,"// to be optimized",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Performance,optimiz,optimized,9,"// to be optimized",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Performance,optimiz,optimized,9,"// to be optimized",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:9,Performance,optimiz,optimized,9,"// to be optimized",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:41,Performance,optimiz,optimize,41,"//; // Recalculate long jump for Boolean optimize; //",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:140,Modifiability,variab,variables,140,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate this formula.; ///; /// The current value of variables x,y,z,t is passed through the pointer x.; /// The parameters used will be the ones in the array params if params is given; /// otherwise parameters will be taken from the stored data members fParams; ///; /// \image html TFormula_eval.png",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:56,Performance,optimiz,optimize,56,"// use the fact that other were check before - see bool optimize",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:21,Performance,optimiz,optimizer,21,"// boolean operation optimizer",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:10,Usability,simpl,simplification,10,/* aucune simplification ! (sic) */,MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:615,Performance,perform,performance,615,"////////////////////////////////////////////////////////////////////////////////; /// static function to set the maximum value of 3 parameters; ///; /// - maxop : maximum number of operations; /// - maxpar : maximum number of parameters; /// - maxconst : maximum number of constants; ///; /// None of these parameters cannot be less than 10 (default is 1000); /// call this function to increase one or all maxima when processing; /// very complex formula, eg TFormula::SetMaxima(100000,1000,1000000);; /// If you process many functions with a small number of operations/parameters; /// you may gain some memory and performance by decreasing these values.",MatchSource.CODE_COMMENT,hist/hist/src/TFormula_v5.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:4534,Availability,error,errors,4534,"## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ## Using different histograms; It is possible to change the histogram being fitted through. fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through. fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). ## Errors; Any serious inconsistency results in an error.; */",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:4601,Availability,error,error,4601,"## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ## Using different histograms; It is possible to change the histogram being fitted through. fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through. fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). ## Errors; Any serious inconsistency results in an error.; */",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:5386,Availability,Error,Errors,5386,"## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ## Using different histograms; It is possible to change the histogram being fitted through. fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through. fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). ## Errors; Any serious inconsistency results in an error.; */",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:5434,Availability,error,error,5434,"## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ## Using different histograms; It is possible to change the histogram being fitted through. fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through. fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). ## Errors; Any serious inconsistency results in an error.; */",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3579,Deployability,Release,ReleaseRangeX,3579,"istribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). ## Applying constraints; Fit parameters can be constrained through. fit->Constrain(parameter #, lower bound, upper bound);. Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function. fit->Unconstrain(parameter #). is also provided to simplify this. ## Setting parameter values; The function. ROOT::Fit::Fitter* fitter = fit->GetFitter();. is provided for direct access to the ROOT::Fit::Fitter object. This allows to; set and fix parameter values, limits and set step sizes directly via. fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);. ## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3709,Deployability,Release,ReleaseRangeY,3709," and all fit parameters (the; template fractions) declared (initially unbounded). ## Applying constraints; Fit parameters can be constrained through. fit->Constrain(parameter #, lower bound, upper bound);. Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function. fit->Unconstrain(parameter #). is also provided to simplify this. ## Setting parameter values; The function. ROOT::Fit::Fitter* fitter = fit->GetFitter();. is provided for direct access to the ROOT::Fit::Fitter object. This allows to; set and fix parameter values, limits and set step sizes directly via. fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);. ## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a s",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3802,Deployability,Release,ReleaseRangeZ,3802,"ameters can be constrained through. fit->Constrain(parameter #, lower bound, upper bound);. Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function. fit->Unconstrain(parameter #). is also provided to simplify this. ## Setting parameter values; The function. ROOT::Fit::Fitter* fitter = fit->GetFitter();. is provided for direct access to the ROOT::Fit::Fitter object. This allows to; set and fix parameter values, limits and set step sizes directly via. fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);. ## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ##",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3324,Modifiability,Config,Config,3324,"ay result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). ## Instantiation; A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). ## Applying constraints; Fit parameters can be constrained through. fit->Constrain(parameter #, lower bound, upper bound);. Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function. fit->Unconstrain(parameter #). is also provided to simplify this. ## Setting parameter values; The function. ROOT::Fit::Fitter* fitter = fit->GetFitter();. is provided for direct access to the ROOT::Fit::Fitter object. This allows to; set and fix parameter values, limits and set step sizes directly via. fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);. ## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a ",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:1701,Performance,perform,perform,1701,"er; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. ~~~{.cpp}; {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }; ~~~. ## Assumptions; A few assumptions need to be made for the fit procedure to be carried out:; 1 The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; 2 The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). ## Instantiation; A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters ",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:566,Safety,predict,predictions,566,"// @(#)root/hist:$Id$; // Author: Frank Filthaut F.Filthaut@science.ru.nl 20/05/2002; // with additions by Bram Wijngaarden <dwijngaa@hef.kun.nl>; /** \class TFractionFitter; Fits MC fractions to data histogram. A la HMCMLL, see R. Barlow and C. Beeston,; Comp. Phys. Comm. 77 (1993) 219-228, and http://www.hep.man.ac.uk/~roger/hfrac.f. The virtue of this fit is that it takes into account both data and Monte Carlo; statistical uncertainties. The way in which this is done is through a standard; likelihood fit using Poisson statistics; however, the template (MC) predictions; are also varied within statistics, leading to additional contributions to the; overall likelihood. This leads to many more fit parameters (one per bin per; template), but the minimisation with respect to these additional parameters is; done analytically rather than introducing them as formal fit parameters. Some; special care needs to be taken in the case of bins with zero content. For more; details please see the original publication cited above. An example application of this fit is given below. For a TH1* histogram; (""data"") fitted as the sum of three Monte Carlo sources (""mc""):. ~~~{.cpp}; {; TH1F *data; //data histogram; TH1F *mc0; // first MC histogram; TH1F *mc1; // second MC histogram; TH1F *mc2; // third MC histogram; .... // retrieve histograms; TObjArray *mc = new TObjArray(3); // MC histograms are put in this array; mc->Add(mc0);; mc->Add(mc1);; mc->Add(mc2);; TFractionFitter* fit = new TFractionFitter(data, mc); // initialise; fit->Constrain(1,0.0,1.0); // constrain fraction 1 to be between 0 and 1; fit->SetRangeX(1,15); // use only the first 15 bins in the fit; Int_t status = fit->Fit(); // perform the fit; std::cout << ""fit status: "" << status << std::endl;; if (status == 0) { // check on fit status; TH1F* result = (TH1F*) fit->GetPlot();; data->Draw(""Ep"");; result->Draw(""same"");; }; }; ~~~. ## Assumptions; A few assumptions need to be made for the fit procedure to be carried out:; 1 ",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:4667,Safety,predict,prediction,4667,"## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ## Using different histograms; It is possible to change the histogram being fitted through. fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through. fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). ## Errors; Any serious inconsistency results in an error.; */",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3190,Security,access,access,3190,"ts in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). ## Instantiation; A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). ## Applying constraints; Fit parameters can be constrained through. fit->Constrain(parameter #, lower bound, upper bound);. Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function. fit->Unconstrain(parameter #). is also provided to simplify this. ## Setting parameter values; The function. ROOT::Fit::Fitter* fitter = fit->GetFitter();. is provided for direct access to the ROOT::Fit::Fitter object. This allows to; set and fix parameter values, limits and set step sizes directly via. fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);. ## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified;",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3062,Usability,simpl,simplify,3062,"all; (so that its Poisson uncertainty can be neglected).; 2 The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). ## Instantiation; A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). ## Applying constraints; Fit parameters can be constrained through. fit->Constrain(parameter #, lower bound, upper bound);. Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function. fit->Unconstrain(parameter #). is also provided to simplify this. ## Setting parameter values; The function. ROOT::Fit::Fitter* fitter = fit->GetFitter();. is provided for direct access to the ROOT::Fit::Fitter object. This allows to; set and fix parameter values, limits and set step sizes directly via. fitter->Config().ParSettings(parameter #).Set(const std::string &name, double value, double step, double lower, double upper);. ## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corre",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:4707,Usability,simpl,simple,4707,"## Restricting the fit range; The fit range can be restricted through. fit->SetRangeX(first bin #, last bin #);; and freed using. fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using. fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also. fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through. fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding. fit->IncludeBin(bin #);. ## Weights histograms; Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through. fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. ## Obtaining fit results; The fit is carried out through. Int_t status = fit->Fit();; where status is the code returned from the ""MINIMIZE"" command. For fits; that converged, parameter values and errors can be obtained through. fit->GetResult(parameter #, value, error);; and the histogram corresponding to the total Monte Carlo prediction (which; is not the same as a simple weighted sum of the input Monte Carlo distributions); can be obtained by. TH1* result = fit->GetPlot();; ## Using different histograms; It is possible to change the histogram being fitted through. fit->SetData(TH1* data);; and to change the template histogram for a given parameter number through. fit->SetMC(parameter #, TH1* MC);; This can speed up code in case of multiple data or template histograms;; however, it should be done with care as any settings are taken over from; the previous fit. In addition, neither the dimensionality nor the numbers of; bins of the histograms should change (in that case it is better to instantiate; a new TFractionFitter object). ## Errors; Any serious inconsistency results in an error.; */",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:614,Integrability,message,message,614,"////////////////////////////////////////////////////////////////////////////////; /// TFractionFitter constructor. Does a complete initialisation (including; /// consistency checks, default fit range as the whole histogram but without; /// under- and overflows, and declaration of the fit parameters). Note that; /// the histograms are not copied, only references are used.; /// \param[in] data histogram to be fitted; /// \param[in] MCs array of TH1* corresponding template distributions; /// \param[in] option can be used to control the print level of the minimization algorithm; /// - option = ""Q"" : quite - no message is printed; /// - option = ""V"" : verbose - max print out; /// - option = """" : default: print initial fraction values and result",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:33,Safety,predict,prediction,33,"// Histogram containing template prediction",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:279,Availability,error,error,279,"////////////////////////////////////////////////////////////////////////////////; /// Change the histogram to be fitted to. Notes:; /// - Parameter constraints and settings are retained from a possible previous fit.; /// - Modifying the dimension or number of bins results in an error (in this case; /// rather instantiate a new TFractionFitter object)",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:292,Availability,error,error,292,"////////////////////////////////////////////////////////////////////////////////; /// Change the histogram for template number `<parm>`. Notes:; /// - Parameter constraints and settings are retained from a possible previous fit.; /// - Modifying the dimension or number of bins results in an error (in this case; /// rather instantiate a new TFractionFitter object)",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:371,Availability,error,error,371,"////////////////////////////////////////////////////////////////////////////////; /// Set bin by bin weights for template number `<parm>` (the parameter numbering; /// follows that of the input template vector).; /// Weights can be ""unset"" by passing a null pointer.; /// Consistency of the weights histogram with the data histogram is checked at; /// this point, and an error in case of problems.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:98,Security,access,access,98,"////////////////////////////////////////////////////////////////////////////////; /// Give direct access to the underlying fitter class. This can be; /// used e.g. to modify parameter values or step sizes.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:181,Availability,error,error,181,"////////////////////////////////////////////////////////////////////////////////; /// Function for internal use, checking parameter validity; /// An invalid parameter results in an error.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:151,Deployability,Release,ReleaseRangeX,151,"////////////////////////////////////////////////////////////////////////////////; /// Set the X range of the histogram to be used in the fit.; /// Use ReleaseRangeX() to go back to fitting the full histogram.; /// The consistency check ensures that no empty fit range occurs (and also; /// recomputes the bin content integrals).; /// \param[in] low lower X bin number; /// \param[in] high upper X bin number",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:86,Deployability,Release,Release,86,"////////////////////////////////////////////////////////////////////////////////; /// Release restrictions on the X range of the histogram to be used in the fit.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:178,Deployability,Release,ReleaseRangeY,178,"////////////////////////////////////////////////////////////////////////////////; /// Set the Y range of the histogram to be used in the fit (2D or 3D histograms only).; /// Use ReleaseRangeY() to go back to fitting the full histogram.; /// The consistency check ensures that no empty fit range occurs (and also; /// recomputes the bin content integrals).; /// \param[in] low lower X bin number; /// \param[in] high upper X bin number",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:86,Deployability,Release,Release,86,"////////////////////////////////////////////////////////////////////////////////; /// Release restrictions on the Y range of the histogram to be used in the fit.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:172,Deployability,Release,ReleaseRangeY,172,"////////////////////////////////////////////////////////////////////////////////; /// Set the Z range of the histogram to be used in the fit (3D histograms only).; /// Use ReleaseRangeY() to go back to fitting the full histogram.; /// The consistency check ensures that no empty fit range occurs (and also; /// recomputes the bin content integrals).; /// \param[in] low lower X bin number; /// \param[in] high upper X bin number",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:86,Deployability,Release,Release,86,"////////////////////////////////////////////////////////////////////////////////; /// Release restrictions on the Z range of the histogram to be used in the fit.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:396,Availability,error,error,396,"////////////////////////////////////////////////////////////////////////////////; /// Function used internally to check the consistency between the; /// various histograms. Checks are performed on nonexistent or empty; /// histograms, the precise histogram class, and the number of bins.; /// In addition, integrals over the ""allowed"" bin ranges are computed.; /// Any inconsistency results in a error.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:184,Performance,perform,performed,184,"////////////////////////////////////////////////////////////////////////////////; /// Function used internally to check the consistency between the; /// various histograms. Checks are performed on nonexistent or empty; /// histograms, the precise histogram class, and the number of bins.; /// In addition, integrals over the ""allowed"" bin ranges are computed.; /// Any inconsistency results in a error.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:86,Performance,Perform,Perform,86,"////////////////////////////////////////////////////////////////////////////////; /// Perform the fit with the default UP value.; /// The value returned is the minimisation status.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:137,Performance,perform,perform,137,"////////////////////////////////////////////////////////////////////////////////; /// Set UP to the given value (see class TMinuit), and perform a MINOS minimisation.",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:107,Safety,predict,prediction,107,"////////////////////////////////////////////////////////////////////////////////; /// Return the ""template prediction"" corresponding to the fit result (this is not; /// the same as the weighted sum of template distributions, as template statistical; /// uncertainties are taken into account).; /// Note that the name of this histogram will simply be the same as that of the; /// ""data"" histogram, prefixed with the string ""Fraction fit to hist: "".; /// Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; /// the class is deleted",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:340,Usability,simpl,simply,340,"////////////////////////////////////////////////////////////////////////////////; /// Return the ""template prediction"" corresponding to the fit result (this is not; /// the same as the weighted sum of template distributions, as template statistical; /// uncertainties are taken into account).; /// Note that the name of this histogram will simply be the same as that of the; /// ""data"" histogram, prefixed with the string ""Fraction fit to hist: "".; /// Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; /// the class is deleted",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:18,Safety,predict,predictions,18,"// Solve for the ""predictions""",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:134,Safety,predict,prediction,134,"////////////////////////////////////////////////////////////////////////////////; /// Function used internally to obtain the template prediction in the individual bins; /// 'bin' <=> 'i' (paper); /// 'par' <=> 'j' (paper)",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:53,Performance,Cache,Cache,53,"// number of events in the real data for bin 'i'; // Cache the weighted fractions and the number of observed MC events; // Sanity check: none of the fractions should be == 0",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:123,Safety,Sanity check,Sanity check,123,"// number of events in the real data for bin 'i'; // Cache the weighted fractions and the number of observed MC events; // Sanity check: none of the fractions should be == 0",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:3,Deployability,update,update,3,"// update delta",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:17,Safety,predict,prediction,17,"// likelihood of prediction",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:208,Safety,predict,prediction,208,"////////////////////////////////////////////////////////////////////////////////; /// Return the adjusted MC template (Aji) for template (parm).; /// Note that the (Aji) times fractions only sum to the total prediction; /// of the fit if all weights are 1.; /// Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; /// the class is deleted",MatchSource.CODE_COMMENT,hist/hist/src/TFractionFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:1346,Integrability,depend,depending,1346,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraph; \ingroup Graphs; A TGraph is an object made of two arrays X and Y with npoints each.; The TGraph painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. #### Notes. - Unlike histogram or tree (or even TGraph2D), TGraph objects; are not automatically attached to the current TFile, in order to keep the; management and size of the TGraph as small as possible.; - The TGraph constructors do not have the TGraph title and name as parameters.; A TGraph has the default title and name ""Graph"". To change the default title; and name `SetTitle` and `SetName` should be called on the TGraph after its creation.; TGraph was a light weight object to start with, like TPolyline or TPolyMarker.; Thats why it did not have any title and name parameters in the constructors. #### Example. The picture below gives an example:. Begin_Macro(source); {; double x[100], y[100];; int n = 20;; for (int i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; auto g = new TGraph(n,x,y);; g->SetTitle(""Graph title;X title;Y title"");; g->Draw(""AC*"");; }; End_Macro. #### Default X-Points. If one doesn't specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending; on the length of the y-points):. Begin_Macro(source); {; double y[6] = {3, 8, 1, 10, 5, 7};; auto g = new TGraph(6,y);; g->SetTitle(""A Graph with default X points"");; g->Draw();; }; End_Macro. */; ////////////////////////////////////////////////////////////////////////////////; /// Graph default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:210,Performance,perform,performed,210,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraph; \ingroup Graphs; A TGraph is an object made of two arrays X and Y with npoints each.; The TGraph painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. #### Notes. - Unlike histogram or tree (or even TGraph2D), TGraph objects; are not automatically attached to the current TFile, in order to keep the; management and size of the TGraph as small as possible.; - The TGraph constructors do not have the TGraph title and name as parameters.; A TGraph has the default title and name ""Graph"". To change the default title; and name `SetTitle` and `SetName` should be called on the TGraph after its creation.; TGraph was a light weight object to start with, like TPolyline or TPolyMarker.; Thats why it did not have any title and name parameters in the constructors. #### Example. The picture below gives an example:. Begin_Macro(source); {; double x[100], y[100];; int n = 20;; for (int i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; auto g = new TGraph(n,x,y);; g->SetTitle(""Graph title;X title;Y title"");; g->Draw(""AC*"");; }; End_Macro. #### Default X-Points. If one doesn't specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending; on the length of the y-points):. Begin_Macro(source); {; double y[6] = {3, 8, 1, 10, 5, 7};; auto g = new TGraph(6,y);; g->SetTitle(""A Graph with default X points"");; g->Draw();; }; End_Macro. */; ////////////////////////////////////////////////////////////////////////////////; /// Graph default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:709,Safety,avoid,avoid,709,"////////////////////////////////////////////////////////////////////////////////; /// Graph constructor reading input from filename.; ///; /// `filename` is assumed to contain at least two columns of numbers.; /// The string format is by default `""%lg %lg""`.; /// This is a standard c formatting for `scanf()`.; /// For example, set format to `""%lg,%lg""` for a comma-separated file.; ///; /// If columns of numbers should be skipped, a `""%*lg""` or `""%*s""` for each column; /// can be added, e.g. `""%lg %*lg %lg""` would read x-values from the first and; /// y-values from the third column.; ///; /// For files separated by a specific delimiter different from ' ' and '\\t' (e.g.; /// ';' in csv files) you can avoid using `%*s` to bypass this delimiter by explicitly; /// specify the `option` argument,; /// e.g. option=`"" \\t,;""` for columns of figures separated by any of these characters; /// (' ', '\\t', ',', ';'); /// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; /// Note in that case, the instantiation is about two times slower.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:45,Availability,error,error,45,"//first condition not to repeat the previous error message",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:51,Integrability,message,message,51,"//first condition not to repeat the previous error message",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:21,Modifiability,variab,variables,21,"// Initializing loop variables",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:10,Testability,log,logic,10,"//special logic to support the case where the same object is; //added multiple times in fFunctions.; //This case happens when the same object is added with different; //drawing modes",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5,Safety,avoid,avoid,5,"//to avoid accessing a deleted object in RecursiveRemove",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:11,Security,access,accessing,11,"//to avoid accessing a deleted object in RecursiveRemove",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:86,Energy Efficiency,Allocate,Allocate,86,"////////////////////////////////////////////////////////////////////////////////; /// Allocate internal data structures for `newsize` points.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:86,Energy Efficiency,Allocate,Allocate,86,"////////////////////////////////////////////////////////////////////////////////; /// Allocate arrays.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:135,Availability,Error,Errors,135,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `y = y + c1*f(x,y)`; /// Errors are not recalculated.; ///; /// \param f may be a 1-D function TF1 or 2-d function TF2; /// \param c1 a scaling factor, 1 by default",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `y = y + c1*f(x,y)`; /// Errors are not recalculated.; ///; /// \param f may be a 1-D function TF1 or 2-d function TF2; /// \param c1 a scaling factor, 1 by default",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:472,Availability,error,errors,472,"////////////////////////////////////////////////////////////////////////////////; /// Return the chisquare of this graph with respect to f1.; /// The chisquare is computed as the sum of the quantity below at each point:; /// \f[; /// \frac{(y-f1(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f1'(x))^{2}}; /// \f]; /// where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; /// This method to approximate the uncertainty in y because of the errors in x, is called; /// ""effective variance"" method.; /// In case of a pure TGraph, the denominator is 1.; /// In case of a TGraphErrors or TGraphAsymmErrors the errors are taken; /// into account.; /// By default the range of the graph is used whatever function range.; /// Use option ""R"" to use the function range",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:638,Availability,error,errors,638,"////////////////////////////////////////////////////////////////////////////////; /// Return the chisquare of this graph with respect to f1.; /// The chisquare is computed as the sum of the quantity below at each point:; /// \f[; /// \frac{(y-f1(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f1'(x))^{2}}; /// \f]; /// where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; /// This method to approximate the uncertainty in y because of the errors in x, is called; /// ""effective variance"" method.; /// In case of a pure TGraph, the denominator is 1.; /// In case of a TGraphErrors or TGraphAsymmErrors the errors are taken; /// into account.; /// By default the range of the graph is used whatever function range.; /// Use option ""R"" to use the function range",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:37,Testability,log,log,37,"// Positive minimum. Used in case of log scale along X axis.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:37,Testability,log,log,37,"// Positive minimum. Used in case of log scale along Y axis.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3,Availability,Error,Error,3,"// Error;",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:49,Usability,simpl,simply,49,"// case TGraph is not sorted; // find neighbours simply looping all points; // and find also the 2 adjacent points: (low2 < low < x < up < up2 ); // needed in case x is outside the graph ascissa interval",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:326,Deployability,release,released,326,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when a graph is clicked with the locator; ///; /// If Left button clicked on one of the line end points, this point; /// follows the cursor until button is released.; ///; /// if Middle button clicked, the line is moved parallel to itself; /// until the button is released.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:434,Deployability,release,released,434,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when a graph is clicked with the locator; ///; /// If Left button clicked on one of the line end points, this point; /// follows the cursor until button is released.; ///; /// if Middle button clicked, the line is moved parallel to itself; /// until the button is released.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:105,Energy Efficiency,allocate,allocate,105,"////////////////////////////////////////////////////////////////////////////////; /// if size > fMaxSize allocate new arrays of 2*size points and copy iend first; /// points.; /// Return pointer to new arrays.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:866,Availability,error,errors,866,"////////////////////////////////////////////////////////////////////////////////; /// Fit this graph with function f1.; ///; /// \param[in] f1 pointer to the function object; /// \param[in] option string defining the fit options (see table below).; /// \param[in] goption specify a list of graphics options. See TGraph::Draw and TGraphPainter for a complete list of these possible options.; /// \param[in] rxmin lower fitting range; /// \param[in] rxmax upper fitting range; ///; /// \anchor GFitOpt; /// ### Graph Fitting Options; /// The list of fit options is given in parameter option.; ///; /// option | description; /// -------|------------; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting ra",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:1217,Availability,error,errors,1217,"on string defining the fit options (see table below).; /// \param[in] goption specify a list of graphics options. See TGraph::Draw and TGraphPainter for a complete list of these possible options.; /// \param[in] rxmin lower fitting range; /// \param[in] rxmax upper fitting range; ///; /// \anchor GFitOpt; /// ### Graph Fitting Options; /// The list of fit options is given in parameter option.; ///; /// option | description; /// -------|------------; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; /// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:1324,Availability,avail,available,1324,"h::Draw and TGraphPainter for a complete list of these possible options.; /// \param[in] rxmin lower fitting range; /// \param[in] rxmax upper fitting range; ///; /// \anchor GFitOpt; /// ### Graph Fitting Options; /// The list of fit options is given in parameter option.; ///; /// option | description; /// -------|------------; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; /// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.; /// ""C"" | In case of linear f",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:2632,Availability,error,errors,2632,"""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; /// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is th",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:2741,Availability,robust,robust,2741,"""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; /// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is th",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3066,Availability,error,errors,3066,"ption when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits are set.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///;",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3204,Availability,error,error,3204,"tions, some default initial values and limits are set.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the lin",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3430,Availability,error,errors,3430,"Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (con",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3454,Availability,error,error,3454,"Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (con",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3651,Availability,error,error,3651,"Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (con",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3987,Availability,error,errors,3987,"raphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (contains the `++` sign) or the fitting; /// function is a polynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in paramete",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:4160,Availability,error,errors,4160,"f the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (contains the `++` sign) or the fitting; /// function is a polynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with th",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:4196,Availability,error,error,4196,"f the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (contains the `++` sign) or the fitting; /// function is a polynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with th",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5133,Availability,robust,robust,5133,"he; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (contains the `++` sign) or the fitting; /// function is a polynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the ",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5693,Availability,error,error,5693,"ynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the following; /// formula:; /// `parameter_error *= sqrt(chisquare/(ndf-1))`; ///; /// ### General Fitting documentation; ///; /// See in TH1::Fit for the documentation of; /// - [Fit Result](\ref HFitRes); /// - [Fit Status](\ref HFitStatus); /// - [Fit Statistics Box](\ref HFitStatBox); /// - [Fitting in a Range](\ref HFitRange); /// - [Setting Initial Conditions](\ref HFitInitial)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5819,Availability,error,errors,5819,"ynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the following; /// formula:; /// `parameter_error *= sqrt(chisquare/(ndf-1))`; ///; /// ### General Fitting documentation; ///; /// See in TH1::Fit for the documentation of; /// - [Fit Result](\ref HFitRes); /// - [Fit Status](\ref HFitStatus); /// - [Fit Statistics Box](\ref HFitStatBox); /// - [Fitting in a Range](\ref HFitRange); /// - [Setting Initial Conditions](\ref HFitInitial)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5893,Availability,error,errors,5893,"ynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the following; /// formula:; /// `parameter_error *= sqrt(chisquare/(ndf-1))`; ///; /// ### General Fitting documentation; ///; /// See in TH1::Fit for the documentation of; /// - [Fit Result](\ref HFitRes); /// - [Fit Status](\ref HFitStatus); /// - [Fit Statistics Box](\ref HFitStatBox); /// - [Fitting in a Range](\ref HFitRange); /// - [Setting Initial Conditions](\ref HFitInitial)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5937,Availability,error,errors,5937,"ynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the following; /// formula:; /// `parameter_error *= sqrt(chisquare/(ndf-1))`; ///; /// ### General Fitting documentation; ///; /// See in TH1::Fit for the documentation of; /// - [Fit Result](\ref HFitRes); /// - [Fit Status](\ref HFitStatus); /// - [Fit Statistics Box](\ref HFitStatBox); /// - [Fitting in a Range](\ref HFitRange); /// - [Setting Initial Conditions](\ref HFitInitial)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:6047,Availability,error,errors,6047,"ynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the following; /// formula:; /// `parameter_error *= sqrt(chisquare/(ndf-1))`; ///; /// ### General Fitting documentation; ///; /// See in TH1::Fit for the documentation of; /// - [Fit Result](\ref HFitRes); /// - [Fit Status](\ref HFitStatus); /// - [Fit Statistics Box](\ref HFitStatBox); /// - [Fitting in a Range](\ref HFitRange); /// - [Setting Initial Conditions](\ref HFitInitial)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:6119,Availability,error,errors,6119,"ynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the following; /// formula:; /// `parameter_error *= sqrt(chisquare/(ndf-1))`; ///; /// ### General Fitting documentation; ///; /// See in TH1::Fit for the documentation of; /// - [Fit Result](\ref HFitRes); /// - [Fit Status](\ref HFitStatus); /// - [Fit Statistics Box](\ref HFitStatBox); /// - [Fitting in a Range](\ref HFitRange); /// - [Setting Initial Conditions](\ref HFitInitial)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:1189,Performance,Perform,Performs,1189,"on string defining the fit options (see table below).; /// \param[in] goption specify a list of graphics options. See TGraph::Draw and TGraphPainter for a complete list of these possible options.; /// \param[in] rxmin lower fitting range; /// \param[in] rxmax upper fitting range; ///; /// \anchor GFitOpt; /// ### Graph Fitting Options; /// The list of fit options is given in parameter option.; ///; /// option | description; /// -------|------------; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""W"" | Ignore all point errors when fitting a TGraphErrors or TGraphAsymmErrors; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; /// ""B"" | Use this option when you want to fix one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3225,Performance,perform,performed,3225,"tions, some default initial values and limits are set.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the lin",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5123,Performance,perform,perform,5123,"he; /// errors in x is to make it equal the error in x times the slope of the line.; /// This approach is called ""effective variance method"" and; /// the implementation is provided in the function FitUtil::EvaluateChi2Effective; ///; /// \anchor GFitLinear; /// ### Linear fitting:; /// When the fitting function is linear (contains the `++` sign) or the fitting; /// function is a polynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the ",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3173,Usability,simpl,simple,3173,"tions, some default initial values and limits are set.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""EX0"" | When fitting a TGraphErrors or TGraphAsymErrors do not consider errors in the X coordinates; /// ""ROB"" | In case of linear fitting, compute the LTS regression coefficients (robust (resistant) regression), using the default fraction of good points ""ROB=0.x"" - compute the LTS regression coefficients, using 0.x as a fraction of good points; ///; ///; /// This function is used for fitting also the derived TGraph classes such as TGraphErrors or TGraphAsymmErrors.; /// See the note below on how the errors are used when fitting a TGraphErrors or TGraphAsymmErrors.; ///; /// The fitting of the TGraph, i.e simple data points without any error associated, is performed using the; /// un-weighted least-square (chi-square) method.; ///; ///; ///\anchor GFitErrors; /// ### TGraphErrors fit:; ///; /// In case of a TGraphErrors or TGraphAsymmErrors object, when `x` errors are present, the error along x,; /// is projected along the y-direction by calculating the function at the points `x-ex_low` and; /// `x+ex_high`, where `ex_low` and `ex_high` are the corresponding lower and upper error in x.; /// The chi-square is then computed as the sum of the quantity below at each data point:; ///; /// \f[; /// \frac{(y-f(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f'(x))^{2}}; /// \f]; ///; /// where `x` and `y` are the point coordinates, and `f'(x)` is the derivative of the; /// function `f(x)`.; ///; /// In case of asymmetric errors, if the function lies below (above) the data point, `ey` is `ey_low` (`ey_high`).; ///; /// The approach used to approximate the uncertainty in y because of the; /// errors in x is to make it equal the error in x times the slope of the lin",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:5393,Usability,simpl,simple,5393,"/// When the fitting function is linear (contains the `++` sign) or the fitting; /// function is a polynomial, a linear fitter is initialised.; /// To create a linear function, use the following syntax: linear parts; /// separated by `++` sign.; /// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; /// TF1 object as; ///; /// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; ///; /// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; /// Going via the linear fitter for functions, linear in parameters, gives a; /// considerable advantage in speed.; /// When using the linear fitting it is also possible to perform a robust fitting with the; /// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; /// See the tutorial `fitLinearRobust.C`.; ///; /// ### Notes on TGraph/TGraphErrors Fitting:; ///; /// 1. By using the ""effective variance"" method a simple linear regression; /// becomes a non-linear case, which takes several iterations; /// instead of 0 as in the linear case.; /// 2. The effective variance technique assumes that there is no correlation; /// between the x and y coordinate.; /// 3. The standard chi2 (least square) method without error in the coordinates (x) can; /// be forced by using option ""EX0""; /// 4. The linear fitter doesn't take into account the errors in x. When fitting a; /// TGraphErrors with a linear functions the errors in x will not be considered.; /// If errors in x are important, use option ""F"" for linear function fitting.; /// 5. When fitting a TGraph (i.e. no errors associated with each point),; /// a correction is applied to the errors on the parameters with the following; /// formula:; /// `parameter_error *= sqrt(chisquare/(ndf-1))`; ///; /// ### General Fitting documentation; ///; /// See in TH1::Fit for the documentation of; /// - [Fit Result](\ref HFitRes); /// - [Fit Status](\ref HFitStatus); /// - [Fit Statistics Box](\ref HFitStatB",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:164,Integrability,interface,interface,164,"////////////////////////////////////////////////////////////////////////////////; /// Fit this graph with function with name `fname`.; ///; /// This is a different interface to TGraph fitting using TGraph::Fit(TF1 *f1,Option_t *, Option_t *, Axis_t, Axis_t); /// See there for the details about fitting a TGraph.; ///; /// The parameter `fname` is the name of an already predefined function created by TF1 or TF2; /// Predefined functions such as gaus, expo and poln are automatically; /// created by ROOT.; ///; /// The parameter `fname` can also be a formula, accepted by the linear fitter (linear parts divided; /// by ""++"" sign), for example ""x++sin(x)"" for fitting ""[0]*x+[1]*sin(x)""",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:7,Modifiability,plugin,plugin,7,"// use plugin manager to create instance of TFitEditor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:73,Testability,log,log,73,"//this is redefined in TGraphErrors; // (if fHistogram exist) && (if the log scale is on) &&; // (if the computed range minimum is > 0) && (if the fHistogram minimum is zero); // then it means fHistogram limits have been computed in linear scale; // therefore they might be too strict and cut some points. In that case the; // fHistogram limits should be recomputed ie: the existing fHistogram; // should not be returned.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:139,Safety,avoid,avoid,139,"// do not add the histogram to gDirectory; // use local TDirectory::TContect that will set temporarly gDirectory to a nullptr and; // will avoid that histogram is added in the global directory",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:162,Energy Efficiency,Adapt,Adapted,162,"////////////////////////////////////////////////////////////////////////////////; /// Implementation to get information on point of graph at cursor position; /// Adapted from class TH1",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:162,Modifiability,Adapt,Adapted,162,"////////////////////////////////////////////////////////////////////////////////; /// Implementation to get information on point of graph at cursor position; /// Adapted from class TH1",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:6,Safety,avoid,avoid,6,"// To avoid redefinitions in descendant classes",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:86,Deployability,Integrat,Integrate,86,"////////////////////////////////////////////////////////////////////////////////; /// Integrate the TGraph data within a given (index) range.; /// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; /// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; /// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; /// with the first one. It is clear that the order of the point is essential in defining the polygon.; /// Also note that the segments should not intersect.; ///; /// NB:; /// - if last=-1 (default) last is set to the last point.; /// - if (first <0) the first point (0) is taken.; ///; /// ### Method:; ///; /// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; /// you have to deal with. The most evident solution would be to divide the polygon in triangles and; /// calculate the surface of them. But this can quickly become complicated as you will have to test; /// every segments of every triangles and check if they are intersecting with a current polygon's; /// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; ///; /// ### The solution (implemented by R.Brun); /// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; /// segments don't intersect.; /// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; /// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; /// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; ///; /// ### Sources; /// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; /// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:86,Integrability,Integrat,Integrate,86,"////////////////////////////////////////////////////////////////////////////////; /// Integrate the TGraph data within a given (index) range.; /// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; /// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; /// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; /// with the first one. It is clear that the order of the point is essential in defining the polygon.; /// Also note that the segments should not intersect.; ///; /// NB:; /// - if last=-1 (default) last is set to the last point.; /// - if (first <0) the first point (0) is taken.; ///; /// ### Method:; ///; /// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; /// you have to deal with. The most evident solution would be to divide the polygon in triangles and; /// calculate the surface of them. But this can quickly become complicated as you will have to test; /// every segments of every triangles and check if they are intersecting with a current polygon's; /// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; ///; /// ### The solution (implemented by R.Brun); /// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; /// segments don't intersect.; /// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; /// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; /// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; ///; /// ### Sources; /// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; /// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:851,Integrability,depend,depends,851,"////////////////////////////////////////////////////////////////////////////////; /// Integrate the TGraph data within a given (index) range.; /// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; /// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; /// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; /// with the first one. It is clear that the order of the point is essential in defining the polygon.; /// Also note that the segments should not intersect.; ///; /// NB:; /// - if last=-1 (default) last is set to the last point.; /// - if (first <0) the first point (0) is taken.; ///; /// ### Method:; ///; /// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; /// you have to deal with. The most evident solution would be to divide the polygon in triangles and; /// calculate the surface of them. But this can quickly become complicated as you will have to test; /// every segments of every triangles and check if they are intersecting with a current polygon's; /// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; ///; /// ### The solution (implemented by R.Brun); /// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; /// segments don't intersect.; /// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; /// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; /// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; ///; /// ### Sources; /// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; /// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:1078,Testability,test,test,1078,"////////////////////////////////////////////////////////////////////////////////; /// Integrate the TGraph data within a given (index) range.; /// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; /// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; /// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; /// with the first one. It is clear that the order of the point is essential in defining the polygon.; /// Also note that the segments should not intersect.; ///; /// NB:; /// - if last=-1 (default) last is set to the last point.; /// - if (first <0) the first point (0) is taken.; ///; /// ### Method:; ///; /// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; /// you have to deal with. The most evident solution would be to divide the polygon in triangles and; /// calculate the surface of them. But this can quickly become complicated as you will have to test; /// every segments of every triangles and check if they are intersecting with a current polygon's; /// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; ///; /// ### The solution (implemented by R.Brun); /// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; /// segments don't intersect.; /// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; /// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; /// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; ///; /// ### Sources; /// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; /// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:502,Usability,clear,clear,502,"////////////////////////////////////////////////////////////////////////////////; /// Integrate the TGraph data within a given (index) range.; /// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; /// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; /// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; /// with the first one. It is clear that the order of the point is essential in defining the polygon.; /// Also note that the segments should not intersect.; ///; /// NB:; /// - if last=-1 (default) last is set to the last point.; /// - if (first <0) the first point (0) is taken.; ///; /// ### Method:; ///; /// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; /// you have to deal with. The most evident solution would be to divide the polygon in triangles and; /// calculate the surface of them. But this can quickly become complicated as you will have to test; /// every segments of every triangles and check if they are intersecting with a current polygon's; /// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; ///; /// ### The solution (implemented by R.Brun); /// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; /// segments don't intersect.; /// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; /// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; /// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; ///; /// ### Sources; /// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; /// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:1371,Usability,simpl,simple,1371,"////////////////////////////////////////////////////////////////////////////////; /// Integrate the TGraph data within a given (index) range.; /// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; /// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; /// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; /// with the first one. It is clear that the order of the point is essential in defining the polygon.; /// Also note that the segments should not intersect.; ///; /// NB:; /// - if last=-1 (default) last is set to the last point.; /// - if (first <0) the first point (0) is taken.; ///; /// ### Method:; ///; /// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; /// you have to deal with. The most evident solution would be to divide the polygon in triangles and; /// calculate the surface of them. But this can quickly become complicated as you will have to test; /// every segments of every triangles and check if they are intersecting with a current polygon's; /// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; ///; /// ### The solution (implemented by R.Brun); /// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; /// segments don't intersect.; /// It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next; /// vertex. Then it subtracts from it the result of the y coordinate of the current vertex multiplied; /// by the x coordinate of the next vertex. Then divide the result by 2 to get the surface/area.; ///; /// ### Sources; /// - http://forums.wolfram.com/mathgroup/archive/1998/Mar/msg00462.html; /// - http://stackoverflow.com/questions/451426/how-do-i-calculate-the-surface-area-of-a-2d-polygon",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:374,Integrability,rout,routine,374,"////////////////////////////////////////////////////////////////////////////////; /// Least squares polynomial fitting without weights.; ///; /// \param [in] m number of parameters; /// \param [in] a array of parameters; /// \param [in] xmin 1st point number to fit (default =0); /// \param [in] xmax last point number to fit (default=fNpoints-1); ///; /// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:245,Testability,log,logarithm,245,"////////////////////////////////////////////////////////////////////////////////; /// Least square linear fit without weights.; ///; /// Fit a straight line (a0 + a1*x) to the data in this graph.; ///; /// \param [in] ndata if ndata<0, fits the logarithm of the graph (used in InitExpo() to set; /// the initial parameter values for a fit with exponential function.; /// \param [in] a0 constant; /// \param [in] a1 slope; /// \param [in] ifail return parameter indicating the status of the fit (ifail=0, fit is OK); /// \param [in] xmin, xmax fitting range; ///; /// extracted from CERNLIB LLSQ: Translated to C++ by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:308,Deployability,install,install,308,"////////////////////////////////////////////////////////////////////////////////; /// Save the graph as .csv, .tsv or .txt. In case of any other extension, fall; /// back to TObject::SaveAs; ///; /// The result can be immediately imported into Excel, gnuplot, Python or whatever,; /// without the needing to install pyroot, etc.; ///; /// \param filename the name of the file where to store the graph; /// \param option some tuning options; ///; /// The file extension defines the delimiter used:; /// - `.csv` : comma; /// - `.tsv` : tab; /// - `.txt` : space; ///; /// If option = ""title"" a title line is generated with the axis titles.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:74,Safety,avoid,avoid,74,"// points above i can be not initialized; // set zero up to i-th point to avoid redefinition; // of this method in descendant classes",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:108,Energy Efficiency,allocate,allocate,108,"////////////////////////////////////////////////////////////////////////////////; /// if size*2 <= fMaxSize allocate new arrays of size points,; /// copy points [0,oend).; /// Return newarray (passed or new instance if it was zero; /// and allocations are needed)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:992,Availability,error,errors,992,"////////////////////////////////////////////////////////////////////////////////; /// Sorts the points of this TGraph using in-place quicksort (see e.g. older glibc).; /// To compare two points the function parameter greaterfunc is used (see TGraph::CompareX for an; /// example of such a method, which is also the default comparison function for Sort). After; /// the sort, greaterfunc(this, i, j) will return kTRUE for all i>j if ascending == kTRUE, and; /// kFALSE otherwise.; ///; /// The last two parameters are used for the recursive quick sort, stating the range to be sorted; ///; /// Examples:; /// ~~~ {.cpp}; /// // sort points along x axis; /// graph->Sort();; /// // sort points along their distance to origin; /// graph->Sort(&TGraph::CompareRadius);; ///; /// Bool_t CompareErrors(const TGraph* gr, Int_t i, Int_t j) {; /// const TGraphErrors* ge=(const TGraphErrors*)gr;; /// return (ge->GetEY()[i]>ge->GetEY()[j]); }; /// // sort using the above comparison function, largest errors first; /// graph->Sort(&CompareErrors, kFALSE);; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:196,Availability,error,errors,196,"// Sort the indices using the provided comparison function; // We use std::stable_sort here because the libc++ implementation of std::sort; // is not standard-compliant until LLVM 14 which caused errors on the mac nodes; // of our CI, related issue: https://github.com/llvm/llvm-project/issues/21211",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update the fX and fY arrays with the sorted values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:211,Availability,error,error,211,"////////////////////////////////////////////////////////////////////////////////; /// Adds all graphs from the collection to this graph.; /// Returns the total number of points in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:108,Performance,perform,perform,108,"////////////////////////////////////////////////////////////////////////////////; /// protected function to perform the merge operation of a graph",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:142,Testability,log,log,142,"////////////////////////////////////////////////////////////////////////////////; /// Move all graph points on specified values dx,dy; /// If log argument specified, calculation done in logarithmic scale like:; /// new_value = exp( log(old_value) + delta );",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:186,Testability,log,logarithmic,186,"////////////////////////////////////////////////////////////////////////////////; /// Move all graph points on specified values dx,dy; /// If log argument specified, calculation done in logarithmic scale like:; /// new_value = exp( log(old_value) + delta );",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:232,Testability,log,log,232,"////////////////////////////////////////////////////////////////////////////////; /// Move all graph points on specified values dx,dy; /// If log argument specified, calculation done in logarithmic scale like:; /// new_value = exp( log(old_value) + delta );",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:101,Deployability,continuous,continuous,101,"////////////////////////////////////////////////////////////////////////////////; /// Find zero of a continuous function.; /// This function finds a real zero of the continuous real; /// function Y(X) in a given interval (A,B). See accompanying; /// notes for details of the argument list and calling sequence",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:166,Deployability,continuous,continuous,166,"////////////////////////////////////////////////////////////////////////////////; /// Find zero of a continuous function.; /// This function finds a real zero of the continuous real; /// function Y(X) in a given interval (A,B). See accompanying; /// notes for details of the argument list and calling sequence",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3,Testability,Test,Test,3,"// Test whether Y(X) is sufficiently small.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3,Testability,Test,Test,3,"// Test whether the signs of Y(AZ) and Y(BZ) are different.; // if not, begin the binary subdivision.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:3,Testability,Test,Test,3,"// Test whether a bracket has been found .; // If not,continue the search",MatchSource.CODE_COMMENT,hist/hist/src/TGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:4224,Deployability,Update,Update,4224," Z; value found via a linear interpolation on the plane defined by the triangle above; the (X,Y) coordinates of the bin center. The existing (X,Y,Z) points can be randomly scattered.; The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; the 2D histogram. The 3D triangles int takes build a 3D surface in; the form of tessellating triangles at various angles. The triangles found can be; drawn in 3D with one of the TGraph2D specific drawing options. The histogram generated by the Delaunay interpolation can be accessed using the; `GetHistogram()` method. The axis settings (title, ranges etc ...) can be changed accessing the axis via; the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; at drawing time only. Therefore they should called after the TGraph2D is drawn:. ~~~ {.cpp}; auto g = new TGraph2D();. [...]. g->Draw(""tri1"");; gPad->Update();; g->GetXaxis()->SetTitle(""X axis title"");; ~~~. \anchor G2D02; ## Examples. \anchor G2D021; ### SURF1 Example. Begin_Macro(source); {; auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t x, y, z, P = 6.;; Int_t np = 200;; auto dt = new TGraph2D();; dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; auto r = new TRandom();; for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(1);; dt->Draw(""surf1"");; }; End_Macro. \anchor G2D022; ### Fitting Example. 2D graphs can be fitted as shown by the following example:. Begin_Macro(source); ../../../tutorials/fit/graph2dfit.C; End_Macro. \anchor G2D023; ### PCOL Example. Example showing the PCOL option. Begin_Macro(source); {; auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t P = 5.;; Int_t npx = 20 ;; Int_t npy = 20 ;; Double_t x = -P;; Double_t y = -P;; Double_t z;; Int_t k = 0;; Double_t dx = (2",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:1447,Modifiability,extend,extended,1447,"anchor G2D00; ## Creating a TGraph2D. This class has different constructors:; - With an array's dimension and three arrays x, y, and z:; ~~~ {.cpp}; auto g = new TGraph2D(n, x, y, z);; ~~~; x, y, z arrays can be doubles, floats, or ints.; - With an array's dimension only:; ~~~ {.cpp}; auto g = new TGraph2D(n);; ~~~; The internal arrays are then filled with `SetPoint()`. The following line; fills the internal arrays at the position `i` with the values; `x`, `y`, `z`.; ~~~ {.cpp}; g->SetPoint(i, x, y, z);; ~~~; - Without parameters:; ~~~ {.cpp}; auto g = new TGraph2D();; ~~~; again `SetPoint()` must be used to fill the internal arrays.; - From a file:; ~~~ {.cpp}; auto g = new TGraph2D(""graph.dat"");; ~~~; Arrays are read from the ASCII file ""graph.dat"" according to a specifies; format. The default format is `%%lg %%lg %%lg`. Note that in any of these three cases, `SetPoint()` can be used to change a data; point or add a new one. If the data point index (`i`) is greater than the; current size of the internal arrays, they are automatically extended. Like TGraph some TGraph2D constructors do not have the TGraph2D title and name as parameters.; For these constructors TGraph2D has the default title and name ""Graph2D"". To change the; default title and name `SetTitle` and `SetName` should be called on the TGraph2D after its; creation. \anchor G2D01; ## Drawing options. Specific drawing options can be used to paint a TGraph2D:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""TRI"" | The Delaunay triangles are drawn using filled area. An hidden surface drawing technique is used. The surface is painted with the current fill area color. The edges of each triangles are painted with the current line color. |; | ""TRIW"" | The Delaunay triangles are drawn as wire frame. |; | ""TRI1"" | The Delaunay triangles are painted with color levels. The edges of each triangles are painted with the current line color. |; | ""TRI2"" | The D",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:3864,Security,access,accessed,3864," `SURF`, `LEGO`, `CONT` etc..). When a TGraph2D is drawn with one of the 2D histogram drawing option,; an intermediate 2D histogram is filled using the Delaunay triangles; to interpolate the data set. The 2D histogram has equidistant bins along the X; and Y directions. The number of bins along each direction can be change using; `SetNpx()` and `SetNpy()`. Each bin is filled with the Z; value found via a linear interpolation on the plane defined by the triangle above; the (X,Y) coordinates of the bin center. The existing (X,Y,Z) points can be randomly scattered.; The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; the 2D histogram. The 3D triangles int takes build a 3D surface in; the form of tessellating triangles at various angles. The triangles found can be; drawn in 3D with one of the TGraph2D specific drawing options. The histogram generated by the Delaunay interpolation can be accessed using the; `GetHistogram()` method. The axis settings (title, ranges etc ...) can be changed accessing the axis via; the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; at drawing time only. Therefore they should called after the TGraph2D is drawn:. ~~~ {.cpp}; auto g = new TGraph2D();. [...]. g->Draw(""tri1"");; gPad->Update();; g->GetXaxis()->SetTitle(""X axis title"");; ~~~. \anchor G2D02; ## Examples. \anchor G2D021; ### SURF1 Example. Begin_Macro(source); {; auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t x, y, z, P = 6.;; Int_t np = 200;; auto dt = new TGraph2D();; dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; auto r = new TRandom();; for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(1);; dt->Draw(""surf1"");; }; End_Macro. \anchor G2D022; ### Fitting Example. 2D graphs can be fitted as",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:3966,Security,access,accessing,3966,"illed using the Delaunay triangles; to interpolate the data set. The 2D histogram has equidistant bins along the X; and Y directions. The number of bins along each direction can be change using; `SetNpx()` and `SetNpy()`. Each bin is filled with the Z; value found via a linear interpolation on the plane defined by the triangle above; the (X,Y) coordinates of the bin center. The existing (X,Y,Z) points can be randomly scattered.; The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; the 2D histogram. The 3D triangles int takes build a 3D surface in; the form of tessellating triangles at various angles. The triangles found can be; drawn in 3D with one of the TGraph2D specific drawing options. The histogram generated by the Delaunay interpolation can be accessed using the; `GetHistogram()` method. The axis settings (title, ranges etc ...) can be changed accessing the axis via; the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; at drawing time only. Therefore they should called after the TGraph2D is drawn:. ~~~ {.cpp}; auto g = new TGraph2D();. [...]. g->Draw(""tri1"");; gPad->Update();; g->GetXaxis()->SetTitle(""X axis title"");; ~~~. \anchor G2D02; ## Examples. \anchor G2D021; ### SURF1 Example. Begin_Macro(source); {; auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t x, y, z, P = 6.;; Int_t np = 200;; auto dt = new TGraph2D();; dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; auto r = new TRandom();; for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(1);; dt->Draw(""surf1"");; }; End_Macro. \anchor G2D022; ### Fitting Example. 2D graphs can be fitted as shown by the following example:. Begin_Macro(source); ../../../tutorials/fit/graph2dfit.C; End_Macro. \anchor G2D023; ### PCOL Example.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:4039,Security,access,access,4039,"istogram has equidistant bins along the X; and Y directions. The number of bins along each direction can be change using; `SetNpx()` and `SetNpy()`. Each bin is filled with the Z; value found via a linear interpolation on the plane defined by the triangle above; the (X,Y) coordinates of the bin center. The existing (X,Y,Z) points can be randomly scattered.; The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then; used to define flat planes in (X,Y,Z) over which the interpolation is done to fill; the 2D histogram. The 3D triangles int takes build a 3D surface in; the form of tessellating triangles at various angles. The triangles found can be; drawn in 3D with one of the TGraph2D specific drawing options. The histogram generated by the Delaunay interpolation can be accessed using the; `GetHistogram()` method. The axis settings (title, ranges etc ...) can be changed accessing the axis via; the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created; at drawing time only. Therefore they should called after the TGraph2D is drawn:. ~~~ {.cpp}; auto g = new TGraph2D();. [...]. g->Draw(""tri1"");; gPad->Update();; g->GetXaxis()->SetTitle(""X axis title"");; ~~~. \anchor G2D02; ## Examples. \anchor G2D021; ### SURF1 Example. Begin_Macro(source); {; auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t x, y, z, P = 6.;; Int_t np = 200;; auto dt = new TGraph2D();; dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; auto r = new TRandom();; for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(1);; dt->Draw(""surf1"");; }; End_Macro. \anchor G2D022; ### Fitting Example. 2D graphs can be fitted as shown by the following example:. Begin_Macro(source); ../../../tutorials/fit/graph2dfit.C; End_Macro. \anchor G2D023; ### PCOL Example. Example showing the PCOL option. Begin_Macro(source); {; auto c = new TC",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:247,Availability,error,errors,247,"////////////////////////////////////////////////////////////////////////////////; /// Graph2D constructor with a TH2 (h2) as input.; /// Only the h2's bins within the X and Y axis ranges are used.; /// Empty bins, recognized when both content and errors are zero, are excluded.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:192,Safety,avoid,avoid,192,"////////////////////////////////////////////////////////////////////////////////; /// Graph2D constructor with name, title and three vectors of doubles as input.; /// name : name of 2D graph (avoid blanks); /// title : 2D graph title; /// if title is of the form ""stringt;stringx;stringy;stringz""; /// the 2D graph title is set to stringt, the x axis title to stringx,; /// the y axis title to stringy,etc",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:320,Safety,avoid,avoid,320,"////////////////////////////////////////////////////////////////////////////////; /// Graph2D constructor reading input from filename; /// filename is assumed to contain at least three columns of numbers.; /// For files separated by a specific delimiter different from ' ' and '\\t' (e.g. ';' in csv files); /// you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; /// e.g. option="" \\t,;"" for columns of figures separated by any of these characters (' ', '\\t', ',', ';'); /// used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; /// Note in that case, the instantiation is about 2 times slower.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:45,Availability,error,error,45,"//first condition not to repeat the previous error message",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:51,Integrability,message,message,51,"//first condition not to repeat the previous error message",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:21,Modifiability,variab,variables,21,"// Initializing loop variables",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:137,Availability,Error,Errors,137,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `z = z + c1*f(x,y,z)`; /// Errors are not recalculated.; ///; /// \param f may be a 2-D function TF2 or 3-d function TF3; /// \param c1 a scaling factor, 1 by default",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `z = z + c1*f(x,y,z)`; /// Errors are not recalculated.; ///; /// \param f may be a 2-D function TF2 or 3-d function TF3; /// \param c1 a scaling factor, 1 by default",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:102,Energy Efficiency,allocate,allocated,102,"////////////////////////////////////////////////////////////////////////////////; /// Free all memory allocated by this object.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:86,Performance,Perform,Perform,86,"////////////////////////////////////////////////////////////////////////////////; /// Perform the automatic addition of the graph to the given directory; ///; /// Note this function is called in place when the semantic requires; /// this object to be added to a directory (I.e. when being read from; /// a TKey or being Cloned)",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:219,Availability,avail,available,219,"////////////////////////////////////////////////////////////////////////////////; /// Fits this 2D graph with function f2; ///; /// f2 is an already predefined function created by TF2.; ///; /// See TGraph::Fit for the available fitting options and fitting notes; ///",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:7,Modifiability,plugin,plugin,7,"// use plugin manager to create instance of TFitEditor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:660,Integrability,rout,routine,660,"////////////////////////////////////////////////////////////////////////////////; /// By default returns a pointer to the Delaunay histogram. If fHistogram; /// doesn't exist, books the 2D histogram fHistogram with a margin around; /// the hull. Calls TGraphDelaunay::Interpolate at each bin centre to build up; /// an interpolated 2D histogram.; ///; /// If the ""empty"" option is selected, returns an empty histogram booked with; /// the limits of fX, fY and fZ. This option is used when the data set is; /// drawn with markers only. In that particular case there is no need to; /// find the Delaunay triangles.; ///; /// By default use the new interpolation routine based on Triangles; /// If the option ""old"" the old interpolation is used",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:6,Safety,avoid,avoid,6,"// to avoid adding fHistogram to gDirectory",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:132,Integrability,depend,depending,132,"////////////////////////////////////////////////////////////////////////////////; /// Projects a 2-d graph into 1 or 2-d histograms depending on the option parameter.; /// option may contain a combination of the characters x,y,z:; ///; /// - option = ""x"" return the x projection into a TH1D histogram; /// - option = ""y"" return the y projection into a TH1D histogram; /// - option = ""xy"" return the x versus y projection into a TH2D histogram; /// - option = ""yx"" return the y versus x projection into a TH2D histogram",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:540,Integrability,rout,routine,540,"////////////////////////////////////////////////////////////////////////////////; /// Sets the histogram to be filled.; /// If the 2D graph needs to be save in a TFile the following set should be; /// followed to read it back:; /// 1. Create TGraph2D; /// 2. Call g->SetHistogram(h), and do whatever you need to do; /// 3. Save g and h to the TFile, exit; /// 4. Open the TFile, retrieve g and h; /// 5. Call h->SetDirectory(0); /// 6. Call g->SetHistogram(h) again; /// 7. Carry on as normal; ///; /// By default use the new interpolation routine based on Triangles; /// If the option ""old"" the old interpolation is used",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:59,Deployability,update,update,59,"// 2D graphs are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:70,Security,hash,hashlist,70,"// 2D graphs are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:59,Deployability,update,update,59,"// 2D graphs are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:70,Security,hash,hashlist,70,"// 2D graphs are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:185,Modifiability,extend,extended,185,"////////////////////////////////////////////////////////////////////////////////; /// Sets point number n.; /// If n is greater than the current size, the arrays are automatically; /// extended.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:69,Availability,error,errors,69,"/** \class TGraph2DAsymmErrors; \ingroup Graphs; Graph 2D class with errors. A TGraph2DAsymmErrors is a TGraph2D with asymmetric errors. It behaves like a TGraph2D and has; the same drawing options. The **""ERR""** drawing option allows to display the error bars. The; following example shows how to use it:. Begin_Macro(source); {; auto c = new TCanvas(""c"",""TGraph2DAsymmErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *exl=0, *exh=0, *eyl=0, *eyh=0, *ezl=0, *ezh=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; exl = new Double_t[np];; exh = new Double_t[np];; eyl = new Double_t[np];; eyh = new Double_t[np];; ezl = new Double_t[np];; ezh = new Double_t[np];. auto r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; exl[N] = r->Rndm(N);; exh[N] = r->Rndm(N);; eyl[N] = r->Rndm(N);; eyh[N] = r->Rndm(N);; ezl[N] = 10*r->Rndm(N);; ezh[N] = 10*r->Rndm(N);; }. auto g = new TGraph2DAsymmErrors(np, rx, ry, rz, exl, exh, eyl, eyh, ezl, ezh);; g->SetTitle(""TGraph2D with asymmetric error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraph2DAsymmErrors default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:129,Availability,error,errors,129,"/** \class TGraph2DAsymmErrors; \ingroup Graphs; Graph 2D class with errors. A TGraph2DAsymmErrors is a TGraph2D with asymmetric errors. It behaves like a TGraph2D and has; the same drawing options. The **""ERR""** drawing option allows to display the error bars. The; following example shows how to use it:. Begin_Macro(source); {; auto c = new TCanvas(""c"",""TGraph2DAsymmErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *exl=0, *exh=0, *eyl=0, *eyh=0, *ezl=0, *ezh=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; exl = new Double_t[np];; exh = new Double_t[np];; eyl = new Double_t[np];; eyh = new Double_t[np];; ezl = new Double_t[np];; ezh = new Double_t[np];. auto r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; exl[N] = r->Rndm(N);; exh[N] = r->Rndm(N);; eyl[N] = r->Rndm(N);; eyh[N] = r->Rndm(N);; ezl[N] = 10*r->Rndm(N);; ezh[N] = 10*r->Rndm(N);; }. auto g = new TGraph2DAsymmErrors(np, rx, ry, rz, exl, exh, eyl, eyh, ezl, ezh);; g->SetTitle(""TGraph2D with asymmetric error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraph2DAsymmErrors default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:250,Availability,error,error,250,"/** \class TGraph2DAsymmErrors; \ingroup Graphs; Graph 2D class with errors. A TGraph2DAsymmErrors is a TGraph2D with asymmetric errors. It behaves like a TGraph2D and has; the same drawing options. The **""ERR""** drawing option allows to display the error bars. The; following example shows how to use it:. Begin_Macro(source); {; auto c = new TCanvas(""c"",""TGraph2DAsymmErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *exl=0, *exh=0, *eyl=0, *eyh=0, *ezl=0, *ezh=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; exl = new Double_t[np];; exh = new Double_t[np];; eyl = new Double_t[np];; eyh = new Double_t[np];; ezl = new Double_t[np];; ezh = new Double_t[np];. auto r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; exl[N] = r->Rndm(N);; exh[N] = r->Rndm(N);; eyl[N] = r->Rndm(N);; eyh[N] = r->Rndm(N);; ezl[N] = 10*r->Rndm(N);; ezh[N] = 10*r->Rndm(N);; }. auto g = new TGraph2DAsymmErrors(np, rx, ry, rz, exl, exh, eyl, eyh, ezl, ezh);; g->SetTitle(""TGraph2D with asymmetric error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraph2DAsymmErrors default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:1213,Availability,error,error,1213,"/** \class TGraph2DAsymmErrors; \ingroup Graphs; Graph 2D class with errors. A TGraph2DAsymmErrors is a TGraph2D with asymmetric errors. It behaves like a TGraph2D and has; the same drawing options. The **""ERR""** drawing option allows to display the error bars. The; following example shows how to use it:. Begin_Macro(source); {; auto c = new TCanvas(""c"",""TGraph2DAsymmErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *exl=0, *exh=0, *eyl=0, *eyh=0, *ezl=0, *ezh=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; exl = new Double_t[np];; exh = new Double_t[np];; eyl = new Double_t[np];; eyh = new Double_t[np];; ezl = new Double_t[np];; ezh = new Double_t[np];. auto r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; exl[N] = r->Rndm(N);; exh[N] = r->Rndm(N);; eyl[N] = r->Rndm(N);; eyh[N] = r->Rndm(N);; ezl[N] = 10*r->Rndm(N);; ezh[N] = 10*r->Rndm(N);; }. auto g = new TGraph2DAsymmErrors(np, rx, ry, rz, exl, exh, eyl, eyh, ezl, ezh);; g->SetTitle(""TGraph2D with asymmetric error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraph2DAsymmErrors default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:8,Availability,error,error,8,"// copy error arrays",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:117,Availability,error,errorbars,117,"////////////////////////////////////////////////////////////////////////////////; /// Add a 3D point with asymmetric errorbars to an existing graph",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:107,Availability,error,error,107,"////////////////////////////////////////////////////////////////////////////////; /// Returns the combined error along X at point i by computing the average; /// of the lower and upper variance.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:102,Availability,error,error,102,"////////////////////////////////////////////////////////////////////////////////; /// Returns the low error along X at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:103,Availability,error,error,103,"////////////////////////////////////////////////////////////////////////////////; /// Returns the high error along X at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:107,Availability,error,error,107,"////////////////////////////////////////////////////////////////////////////////; /// Returns the combined error along Y at point i by computing the average; /// of the lower and upper variance.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:102,Availability,error,error,102,"////////////////////////////////////////////////////////////////////////////////; /// Returns the low error along Y at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:103,Availability,error,error,103,"////////////////////////////////////////////////////////////////////////////////; /// Returns the high error along Y at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:107,Availability,error,error,107,"////////////////////////////////////////////////////////////////////////////////; /// Returns the combined error along Z at point i by computing the average; /// of the lower and upper variance.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:102,Availability,error,error,102,"////////////////////////////////////////////////////////////////////////////////; /// Returns the low error along Z at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:103,Availability,error,error,103,"////////////////////////////////////////////////////////////////////////////////; /// Returns the high error along Z at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X maximum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X minimum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Y maximum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Y minimum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Z maximum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Z minimum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:105,Availability,error,errors,105,"////////////////////////////////////////////////////////////////////////////////; /// Print 2D graph and errors values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:110,Availability,error,errors,110,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:210,Availability,error,errors,210,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:273,Availability,error,errors,273,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:336,Availability,error,errors,336,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:416,Availability,error,errors,416,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:64,Availability,error,errors,64,"/** \class TGraph2DErrors; \ingroup Graphs; Graph 2D class with errors. A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; the same drawing options. The **""ERR""** drawing option allows to display the error bars. The; following example shows how to use it:. Begin_Macro(source); {; auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *ex=0, *ey=0, *ez=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; ex = new Double_t[np];; ey = new Double_t[np];; ez = new Double_t[np];. auto r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; ex[N] = r->Rndm(N);; ey[N] = r->Rndm(N);; ez[N] = 10*r->Rndm(N);; }. auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; g->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraph2DErrors default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:108,Availability,error,errors,108,"/** \class TGraph2DErrors; \ingroup Graphs; Graph 2D class with errors. A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; the same drawing options. The **""ERR""** drawing option allows to display the error bars. The; following example shows how to use it:. Begin_Macro(source); {; auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *ex=0, *ey=0, *ez=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; ex = new Double_t[np];; ey = new Double_t[np];; ez = new Double_t[np];. auto r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; ex[N] = r->Rndm(N);; ey[N] = r->Rndm(N);; ez[N] = 10*r->Rndm(N);; }. auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; g->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraph2DErrors default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:229,Availability,error,error,229,"/** \class TGraph2DErrors; \ingroup Graphs; Graph 2D class with errors. A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; the same drawing options. The **""ERR""** drawing option allows to display the error bars. The; following example shows how to use it:. Begin_Macro(source); {; auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *ex=0, *ey=0, *ez=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; ex = new Double_t[np];; ey = new Double_t[np];; ez = new Double_t[np];. auto r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; ex[N] = r->Rndm(N);; ey[N] = r->Rndm(N);; ez[N] = 10*r->Rndm(N);; }. auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; g->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraph2DErrors default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:976,Availability,error,error,976,"/** \class TGraph2DErrors; \ingroup Graphs; Graph 2D class with errors. A TGraph2DErrors is a TGraph2D with errors. It behaves like a TGraph2D and has; the same drawing options. The **""ERR""** drawing option allows to display the error bars. The; following example shows how to use it:. Begin_Macro(source); {; auto c = new TCanvas(""c"",""TGraph2DErrors example"",0,0,600,600);; Double_t P = 6.;; Int_t np = 200;. Double_t *rx=0, *ry=0, *rz=0;; Double_t *ex=0, *ey=0, *ez=0;. rx = new Double_t[np];; ry = new Double_t[np];; rz = new Double_t[np];; ex = new Double_t[np];; ey = new Double_t[np];; ez = new Double_t[np];. auto r = new TRandom();. for (Int_t N=0; N<np;N++) {; rx[N] = 2*P*(r->Rndm(N))-P;; ry[N] = 2*P*(r->Rndm(N))-P;; rz[N] = rx[N]*rx[N]-ry[N]*ry[N];; rx[N] = 10.+rx[N];; ry[N] = 10.+ry[N];; rz[N] = 40.+rz[N];; ex[N] = r->Rndm(N);; ey[N] = r->Rndm(N);; ez[N] = 10*r->Rndm(N);; }. auto g = new TGraph2DErrors(np, rx, ry, rz, ex, ey, ez);; g->SetTitle(""TGraph2D with error bars: option \""ERR\"""");; g->SetFillColor(29);; g->SetMarkerSize(0.8);; g->SetMarkerStyle(20);; g->SetMarkerColor(kRed);; g->SetLineColor(kBlue-3);; g->SetLineWidth(2);; gPad->SetLogy(1);; g->Draw(""err p0"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraph2DErrors default constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:8,Availability,error,error,8,"// copy error arrays",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:103,Availability,error,errorbars,103,"////////////////////////////////////////////////////////////////////////////////; /// Add a point with errorbars to the graph.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:154,Availability,error,error,154,"////////////////////////////////////////////////////////////////////////////////; /// This function is called by Graph2DFitChisquare.; /// It returns the error along X at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:154,Availability,error,error,154,"////////////////////////////////////////////////////////////////////////////////; /// This function is called by Graph2DFitChisquare.; /// It returns the error along Y at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:154,Availability,error,error,154,"////////////////////////////////////////////////////////////////////////////////; /// This function is called by Graph2DFitChisquare.; /// It returns the error along Z at point i.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X maximum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the X minimum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Y maximum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Y minimum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Z maximum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:113,Availability,error,errors,113,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Z minimum with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:105,Availability,error,errors,105,"////////////////////////////////////////////////////////////////////////////////; /// Print 2D graph and errors values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:110,Availability,error,errors,110,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:205,Availability,error,errors,205,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:268,Availability,error,errors,268,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:331,Availability,error,errors,331,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:411,Availability,error,errors,411,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraph2DErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""z"" the z values and errors are scaled; /// If option contains ""xyz"" all three x, y and z values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraph2DErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2DErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:70,Availability,error,error,70,"/** \class TGraphAsymmErrors; \ingroup Graphs; TGraph with asymmetric error bars. The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; auto gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:354,Availability,error,error,354,"/** \class TGraphAsymmErrors; \ingroup Graphs; TGraph with asymmetric error bars. The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; auto gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:116,Performance,perform,performed,116,"/** \class TGraphAsymmErrors; \ingroup Graphs; TGraph with asymmetric error bars. The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; auto gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:325,Usability,Simpl,Simple,325,"/** \class TGraphAsymmErrors; \ingroup Graphs; TGraph with asymmetric error bars. The TGraphAsymmErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with asymmetric error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; auto gr = new TGraphAsymmErrors(n,x,y,exl,exh,eyl,eyh);; gr->SetTitle(""TGraphAsymmErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:232,Availability,error,errors,232,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with six vectors of floats in input; /// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; /// and the errors from vectors vexl/h and veyl/h.; /// The number of points in the graph is the minimum of number of points; /// in vx and vy.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:233,Availability,error,errors,233,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with six vectors of doubles in input; /// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; /// and the errors from vectors vexl/h and veyl/h.; /// The number of points in the graph is the minimum of number of points; /// in vx and vy.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:202,Availability,error,errors,202,"////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors constructor importing its parameters from the TH1 object passed as argument; /// the low and high errors are set to the bin error of the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:228,Availability,error,error,228,"////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors constructor importing its parameters from the TH1 object passed as argument; /// the low and high errors are set to the bin error of the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:652,Safety,avoid,avoid,652,"////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors constructor reading input from filename; /// filename is assumed to contain at least 2 columns of numbers; ///; /// convention for format (default=`""%lg %lg %lg %lg %lg %lg""`); /// - format = `""%lg %lg""` read only 2 first columns into X, Y; /// - format = `""%lg %lg %lg %lg""` read only 4 first columns into X, Y, ELY, EHY; /// - format = `""%lg %lg %lg %lg %lg %lg""` read only 6 first columns into X, Y, EXL, EYH, EYL, EHY; ///; /// For files separated by a specific delimiter different from `' '` and `'\\t'` (e.g. `';'` in csv files); /// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `""option"" argument,; /// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters `(' ', '\\t', ',', ';')`; /// used once `(e.g. ""1;1"")` or in a combined way `("" 1;,;; 1"")`.; /// Note in that case, the instantiation is about 2 times slower.; /// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:45,Availability,error,error,45,"//first condition not to repeat the previous error message",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:51,Integrability,message,message,51,"//first condition not to repeat the previous error message",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:21,Modifiability,variab,variables,21,"// Initializing loop variables",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:86,Energy Efficiency,Allocate,Allocate,86,"////////////////////////////////////////////////////////////////////////////////; /// Allocate internal data structures for `size` points.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:114,Availability,error,errorbars,114,"////////////////////////////////////////////////////////////////////////////////; /// Add a point with asymmetric errorbars to the graph.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:151,Availability,Error,Errors,151,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:346,Availability,down,down,346,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:83,Availability,error,error,83,"// in the case of the functions like y-> -1*y the roles of the; // upper and lower error bars is reversed",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:2,Availability,error,error,2,"//error on x doesn't change",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:1742,Availability,error,errors,1742,"ext{effective entries} = \frac{(\sum w_{i})^{2}}{\sum w_{i}^{2}}; /// \f]; /// The points are assigned a x value at the center of each histogram bin.; /// The y values are \f$\text{eff} = \frac{\text{pass}}{\text{total}}\f$; /// for all options except for the; /// bayesian methods where the result depends on the chosen option.; ///; /// If the denominator becomes 0 or pass > total, the corresponding bin is; /// skipped.; ///; /// ### 2) calculating ratios of two Poisson means (option 'pois'):; ///; /// The two histograms are interpreted as independent Poisson processes and the ratio; /// \f[; /// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; /// \f]; /// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; /// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; /// is used for \f$n_{2}\f$.; ///; /// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; /// of efficiency by a parameter transformation:; /// \f[; /// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; /// \f]; ///; /// The x errors span each histogram bin (lowedge ... lowedge+width); /// The y errors depend on the chosen statistic methode which can be determined; /// by the options given below. For a detailed description of the used statistic; /// calculations please have a look at the corresponding functions!; ///; /// Options:; /// - v : verbose mode: prints information about the number of used bins; /// and calculated efficiencies with their errors; /// - cl=x : determine the used confidence level (0<x<1) (default is 0.683); /// - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); /// - w : Wilson interval (see TEfficiency::Wilson); /// - n : normal approximation propagation (see TEfficiency::Normal); /// - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); /// - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); /// - midp : Lancaster mid-P inter",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:1812,Availability,error,errors,1812,"\f$; /// for all options except for the; /// bayesian methods where the result depends on the chosen option.; ///; /// If the denominator becomes 0 or pass > total, the corresponding bin is; /// skipped.; ///; /// ### 2) calculating ratios of two Poisson means (option 'pois'):; ///; /// The two histograms are interpreted as independent Poisson processes and the ratio; /// \f[; /// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; /// \f]; /// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; /// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; /// is used for \f$n_{2}\f$.; ///; /// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; /// of efficiency by a parameter transformation:; /// \f[; /// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; /// \f]; ///; /// The x errors span each histogram bin (lowedge ... lowedge+width); /// The y errors depend on the chosen statistic methode which can be determined; /// by the options given below. For a detailed description of the used statistic; /// calculations please have a look at the corresponding functions!; ///; /// Options:; /// - v : verbose mode: prints information about the number of used bins; /// and calculated efficiencies with their errors; /// - cl=x : determine the used confidence level (0<x<1) (default is 0.683); /// - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); /// - w : Wilson interval (see TEfficiency::Wilson); /// - n : normal approximation propagation (see TEfficiency::Normal); /// - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); /// - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); /// - midp : Lancaster mid-P interval (see TEfficiency::MidPInterval); /// - b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0; /// (see TEfficiency::Bayesian); /// - mode : use mode of posterior for Bayesian interval (default is mea",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:2170,Availability,error,errors,2170," ratios of two Poisson means (option 'pois'):; ///; /// The two histograms are interpreted as independent Poisson processes and the ratio; /// \f[; /// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; /// \f]; /// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; /// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; /// is used for \f$n_{2}\f$.; ///; /// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; /// of efficiency by a parameter transformation:; /// \f[; /// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; /// \f]; ///; /// The x errors span each histogram bin (lowedge ... lowedge+width); /// The y errors depend on the chosen statistic methode which can be determined; /// by the options given below. For a detailed description of the used statistic; /// calculations please have a look at the corresponding functions!; ///; /// Options:; /// - v : verbose mode: prints information about the number of used bins; /// and calculated efficiencies with their errors; /// - cl=x : determine the used confidence level (0<x<1) (default is 0.683); /// - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); /// - w : Wilson interval (see TEfficiency::Wilson); /// - n : normal approximation propagation (see TEfficiency::Normal); /// - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); /// - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); /// - midp : Lancaster mid-P interval (see TEfficiency::MidPInterval); /// - b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0; /// (see TEfficiency::Bayesian); /// - mode : use mode of posterior for Bayesian interval (default is mean); /// - shortest: use shortest interval (done by default if mode is set); /// - central: use central interval (done by default if mode is NOT set); /// - pois: interpret histograms as poisson ratio instead of efficiency; /// - e0 ",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:928,Integrability,depend,depends,928,"////////////////////////////////////////////////////////////////////////////////; /// Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total; ///; /// This method serves two purposes:; ///; /// ### 1) calculating efficiencies:; ///; /// The assumption is that the entries in ""pass"" are a subset of those in; /// ""total"". That is, we create an ""efficiency"" graph, where each entry is; /// between 0 and 1, inclusive.; ///; /// If the histograms are not filled with unit weights, the number of effective; /// entries is used to normalise the bin contents which might lead to wrong results.; /// \f[; /// \text{effective entries} = \frac{(\sum w_{i})^{2}}{\sum w_{i}^{2}}; /// \f]; /// The points are assigned a x value at the center of each histogram bin.; /// The y values are \f$\text{eff} = \frac{\text{pass}}{\text{total}}\f$; /// for all options except for the; /// bayesian methods where the result depends on the chosen option.; ///; /// If the denominator becomes 0 or pass > total, the corresponding bin is; /// skipped.; ///; /// ### 2) calculating ratios of two Poisson means (option 'pois'):; ///; /// The two histograms are interpreted as independent Poisson processes and the ratio; /// \f[; /// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; /// \f]; /// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; /// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; /// is used for \f$n_{2}\f$.; ///; /// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; /// of efficiency by a parameter transformation:; /// \f[; /// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; /// \f]; ///; /// The x errors span each histogram bin (lowedge ... lowedge+width); /// The y errors depend on the chosen statistic methode which can be determined; /// by the options given below. For a detailed description of the used statistic; /// calculations please have a look ",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:1819,Integrability,depend,depend,1819,"\f$; /// for all options except for the; /// bayesian methods where the result depends on the chosen option.; ///; /// If the denominator becomes 0 or pass > total, the corresponding bin is; /// skipped.; ///; /// ### 2) calculating ratios of two Poisson means (option 'pois'):; ///; /// The two histograms are interpreted as independent Poisson processes and the ratio; /// \f[; /// \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; /// \f]; /// with \f$\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\f$.; /// The histogram 'pass' is interpreted as \f$n_{1}\f$ and the total histogram; /// is used for \f$n_{2}\f$.; ///; /// The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; /// of efficiency by a parameter transformation:; /// \f[; /// \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; /// \f]; ///; /// The x errors span each histogram bin (lowedge ... lowedge+width); /// The y errors depend on the chosen statistic methode which can be determined; /// by the options given below. For a detailed description of the used statistic; /// calculations please have a look at the corresponding functions!; ///; /// Options:; /// - v : verbose mode: prints information about the number of used bins; /// and calculated efficiencies with their errors; /// - cl=x : determine the used confidence level (0<x<1) (default is 0.683); /// - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); /// - w : Wilson interval (see TEfficiency::Wilson); /// - n : normal approximation propagation (see TEfficiency::Normal); /// - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); /// - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); /// - midp : Lancaster mid-P interval (see TEfficiency::MidPInterval); /// - b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0; /// (see TEfficiency::Bayesian); /// - mode : use mode of posterior for Bayesian interval (default is mea",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:251,Availability,Error,Error,251,"// we do not want to ignore the weights; // if (bEffective && (pass->GetSumw2()->fN == 0 || total->GetSumw2()->fN == 0) ) {; // Warning(""Divide"",""histogram have been computed with weights but the sum of weight squares are not stored in the histogram. Error calculation is performed ignoring the weights"");; // bEffective = false;; // }; //parse option",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:272,Performance,perform,performed,272,"// we do not want to ignore the weights; // if (bEffective && (pass->GetSumw2()->fN == 0 || total->GetSumw2()->fN == 0) ) {; // Warning(""Divide"",""histogram have been computed with weights but the sum of weight squares are not stored in the histogram. Error calculation is performed ignoring the weights"");; // bEffective = false;; // }; //parse option",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:26,Availability,error,errors,26,"// case of bins with zero errors",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:14,Availability,error,error,14,"// use normal error calculation using variance of MLE with weights (F.James 8.5.2); // this is the same formula used in ROOT for TH1::Divide(""B"")",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:31,Availability,error,errors,31,"//Set the point center and its errors",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:95,Deployability,release,release,95,"////////////////////////////////////////////////////////////////////////////////; /// Copy and release.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:91,Availability,error,errors,91,"////////////////////////////////////////////////////////////////////////////////; /// Copy errors from `fE***` to `arrays[***]`; /// or to `f***` Copy points.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:163,Availability,error,errors,163,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with asymmetric errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:108,Performance,perform,perform,108,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with asymmetric errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:107,Availability,error,error,107,"////////////////////////////////////////////////////////////////////////////////; /// Returns the combined error along X at point i by computing the average; /// of the lower and upper variance.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:107,Availability,error,error,107,"////////////////////////////////////////////////////////////////////////////////; /// Returns the combined error along Y at point i by computing the average; /// of the lower and upper variance.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:95,Availability,error,error,95,"////////////////////////////////////////////////////////////////////////////////; /// Get high error on X.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get low error on X.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:95,Availability,error,error,95,"////////////////////////////////////////////////////////////////////////////////; /// Get high error on Y.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get low error on Y.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Adds all graphs with asymmetric errors from the collection to this graph.; /// Returns the total number of points in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:234,Availability,error,error,234,"////////////////////////////////////////////////////////////////////////////////; /// Adds all graphs with asymmetric errors from the collection to this graph.; /// Returns the total number of points in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:102,Availability,error,errors,102,"////////////////////////////////////////////////////////////////////////////////; /// Print graph and errors values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:110,Availability,error,errors,110,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:208,Availability,error,errors,208,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:271,Availability,error,errors,271,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:342,Availability,error,errors,342,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphAsymmErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:27,Availability,error,error,27,"// Fill the sorted X and Y error values based on the sorted indices",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:27,Availability,error,error,27,"// Copy the sorted X and Y error values back to the original arrays",MatchSource.CODE_COMMENT,hist/hist/src/TGraphAsymmErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:181,Availability,error,error,181,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphBentErrors; \ingroup Graphs; A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The TGraphBentErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:; Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphBentErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:458,Availability,error,error,458,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphBentErrors; \ingroup Graphs; A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The TGraphBentErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:; Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphBentErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:226,Performance,perform,performed,226,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphBentErrors; \ingroup Graphs; A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The TGraphBentErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:; Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphBentErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:435,Usability,Simpl,Simple,435,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphBentErrors; \ingroup Graphs; A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The TGraphBentErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:; Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphBentErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:108,Availability,error,errors,108,"////////////////////////////////////////////////////////////////////////////////; /// Add a point with bent errors to the graph.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:152,Availability,Error,Errors,152,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$.; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:348,Availability,down,down,348,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$.; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:83,Availability,error,error,83,"// in the case of the functions like y-> -1*y the roles of the; // upper and lower error bars is reversed",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:2,Availability,error,error,2,"//error on x doesn't change",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:95,Deployability,release,release,95,"////////////////////////////////////////////////////////////////////////////////; /// Copy and release.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:91,Availability,error,errors,91,"////////////////////////////////////////////////////////////////////////////////; /// Copy errors from `fE*** `to `arrays[***]`; /// or to `f***` Copy points.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:163,Availability,error,errors,163,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with asymmetric errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:108,Performance,perform,perform,108,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with asymmetric errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// It returns the error along X at point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// It returns the error along Y at point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:95,Availability,error,error,95,"////////////////////////////////////////////////////////////////////////////////; /// Get high error on X[i].",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get low error on X[i].",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:95,Availability,error,error,95,"////////////////////////////////////////////////////////////////////////////////; /// Get high error on Y[i].",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get low error on Y[i].",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:102,Availability,error,errors,102,"////////////////////////////////////////////////////////////////////////////////; /// Print graph and errors values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:110,Availability,error,errors,110,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphBentErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:207,Availability,error,errors,207,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphBentErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:270,Availability,error,errors,270,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphBentErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:341,Availability,error,errors,341,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphBentErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update the fX, fY, fEXlow, fEXhigh, fEXlowd, fEXhighd, fEYlow, fEYhigh, fEYlowd, ; /// and fEYhighd arrays with the sorted values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:27,Availability,error,error,27,"// Fill the sorted X and Y error values based on the sorted indices",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:27,Availability,error,error,27,"// Copy the sorted X and Y error values back to the original arrays",MatchSource.CODE_COMMENT,hist/hist/src/TGraphBentErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:91,Safety,avoid,avoid,91,"// Wrong zeros may appear when points sit on a regular grid.; // The following line try to avoid this problem.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:185,Availability,error,errors,185,"// increase/decrease xm and ym a little to produce a point; // just outside the triangle (ensuring that the amount added will; // be large enough such that it won't be lost in rounding errors)",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:122,Testability,test,test,122,"// is it a Delaunay triangle? (ie. are there any other points; // inside the circle that is defined by its vertices?); // test the triangle for Delaunay'ness; // loop over all other points testing each to see if it's; // inside the triangle's circle",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:189,Testability,test,testing,189,"// is it a Delaunay triangle? (ie. are there any other points; // inside the circle that is defined by its vertices?); // test the triangle for Delaunay'ness; // loop over all other points testing each to see if it's; // inside the triangle's circle",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:248,Testability,test,test,248,"// An easy first check is to see if point z is inside the triangle; // (if it's in the triangle it's also in the circle); // point z cannot be inside the triangle if it's further from (xx,yy); // than the furthest pointing making up the triangle - test this",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:4,Availability,Error,Error,4,"/// Error(""Interpolate"", ""Should not get to here"");; // may as well soldier on",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:68,Availability,error,errors,68,"// point z lies on the circumference of the circle (within rounding errors); // defined by the triangle, so there is potential for degeneracy in the; // triangle set (Delaunay triangulation does not give a unique way to split; // a polygon whose points lie on a circle into constituent triangles). Make; // a note of the additional point number.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:144,Availability,Error,Error,144,"// but is degenerate with at least one other,; // haven't figured out what to do if more than 4 points are involved; /// if (ndegen > 1) {; /// Error(""Interpolate"",; /// ""More than 4 points lying on a circle. No decision making process formulated for triangulating this region in a non-arbitrary way %d %d %d %d"",; /// p,n,m,degen);; /// return thevalue;; /// }; // we have a quadrilateral which can be split down either diagonal; // (d<->f or o1<->o2) to form valid Delaunay triangles. Choose diagonal; // with highest average z-value. Whichever we choose we will have; // verified two triangles as good and two as bad, only note the good ones",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:409,Availability,down,down,409,"// but is degenerate with at least one other,; // haven't figured out what to do if more than 4 points are involved; /// if (ndegen > 1) {; /// Error(""Interpolate"",; /// ""More than 4 points lying on a circle. No decision making process formulated for triangulating this region in a non-arbitrary way %d %d %d %d"",; /// p,n,m,degen);; /// return thevalue;; /// }; // we have a quadrilateral which can be split down either diagonal; // (d<->f or o1<->o2) to form valid Delaunay triangles. Choose diagonal; // with highest average z-value. Whichever we choose we will have; // verified two triangles as good and two as bad, only note the good ones",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:118,Testability,test,tested,118,"////////////////////////////////////////////////////////////////////////////////; /// Defines the number of triangles tested for a Delaunay triangle; /// (number of iterations) before abandoning the search",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay2D.cxx:492,Availability,avail,available,492,"/** \class TGraphDelaunay2D; \ingroup Graphs; TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D.; The algorithm used for finding the triangles is based on [CDT](https://github.com/artem-ogre/CDT),; a C++ library for generating constraint or conforming Delaunay triangulations. The ROOT::Math::Delaunay2D class provides a wrapper for using; the **CDT** library. This implementation provides large improvements in terms of computational performances; compared to the legacy one available in TGraphDelaunay, and it is by default; used in TGraph2D. The old, legacy implementation can be still used when calling; `TGraph2D::GetHistogram` and `TGraph2D::Draw` with the `old` option. Definition of Delaunay triangulation (After B. Delaunay):; For a set S of points in the Euclidean plane, the unique triangulation DT(S); of S such that no point in S is inside the circumcircle of any triangle in; DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of; points in S, the Voronoi diagram of S is the partitioning of the plane; containing S points into n convex polygons such that each polygon contains; exactly one point and every point in a given polygon is closer to its; central point than to any other. A Voronoi diagram is sometimes also known; as a Dirichlet tessellation. \image html tgraph2d_delaunay.png. [This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html); gives a nice practical view of Delaunay triangulation and Voronoi diagram.; */; /// TGraphDelaunay2D normal constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay2D.cxx:337,Integrability,wrap,wrapper,337,"/** \class TGraphDelaunay2D; \ingroup Graphs; TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D.; The algorithm used for finding the triangles is based on [CDT](https://github.com/artem-ogre/CDT),; a C++ library for generating constraint or conforming Delaunay triangulations. The ROOT::Math::Delaunay2D class provides a wrapper for using; the **CDT** library. This implementation provides large improvements in terms of computational performances; compared to the legacy one available in TGraphDelaunay, and it is by default; used in TGraph2D. The old, legacy implementation can be still used when calling; `TGraph2D::GetHistogram` and `TGraph2D::Draw` with the `old` option. Definition of Delaunay triangulation (After B. Delaunay):; For a set S of points in the Euclidean plane, the unique triangulation DT(S); of S such that no point in S is inside the circumcircle of any triangle in; DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of; points in S, the Voronoi diagram of S is the partitioning of the plane; containing S points into n convex polygons such that each polygon contains; exactly one point and every point in a given polygon is closer to its; central point than to any other. A Voronoi diagram is sometimes also known; as a Dirichlet tessellation. \image html tgraph2d_delaunay.png. [This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html); gives a nice practical view of Delaunay triangulation and Voronoi diagram.; */; /// TGraphDelaunay2D normal constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay2D.cxx:451,Performance,perform,performances,451,"/** \class TGraphDelaunay2D; \ingroup Graphs; TGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D.; The algorithm used for finding the triangles is based on [CDT](https://github.com/artem-ogre/CDT),; a C++ library for generating constraint or conforming Delaunay triangulations. The ROOT::Math::Delaunay2D class provides a wrapper for using; the **CDT** library. This implementation provides large improvements in terms of computational performances; compared to the legacy one available in TGraphDelaunay, and it is by default; used in TGraph2D. The old, legacy implementation can be still used when calling; `TGraph2D::GetHistogram` and `TGraph2D::Draw` with the `old` option. Definition of Delaunay triangulation (After B. Delaunay):; For a set S of points in the Euclidean plane, the unique triangulation DT(S); of S such that no point in S is inside the circumcircle of any triangle in; DT(S). DT(S) is the dual of the Voronoi diagram of S. If n is the number of; points in S, the Voronoi diagram of S is the partitioning of the plane; containing S points into n convex polygons such that each polygon contains; exactly one point and every point in a given polygon is closer to its; central point than to any other. A Voronoi diagram is sometimes also known; as a Dirichlet tessellation. \image html tgraph2d_delaunay.png. [This applet](http://www.cs.cornell.edu/Info/People/chew/Delaunay.html); gives a nice practical view of Delaunay triangulation and Voronoi diagram.; */; /// TGraphDelaunay2D normal constructor",MatchSource.CODE_COMMENT,hist/hist/src/TGraphDelaunay2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:156,Availability,error,error,156,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphErrors; \ingroup Graphs; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; auto gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:424,Availability,error,error,424,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphErrors; \ingroup Graphs; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; auto gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:197,Performance,perform,performed,197,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphErrors; \ingroup Graphs; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; auto gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:406,Usability,Simpl,Simple,406,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphErrors; \ingroup Graphs; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; auto gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:239,Availability,error,errors,239,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with four vectors of floats in input.; ///; /// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; /// and the errors from vectors vex and vey.; /// The number of points in the graph is the minimum of number of points; /// in vx and vy.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:240,Availability,error,errors,240,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with four vectors of doubles in input.; ///; /// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; /// and the errors from vectors vex and vey.; /// The number of points in the graph is the minimum of number of points; /// in vx and vy.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:610,Safety,avoid,avoid,610,"////////////////////////////////////////////////////////////////////////////////; /// GraphErrors constructor reading input from `filename`.; ///; /// `filename` is assumed to contain at least 2 columns of numbers; ///; /// Convention for format (default=`""%lg %lg %lg %lg""`); ///; /// - format = `%lg %lg` read only 2 first columns into X,Y; /// - format = `%lg %lg %lg` read only 3 first columns into X,Y and EY; /// - format = `%lg %lg %lg %lg` read only 4 first columns into X,Y,EX,EY.; ///; /// For files separated by a specific delimiter different from ' ' and `\\t` (e.g. `;` in csv files); /// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `option` argument,; /// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters (`' ', '\\t', ',', ';'`); /// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; ///; /// Note in that case, the instantiation is about 2 times slower.; /// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:45,Availability,error,error,45,"//first condition not to repeat the previous error message",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:51,Integrability,message,message,51,"//first condition not to repeat the previous error message",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:21,Modifiability,variab,variables,21,"// Initializing loop variables",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:103,Availability,error,errorbars,103,"////////////////////////////////////////////////////////////////////////////////; /// Add a point with errorbars to the graph.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:158,Availability,error,error,158,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ y = f(x,y) \f$.; ///; /// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; /// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ x \f$ doesn't change.; ///; /// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:246,Availability,error,error,246,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ y = f(x,y) \f$.; ///; /// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; /// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ x \f$ doesn't change.; ///; /// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:283,Availability,error,errors,283,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ y = f(x,y) \f$.; ///; /// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; /// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ x \f$ doesn't change.; ///; /// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:337,Availability,error,errors,337,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ y = f(x,y) \f$.; ///; /// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; /// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ x \f$ doesn't change.; ///; /// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:443,Availability,Error,Error,443,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ y = f(x,y) \f$.; ///; /// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; /// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ x \f$ doesn't change.; ///; /// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:158,Availability,error,error,158,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ x = f(x,y) \f$.; ///; /// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; /// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ y \f$ doesn't change.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:246,Availability,error,error,246,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ x = f(x,y) \f$.; ///; /// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; /// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ y \f$ doesn't change.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:283,Availability,error,errors,283,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ x = f(x,y) \f$.; ///; /// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; /// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ y \f$ doesn't change.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:337,Availability,error,errors,337,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ x = f(x,y) \f$.; ///; /// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; /// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ y \f$ doesn't change.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:443,Availability,Error,Error,443,"////////////////////////////////////////////////////////////////////////////////; /// Apply function to all the data points \f$ x = f(x,y) \f$.; ///; /// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; /// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; ///; /// For generic functions the symmetric errors might become non-symmetric; /// and are averaged here. Use TGraphAsymmErrors if desired.; ///; /// Error on \f$ y \f$ doesn't change.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:95,Deployability,release,release,95,"////////////////////////////////////////////////////////////////////////////////; /// Copy and release.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:91,Availability,error,errors,91,"////////////////////////////////////////////////////////////////////////////////; /// Copy errors from `fEX` and `fEY` to `arrays[0]` and `arrays[1]`; /// or to `fEX` and `fEY` if `arrays == 0` and `ibegin != iend`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:98,Energy Efficiency,allocate,allocate,98,"////////////////////////////////////////////////////////////////////////////////; /// Constructor allocate.; ///; /// Note: This function should be called only from the constructor; /// since it does not delete previously existing arrays.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:152,Availability,error,errors,152,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:108,Performance,perform,perform,108,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// It returns the error along X at point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// It returns the error along Y at point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// It returns the error along X at point `i`. For TGraphErrors this method is; /// the same as GetErrorX.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// It returns the error along X at point `i`. For TGraphErrors this method is; /// the same as GetErrorX.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// It returns the error along Y at point `i`. For TGraphErrors this method is; /// the same as GetErrorY.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// It returns the error along Y at point `i`. For TGraphErrors this method is; /// the same as GetErrorY.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:107,Availability,error,errors,107,"////////////////////////////////////////////////////////////////////////////////; /// Adds all graphs with errors from the collection to this graph.; /// Returns the total number of points in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:223,Availability,error,error,223,"////////////////////////////////////////////////////////////////////////////////; /// Adds all graphs with errors from the collection to this graph.; /// Returns the total number of points in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:102,Availability,error,errors,102,"////////////////////////////////////////////////////////////////////////////////; /// Print graph and errors values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:110,Availability,error,errors,110,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:203,Availability,error,errors,203,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:266,Availability,error,errors,266,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:337,Availability,error,errors,337,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and errors are scaled; /// If option contains ""xy"" both x and y values and errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update the fX, fY, fEX, and fEY arrays with the sorted values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:27,Availability,error,error,27,"// Fill the sorted X and Y error values based on the sorted indices",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:27,Availability,error,error,27,"// Copy the sorted X and Y error values back to the original arrays",MatchSource.CODE_COMMENT,hist/hist/src/TGraphErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:70,Availability,error,error,70,"/** \class TGraphMultiErrors; \ingroup Graphs; TGraph with asymmetric error bars and multiple y error dimensions. The TGraphMultiErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; gme->Draw(""APS ; Z ; 5 s=0.5"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:96,Availability,error,error,96,"/** \class TGraphMultiErrors; \ingroup Graphs; TGraph with asymmetric error bars and multiple y error dimensions. The TGraphMultiErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; gme->Draw(""APS ; Z ; 5 s=0.5"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:387,Availability,error,errors,387,"/** \class TGraphMultiErrors; \ingroup Graphs; TGraph with asymmetric error bars and multiple y error dimensions. The TGraphMultiErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; gme->Draw(""APS ; Z ; 5 s=0.5"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:148,Performance,perform,performed,148,"/** \class TGraphMultiErrors; \ingroup Graphs; TGraph with asymmetric error bars and multiple y error dimensions. The TGraphMultiErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; gme->Draw(""APS ; Z ; 5 s=0.5"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:358,Usability,Simpl,Simple,358,"/** \class TGraphMultiErrors; \ingroup Graphs; TGraph with asymmetric error bars and multiple y error dimensions. The TGraphMultiErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"", ""A Simple Graph with multiple y-errors"", 200, 10, 700, 500);; c1->SetGrid();; c1->GetFrame()->SetBorderSize(12);; const Int_t np = 5;; Double_t x[np] = {0, 1, 2, 3, 4};; Double_t y[np] = {0, 2, 4, 1, 3};; Double_t exl[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t exh[np] = {0.3, 0.3, 0.3, 0.3, 0.3};; Double_t eylstat[np] = {1, 0.5, 1, 0.5, 1};; Double_t eyhstat[np] = {0.5, 1, 0.5, 1, 2};; Double_t eylsys[np] = {0.5, 0.4, 0.8, 0.3, 1.2};; Double_t eyhsys[np] = {0.6, 0.7, 0.6, 0.4, 0.8};; auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; gme->AddYError(np, eylsys, eyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);; gme->Draw(""APS ; Z ; 5 s=0.5"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:147,Availability,error,errors,147,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with np points and ne y-errors.; ///; /// All values are initialized to 0.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:168,Availability,error,errors,168,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; ///; /// All values are initialized to 0.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:155,Availability,error,error,155,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and a single y-error.; ///; /// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; /// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:172,Availability,error,error,172,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and a single y-error.; ///; /// If `exL`,`exH` or `eyL`,`eyH` are NULL, the corresponding values are preset to zero.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:155,Availability,error,error,155,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and a single y-error.; ///; /// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; /// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:168,Availability,error,error,168,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with name, title, `np` points and a single y-error.; ///; /// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:151,Availability,error,errors,151,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of std::vectors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:259,Availability,error,errors,259,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of std::vectors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:164,Availability,error,errors,164,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of std::vectors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:272,Availability,error,errors,272,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of std::vectors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:151,Availability,error,errors,151,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of std::vectors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:259,Availability,error,errors,259,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of std::vectors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:168,Availability,error,errors,168,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of std::vectors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:276,Availability,error,errors,276,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of std::vectors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:151,Availability,error,errors,151,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of TArrayF objects.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:259,Availability,error,errors,259,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of TArrayF objects.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:164,Availability,error,errors,164,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of TArrayF objects.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:272,Availability,error,errors,272,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of TArrayF objects.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:151,Availability,error,errors,151,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of TArrayD objects.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:259,Availability,error,errors,259,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of TArrayD objects.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:168,Availability,error,errors,168,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of TArrayD objects.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:276,Availability,error,errors,276,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; ///; /// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; /// The multiple y-errors are passed as std::vectors of TArrayD objects.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:149,Availability,error,error,149,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with six vectors of floats in input and a single y error dimension.; /// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; /// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; /// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; /// The number of points in the graph is the minimum of number of points; /// in `tvX` and `tvY`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:379,Availability,error,errors,379,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with six vectors of floats in input and a single y error dimension.; /// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; /// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; /// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; /// The number of points in the graph is the minimum of number of points; /// in `tvX` and `tvY`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:150,Availability,error,error,150,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with six vectors of doubles in input and a single y error dimension.; /// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; /// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; /// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; /// The number of points in the graph is the minimum of number of points; /// in `tvX` and `tvY`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:380,Availability,error,errors,380,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with six vectors of doubles in input and a single y error dimension.; /// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; /// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; /// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; /// The number of points in the graph is the minimum of number of points; /// in `tvX` and `tvY`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:154,Availability,error,error,154,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with multiple vectors of floats in input and multiple y error dimension.; /// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; /// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; /// The number of points in the graph is the minimum of number of points; /// in `tvX` and `tvY`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:281,Availability,error,errors,281,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with multiple vectors of floats in input and multiple y error dimension.; /// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; /// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; /// The number of points in the graph is the minimum of number of points; /// in `tvX` and `tvY`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:155,Availability,error,error,155,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with multiple vectors of doubles in input and multiple y error dimensions; /// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; /// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; /// The number of points in the graph is the minimum of number of points; /// in `tvX` and `tvY`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:282,Availability,error,errors,282,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with multiple vectors of doubles in input and multiple y error dimensions; /// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; /// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; /// The number of points in the graph is the minimum of number of points; /// in `tvX` and `tvY`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:203,Availability,error,errors,203,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors constructor importing its parameters from the TH1 object passed as argument.; /// The low and high errors are set to the bin error of the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:229,Availability,error,error,229,"////////////////////////////////////////////////////////////////////////////////; /// TGraphMultiErrors constructor importing its parameters from the TH1 object passed as argument.; /// The low and high errors are set to the bin error of the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:95,Deployability,release,release,95,"////////////////////////////////////////////////////////////////////////////////; /// Copy and release.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:91,Availability,error,errors,91,"////////////////////////////////////////////////////////////////////////////////; /// Copy errors from `fE***` to `arrays[***]`; /// or to `f***` Copy points.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:112,Availability,error,error,112,"////////////////////////////////////////////////////////////////////////////////; /// Recalculates the summed y error arrays.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:172,Availability,error,errors,172,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with multiple asymmetric errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:108,Performance,perform,perform,108,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with multiple asymmetric errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:98,Availability,error,error,98,"////////////////////////////////////////////////////////////////////////////////; /// Add a new y error to the graph and fill it with the values from `eyL` and `eyH`",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:86,Energy Efficiency,Allocate,Allocate,86,"////////////////////////////////////////////////////////////////////////////////; /// Allocate internal data structures for `size` points.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:152,Availability,Error,Errors,152,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$.; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; ///; /// Only the first error dimension is affected.; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:275,Availability,error,error,275,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$.; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; ///; /// Only the first error dimension is affected.; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:401,Availability,down,down,401,"////////////////////////////////////////////////////////////////////////////////; /// Apply a function to all data points \f$ y = f(x,y) \f$.; ///; /// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; /// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; ///; /// Only the first error dimension is affected.; ///; /// Special treatment has to be applied for the functions where the; /// role of ""up"" and ""down"" is reversed.; ///; /// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:14,Availability,error,errors,14,"// systematic errors and error on x doesn't change",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:25,Availability,error,error,25,"// systematic errors and error on x doesn't change",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:228,Availability,error,error,228,"////////////////////////////////////////////////////////////////////////////////; /// This function was adapted from the TGraphAsymmErrors class.; /// See TGraphAsymmErrors::Divide for the documentation; ///; /// Only the first error dimension is affected.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:104,Energy Efficiency,adapt,adapted,104,"////////////////////////////////////////////////////////////////////////////////; /// This function was adapted from the TGraphAsymmErrors class.; /// See TGraphAsymmErrors::Divide for the documentation; ///; /// Only the first error dimension is affected.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:104,Modifiability,adapt,adapted,104,"////////////////////////////////////////////////////////////////////////////////; /// This function was adapted from the TGraphAsymmErrors class.; /// See TGraphAsymmErrors::Divide for the documentation; ///; /// Only the first error dimension is affected.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:255,Availability,Error,Error,255,"// we do not want to ignore the weights; // if (bEffective && (pass->GetSumw2()->fN == 0 || total->GetSumw2()->fN == 0) ) {; // Warning(""Divide"",""histogram have been computed with weights but the sum of weight squares are not stored in the; // histogram. Error calculation is performed ignoring the weights""); bEffective = false;; // }; // parse option",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:276,Performance,perform,performed,276,"// we do not want to ignore the weights; // if (bEffective && (pass->GetSumw2()->fN == 0 || total->GetSumw2()->fN == 0) ) {; // Warning(""Divide"",""histogram have been computed with weights but the sum of weight squares are not stored in the; // histogram. Error calculation is performed ignoring the weights""); bEffective = false;; // }; // parse option",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:26,Availability,error,errors,26,"// case of bins with zero errors",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:14,Availability,error,error,14,"// use normal error calculation using variance of MLE with weights (F.James 8.5.2); // this is the same formula used in ROOT for TH1::Divide(""B"")",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:32,Availability,error,errors,32,"// Set the point center and its errors",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:100,Availability,error,error,100,"////////////////////////////////////////////////////////////////////////////////; /// Deletes the y error with the index `e`.; /// Note that you must keep at least 1 error",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:166,Availability,error,error,166,"////////////////////////////////////////////////////////////////////////////////; /// Deletes the y error with the index `e`.; /// Note that you must keep at least 1 error",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Get error on x coordinate for point `i`.; /// In case of asymmetric errors the mean of the square sum is returned",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:154,Availability,error,errors,154,"////////////////////////////////////////////////////////////////////////////////; /// Get error on x coordinate for point `i`.; /// In case of asymmetric errors the mean of the square sum is returned",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Get error on y coordinate for point `i`.; /// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; /// In case of asymmetric errors the mean of the square sum is returned",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:145,Availability,error,errors,145,"////////////////////////////////////////////////////////////////////////////////; /// Get error on y coordinate for point `i`.; /// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; /// In case of asymmetric errors the mean of the square sum is returned",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:239,Availability,error,errors,239,"////////////////////////////////////////////////////////////////////////////////; /// Get error on y coordinate for point `i`.; /// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; /// In case of asymmetric errors the mean of the square sum is returned",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Get error e on y coordinate for point `i`.; /// In case of asymmetric errors the mean of the square sum is returned",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:156,Availability,error,errors,156,"////////////////////////////////////////////////////////////////////////////////; /// Get error e on y coordinate for point `i`.; /// In case of asymmetric errors the mean of the square sum is returned",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get low error on x coordinate for point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:95,Availability,error,error,95,"////////////////////////////////////////////////////////////////////////////////; /// Get high error on x coordinate for point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get low error on y coordinate for point `i`.; /// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:149,Availability,error,errors,149,"////////////////////////////////////////////////////////////////////////////////; /// Get low error on y coordinate for point `i`.; /// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:95,Availability,error,error,95,"////////////////////////////////////////////////////////////////////////////////; /// Get high error on y coordinate for point `i`.; /// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:150,Availability,error,errors,150,"////////////////////////////////////////////////////////////////////////////////; /// Get high error on y coordinate for point `i`.; /// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get low error e on y coordinate for point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:95,Availability,error,error,95,"////////////////////////////////////////////////////////////////////////////////; /// Get high error e on y coordinate for point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:98,Availability,error,errors,98,"////////////////////////////////////////////////////////////////////////////////; /// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:99,Availability,error,errors,99,"////////////////////////////////////////////////////////////////////////////////; /// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:98,Availability,error,errors,98,"////////////////////////////////////////////////////////////////////////////////; /// Get all low errors `e` on y coordinates as an array.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:99,Availability,error,errors,99,"////////////////////////////////////////////////////////////////////////////////; /// Get all high errors `e` on y coordinates as an array.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:120,Availability,error,error,120,"////////////////////////////////////////////////////////////////////////////////; /// Get AttFill pointer for specified error dimension.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:120,Availability,error,error,120,"////////////////////////////////////////////////////////////////////////////////; /// Get AttLine pointer for specified error dimension.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:115,Availability,error,error,115,"////////////////////////////////////////////////////////////////////////////////; /// Get Fill Color for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:142,Availability,error,errors,142,"////////////////////////////////////////////////////////////////////////////////; /// Get Fill Color for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:115,Availability,error,error,115,"////////////////////////////////////////////////////////////////////////////////; /// Get Fill Style for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:142,Availability,error,errors,142,"////////////////////////////////////////////////////////////////////////////////; /// Get Fill Style for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:115,Availability,error,error,115,"////////////////////////////////////////////////////////////////////////////////; /// Get Line Color for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:142,Availability,error,errors,142,"////////////////////////////////////////////////////////////////////////////////; /// Get Line Color for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:115,Availability,error,error,115,"////////////////////////////////////////////////////////////////////////////////; /// Get Line Style for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:142,Availability,error,errors,142,"////////////////////////////////////////////////////////////////////////////////; /// Get Line Style for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:115,Availability,error,error,115,"////////////////////////////////////////////////////////////////////////////////; /// Get Line Width for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:142,Availability,error,errors,142,"////////////////////////////////////////////////////////////////////////////////; /// Get Line Width for specified error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:102,Availability,error,errors,102,"////////////////////////////////////////////////////////////////////////////////; /// Print graph and errors values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:110,Availability,error,errors,110,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and (multiple) errors are scaled; /// If option contains ""xy"" both x and y values and (multiple) errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:208,Availability,error,errors,208,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and (multiple) errors are scaled; /// If option contains ""xy"" both x and y values and (multiple) errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:282,Availability,error,errors,282,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and (multiple) errors are scaled; /// If option contains ""xy"" both x and y values and (multiple) errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:364,Availability,error,errors,364,"////////////////////////////////////////////////////////////////////////////////; /// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; ///; /// If option contains ""x"" the x values and errors are scaled; /// If option contains ""y"" the y values and (multiple) errors are scaled; /// If option contains ""xy"" both x and y values and (multiple) errors are scaled",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:159,Availability,error,error,159,"////////////////////////////////////////////////////////////////////////////////; /// Set ex and ey values for point pointed by the mouse.; ///; /// Up to 3 y error dimensions possible.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error e ey values for point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error e eyL value for point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error e eyH value for point `i`.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error e ey values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error e eyL values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error e eyH values.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:98,Availability,error,errors,98,"////////////////////////////////////////////////////////////////////////////////; /// Set the sum errors mode and recalculate summed errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:133,Availability,error,errors,133,"////////////////////////////////////////////////////////////////////////////////; /// Set the sum errors mode and recalculate summed errors.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:113,Availability,error,error,113,"////////////////////////////////////////////////////////////////////////////////; /// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:173,Availability,error,errors,173,"////////////////////////////////////////////////////////////////////////////////; /// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:113,Availability,error,error,113,"////////////////////////////////////////////////////////////////////////////////; /// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:173,Availability,error,errors,173,"////////////////////////////////////////////////////////////////////////////////; /// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:104,Availability,error,error,104,"////////////////////////////////////////////////////////////////////////////////; /// Set Fill Color of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:131,Availability,error,errors,131,"////////////////////////////////////////////////////////////////////////////////; /// Set Fill Color of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:114,Availability,error,error,114,"////////////////////////////////////////////////////////////////////////////////; /// Set Fill Color and Alpha of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:141,Availability,error,errors,141,"////////////////////////////////////////////////////////////////////////////////; /// Set Fill Color and Alpha of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:104,Availability,error,error,104,"////////////////////////////////////////////////////////////////////////////////; /// Set Fill Style of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:131,Availability,error,errors,131,"////////////////////////////////////////////////////////////////////////////////; /// Set Fill Style of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:104,Availability,error,error,104,"////////////////////////////////////////////////////////////////////////////////; /// Set Line Color of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:131,Availability,error,errors,131,"////////////////////////////////////////////////////////////////////////////////; /// Set Line Color of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:114,Availability,error,error,114,"////////////////////////////////////////////////////////////////////////////////; /// Set Line Color and Alpha of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:141,Availability,error,errors,141,"////////////////////////////////////////////////////////////////////////////////; /// Set Line Color and Alpha of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:104,Availability,error,error,104,"////////////////////////////////////////////////////////////////////////////////; /// Set Line Style of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:131,Availability,error,errors,131,"////////////////////////////////////////////////////////////////////////////////; /// Set Line Style of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:104,Availability,error,error,104,"////////////////////////////////////////////////////////////////////////////////; /// Set Line Width of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:131,Availability,error,errors,131,"////////////////////////////////////////////////////////////////////////////////; /// Set Line Width of error e (-1 = Global and x errors).",MatchSource.CODE_COMMENT,hist/hist/src/TGraphMultiErrors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:667,Energy Efficiency,adapt,adapted,667,"// @(#)root/hist:$Id$; // Author: Christian Stratowa 30/09/2001; /*************************************************************************; * Copyright (C) 2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /******************************************************************************; * Copyright(c) 2001-2006, Dr. Christian Stratowa, Vienna, Austria. *; * Author: Christian Stratowa with help from Rene Brun. *; * *; * Algorithms for smooth regression adapted from: *; * R: A Computer Language for Statistical Data Analysis *; * *; ******************************************************************************/",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:667,Modifiability,adapt,adapted,667,"// @(#)root/hist:$Id$; // Author: Christian Stratowa 30/09/2001; /*************************************************************************; * Copyright (C) 2006, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /******************************************************************************; * Copyright(c) 2001-2006, Dr. Christian Stratowa, Vienna, Austria. *; * Author: Christian Stratowa with help from Rene Brun. *; * *; * Algorithms for smooth regression adapted from: *; * R: A Computer Language for Statistical Data Analysis *; * *; ******************************************************************************/",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:597,Availability,robust,robustifying,597,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Lowess smoother; ///; /// This function performs the computations for the LOWESS smoother; /// (see the reference below). Lowess returns the output points; /// x and y which give the coordinates of the smooth.; ///; /// \param[in] grin Input graph; /// \param[in] option specific options; /// \param[in] span the smoother span. This gives the proportion of points in the plot; /// which influence the smooth at each value. Larger values give more smoothness.; /// \param[in] iter the number of robustifying iterations which should be performed.; /// Using smaller values of iter will make lowess run faster.; /// \param[in] delta values of x which lie within delta of each other replaced by a; /// single value in the output from lowess.; /// For delta = 0, delta will be calculated.; ///; /// References:; ///; /// - Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; /// scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; /// - Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; /// by robust locally weighted regression.; /// The American Statistician, 35, 54.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:945,Availability,Robust,Robust,945,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Lowess smoother; ///; /// This function performs the computations for the LOWESS smoother; /// (see the reference below). Lowess returns the output points; /// x and y which give the coordinates of the smooth.; ///; /// \param[in] grin Input graph; /// \param[in] option specific options; /// \param[in] span the smoother span. This gives the proportion of points in the plot; /// which influence the smooth at each value. Larger values give more smoothness.; /// \param[in] iter the number of robustifying iterations which should be performed.; /// Using smaller values of iter will make lowess run faster.; /// \param[in] delta values of x which lie within delta of each other replaced by a; /// single value in the output from lowess.; /// For delta = 0, delta will be calculated.; ///; /// References:; ///; /// - Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; /// scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; /// - Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; /// by robust locally weighted regression.; /// The American Statistician, 35, 54.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1135,Availability,robust,robust,1135,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Lowess smoother; ///; /// This function performs the computations for the LOWESS smoother; /// (see the reference below). Lowess returns the output points; /// x and y which give the coordinates of the smooth.; ///; /// \param[in] grin Input graph; /// \param[in] option specific options; /// \param[in] span the smoother span. This gives the proportion of points in the plot; /// which influence the smooth at each value. Larger values give more smoothness.; /// \param[in] iter the number of robustifying iterations which should be performed.; /// Using smaller values of iter will make lowess run faster.; /// \param[in] delta values of x which lie within delta of each other replaced by a; /// single value in the output from lowess.; /// For delta = 0, delta will be calculated.; ///; /// References:; ///; /// - Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; /// scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; /// - Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; /// by robust locally weighted regression.; /// The American Statistician, 35, 54.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:143,Performance,perform,performs,143,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Lowess smoother; ///; /// This function performs the computations for the LOWESS smoother; /// (see the reference below). Lowess returns the output points; /// x and y which give the coordinates of the smooth.; ///; /// \param[in] grin Input graph; /// \param[in] option specific options; /// \param[in] span the smoother span. This gives the proportion of points in the plot; /// which influence the smooth at each value. Larger values give more smoothness.; /// \param[in] iter the number of robustifying iterations which should be performed.; /// Using smaller values of iter will make lowess run faster.; /// \param[in] delta values of x which lie within delta of each other replaced by a; /// single value in the output from lowess.; /// For delta = 0, delta will be calculated.; ///; /// References:; ///; /// - Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; /// scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; /// - Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; /// by robust locally weighted regression.; /// The American Statistician, 35, 54.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:637,Performance,perform,performed,637,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Lowess smoother; ///; /// This function performs the computations for the LOWESS smoother; /// (see the reference below). Lowess returns the output points; /// x and y which give the coordinates of the smooth.; ///; /// \param[in] grin Input graph; /// \param[in] option specific options; /// \param[in] span the smoother span. This gives the proportion of points in the plot; /// which influence the smooth at each value. Larger values give more smoothness.; /// \param[in] iter the number of robustifying iterations which should be performed.; /// Using smaller values of iter will make lowess run faster.; /// \param[in] delta values of x which lie within delta of each other replaced by a; /// single value in the output from lowess.; /// For delta = 0, delta will be calculated.; ///; /// References:; ///; /// - Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; /// scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; /// - Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; /// by robust locally weighted regression.; /// The American Statistician, 35, 54.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:3,Availability,robust,robustness,3,"// robustness iterations",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:11,Availability,robust,robustness,11,"// compute robustness weights except last time",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1759,Modifiability,variab,variable,1759,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Super smoother.; /// Smooth the (x, y) values by Friedman's ``super smoother''.; ///; /// \param[in] grin graph for smoothing; /// \param[in] option specific options; /// \param[in] span the fraction of the observations in the span of the running lines; /// smoother, or 0 to choose this by leave-one-out cross-validation.; /// \param[in] bass controls the smoothness of the fitted curve.; /// Values of up to 10 indicate increasing smoothness.; /// \param[in] isPeriodic if TRUE, the x values are assumed to be in [0, 1]; /// and of period 1.; /// \param[in] w case weights; ///; /// Details:; ///; /// supsmu is a running lines smoother which chooses between three spans for; /// the lines. The running lines smoothers are symmetric, with k/2 data points; /// each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; /// 0.05 * n, where n is the number of data points. If span is specified,; /// a single smoother with span span * n is used.; ///; /// The best of the three smoothers is chosen by cross-validation for each; /// prediction. The best spans are then smoothed by a running lines smoother; /// and the final prediction chosen by linear interpolation.; ///; /// The FORTRAN code says: ``For small samples (n < 40) or if there are; /// substantial serial correlations between observations close in x - value,; /// then a prespecified fixed span smoother (span > 0) should be used.; /// Reasonable span values are 0.2 to 0.4.''; ///; /// References:; /// - Friedman, J. H. (1984) SMART User's Guide.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 1.; /// - Friedman, J. H. (1984) A variable span scatterplot smoother.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 5.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:882,Safety,predict,predicted,882,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Super smoother.; /// Smooth the (x, y) values by Friedman's ``super smoother''.; ///; /// \param[in] grin graph for smoothing; /// \param[in] option specific options; /// \param[in] span the fraction of the observations in the span of the running lines; /// smoother, or 0 to choose this by leave-one-out cross-validation.; /// \param[in] bass controls the smoothness of the fitted curve.; /// Values of up to 10 indicate increasing smoothness.; /// \param[in] isPeriodic if TRUE, the x values are assumed to be in [0, 1]; /// and of period 1.; /// \param[in] w case weights; ///; /// Details:; ///; /// supsmu is a running lines smoother which chooses between three spans for; /// the lines. The running lines smoothers are symmetric, with k/2 data points; /// each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; /// 0.05 * n, where n is the number of data points. If span is specified,; /// a single smoother with span span * n is used.; ///; /// The best of the three smoothers is chosen by cross-validation for each; /// prediction. The best spans are then smoothed by a running lines smoother; /// and the final prediction chosen by linear interpolation.; ///; /// The FORTRAN code says: ``For small samples (n < 40) or if there are; /// substantial serial correlations between observations close in x - value,; /// then a prespecified fixed span smoother (span > 0) should be used.; /// Reasonable span values are 0.2 to 0.4.''; ///; /// References:; /// - Friedman, J. H. (1984) SMART User's Guide.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 1.; /// - Friedman, J. H. (1984) A variable span scatterplot smoother.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 5.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1151,Safety,predict,prediction,1151,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Super smoother.; /// Smooth the (x, y) values by Friedman's ``super smoother''.; ///; /// \param[in] grin graph for smoothing; /// \param[in] option specific options; /// \param[in] span the fraction of the observations in the span of the running lines; /// smoother, or 0 to choose this by leave-one-out cross-validation.; /// \param[in] bass controls the smoothness of the fitted curve.; /// Values of up to 10 indicate increasing smoothness.; /// \param[in] isPeriodic if TRUE, the x values are assumed to be in [0, 1]; /// and of period 1.; /// \param[in] w case weights; ///; /// Details:; ///; /// supsmu is a running lines smoother which chooses between three spans for; /// the lines. The running lines smoothers are symmetric, with k/2 data points; /// each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; /// 0.05 * n, where n is the number of data points. If span is specified,; /// a single smoother with span span * n is used.; ///; /// The best of the three smoothers is chosen by cross-validation for each; /// prediction. The best spans are then smoothed by a running lines smoother; /// and the final prediction chosen by linear interpolation.; ///; /// The FORTRAN code says: ``For small samples (n < 40) or if there are; /// substantial serial correlations between observations close in x - value,; /// then a prespecified fixed span smoother (span > 0) should be used.; /// Reasonable span values are 0.2 to 0.4.''; ///; /// References:; /// - Friedman, J. H. (1984) SMART User's Guide.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 1.; /// - Friedman, J. H. (1984) A variable span scatterplot smoother.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 5.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1243,Safety,predict,prediction,1243,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Super smoother.; /// Smooth the (x, y) values by Friedman's ``super smoother''.; ///; /// \param[in] grin graph for smoothing; /// \param[in] option specific options; /// \param[in] span the fraction of the observations in the span of the running lines; /// smoother, or 0 to choose this by leave-one-out cross-validation.; /// \param[in] bass controls the smoothness of the fitted curve.; /// Values of up to 10 indicate increasing smoothness.; /// \param[in] isPeriodic if TRUE, the x values are assumed to be in [0, 1]; /// and of period 1.; /// \param[in] w case weights; ///; /// Details:; ///; /// supsmu is a running lines smoother which chooses between three spans for; /// the lines. The running lines smoothers are symmetric, with k/2 data points; /// each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; /// 0.05 * n, where n is the number of data points. If span is specified,; /// a single smoother with span span * n is used.; ///; /// The best of the three smoothers is chosen by cross-validation for each; /// prediction. The best spans are then smoothed by a running lines smoother; /// and the final prediction chosen by linear interpolation.; ///; /// The FORTRAN code says: ``For small samples (n < 40) or if there are; /// substantial serial correlations between observations close in x - value,; /// then a prespecified fixed span smoother (span > 0) should be used.; /// Reasonable span values are 0.2 to 0.4.''; ///; /// References:; /// - Friedman, J. H. (1984) SMART User's Guide.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 1.; /// - Friedman, J. H. (1984) A variable span scatterplot smoother.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 5.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:414,Security,validat,validation,414,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Super smoother.; /// Smooth the (x, y) values by Friedman's ``super smoother''.; ///; /// \param[in] grin graph for smoothing; /// \param[in] option specific options; /// \param[in] span the fraction of the observations in the span of the running lines; /// smoother, or 0 to choose this by leave-one-out cross-validation.; /// \param[in] bass controls the smoothness of the fitted curve.; /// Values of up to 10 indicate increasing smoothness.; /// \param[in] isPeriodic if TRUE, the x values are assumed to be in [0, 1]; /// and of period 1.; /// \param[in] w case weights; ///; /// Details:; ///; /// supsmu is a running lines smoother which chooses between three spans for; /// the lines. The running lines smoothers are symmetric, with k/2 data points; /// each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; /// 0.05 * n, where n is the number of data points. If span is specified,; /// a single smoother with span span * n is used.; ///; /// The best of the three smoothers is chosen by cross-validation for each; /// prediction. The best spans are then smoothed by a running lines smoother; /// and the final prediction chosen by linear interpolation.; ///; /// The FORTRAN code says: ``For small samples (n < 40) or if there are; /// substantial serial correlations between observations close in x - value,; /// then a prespecified fixed span smoother (span > 0) should be used.; /// Reasonable span values are 0.2 to 0.4.''; ///; /// References:; /// - Friedman, J. H. (1984) SMART User's Guide.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 1.; /// - Friedman, J. H. (1984) A variable span scatterplot smoother.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 5.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1126,Security,validat,validation,1126,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Super smoother.; /// Smooth the (x, y) values by Friedman's ``super smoother''.; ///; /// \param[in] grin graph for smoothing; /// \param[in] option specific options; /// \param[in] span the fraction of the observations in the span of the running lines; /// smoother, or 0 to choose this by leave-one-out cross-validation.; /// \param[in] bass controls the smoothness of the fitted curve.; /// Values of up to 10 indicate increasing smoothness.; /// \param[in] isPeriodic if TRUE, the x values are assumed to be in [0, 1]; /// and of period 1.; /// \param[in] w case weights; ///; /// Details:; ///; /// supsmu is a running lines smoother which chooses between three spans for; /// the lines. The running lines smoothers are symmetric, with k/2 data points; /// each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; /// 0.05 * n, where n is the number of data points. If span is specified,; /// a single smoother with span span * n is used.; ///; /// The best of the three smoothers is chosen by cross-validation for each; /// prediction. The best spans are then smoothed by a running lines smoother; /// and the final prediction chosen by linear interpolation.; ///; /// The FORTRAN code says: ``For small samples (n < 40) or if there are; /// substantial serial correlations between observations close in x - value,; /// then a prespecified fixed span smoother (span > 0) should be used.; /// Reasonable span values are 0.2 to 0.4.''; ///; /// References:; /// - Friedman, J. H. (1984) SMART User's Guide.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 1.; /// - Friedman, J. H. (1984) A variable span scatterplot smoother.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 5.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1625,Usability,Guid,Guide,1625,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Super smoother.; /// Smooth the (x, y) values by Friedman's ``super smoother''.; ///; /// \param[in] grin graph for smoothing; /// \param[in] option specific options; /// \param[in] span the fraction of the observations in the span of the running lines; /// smoother, or 0 to choose this by leave-one-out cross-validation.; /// \param[in] bass controls the smoothness of the fitted curve.; /// Values of up to 10 indicate increasing smoothness.; /// \param[in] isPeriodic if TRUE, the x values are assumed to be in [0, 1]; /// and of period 1.; /// \param[in] w case weights; ///; /// Details:; ///; /// supsmu is a running lines smoother which chooses between three spans for; /// the lines. The running lines smoothers are symmetric, with k/2 data points; /// each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; /// 0.05 * n, where n is the number of data points. If span is specified,; /// a single smoother with span span * n is used.; ///; /// The best of the three smoothers is chosen by cross-validation for each; /// prediction. The best spans are then smoothed by a running lines smoother; /// and the final prediction chosen by linear interpolation.; ///; /// The FORTRAN code says: ``For small samples (n < 40) or if there are; /// substantial serial correlations between observations close in x - value,; /// then a prespecified fixed span smoother (span > 0) should be used.; /// Reasonable span values are 0.2 to 0.4.''; ///; /// References:; /// - Friedman, J. H. (1984) SMART User's Guide.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 1.; /// - Friedman, J. H. (1984) A variable span scatterplot smoother.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 5.",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:606,Modifiability,variab,variable,606,"////////////////////////////////////////////////////////////////////////////////; /// Friedmanns super smoother (Friedman, 1984).; ///; /// version 10/10/84; /// coded and copyright (c) 1984 by:; ///; /// Jerome H. Friedman; /// department of statistics; /// and; /// stanford linear accelerator center; /// stanford university; ///; /// all rights reserved.; ///; /// \param[in] n number of observations (x,y - pairs).; /// \param[in] x ordered abscissa values.; /// \param[in] y corresponding ordinate (response) values.; /// \param[in] w weight for each (x,y) observation.; /// \param[in] iper periodic variable flag.; /// - iper=1 => x is ordered interval variable.; /// - iper=2 => x is a periodic variable with values; /// in the range (0.0,1.0) and period 1.0.; /// \param[in] span smoother span (fraction of observations in window).; /// - span=0.0 => automatic (variable) span selection.; /// \param[in] alpha controls high frequency (small span) penality; /// used with automatic span selection (bass tone control).; /// (alpha.le.0.0 or alpha.gt.10.0 => no effect.); /// \param[out] smo smoothed ordinate (response) values.; /// \param sc internal working storage.; ///; /// note:; ///; /// for small samples (n < 40) or if there are substantial serial; /// correlations between observations close in x - value, then; /// a prespecified fixed span smoother (span > 0) should be; /// used. reasonable span values are 0.2 to 0.4.; ///; /// current implementation:; ///; /// Based on R function supsmu: Translated to C++ by C. Stratowa; /// (R source file: ppr.f by B.D.Ripley Copyright (C) 1994-97)",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:660,Modifiability,variab,variable,660,"////////////////////////////////////////////////////////////////////////////////; /// Friedmanns super smoother (Friedman, 1984).; ///; /// version 10/10/84; /// coded and copyright (c) 1984 by:; ///; /// Jerome H. Friedman; /// department of statistics; /// and; /// stanford linear accelerator center; /// stanford university; ///; /// all rights reserved.; ///; /// \param[in] n number of observations (x,y - pairs).; /// \param[in] x ordered abscissa values.; /// \param[in] y corresponding ordinate (response) values.; /// \param[in] w weight for each (x,y) observation.; /// \param[in] iper periodic variable flag.; /// - iper=1 => x is ordered interval variable.; /// - iper=2 => x is a periodic variable with values; /// in the range (0.0,1.0) and period 1.0.; /// \param[in] span smoother span (fraction of observations in window).; /// - span=0.0 => automatic (variable) span selection.; /// \param[in] alpha controls high frequency (small span) penality; /// used with automatic span selection (bass tone control).; /// (alpha.le.0.0 or alpha.gt.10.0 => no effect.); /// \param[out] smo smoothed ordinate (response) values.; /// \param sc internal working storage.; ///; /// note:; ///; /// for small samples (n < 40) or if there are substantial serial; /// correlations between observations close in x - value, then; /// a prespecified fixed span smoother (span > 0) should be; /// used. reasonable span values are 0.2 to 0.4.; ///; /// current implementation:; ///; /// Based on R function supsmu: Translated to C++ by C. Stratowa; /// (R source file: ppr.f by B.D.Ripley Copyright (C) 1994-97)",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:703,Modifiability,variab,variable,703,"////////////////////////////////////////////////////////////////////////////////; /// Friedmanns super smoother (Friedman, 1984).; ///; /// version 10/10/84; /// coded and copyright (c) 1984 by:; ///; /// Jerome H. Friedman; /// department of statistics; /// and; /// stanford linear accelerator center; /// stanford university; ///; /// all rights reserved.; ///; /// \param[in] n number of observations (x,y - pairs).; /// \param[in] x ordered abscissa values.; /// \param[in] y corresponding ordinate (response) values.; /// \param[in] w weight for each (x,y) observation.; /// \param[in] iper periodic variable flag.; /// - iper=1 => x is ordered interval variable.; /// - iper=2 => x is a periodic variable with values; /// in the range (0.0,1.0) and period 1.0.; /// \param[in] span smoother span (fraction of observations in window).; /// - span=0.0 => automatic (variable) span selection.; /// \param[in] alpha controls high frequency (small span) penality; /// used with automatic span selection (bass tone control).; /// (alpha.le.0.0 or alpha.gt.10.0 => no effect.); /// \param[out] smo smoothed ordinate (response) values.; /// \param sc internal working storage.; ///; /// note:; ///; /// for small samples (n < 40) or if there are substantial serial; /// correlations between observations close in x - value, then; /// a prespecified fixed span smoother (span > 0) should be; /// used. reasonable span values are 0.2 to 0.4.; ///; /// current implementation:; ///; /// Based on R function supsmu: Translated to C++ by C. Stratowa; /// (R source file: ppr.f by B.D.Ripley Copyright (C) 1994-97)",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:871,Modifiability,variab,variable,871,"////////////////////////////////////////////////////////////////////////////////; /// Friedmanns super smoother (Friedman, 1984).; ///; /// version 10/10/84; /// coded and copyright (c) 1984 by:; ///; /// Jerome H. Friedman; /// department of statistics; /// and; /// stanford linear accelerator center; /// stanford university; ///; /// all rights reserved.; ///; /// \param[in] n number of observations (x,y - pairs).; /// \param[in] x ordered abscissa values.; /// \param[in] y corresponding ordinate (response) values.; /// \param[in] w weight for each (x,y) observation.; /// \param[in] iper periodic variable flag.; /// - iper=1 => x is ordered interval variable.; /// - iper=2 => x is a periodic variable with values; /// in the range (0.0,1.0) and period 1.0.; /// \param[in] span smoother span (fraction of observations in window).; /// - span=0.0 => automatic (variable) span selection.; /// \param[in] alpha controls high frequency (small span) penality; /// used with automatic span selection (bass tone control).; /// (alpha.le.0.0 or alpha.gt.10.0 => no effect.); /// \param[out] smo smoothed ordinate (response) values.; /// \param sc internal working storage.; ///; /// note:; ///; /// for small samples (n < 40) or if there are substantial serial; /// correlations between observations close in x - value, then; /// a prespecified fixed span smoother (span > 0) should be; /// used. reasonable span values are 0.2 to 0.4.; ///; /// current implementation:; ///; /// Based on R function supsmu: Translated to C++ by C. Stratowa; /// (R source file: ppr.f by B.D.Ripley Copyright (C) 1994-97)",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:9,Modifiability,variab,variables,9,"// Local variables",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:17,Energy Efficiency,power,power,17,"// Computing 2nd power",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:9,Modifiability,variab,variables,9,"// Local variables",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:17,Energy Efficiency,power,power,17,"// Computing 2nd power",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1430,Deployability,continuous,continuous,1430," (iKind = 2).; /// \param[in] nout If xout is not specified, interpolation takes place at n equally; /// spaced points spanning the interval [min(x), max(x)], where; /// nout = max(nout, number of input data).; /// \param[in] xout an optional set of values specifying where interpolation is to; /// take place.; /// \param[in] yleft the value to be returned when input x values less than min(x).; /// The default is defined by the value of rule given below.; /// \param[in] yright the value to be returned when input x values greater than max(x).; /// The default is defined by the value of rule given below.; /// \param[in] rule an integer describing how interpolation is to take place outside; /// the interval [min(x), max(x)]. If rule is 0 then the given yleft; /// and yright values are returned, if it is 1 then 0 is returned; /// for such points and if it is 2, the value at the closest data; /// extreme is used.; /// \param[in] f For method=""constant"" a number between 0 and 1 inclusive,; /// indicating a compromise between left- and right-continuous step; /// functions. If y0 and y1 are the values to the left and right of; /// the point then the value is y0*f+y1*(1-f) so that f=0 is; /// right-continuous and f=1 is left-continuous; /// \param[in] ties Handling of tied x values. An integer describing a function with; /// a single vector argument returning a single number result:; /// - ties = ""ordered"" (iTies = 0): input x are ""ordered""; /// - ties = ""mean"" (iTies = 1): function ""mean""; /// - ties = ""min"" (iTies = 2): function ""min""; /// - ties = ""max"" (iTies = 3): function ""max""; ///; /// Details:; ///; /// At least two complete (x, y) pairs are required.; /// If there are duplicated (tied) x values and ties is a function it is; /// applied to the y values for each distinct x value. Useful functions in; /// this context include mean, min, and max.; /// If ties=""ordered"" the x values are assumed to be already ordered. The; /// first y value will be used for interpolation t",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1588,Deployability,continuous,continuous,1588,"number of input data).; /// \param[in] xout an optional set of values specifying where interpolation is to; /// take place.; /// \param[in] yleft the value to be returned when input x values less than min(x).; /// The default is defined by the value of rule given below.; /// \param[in] yright the value to be returned when input x values greater than max(x).; /// The default is defined by the value of rule given below.; /// \param[in] rule an integer describing how interpolation is to take place outside; /// the interval [min(x), max(x)]. If rule is 0 then the given yleft; /// and yright values are returned, if it is 1 then 0 is returned; /// for such points and if it is 2, the value at the closest data; /// extreme is used.; /// \param[in] f For method=""constant"" a number between 0 and 1 inclusive,; /// indicating a compromise between left- and right-continuous step; /// functions. If y0 and y1 are the values to the left and right of; /// the point then the value is y0*f+y1*(1-f) so that f=0 is; /// right-continuous and f=1 is left-continuous; /// \param[in] ties Handling of tied x values. An integer describing a function with; /// a single vector argument returning a single number result:; /// - ties = ""ordered"" (iTies = 0): input x are ""ordered""; /// - ties = ""mean"" (iTies = 1): function ""mean""; /// - ties = ""min"" (iTies = 2): function ""min""; /// - ties = ""max"" (iTies = 3): function ""max""; ///; /// Details:; ///; /// At least two complete (x, y) pairs are required.; /// If there are duplicated (tied) x values and ties is a function it is; /// applied to the y values for each distinct x value. Useful functions in; /// this context include mean, min, and max.; /// If ties=""ordered"" the x values are assumed to be already ordered. The; /// first y value will be used for interpolation to the left and the last; /// one for interpolation to the right.; ///; /// Value:; ///; /// approx returns a graph with components x and y, containing n coordinates; /// which interpolat",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:1615,Deployability,continuous,continuous,1615,"number of input data).; /// \param[in] xout an optional set of values specifying where interpolation is to; /// take place.; /// \param[in] yleft the value to be returned when input x values less than min(x).; /// The default is defined by the value of rule given below.; /// \param[in] yright the value to be returned when input x values greater than max(x).; /// The default is defined by the value of rule given below.; /// \param[in] rule an integer describing how interpolation is to take place outside; /// the interval [min(x), max(x)]. If rule is 0 then the given yleft; /// and yright values are returned, if it is 1 then 0 is returned; /// for such points and if it is 2, the value at the closest data; /// extreme is used.; /// \param[in] f For method=""constant"" a number between 0 and 1 inclusive,; /// indicating a compromise between left- and right-continuous step; /// functions. If y0 and y1 are the values to the left and right of; /// the point then the value is y0*f+y1*(1-f) so that f=0 is; /// right-continuous and f=1 is left-continuous; /// \param[in] ties Handling of tied x values. An integer describing a function with; /// a single vector argument returning a single number result:; /// - ties = ""ordered"" (iTies = 0): input x are ""ordered""; /// - ties = ""mean"" (iTies = 1): function ""mean""; /// - ties = ""min"" (iTies = 2): function ""min""; /// - ties = ""max"" (iTies = 3): function ""max""; ///; /// Details:; ///; /// At least two complete (x, y) pairs are required.; /// If there are duplicated (tied) x values and ties is a function it is; /// applied to the y values for each distinct x value. Useful functions in; /// this context include mean, min, and max.; /// If ties=""ordered"" the x values are assumed to be already ordered. The; /// first y value will be used for interpolation to the left and the last; /// one for interpolation to the right.; ///; /// Value:; ///; /// approx returns a graph with components x and y, containing n coordinates; /// which interpolat",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:135,Energy Efficiency,adapt,adapted,135,"////////////////////////////////////////////////////////////////////////////////; /// Static function; /// based on R function rPsort: adapted to C++ by Christian Stratowa; /// (R source file: R_sort.c by R Development Core Team (C) 1999-2001)",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:135,Modifiability,adapt,adapted,135,"////////////////////////////////////////////////////////////////////////////////; /// Static function; /// based on R function rPsort: adapted to C++ by Christian Stratowa; /// (R source file: R_sort.c by R Development Core Team (C) 1999-2001)",MatchSource.CODE_COMMENT,hist/hist/src/TGraphSmooth.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1156,Availability,error,errors,1156,"channel (see TH1 documentation); \class TH1F; \brief 1-D histogram with a float per channel (see TH1 documentation); \class TH1D; \brief 1-D histogram with a double per channel (see TH1 documentation); @}; */; /** \class TH1; \ingroup Histograms; TH1 is the base class of all histogram classes in %ROOT. It provides the common interface for operations such as binning, filling, drawing, which; will be detailed below. -# [Creating histograms](\ref creating-histograms); - [Labelling axes](\ref labelling-axis); -# [Binning](\ref binning); - [Fix or variable bin size](\ref fix-var); - [Convention for numbering bins](\ref convention); - [Alphanumeric Bin Labels](\ref alpha); - [Histograms with automatic bins](\ref auto-bin); - [Rebinning](\ref rebinning); -# [Filling histograms](\ref filling-histograms); - [Associated errors](\ref associated-errors); - [Associated functions](\ref associated-functions); - [Projections of histograms](\ref prof-hist); - [Random Numbers and histograms](\ref random-numbers); - [Making a copy of a histogram](\ref making-a-copy); - [Normalizing histograms](\ref normalizing); -# [Drawing histograms](\ref drawing-histograms); - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); - [Setting histogram graphics attributes](\ref graph-att); - [Customising how axes are drawn](\ref axis-drawing); -# [Fitting histograms](\ref fitting-histograms); -# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); -# [Operations on histograms](\ref operations-on-histograms); -# [Miscellaneous operations](\ref misc). ROOT supports the following histogram types:. - 1-D histograms:; - TH1C : histograms with one byte per channel. Maximum bin content = 127; - TH1S : histograms with one short per channel. Maximum bin content = 32767; - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**""); - ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1180,Availability,error,errors,1180,"channel (see TH1 documentation); \class TH1F; \brief 1-D histogram with a float per channel (see TH1 documentation); \class TH1D; \brief 1-D histogram with a double per channel (see TH1 documentation); @}; */; /** \class TH1; \ingroup Histograms; TH1 is the base class of all histogram classes in %ROOT. It provides the common interface for operations such as binning, filling, drawing, which; will be detailed below. -# [Creating histograms](\ref creating-histograms); - [Labelling axes](\ref labelling-axis); -# [Binning](\ref binning); - [Fix or variable bin size](\ref fix-var); - [Convention for numbering bins](\ref convention); - [Alphanumeric Bin Labels](\ref alpha); - [Histograms with automatic bins](\ref auto-bin); - [Rebinning](\ref rebinning); -# [Filling histograms](\ref filling-histograms); - [Associated errors](\ref associated-errors); - [Associated functions](\ref associated-functions); - [Projections of histograms](\ref prof-hist); - [Random Numbers and histograms](\ref random-numbers); - [Making a copy of a histogram](\ref making-a-copy); - [Normalizing histograms](\ref normalizing); -# [Drawing histograms](\ref drawing-histograms); - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); - [Setting histogram graphics attributes](\ref graph-att); - [Customising how axes are drawn](\ref axis-drawing); -# [Fitting histograms](\ref fitting-histograms); -# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); -# [Operations on histograms](\ref operations-on-histograms); -# [Miscellaneous operations](\ref misc). ROOT supports the following histogram types:. - 1-D histograms:; - TH1C : histograms with one byte per channel. Maximum bin content = 127; - TH1S : histograms with one short per channel. Maximum bin content = 32767; - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**""); - ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:8547,Availability,error,error,8547,"fill, manipulate, draw or access; histograms are identical in both cases. Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp}; Int_t gbin = h->GetBin(binx, biny, binz);; ~~~; returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:; ~~~ {.cpp}; Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; ~~~; returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3. \anchor alpha; ### Alphanumeric Bin Labels. By default, a histogram axis is drawn with its numeric bin labels.; One can specify alphanumeric labels instead with:. - call TAxis::SetBinLabel(bin, label);; This can always be done before or after filling.; When the histogram is drawn, bin labels will be automatically drawn.; See examples labels1.C and labels2.C; - call to a Fill function with one of the arguments being a string, e.g.; ~~~ {.cpp}; hist1->Fill(somename, weight);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);; ~~~; See examples hlabels1.C and hlabels2.C; - via TTree::Draw. see",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:8661,Availability,error,errors,8661,"objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp}; Int_t gbin = h->GetBin(binx, biny, binz);; ~~~; returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:; ~~~ {.cpp}; Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; ~~~; returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3. \anchor alpha; ### Alphanumeric Bin Labels. By default, a histogram axis is drawn with its numeric bin labels.; One can specify alphanumeric labels instead with:. - call TAxis::SetBinLabel(bin, label);; This can always be done before or after filling.; When the histogram is drawn, bin labels will be automatically drawn.; See examples labels1.C and labels2.C; - call to a Fill function with one of the arguments being a string, e.g.; ~~~ {.cpp}; hist1->Fill(somename, weight);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);; ~~~; See examples hlabels1.C and hlabels2.C; - via TTree::Draw. see for example cernstaff.C; ~~~ {.cpp}; tree.Draw(""Nation::Division"");; ~~~; where ""Nation"" and ""Division"" are two ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10427,Availability,down,down,10427,"ring, e.g.; ~~~ {.cpp}; hist1->Fill(somename, weight);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);; ~~~; See examples hlabels1.C and hlabels2.C; - via TTree::Draw. see for example cernstaff.C; ~~~ {.cpp}; tree.Draw(""Nation::Division"");; ~~~; where ""Nation"" and ""Division"" are two branches of a Tree. When using the options 2 or 3 above, the labels are automatically; added to the list (THashList) of labels for a given axis.; By default, an axis is drawn with the order of bins corresponding; to the filling sequence. It is possible to reorder the axis. - alphabetically; - by increasing or decreasing values. The reordering can be triggered via the TAxis context menu by selecting; the menu item ""LabelsOption"" or by calling directly; TH1::LabelsOption(option, axis) where. - axis may be ""X"", ""Y"" or ""Z""; - option may be:; - ""a"" sort by alphabetic order; - "">"" sort by decreasing values; - ""<"" sort by increasing values; - ""h"" draw labels horizontal; - ""v"" draw labels vertical; - ""u"" draw labels up (end of label right adjusted); - ""d"" draw labels down (start of label left adjusted). When using the option 2 above, new labels are added by doubling the current; number of bins in case one label does not exist yet.; When the Filling is terminated, it is possible to trim the number; of bins to match the number of active labels by calling; ~~~ {.cpp}; TH1::LabelsDeflate(axis) with axis = ""X"", ""Y"" or ""Z""; ~~~; This operation is automatic when using TTree::Draw.; Once bin labels have been created, they become persistent if the histogram; is written to a file or when generating the C++ code via SavePrimitive. \anchor auto-bin; ### Histograms with automatic bins. When a histogram is created with an axis lower limit greater or equal; to its upper limit, the SetBuffer is automatically called with an; argument fBufferSize equal to fgBufferSize (default value=1000).; fgBufferSize may be reset via the static function TH1::Set",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:11614,Availability,error,errors,11614,"e to trim the number; of bins to match the number of active labels by calling; ~~~ {.cpp}; TH1::LabelsDeflate(axis) with axis = ""X"", ""Y"" or ""Z""; ~~~; This operation is automatic when using TTree::Draw.; Once bin labels have been created, they become persistent if the histogram; is written to a file or when generating the C++ code via SavePrimitive. \anchor auto-bin; ### Histograms with automatic bins. When a histogram is created with an axis lower limit greater or equal; to its upper limit, the SetBuffer is automatically called with an; argument fBufferSize equal to fgBufferSize (default value=1000).; fgBufferSize may be reset via the static function TH1::SetDefaultBufferSize.; The axis limits will be automatically computed when the buffer will; be full or when the function BufferEmpty is called. \anchor rebinning; ### Rebinning. At any time, a histogram can be rebinned via TH1::Rebin. This function; returns a new histogram with the rebinned contents.; If bin errors were stored, they are recomputed during the rebinning. \anchor filling-histograms; ## Filling histograms. A histogram is typically filled with statements like:; ~~~ {.cpp}; h1->Fill(x);; h1->Fill(x, w); //fill with weight; h2->Fill(x, y); h2->Fill(x, y, w); h3->Fill(x, y, z); h3->Fill(x, y, z, w); ~~~; or via one of the Fill functions accepting names described above.; The Fill functions compute the bin number corresponding to the given; x, y or z argument and increment this bin by the given weight.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent. Passing an; out-of-range bin to TH1::AddBinContent leads to undefined behavior.; To access the bin content of a given bin, do:; ~~~ {.cpp}; Double_t binContent = h->GetBinContent(bin);",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13659,Availability,error,errors,13659,"rent axis ranges.; If the automatic binning option has been set via; ~~~ {.cpp}; h->SetCanExtend(TH1::kAllAxes);; ~~~; then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents. \anchor associated-errors; ### Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of weights per bin.; If Sumw2 has been called, the error per bin is computed as the; sqrt(sum of squares of weights), otherwise the error is set equal; to the sqrt(bin content).; To return the error for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBinError(bin);; ~~~. \anchor associated-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogra",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13682,Availability,error,errors,13682,"rent axis ranges.; If the automatic binning option has been set via; ~~~ {.cpp}; h->SetCanExtend(TH1::kAllAxes);; ~~~; then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents. \anchor associated-errors; ### Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of weights per bin.; If Sumw2 has been called, the error per bin is computed as the; sqrt(sum of squares of weights), otherwise the error is set equal; to the sqrt(bin content).; To return the error for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBinError(bin);; ~~~. \anchor associated-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogra",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13905,Availability,error,error,13905,"od; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents. \anchor associated-errors; ### Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of weights per bin.; If Sumw2 has been called, the error per bin is computed as the; sqrt(sum of squares of weights), otherwise the error is set equal; to the sqrt(bin content).; To return the error for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBinError(bin);; ~~~. \anchor associated-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogram.; - Additions of two histograms with coefficients and storage into the current; histogram.; - Multiplications and Divisions are supported in the same way as additions.; - The Add, Divide and Multiply functions also exist to add, divide or multiply; a",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13986,Availability,error,error,13986,"od; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents. \anchor associated-errors; ### Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of weights per bin.; If Sumw2 has been called, the error per bin is computed as the; sqrt(sum of squares of weights), otherwise the error is set equal; to the sqrt(bin content).; To return the error for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBinError(bin);; ~~~. \anchor associated-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogram.; - Additions of two histograms with coefficients and storage into the current; histogram.; - Multiplications and Divisions are supported in the same way as additions.; - The Add, Divide and Multiply functions also exist to add, divide or multiply; a",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:14047,Availability,error,error,14047,"tomatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents. \anchor associated-errors; ### Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of weights per bin.; If Sumw2 has been called, the error per bin is computed as the; sqrt(sum of squares of weights), otherwise the error is set equal; to the sqrt(bin content).; To return the error for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBinError(bin);; ~~~. \anchor associated-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogram.; - Additions of two histograms with coefficients and storage into the current; histogram.; - Multiplications and Divisions are supported in the same way as additions.; - The Add, Divide and Multiply functions also exist to add, divide or multiply; a histogram by a function. If a histogram has associated error bars (TH1::Sumw2 has been called),; the result",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:14103,Availability,error,error,14103,"Tree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents. \anchor associated-errors; ### Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of weights per bin.; If Sumw2 has been called, the error per bin is computed as the; sqrt(sum of squares of weights), otherwise the error is set equal; to the sqrt(bin content).; To return the error for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBinError(bin);; ~~~. \anchor associated-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogram.; - Additions of two histograms with coefficients and storage into the current; histogram.; - Multiplications and Divisions are supported in the same way as additions.; - The Add, Divide and Multiply functions also exist to add, divide or multiply; a histogram by a function. If a histogram has associated error bars (TH1::Sumw2 has been called),; the resulting error bars are also computed assuming independent",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:15008,Availability,error,error,15008,"r for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBinError(bin);; ~~~. \anchor associated-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogram.; - Additions of two histograms with coefficients and storage into the current; histogram.; - Multiplications and Divisions are supported in the same way as additions.; - The Add, Divide and Multiply functions also exist to add, divide or multiply; a histogram by a function. If a histogram has associated error bars (TH1::Sumw2 has been called),; the resulting error bars are also computed assuming independent histograms.; In case of divisions, Binomial errors are also supported.; One can mark a histogram to be an ""average"" histogram by setting its bit kIsAverage via; myhist.SetBit(TH1::kIsAverage);; When adding (see TH1::Add) average histograms, the histograms are averaged and not summed. \anchor prof-hist; ### Projections of histograms. One can:. - make a 1-D projection of a 2-D histogram or Profile; see functions TH2::ProjectionX,Y, TH2::ProfileX,Y, TProfile::ProjectionX; - make a 1-D, 2-D or profile out of a 3-D histogram; see functions TH3::ProjectionZ, TH3::Project3D. One can fit these projections via:; ~~~ {.cpp}; TH2::FitSlicesX,Y, TH3::FitSlicesZ.; ~~~. \anchor random-numbers; ### Random Numbers and histograms. TH1::FillRandom can be used to randomly fill a histogram using; the contents of an existing TF1 function or another; TH1 histogram (for all dimensions).; For example, the following two statements create and fill a",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:15064,Availability,error,error,15064,"r for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBinError(bin);; ~~~. \anchor associated-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogram.; - Additions of two histograms with coefficients and storage into the current; histogram.; - Multiplications and Divisions are supported in the same way as additions.; - The Add, Divide and Multiply functions also exist to add, divide or multiply; a histogram by a function. If a histogram has associated error bars (TH1::Sumw2 has been called),; the resulting error bars are also computed assuming independent histograms.; In case of divisions, Binomial errors are also supported.; One can mark a histogram to be an ""average"" histogram by setting its bit kIsAverage via; myhist.SetBit(TH1::kIsAverage);; When adding (see TH1::Add) average histograms, the histograms are averaged and not summed. \anchor prof-hist; ### Projections of histograms. One can:. - make a 1-D projection of a 2-D histogram or Profile; see functions TH2::ProjectionX,Y, TH2::ProfileX,Y, TProfile::ProjectionX; - make a 1-D, 2-D or profile out of a 3-D histogram; see functions TH3::ProjectionZ, TH3::Project3D. One can fit these projections via:; ~~~ {.cpp}; TH2::FitSlicesX,Y, TH3::FitSlicesZ.; ~~~. \anchor random-numbers; ### Random Numbers and histograms. TH1::FillRandom can be used to randomly fill a histogram using; the contents of an existing TF1 function or another; TH1 histogram (for all dimensions).; For example, the following two statements create and fill a",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:15158,Availability,error,errors,15158,"ed-functions; ### Associated functions; One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each histogram.; When TH1::Fit is invoked, the fitted function is added to this list.; Given a histogram h, one can retrieve an associated function; with:; ~~~ {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ~~~. \anchor operations-on-histograms; ## Operations on histograms. Many types of operations are supported on histograms or between histograms. - Addition of a histogram to the current histogram.; - Additions of two histograms with coefficients and storage into the current; histogram.; - Multiplications and Divisions are supported in the same way as additions.; - The Add, Divide and Multiply functions also exist to add, divide or multiply; a histogram by a function. If a histogram has associated error bars (TH1::Sumw2 has been called),; the resulting error bars are also computed assuming independent histograms.; In case of divisions, Binomial errors are also supported.; One can mark a histogram to be an ""average"" histogram by setting its bit kIsAverage via; myhist.SetBit(TH1::kIsAverage);; When adding (see TH1::Add) average histograms, the histograms are averaged and not summed. \anchor prof-hist; ### Projections of histograms. One can:. - make a 1-D projection of a 2-D histogram or Profile; see functions TH2::ProjectionX,Y, TH2::ProfileX,Y, TProfile::ProjectionX; - make a 1-D, 2-D or profile out of a 3-D histogram; see functions TH3::ProjectionZ, TH3::Project3D. One can fit these projections via:; ~~~ {.cpp}; TH2::FitSlicesX,Y, TH3::FitSlicesZ.; ~~~. \anchor random-numbers; ### Random Numbers and histograms. TH1::FillRandom can be used to randomly fill a histogram using; the contents of an existing TF1 function or another; TH1 histogram (for all dimensions).; For example, the following two statements create and fill a histogram; 10000 times with a default gaussian distribution of mean 0 and sigma 1:; ~~~ {.cpp}; TH1F h1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:16571,Availability,error,errors,16571,"nX,Y, TH2::ProfileX,Y, TProfile::ProjectionX; - make a 1-D, 2-D or profile out of a 3-D histogram; see functions TH3::ProjectionZ, TH3::Project3D. One can fit these projections via:; ~~~ {.cpp}; TH2::FitSlicesX,Y, TH3::FitSlicesZ.; ~~~. \anchor random-numbers; ### Random Numbers and histograms. TH1::FillRandom can be used to randomly fill a histogram using; the contents of an existing TF1 function or another; TH1 histogram (for all dimensions).; For example, the following two statements create and fill a histogram; 10000 times with a default gaussian distribution of mean 0 and sigma 1:; ~~~ {.cpp}; TH1F h1(""h1"", ""histo from a gaussian"", 100, -3, 3);; h1.FillRandom(""gaus"", 10000);; ~~~; TH1::GetRandom can be used to return a random number distributed; according to the contents of a histogram. \anchor making-a-copy; ### Making a copy of a histogram; Like for any other ROOT object derived from TObject, one can use; the Clone() function. This makes an identical copy of the original; histogram including all associated errors and functions, e.g.:; ~~~ {.cpp}; TH1F *hnew = (TH1F*)h->Clone(""hnew"");; ~~~. \anchor normalizing; ### Normalizing histograms. One can scale a histogram such that the bins integral is equal to; the normalization parameter via TH1::Scale(Double_t norm), where norm; is the desired normalization divided by the integral of the histogram. \anchor drawing-histograms; ## Drawing histograms. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; Many drawing options are supported.; See THistPainter::Paint() for more details. The same histogram can be drawn with different options in different pads.; When a histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If a histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is update",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20802,Availability,error,errors,20802,"function via TH1::Fit.; See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation and the possible [fitting options](\ref HFitOpt). The FitPanel can also be used for fitting an histogram. See the [FitPanel documentation](https://root.cern/manual/fitting/#using-the-fit-panel). \anchor saving-histograms; ## Saving/reading histograms to/from a ROOT file. The following statements create a ROOT file and store a histogram; on the file. Because TH1 derives from TNamed, the key identifier on; the file is the histogram name:; ~~~ {.cpp}; TFile f(""histos.root"", ""new"");; TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; h1.FillRandom(""gaus"", 10000);; h1->Write();; ~~~; To read this histogram in another Root session, do:; ~~~ {.cpp}; TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");; ~~~; One can save all histograms in memory to the file by:; ~~~ {.cpp}; file->Write();; ~~~. \anchor misc; ## Miscellaneous operations. ~~~ {.cpp}; TH1::KolmogorovTest(): statistical test of compatibility in shape; between two histograms; TH1::Smooth() smooths the bin contents of a 1-d histogram; TH1::Integral() returns the integral of bin contents in a given bin range; TH1::GetMean(int axis) returns the mean value along axis; TH1::GetStdDev(int axis) returns the sigma distribution along axis; TH1::GetEntries() returns the number of entries; TH1::Reset() resets the bin contents and errors of a histogram; ~~~; IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the; histogram statistics are calculated. By default, if no range has been set, the; returned values are the (unbinned) ones calculated at fill time. If a range has been; set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN; IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset the range.; To ensure that the returned values are always those of the binned data stored in the; histogram, call TH1::ResetStats. See TH1::GetStats.; */",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:17536,Deployability,update,updated,17536,"e; the Clone() function. This makes an identical copy of the original; histogram including all associated errors and functions, e.g.:; ~~~ {.cpp}; TH1F *hnew = (TH1F*)h->Clone(""hnew"");; ~~~. \anchor normalizing; ### Normalizing histograms. One can scale a histogram such that the bins integral is equal to; the normalization parameter via TH1::Scale(Double_t norm), where norm; is the desired normalization divided by the integral of the histogram. \anchor drawing-histograms; ## Drawing histograms. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; Many drawing options are supported.; See THistPainter::Paint() for more details. The same histogram can be drawn with different options in different pads.; When a histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If a histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of a histogram in a pad, one can use; ~~~ {.cpp}; h->DrawCopy();; ~~~; This makes a clone (see Clone below) of the histogram. Once the clone; is drawn, the original histogram may be modified or deleted without; affecting the aspect of the clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; functions affect the z-axis). TH1::UseCurrentStyle() can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle(). \anchor con",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:661,Integrability,interface,interface,661,"/** \addtogroup Histograms; @{; \class TH1C; \brief 1-D histogram with a byte per channel (see TH1 documentation); \class TH1S; \brief 1-D histogram with a short per channel (see TH1 documentation); \class TH1I; \brief 1-D histogram with an int per channel (see TH1 documentation); \class TH1L; \brief 1-D histogram with a long64 per channel (see TH1 documentation); \class TH1F; \brief 1-D histogram with a float per channel (see TH1 documentation); \class TH1D; \brief 1-D histogram with a double per channel (see TH1 documentation); @}; */; /** \class TH1; \ingroup Histograms; TH1 is the base class of all histogram classes in %ROOT. It provides the common interface for operations such as binning, filling, drawing, which; will be detailed below. -# [Creating histograms](\ref creating-histograms); - [Labelling axes](\ref labelling-axis); -# [Binning](\ref binning); - [Fix or variable bin size](\ref fix-var); - [Convention for numbering bins](\ref convention); - [Alphanumeric Bin Labels](\ref alpha); - [Histograms with automatic bins](\ref auto-bin); - [Rebinning](\ref rebinning); -# [Filling histograms](\ref filling-histograms); - [Associated errors](\ref associated-errors); - [Associated functions](\ref associated-functions); - [Projections of histograms](\ref prof-hist); - [Random Numbers and histograms](\ref random-numbers); - [Making a copy of a histogram](\ref making-a-copy); - [Normalizing histograms](\ref normalizing); -# [Drawing histograms](\ref drawing-histograms); - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); - [Setting histogram graphics attributes](\ref graph-att); - [Customising how axes are drawn](\ref axis-drawing); -# [Fitting histograms](\ref fitting-histograms); -# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); -# [Operations on histograms](\ref operations-on-histograms); -# [Miscellaneous operations](\ref misc). ROOT supports the following histogram types:. - 1-D histograms:; - TH1C : histogra",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20892,Integrability,depend,depend,20892,"function via TH1::Fit.; See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation and the possible [fitting options](\ref HFitOpt). The FitPanel can also be used for fitting an histogram. See the [FitPanel documentation](https://root.cern/manual/fitting/#using-the-fit-panel). \anchor saving-histograms; ## Saving/reading histograms to/from a ROOT file. The following statements create a ROOT file and store a histogram; on the file. Because TH1 derives from TNamed, the key identifier on; the file is the histogram name:; ~~~ {.cpp}; TFile f(""histos.root"", ""new"");; TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; h1.FillRandom(""gaus"", 10000);; h1->Write();; ~~~; To read this histogram in another Root session, do:; ~~~ {.cpp}; TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");; ~~~; One can save all histograms in memory to the file by:; ~~~ {.cpp}; file->Write();; ~~~. \anchor misc; ## Miscellaneous operations. ~~~ {.cpp}; TH1::KolmogorovTest(): statistical test of compatibility in shape; between two histograms; TH1::Smooth() smooths the bin contents of a 1-d histogram; TH1::Integral() returns the integral of bin contents in a given bin range; TH1::GetMean(int axis) returns the mean value along axis; TH1::GetStdDev(int axis) returns the sigma distribution along axis; TH1::GetEntries() returns the number of entries; TH1::Reset() resets the bin contents and errors of a histogram; ~~~; IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the; histogram statistics are calculated. By default, if no range has been set, the; returned values are the (unbinned) ones calculated at fill time. If a range has been; set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN; IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset the range.; To ensure that the returned values are always those of the binned data stored in the; histogram, call TH1::ResetStats. See TH1::GetStats.; */",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:883,Modifiability,variab,variable,883,"channel (see TH1 documentation); \class TH1F; \brief 1-D histogram with a float per channel (see TH1 documentation); \class TH1D; \brief 1-D histogram with a double per channel (see TH1 documentation); @}; */; /** \class TH1; \ingroup Histograms; TH1 is the base class of all histogram classes in %ROOT. It provides the common interface for operations such as binning, filling, drawing, which; will be detailed below. -# [Creating histograms](\ref creating-histograms); - [Labelling axes](\ref labelling-axis); -# [Binning](\ref binning); - [Fix or variable bin size](\ref fix-var); - [Convention for numbering bins](\ref convention); - [Alphanumeric Bin Labels](\ref alpha); - [Histograms with automatic bins](\ref auto-bin); - [Rebinning](\ref rebinning); -# [Filling histograms](\ref filling-histograms); - [Associated errors](\ref associated-errors); - [Associated functions](\ref associated-functions); - [Projections of histograms](\ref prof-hist); - [Random Numbers and histograms](\ref random-numbers); - [Making a copy of a histogram](\ref making-a-copy); - [Normalizing histograms](\ref normalizing); -# [Drawing histograms](\ref drawing-histograms); - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); - [Setting histogram graphics attributes](\ref graph-att); - [Customising how axes are drawn](\ref axis-drawing); -# [Fitting histograms](\ref fitting-histograms); -# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); -# [Operations on histograms](\ref operations-on-histograms); -# [Miscellaneous operations](\ref misc). ROOT supports the following histogram types:. - 1-D histograms:; - TH1C : histograms with one byte per channel. Maximum bin content = 127; - TH1S : histograms with one short per channel. Maximum bin content = 32767; - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**""); - ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4595,Modifiability,variab,variable,4595,"ograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**""); - TH3F : histograms with one float per channel. Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax ""***""); - TH3D : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax ""****""); - Profile histograms: See classes TProfile, TProfile2D and TProfile3D.; Profile histograms are used to display the mean value of Y and its standard deviation; for each bin in X. Profile histograms are in many cases an elegant; replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile; histogram with much better precision than by a scatter-plot. <sup>; \anchor intmax (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor llongmax (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor floatmax (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; \anchor doublemax (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); </sup>. The inheritance hierarchy looks as follows:. \image html classTH1__inherit__graph_org.svg width=100%. \anchor creating-histograms; ## Creating histograms. Histograms are created by invoking one of the constructors, e.g.; ~~~ {.cpp}; TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 t",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4773,Modifiability,variab,variable,4773,"ion 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax ""***""); - TH3D : histograms with one double per channel. Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax ""****""); - Profile histograms: See classes TProfile, TProfile2D and TProfile3D.; Profile histograms are used to display the mean value of Y and its standard deviation; for each bin in X. Profile histograms are in many cases an elegant; replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile; histogram with much better precision than by a scatter-plot. <sup>; \anchor intmax (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor llongmax (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor floatmax (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; \anchor doublemax (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); </sup>. The inheritance hierarchy looks as follows:. \image html classTH1__inherit__graph_org.svg width=100%. \anchor creating-histograms; ## Creating histograms. Histograms are created by invoking one of the constructors, e.g.; ~~~ {.cpp}; TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);; ~~~; Histograms may also be created by:. - calling the Clone() function, see below; - making a projection from a 2-D or 3",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5255,Modifiability,inherit,inheritance,5255,"nd Y can always be visualized by a two-dimensional; histogram or scatter-plot; If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile; histogram with much better precision than by a scatter-plot. <sup>; \anchor intmax (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor llongmax (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor floatmax (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; \anchor doublemax (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); </sup>. The inheritance hierarchy looks as follows:. \image html classTH1__inherit__graph_org.svg width=100%. \anchor creating-histograms; ## Creating histograms. Histograms are created by invoking one of the constructors, e.g.; ~~~ {.cpp}; TH1F *h1 = new TH1F(""h1"", ""h1 title"", 100, 0, 4.4);; TH2F *h2 = new TH2F(""h2"", ""h2 title"", 40, 0, 4, 30, -3, 3);; ~~~; Histograms may also be created by:. - calling the Clone() function, see below; - making a projection from a 2-D or 3-D histogram, see below; - reading a histogram from a file. When a histogram is created, a reference to it is automatically added; to the list of in-memory objects for the current file or directory.; Then the pointer to this histogram in the current directory can be found; by its name, doing:; ~~~ {.cpp}; TH1F *h1 = (TH1F*)gDirectory->FindObject(name);; ~~~. This default behaviour can be changed by:; ~~~ {.cpp}; h->SetDirectory(nullptr); // for the current histogram h; TH1::AddDirectory(kFALSE); // sets a global switch disabling the referencing; ~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7352,Modifiability,variab,variable,7352,"e list of objects in memory.; When a file is closed, all histograms in memory associated with this file; are automatically deleted. \anchor labelling-axis; ### Labelling axes. Axis titles can be specified in the title argument of the constructor.; They must be separated by "";"":; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis"", 100, 0, 1);; ~~~; The histogram title and the axis titles can be any TLatex string, and; are persisted if a histogram is written to a file. Any title can be omitted:; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; ~~~; The method SetTitle() has the same syntax:; ~~~ {.cpp}; h->SetTitle(""Histogram title;Another X title Axis"");; ~~~; Alternatively, the title of each axis can be set directly:; ~~~ {.cpp}; h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; ~~~; For bin labels see \ref binning. \anchor binning; ## Binning. \anchor fix-var; ### Fix or variable bin size. All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases. Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D hist",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7413,Modifiability,variab,variable,7413,"l histograms in memory associated with this file; are automatically deleted. \anchor labelling-axis; ### Labelling axes. Axis titles can be specified in the title argument of the constructor.; They must be separated by "";"":; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis"", 100, 0, 1);; ~~~; The histogram title and the axis titles can be any TLatex string, and; are persisted if a histogram is written to a file. Any title can be omitted:; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; ~~~; The method SetTitle() has the same syntax:; ~~~ {.cpp}; h->SetTitle(""Histogram title;Another X title Axis"");; ~~~; Alternatively, the title of each axis can be set directly:; ~~~ {.cpp}; h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; ~~~; For bin labels see \ref binning. \anchor binning; ## Binning. \anchor fix-var; ### Fix or variable bin size. All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases. Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7484,Modifiability,variab,variable,7484,"anchor labelling-axis; ### Labelling axes. Axis titles can be specified in the title argument of the constructor.; They must be separated by "";"":; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis"", 100, 0, 1);; ~~~; The histogram title and the axis titles can be any TLatex string, and; are persisted if a histogram is written to a file. Any title can be omitted:; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; ~~~; The method SetTitle() has the same syntax:; ~~~ {.cpp}; h->SetTitle(""Histogram title;Another X title Axis"");; ~~~; Alternatively, the title of each axis can be set directly:; ~~~ {.cpp}; h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; ~~~; For bin labels see \ref binning. \anchor binning; ## Binning. \anchor fix-var; ### Fix or variable bin size. All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases. Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp}; Int_t gbin = h->GetBin(binx, biny, binz);; ~~~; returns a global/linearized",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12861,Modifiability,extend,extend,12861,"; h2->Fill(x, y, w); h3->Fill(x, y, z); h3->Fill(x, y, z, w); ~~~; or via one of the Fill functions accepting names described above.; The Fill functions compute the bin number corresponding to the given; x, y or z argument and increment this bin by the given weight.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent. Passing an; out-of-range bin to TH1::AddBinContent leads to undefined behavior.; To access the bin content of a given bin, do:; ~~~ {.cpp}; Double_t binContent = h->GetBinContent(bin);; ~~~. By default, the bin number is computed using the current axis ranges.; If the automatic binning option has been set via; ~~~ {.cpp}; h->SetCanExtend(TH1::kAllAxes);; ~~~; then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents. \anchor associated-errors; ### Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of we",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13156,Modifiability,variab,variables,13156,"ght.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent. Passing an; out-of-range bin to TH1::AddBinContent leads to undefined behavior.; To access the bin content of a given bin, do:; ~~~ {.cpp}; Double_t binContent = h->GetBinContent(bin);; ~~~. By default, the bin number is computed using the current axis ranges.; If the automatic binning option has been set via; ~~~ {.cpp}; h->SetCanExtend(TH1::kAllAxes);; ~~~; then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 32767). Histograms of all types may have positive; or/and negative bin contents. \anchor associated-errors; ### Associated errors; By default, for each bin, the sum of weights is computed at fill time.; One can also call TH1::Sumw2 to force the storage and computation; of the sum of the square of weights per bin.; If Sumw2 has been called, the error per bin is computed as the; sqrt(sum of squares of weights), otherwise the error is set equal; to the sqrt(bin content).; To return the error for a given bin number, do:; ~~~ {.cpp}; Double_t error = h->GetBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18366,Modifiability,inherit,inherit,18366,"ads where it was drawn.; If a histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of a histogram in a pad, one can use; ~~~ {.cpp}; h->DrawCopy();; ~~~; This makes a clone (see Clone below) of the histogram. Once the clone; is drawn, the original histogram may be modified or deleted without; affecting the aspect of the clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; functions affect the z-axis). TH1::UseCurrentStyle() can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle(). \anchor cont-level; ### Setting Drawing histogram contour levels (2-D hists only). By default contours are automatically generated at equidistant; intervals. A default value of 20 levels is used. This can be modified; via TH1::SetContour() or TH1::SetContourLevel().; the contours level info is used by the drawing options ""cont"", ""surf"",; and ""lego"". \anchor graph-att; ### Setting histogram graphics attributes. The histogram classes inherit from the attribute classes:; TAttLine, TAttFill, and TAttMarker.; See the member functions of these classes for the list of options. \anchor axis-drawing; ### Customizing how axes are drawn. Use the functions of TAxis, such as; ~~~ {.cpp}; histogram.GetXaxis()->SetTicks(""+"");; histogram.GetYaxis()->SetRangeUser(1., 5.);; ~~~. \anchor fitting-histograms; ## Fitting histograms. Histograms (1-D, 2-D, 3-D and Profiles) can be fitted with a user; specified function ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18891,Modifiability,inherit,inherit,18891,"to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histograms these; functions affect the z-axis). TH1::UseCurrentStyle() can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle(). \anchor cont-level; ### Setting Drawing histogram contour levels (2-D hists only). By default contours are automatically generated at equidistant; intervals. A default value of 20 levels is used. This can be modified; via TH1::SetContour() or TH1::SetContourLevel().; the contours level info is used by the drawing options ""cont"", ""surf"",; and ""lego"". \anchor graph-att; ### Setting histogram graphics attributes. The histogram classes inherit from the attribute classes:; TAttLine, TAttFill, and TAttMarker.; See the member functions of these classes for the list of options. \anchor axis-drawing; ### Customizing how axes are drawn. Use the functions of TAxis, such as; ~~~ {.cpp}; histogram.GetXaxis()->SetTicks(""+"");; histogram.GetYaxis()->SetRangeUser(1., 5.);; ~~~. \anchor fitting-histograms; ## Fitting histograms. Histograms (1-D, 2-D, 3-D and Profiles) can be fitted with a user; specified function or a pre-defined function via TH1::Fit.; See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation and the possible [fitting options](\ref HFitOpt). The FitPanel can also be used for fitting an histogram. See the [FitPanel documentation](https://root.cern/manual/fitting/#using-the-fit-panel). \anchor saving-histograms; ## Saving/reading histograms to/from a ROOT file. The following statements create a ROOT file and store a histogram; on the file. Because TH1 derives from TNamed, the key identifier on; the file i",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7570,Security,access,access,7570,"t of the constructor.; They must be separated by "";"":; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;X Axis;Y Axis"", 100, 0, 1);; ~~~; The histogram title and the axis titles can be any TLatex string, and; are persisted if a histogram is written to a file. Any title can be omitted:; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; ~~~; The method SetTitle() has the same syntax:; ~~~ {.cpp}; h->SetTitle(""Histogram title;Another X title Axis"");; ~~~; Alternatively, the title of each axis can be set directly:; ~~~ {.cpp}; h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; ~~~; For bin labels see \ref binning. \anchor binning; ## Binning. \anchor fix-var; ### Fix or variable bin size. All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases. Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp}; Int_t gbin = h->GetBin(binx, biny, binz);; ~~~; returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information indepen",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7710,Security,access,access,7710,"tle and the axis titles can be any TLatex string, and; are persisted if a histogram is written to a file. Any title can be omitted:; ~~~ {.cpp}; TH1F* h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; ~~~; The method SetTitle() has the same syntax:; ~~~ {.cpp}; h->SetTitle(""Histogram title;Another X title Axis"");; ~~~; Alternatively, the title of each axis can be set directly:; ~~~ {.cpp}; h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; ~~~; For bin labels see \ref binning. \anchor binning; ## Binning. \anchor fix-var; ### Fix or variable bin size. All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases. Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp}; Int_t gbin = h->GetBin(binx, biny, binz);; ~~~; returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:; ~~~ {.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7895,Security,access,access,7895," h=new TH1F(""h"", ""Histogram title;;Y Axis"", 100, 0, 1);; TH1F* h=new TH1F(""h"", "";;Y Axis"", 100, 0, 1);; ~~~; The method SetTitle() has the same syntax:; ~~~ {.cpp}; h->SetTitle(""Histogram title;Another X title Axis"");; ~~~; Alternatively, the title of each axis can be set directly:; ~~~ {.cpp}; h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");; ~~~; For bin labels see \ref binning. \anchor binning; ## Binning. \anchor fix-var; ### Fix or variable bin size. All histogram types support either fix or variable bin sizes.; 2-D histograms may have fix size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw or access; histograms are identical in both cases. Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp}; Int_t gbin = h->GetBin(binx, biny, binz);; ~~~; returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:; ~~~ {.cpp}; Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; ~~~; returns the center along z of bin number 27 (not the global bin); in the 3-D histogra",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:8524,Security,access,access,8524,"fill, manipulate, draw or access; histograms are identical in both cases. Each histogram always contains 3 axis objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp}; Int_t gbin = h->GetBin(binx, biny, binz);; ~~~; returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:; ~~~ {.cpp}; Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; ~~~; returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3. \anchor alpha; ### Alphanumeric Bin Labels. By default, a histogram axis is drawn with its numeric bin labels.; One can specify alphanumeric labels instead with:. - call TAxis::SetBinLabel(bin, label);; This can always be done before or after filling.; When the histogram is drawn, bin labels will be automatically drawn.; See examples labels1.C and labels2.C; - call to a Fill function with one of the arguments being a string, e.g.; ~~~ {.cpp}; hist1->Fill(somename, weight);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);; ~~~; See examples hlabels1.C and hlabels2.C; - via TTree::Draw. see",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:8611,Security,access,access,8611,"objects of type TAxis: fXaxis, fYaxis and fZaxis.; To access the axis parameters, use:; ~~~ {.cpp}; TAxis *xaxis = h->GetXaxis(); etc.; Double_t binCenter = xaxis->GetBinCenter(bin), etc.; ~~~; See class TAxis for a description of all the access functions.; The axis range is always stored internally in double precision. \anchor convention; ### Convention for numbering bins. For all histogram types: nbins, xlow, xup; ~~~ {.cpp}; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; ~~~; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with (binx, biny, binz), the function; ~~~ {.cpp}; Int_t gbin = h->GetBin(binx, biny, binz);; ~~~; returns a global/linearized gbin number. This global gbin is useful; to access the bin content/error information independently of the dimension.; Note that to access the information other than bin content and errors; one should use the TAxis object directly with e.g.:; ~~~ {.cpp}; Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; ~~~; returns the center along z of bin number 27 (not the global bin); in the 3-D histogram h3. \anchor alpha; ### Alphanumeric Bin Labels. By default, a histogram axis is drawn with its numeric bin labels.; One can specify alphanumeric labels instead with:. - call TAxis::SetBinLabel(bin, label);; This can always be done before or after filling.; When the histogram is drawn, bin labels will be automatically drawn.; See examples labels1.C and labels2.C; - call to a Fill function with one of the arguments being a string, e.g.; ~~~ {.cpp}; hist1->Fill(somename, weight);; hist2->Fill(x, somename, weight);; hist2->Fill(somename, y, weight);; hist2->Fill(somenamex, somenamey, weight);; ~~~; See examples hlabels1.C and hlabels2.C; - via TTree::Draw. see for example cernstaff.C; ~~~ {.cpp}; tree.Draw(""Nation::Division"");; ~~~; where ""Nation"" and ""Division"" are two ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12540,Security,access,access,12540,"a new histogram with the rebinned contents.; If bin errors were stored, they are recomputed during the rebinning. \anchor filling-histograms; ## Filling histograms. A histogram is typically filled with statements like:; ~~~ {.cpp}; h1->Fill(x);; h1->Fill(x, w); //fill with weight; h2->Fill(x, y); h2->Fill(x, y, w); h3->Fill(x, y, z); h3->Fill(x, y, z, w); ~~~; or via one of the Fill functions accepting names described above.; The Fill functions compute the bin number corresponding to the given; x, y or z argument and increment this bin by the given weight.; The Fill functions return the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms.; If TH1::Sumw2 has been called before filling, the sum of squares of; weights is also stored.; One can also increment directly a bin number via TH1::AddBinContent; or replace the existing content via TH1::SetBinContent. Passing an; out-of-range bin to TH1::AddBinContent leads to undefined behavior.; To access the bin content of a given bin, do:; ~~~ {.cpp}; Double_t binContent = h->GetBinContent(bin);; ~~~. By default, the bin number is computed using the current axis ranges.; If the automatic binning option has been set via; ~~~ {.cpp}; h->SetCanExtend(TH1::kAllAxes);; ~~~; then, the Fill Function will automatically extend the axis range to; accomodate the new value specified in the Fill argument. The method; used is to double the bin size until the new value fits in the range,; merging bins two by two. This automatic binning options is extensively; used by the TTree::Draw function when histogramming Tree variables; with an unknown range.; This automatic binning option is supported for 1-D, 2-D and 3-D histograms. During filling, some statistics parameters are incremented to compute; the mean value and Root Mean Square with the maximum precision. In case of histograms of type TH1C, TH1S, TH2C, TH2S, TH3C, TH3S; a check is made that the bin contents do not exceed the maximum positive; capacity (127 or 3276",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20396,Testability,test,test,20396,"function via TH1::Fit.; See TH1::Fit(TF1*, Option_t *, Option_t *, Double_t, Double_t) for the fitting documentation and the possible [fitting options](\ref HFitOpt). The FitPanel can also be used for fitting an histogram. See the [FitPanel documentation](https://root.cern/manual/fitting/#using-the-fit-panel). \anchor saving-histograms; ## Saving/reading histograms to/from a ROOT file. The following statements create a ROOT file and store a histogram; on the file. Because TH1 derives from TNamed, the key identifier on; the file is the histogram name:; ~~~ {.cpp}; TFile f(""histos.root"", ""new"");; TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; h1.FillRandom(""gaus"", 10000);; h1->Write();; ~~~; To read this histogram in another Root session, do:; ~~~ {.cpp}; TFile f(""histos.root"");; TH1F *h = (TH1F*)f.Get(""hgaus"");; ~~~; One can save all histograms in memory to the file by:; ~~~ {.cpp}; file->Write();; ~~~. \anchor misc; ## Miscellaneous operations. ~~~ {.cpp}; TH1::KolmogorovTest(): statistical test of compatibility in shape; between two histograms; TH1::Smooth() smooths the bin contents of a 1-d histogram; TH1::Integral() returns the integral of bin contents in a given bin range; TH1::GetMean(int axis) returns the mean value along axis; TH1::GetStdDev(int axis) returns the sigma distribution along axis; TH1::GetEntries() returns the number of entries; TH1::Reset() resets the bin contents and errors of a histogram; ~~~; IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the; histogram statistics are calculated. By default, if no range has been set, the; returned values are the (unbinned) ones calculated at fill time. If a range has been; set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN; IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset the range.; To ensure that the returned values are always those of the binned data stored in the; histogram, call TH1::ResetStats. See TH1::GetStats.; */",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:17070,Usability,usab,usable,17070,"am; 10000 times with a default gaussian distribution of mean 0 and sigma 1:; ~~~ {.cpp}; TH1F h1(""h1"", ""histo from a gaussian"", 100, -3, 3);; h1.FillRandom(""gaus"", 10000);; ~~~; TH1::GetRandom can be used to return a random number distributed; according to the contents of a histogram. \anchor making-a-copy; ### Making a copy of a histogram; Like for any other ROOT object derived from TObject, one can use; the Clone() function. This makes an identical copy of the original; histogram including all associated errors and functions, e.g.:; ~~~ {.cpp}; TH1F *hnew = (TH1F*)h->Clone(""hnew"");; ~~~. \anchor normalizing; ### Normalizing histograms. One can scale a histogram such that the bins integral is equal to; the normalization parameter via TH1::Scale(Double_t norm), where norm; is the desired normalization divided by the integral of the histogram. \anchor drawing-histograms; ## Drawing histograms. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; Many drawing options are supported.; See THistPainter::Paint() for more details. The same histogram can be drawn with different options in different pads.; When a histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If a histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of a histogram in a pad, one can use; ~~~ {.cpp}; h->DrawCopy();; ~~~; This makes a clone (see Clone below) of the histogram. Once the clone; is drawn, the original histogram may be modified or deleted without; affecting the aspect of the clone. One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular; value for the maximum or the minimum scale on the plot. (For 1-D; histograms this means the y-axis, while for 2-D histogr",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10,Testability,log,logic,10,"//special logic to support the case where the same object is; //added multiple times in fFunctions.; //This case happens when the same object is added with different; //drawing modes; //In the loop below we must be careful with objects (eg TCutG) that may; // have been added to the list of functions of several histograms; //and may have been already deleted.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:215,Safety,avoid,avoid,215,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for fix bin size histograms.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`,; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbins number of bins; /// \param[in] xlow low edge of first bin; /// \param[in] xup upper edge of last bin (not included in last bin)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size histograms using an input array of type float.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbins number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbins+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:255,Safety,avoid,avoid,255,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size histograms using an input array of type float.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbins number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbins+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size histograms using an input array of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbins number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbins+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:213,Safety,avoid,avoid,213,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size histograms using an input array of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbins number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbins+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:140,Availability,error,errors,140,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*f1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// By default, the function is computed at the centre of the bin.; /// if option ""I"" is specified (1-d histogram only), the integral of the; /// function in each bin is used instead of the value of the function at; /// the centre of the bin.; ///; /// Only bins inside the function range are recomputed.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:177,Availability,error,errors,177,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*f1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// By default, the function is computed at the centre of the bin.; /// if option ""I"" is specified (1-d histogram only), the integral of the; /// function in each bin is used instead of the value of the function at; /// the centre of the bin.; ///; /// Only bins inside the function range are recomputed.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:569,Availability,error,errors,569,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*f1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// By default, the function is computed at the centre of the bin.; /// if option ""I"" is specified (1-d histogram only), the integral of the; /// function in each bin is used instead of the value of the function at; /// the centre of the bin.; ///; /// Only bins inside the function range are recomputed.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*f1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// By default, the function is computed at the centre of the bin.; /// if option ""I"" is specified (1-d histogram only), the integral of the; /// function in each bin is used instead of the value of the function at; /// the centre of the bin.; ///; /// Only bins inside the function range are recomputed.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:140,Availability,error,errors,140,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1`; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram with labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE1: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; /// is used , ie this = this + c1*factor*h1; /// Use the other TH1::Add function if you do not want this feature; ///; /// IMPORTANT NOTE3: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:177,Availability,error,errors,177,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1`; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram with labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE1: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; /// is used , ie this = this + c1*factor*h1; /// Use the other TH1::Add function if you do not want this feature; ///; /// IMPORTANT NOTE3: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:972,Availability,error,errors,972,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1`; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram with labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE1: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; /// is used , ie this = this + c1*factor*h1; /// Use the other TH1::Add function if you do not want this feature; ///; /// IMPORTANT NOTE3: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1487,Integrability,depend,depending,1487,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1`; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram with labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE1: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; /// is used , ie this = this + c1*factor*h1; /// Use the other TH1::Add function if you do not want this feature; ///; /// IMPORTANT NOTE3: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1`; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram with labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE1: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; /// is used , ie this = this + c1*factor*h1; /// Use the other TH1::Add function if you do not want this feature; ///; /// IMPORTANT NOTE3: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:128,Safety,risk,risks,128,"// statistics can be preserved only in case of positive coefficients; // otherwise with negative c1 (histogram subtraction) one risks to get negative variances",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:84,Integrability,depend,depending,84,"// need to initialize to zero s1 and s2 since; // GetStats fills only used elements depending on dimension and type",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:39,Availability,error,errors,39,"// consider all special cases when bin errors are zero; // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20,Availability,error,error,20,"// use an estimated error from the global histogram scale",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20,Availability,error,error,20,"// use an estimated error from the global histogram scale",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Deployability,update,update,3,"// update statistics (do here to avoid changes by SetBinContent)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:33,Safety,avoid,avoid,33,"// update statistics (do here to avoid changes by SetBinContent)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:192,Availability,error,errors,192,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the addition of h1 and h2.; ///; /// `this = c1*h1 + c2*h2`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated; ///; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram ith labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0; /// do a scaling this = c1 * h1 / (bin Volume); ///; /// The function returns kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:229,Availability,error,errors,229,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the addition of h1 and h2.; ///; /// `this = c1*h1 + c2*h2`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated; ///; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram ith labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0; /// do a scaling this = c1 * h1 / (bin Volume); ///; /// The function returns kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1028,Availability,error,errors,1028,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the addition of h1 and h2.; ///; /// `this = c1*h1 + c2*h2`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated; ///; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram ith labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0; /// do a scaling this = c1 * h1 / (bin Volume); ///; /// The function returns kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1343,Integrability,depend,depending,1343,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the addition of h1 and h2.; ///; /// `this = c1*h1 + c2*h2`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated; ///; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram ith labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0; /// do a scaling this = c1 * h1 / (bin Volume); ///; /// The function returns kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:144,Safety,risk,risks,144,"// TODO remove; // statistics can be preserved only in case of positive coefficients; // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; // also in case of scaling with the width we cannot preserve the statistics",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:84,Integrability,depend,depending,84,"// need to initialize to zero s1 and s2 since; // GetStats fills only used elements depending on dimension and type",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:39,Availability,error,errors,39,"// consider all special cases when bin errors are zero; // see http://root-forum.cern.ch/viewtopic.php?f=3&t=13299",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20,Availability,error,error,20,"// use an estimated error from the global histogram scale",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20,Availability,error,error,20,"// use an estimated error from the global histogram scale",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:11,Usability,simpl,simple,11,"// case of simple histogram addition",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Deployability,update,update,3,"// update statistics (do here to avoid changes by SetBinContent) FIXME remove???",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:33,Safety,avoid,avoid,33,"// update statistics (do here to avoid changes by SetBinContent) FIXME remove???",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Energy Efficiency,power,power,116,"////////////////////////////////////////////////////////////////////////////////; /// Auxiliary function to get the power of 2 next (larger) or previous (smaller); /// a given x; ///; /// next = kTRUE : next larger; /// next = kFALSE : previous smaller; ///; /// Used by the autobin power of 2 algorithm",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:283,Energy Efficiency,power,power,283,"////////////////////////////////////////////////////////////////////////////////; /// Auxiliary function to get the power of 2 next (larger) or previous (smaller); /// a given x; ///; /// next = kTRUE : next larger; /// next = kFALSE : previous smaller; ///; /// Used by the autobin power of 2 algorithm",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:121,Energy Efficiency,power,power,121,"////////////////////////////////////////////////////////////////////////////////; /// Auxiliary function to get the next power of 2 integer value larger then n; ///; /// Used by the autobin power of 2 algorithm",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:190,Energy Efficiency,power,power,190,"////////////////////////////////////////////////////////////////////////////////; /// Auxiliary function to get the next power of 2 integer value larger then n; ///; /// Used by the autobin power of 2 algorithm",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:141,Energy Efficiency,power,power,141,"////////////////////////////////////////////////////////////////////////////////; /// Buffer-based estimate of the histogram range using the power of 2 algorithm.; ///; /// Used by the autobin power of 2 algorithm.; ///; /// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; /// fXmax, NBinsX (from fXaxis), ...; /// Result save internally in fXaxis.; ///; /// Overloaded by TH2 and TH3.; ///; /// Return -1 if internal inputs are inconsistent, 0 otherwise.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:193,Energy Efficiency,power,power,193,"////////////////////////////////////////////////////////////////////////////////; /// Buffer-based estimate of the histogram range using the power of 2 algorithm.; ///; /// Used by the autobin power of 2 algorithm.; ///; /// Works on arguments (min and max from fBuffer) and internal inputs: fXmin,; /// fXmax, NBinsX (from fXaxis), ...; /// Result save internally in fXaxis.; ///; /// Overloaded by TH2 and TH3.; ///; /// Return -1 if internal inputs are inconsistent, 0 otherwise.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:30,Energy Efficiency,power,power,30,"// Round the bins to the next power of 2; take into account the possible inflation; // of the range",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:53,Safety,avoid,avoid,53,"// if action is 1 we delete the buffer; // this will avoid infinite recursion",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:98,Safety,avoid,avoid,98,"// call DoFillN which will not put entries in the buffer as FillN does; // set fBuffer to zero to avoid re-emptying the buffer from functions called; // by DoFillN (e.g Sumw2)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:71,Safety,avoid,avoid,71,"// if number of entries is consistent with buffer - set it negative to avoid; // refilling the histogram every time BufferEmpty(0) is called; // In case it is not consistent, by setting fBuffer[0]=0 is like resetting the buffer; // (it will not be used anymore the next time BufferEmpty is called)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:26,Safety,avoid,avoid,26,"// set fBuffer to zero to avoid calling BufferEmpty in Reset",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6,Safety,avoid,avoid,6,"// to avoid infinite recursion Fill->BufferFill->Fill",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:222,Modifiability,variab,variable,222,"////////////////////////////////////////////////////////////////////////////////; /// Check that two sub axis are the same.; /// The limits are defined by first bin and last bin; /// N.B. no check is done in this case for variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7738,Availability,down,down,7738,"on; /// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.; /// If we replace the variance \f$ \sigma_{i}^{2} \f$; /// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of; /// events in the ith bin) and the hypothesis of identity is valid, then the; /// maximum likelihood estimator of pi,i=1,...,r, is; ///\f[; /// \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}; ///\f]; /// We may then use the test statistic; ///\f[; /// X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}; ///\f]; /// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well; /// as the original one [3], has a restriction on the expected frequencies. The; /// expected frequencies recommended for the weighted histogram is more than 25.; /// The value of the minimal expected frequency can be decreased down to 10 for; /// the case when the weights of the events are close to constant. In the case; /// of a weighted histogram if the number of events is unknown, then we can; /// apply this recommendation for the equivalent number of events as; ///\f[; /// n_{i}^{equiv} = \frac{ w_{i}^{2} }{ s_{i}^{2} }; ///\f]; /// The minimal expected frequency for an unweighted histogram must be 1. Notice; /// that any usual (unweighted) histogram can be considered as a weighted; /// histogram with events that have constant weights equal to 1.; /// The variance \f$ z_{i}^{2} \f$ of the difference between the weight wi; /// and the estimated expectation value of the weight is approximately equal to:; ///\f[; /// z_{i}^{2} = Var(w_{i}-W\hat{p}_{i}) = N\hat{p}_{i}(1-N\hat{p}_{i})\left(\frac{Ws_{i}^{2}}{\sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}\right)^{2}+\frac{s_{i}^{2}}{4}\left(1+\frac{Ns_{i}^{2}-w_{i}W}{\sqrt{(Ns_{i}^{2}-w_{i}W)^{2}+4W^{2}s_{i}^{2}n_{i}}}\right)^{2}; ///\f]; /// The residuals; ///\f",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:14604,Availability,robust,robustness,14604,"17 events (minimal expected; /// frequency equal to one) and the weighted histogram with 500 events (minimal; /// expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C(17); /// End_Macro; /// Fig 2. An example of comparison of the unweighted histogram with 217 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histogram;; /// 2. weighted histogram;; /// 3. normalized residuals plot;; /// 4. normal Q-Q plot of residuals.; ///; /// The value of the test statistic \f$ \chi^{2} \f$ is equal to; /// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; /// the two histograms is rejected for 0.05 significant level. The behavior of; /// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; /// Fig. 2d) of residuals are not regular and we can identify the outlier or; /// bin with a big influence on \f$ \chi^{2} \f$.; ///; /// #### References:; ///; /// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; /// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; /// Series No. 1, London.; /// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; /// of weighted and unweighted histograms. Statistical Problems in Particle; /// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; /// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; /// Gagunashvili,N., Comparison of weighted and unweighted histograms,; /// arXiv:physics/0605123, 2006.; /// - [3] Cramer, H., 1946. Mathematical methods of statistics.; /// Princeton University Press, Princeton.; /// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; /// Biometrics 29, 205-220.; /// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; /// test in 2xN tables. Biometrics 21, 19-33.; /// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; /// John Wiley & Sons Inc., New York.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3021,Energy Efficiency,power,power,3021,"ew:; ///; /// Comparison of two histograms expect hypotheses that two histograms; /// represent identical distributions. To make a decision p-value should; /// be calculated. The hypotheses of identity is rejected if the p-value is; /// lower then some significance level. Traditionally significance levels; /// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; /// analysis of the residuals which is often helpful in identifying the; /// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; /// Residuals are the difference between bin contents and expected bin; /// contents. Most convenient for analysis are the normalized residuals. If; /// hypotheses of identity are valid then normalized residuals are; /// approximately independent and identically distributed random variables; /// having N(0,1) distribution. Analysis of residuals expect test of above; /// mentioned properties of residuals. Notice that indirectly the analysis; /// of residuals increase the power of \f$ \chi^{2} \f$ test.; ///; /// #### Methods of comparison:; ///; /// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; /// Let us consider two histograms with the same binning and the number; /// of bins equal to r. Let us denote the number of events in the ith bin; /// in the first histogram as ni and as mi in the second one. The total; /// number of events in the first histogram is equal to:; /// \f[; /// N = \sum_{i=1}^{r} n_{i}; /// \f]; /// and; /// \f[; /// M = \sum_{i=1}^{r} m_{i}; /// \f]; /// in the second histogram. The hypothesis of identity (homogeneity) [3]; /// is that the two histograms represent random values with identical; /// distributions. It is equivalent that there exist r constants p1,...,pr,; /// such that; /// \f[; ///\sum_{i=1}^{r} p_{i}=1; /// \f]; /// and the probability of belonging to the ith bin for some measured value; /// in both experiments is equal to pi. The number of events in the ith; /// bin is a rando",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2828,Modifiability,variab,variables,2828,"s; /// for comparison of weighted and unweighted histograms and two weighted; /// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; /// comparison two usual (unweighted) histograms.; ///; /// #### Overview:; ///; /// Comparison of two histograms expect hypotheses that two histograms; /// represent identical distributions. To make a decision p-value should; /// be calculated. The hypotheses of identity is rejected if the p-value is; /// lower then some significance level. Traditionally significance levels; /// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; /// analysis of the residuals which is often helpful in identifying the; /// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; /// Residuals are the difference between bin contents and expected bin; /// contents. Most convenient for analysis are the normalized residuals. If; /// hypotheses of identity are valid then normalized residuals are; /// approximately independent and identically distributed random variables; /// having N(0,1) distribution. Analysis of residuals expect test of above; /// mentioned properties of residuals. Notice that indirectly the analysis; /// of residuals increase the power of \f$ \chi^{2} \f$ test.; ///; /// #### Methods of comparison:; ///; /// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; /// Let us consider two histograms with the same binning and the number; /// of bins equal to r. Let us denote the number of events in the ith bin; /// in the first histogram as ni and as mi in the second one. The total; /// number of events in the first histogram is equal to:; /// \f[; /// N = \sum_{i=1}^{r} n_{i}; /// \f]; /// and; /// \f[; /// M = \sum_{i=1}^{r} m_{i}; /// \f]; /// in the second histogram. The hypothesis of identity (homogeneity) [3]; /// is that the two histograms represent random values with identical; /// distributions. It is equivalent that there exist r constants p1,...,pr,; /// s",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4005,Modifiability,variab,variable,4005,"r comparison two (unweighted) histograms:; /// Let us consider two histograms with the same binning and the number; /// of bins equal to r. Let us denote the number of events in the ith bin; /// in the first histogram as ni and as mi in the second one. The total; /// number of events in the first histogram is equal to:; /// \f[; /// N = \sum_{i=1}^{r} n_{i}; /// \f]; /// and; /// \f[; /// M = \sum_{i=1}^{r} m_{i}; /// \f]; /// in the second histogram. The hypothesis of identity (homogeneity) [3]; /// is that the two histograms represent random values with identical; /// distributions. It is equivalent that there exist r constants p1,...,pr,; /// such that; /// \f[; ///\sum_{i=1}^{r} p_{i}=1; /// \f]; /// and the probability of belonging to the ith bin for some measured value; /// in both experiments is equal to pi. The number of events in the ith; /// bin is a random variable with a distribution approximated by a Poisson; /// probability distribution; /// \f[; ///\frac{e^{-Np_{i}}(Np_{i})^{n_{i}}}{n_{i}!}; /// \f]; ///for the first histogram and with distribution; /// \f[; ///\frac{e^{-Mp_{i}}(Mp_{i})^{m_{i}}}{m_{i}!}; /// \f]; /// for the second histogram. If the hypothesis of homogeneity is valid,; /// then the maximum likelihood estimator of pi, i=1,...,r, is; /// \f[; ///\hat{p}_{i}= \frac{n_{i}+m_{i}}{N+M}; /// \f]; /// and then; /// \f[; /// X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}; /// \f]; /// has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [3].; /// The comparison procedure can include an analysis of the residuals which; /// is often helpful in identifying the bins of histograms responsible for; /// a significant overall \f$ \chi^{2} \f$ value. Most convenient for; /// analysis are the adjusted (normalized) residuals [4]; /// \f[; /// r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5303,Modifiability,variab,variables,5303,"for the first histogram and with distribution; /// \f[; ///\frac{e^{-Mp_{i}}(Mp_{i})^{m_{i}}}{m_{i}!}; /// \f]; /// for the second histogram. If the hypothesis of homogeneity is valid,; /// then the maximum likelihood estimator of pi, i=1,...,r, is; /// \f[; ///\hat{p}_{i}= \frac{n_{i}+m_{i}}{N+M}; /// \f]; /// and then; /// \f[; /// X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}; /// \f]; /// has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [3].; /// The comparison procedure can include an analysis of the residuals which; /// is often helpful in identifying the bins of histograms responsible for; /// a significant overall \f$ \chi^{2} \f$ value. Most convenient for; /// analysis are the adjusted (normalized) residuals [4]; /// \f[; /// r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}; /// \f]; /// If hypotheses of homogeneity are valid then residuals ri are; /// approximately independent and identically distributed random variables; /// having N(0,1) distribution. The application of the \f$ \chi^{2} \f$ test has; /// restrictions related to the value of the expected frequencies Npi,; /// Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; /// expectations must be 1 or greater for both histograms. In practical; /// cases when expected frequencies are not known the estimated expected; /// frequencies \f$ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \f$ can be used.; ///; /// #### Unweighted and weighted histograms comparison:; ///; /// A simple modification of the ideas described above can be used for the; /// comparison of the usual (unweighted) and weighted histograms. Let us; /// denote the number of events in the ith bin in the unweighted; /// histogram as ni and the common weight of events in the ith bin of the; /// weighted histogram as wi. The t",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6662,Modifiability,variab,variable,6662,",...,r \f$ can be used.; ///; /// #### Unweighted and weighted histograms comparison:; ///; /// A simple modification of the ideas described above can be used for the; /// comparison of the usual (unweighted) and weighted histograms. Let us; /// denote the number of events in the ith bin in the unweighted; /// histogram as ni and the common weight of events in the ith bin of the; /// weighted histogram as wi. The total number of events in the; /// unweighted histogram is equal to; ///\f[; /// N = \sum_{i=1}^{r} n_{i}; ///\f]; /// and the total weight of events in the weighted histogram is equal to; ///\f[; /// W = \sum_{i=1}^{r} w_{i}; ///\f]; /// Let us formulate the hypothesis of identity of an unweighted histogram; /// to a weighted histogram so that there exist r constants p1,...,pr, such; /// that; ///\f[; /// \sum_{i=1}^{r} p_{i} = 1; ///\f]; /// for the unweighted histogram. The weight wi is a random variable with a; /// distribution approximated by the normal probability distribution; /// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.; /// If we replace the variance \f$ \sigma_{i}^{2} \f$; /// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of; /// events in the ith bin) and the hypothesis of identity is valid, then the; /// maximum likelihood estimator of pi,i=1,...,r, is; ///\f[; /// \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}; ///\f]; /// We may then use the test statistic; ///\f[; /// X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}; ///\f]; /// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well; /// as the original one [3], has a restriction on the expected frequencies. The; /// expected frequencies recommended for the weighted histogram is more than 25.; /// The value of the minimal expected frequency can be decreased down",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:9634,Modifiability,variab,variables,9634," residuals; ///\f[; /// r_{i} = \frac{w_{i}-W\hat{p}_{i}}{z_{i}}; ///\f]; /// have approximately a normal distribution with mean equal to 0 and standard; /// deviation equal to 1.; ///; /// #### Two weighted histograms comparison:; ///; /// Let us denote the common weight of events of the ith bin in the first; /// histogram as w1i and as w2i in the second one. The total weight of events; /// in the first histogram is equal to; ///\f[; /// W_{1} = \sum_{i=1}^{r} w_{1i}; ///\f]; /// and; ///\f[; /// W_{2} = \sum_{i=1}^{r} w_{2i}; ///\f]; /// in the second histogram. Let us formulate the hypothesis of identity of; /// weighted histograms so that there exist r constants p1,...,pr, such that; ///\f[; /// \sum_{i=1}^{r} p_{i} = 1; ///\f]; /// and also expectation value of weight w1i equal to W1pi and expectation value; /// of weight w2i equal to W2pi. Weights in both the histograms are random; /// variables with distributions which can be approximated by a normal; /// probability distribution \f$ N(W_{1}p_{i},\sigma_{1i}^{2}) \f$ for the first histogram; /// and by a distribution \f$ N(W_{2}p_{i},\sigma_{2i}^{2}) \f$ for the second.; /// Here \f$ \sigma_{1i}^{2} \f$ and \f$ \sigma_{2i}^{2} \f$ are the variances; /// of w1i and w2i with estimators \f$ s_{1i}^{2} \f$ and \f$ s_{2i}^{2} \f$ respectively.; /// If the hypothesis of identity is valid, then the maximum likelihood and; /// Least Square Method estimator of pi,i=1,...,r, is; ///\f[; /// \hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}; ///\f]; /// We may then use the test statistic; ///\f[; /// X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}; ///\f]; /// and it has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [2].; /// The normalized or studentised residuals [6]; /",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13882,Security,Biometric,Biometric,13882,"17 events (minimal expected; /// frequency equal to one) and the weighted histogram with 500 events (minimal; /// expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C(17); /// End_Macro; /// Fig 2. An example of comparison of the unweighted histogram with 217 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histogram;; /// 2. weighted histogram;; /// 3. normalized residuals plot;; /// 4. normal Q-Q plot of residuals.; ///; /// The value of the test statistic \f$ \chi^{2} \f$ is equal to; /// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; /// the two histograms is rejected for 0.05 significant level. The behavior of; /// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; /// Fig. 2d) of residuals are not regular and we can identify the outlier or; /// bin with a big influence on \f$ \chi^{2} \f$.; ///; /// #### References:; ///; /// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; /// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; /// Series No. 1, London.; /// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; /// of weighted and unweighted histograms. Statistical Problems in Particle; /// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; /// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; /// Gagunashvili,N., Comparison of weighted and unweighted histograms,; /// arXiv:physics/0605123, 2006.; /// - [3] Cramer, H., 1946. Mathematical methods of statistics.; /// Princeton University Press, Princeton.; /// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; /// Biometrics 29, 205-220.; /// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; /// test in 2xN tables. Biometrics 21, 19-33.; /// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; /// John Wiley & Sons Inc., New York.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:14523,Security,Biometric,Biometrics,14523,"17 events (minimal expected; /// frequency equal to one) and the weighted histogram with 500 events (minimal; /// expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C(17); /// End_Macro; /// Fig 2. An example of comparison of the unweighted histogram with 217 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histogram;; /// 2. weighted histogram;; /// 3. normalized residuals plot;; /// 4. normal Q-Q plot of residuals.; ///; /// The value of the test statistic \f$ \chi^{2} \f$ is equal to; /// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; /// the two histograms is rejected for 0.05 significant level. The behavior of; /// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; /// Fig. 2d) of residuals are not regular and we can identify the outlier or; /// bin with a big influence on \f$ \chi^{2} \f$.; ///; /// #### References:; ///; /// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; /// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; /// Series No. 1, London.; /// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; /// of weighted and unweighted histograms. Statistical Problems in Particle; /// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; /// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; /// Gagunashvili,N., Comparison of weighted and unweighted histograms,; /// arXiv:physics/0605123, 2006.; /// - [3] Cramer, H., 1946. Mathematical methods of statistics.; /// Princeton University Press, Princeton.; /// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; /// Biometrics 29, 205-220.; /// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; /// test in 2xN tables. Biometrics 21, 19-33.; /// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; /// John Wiley & Sons Inc., New York.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:14655,Security,Biometric,Biometrics,14655,"17 events (minimal expected; /// frequency equal to one) and the weighted histogram with 500 events (minimal; /// expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C(17); /// End_Macro; /// Fig 2. An example of comparison of the unweighted histogram with 217 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histogram;; /// 2. weighted histogram;; /// 3. normalized residuals plot;; /// 4. normal Q-Q plot of residuals.; ///; /// The value of the test statistic \f$ \chi^{2} \f$ is equal to; /// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; /// the two histograms is rejected for 0.05 significant level. The behavior of; /// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; /// Fig. 2d) of residuals are not regular and we can identify the outlier or; /// bin with a big influence on \f$ \chi^{2} \f$.; ///; /// #### References:; ///; /// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; /// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; /// Series No. 1, London.; /// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; /// of weighted and unweighted histograms. Statistical Problems in Particle; /// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; /// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; /// Gagunashvili,N., Comparison of weighted and unweighted histograms,; /// arXiv:physics/0605123, 2006.; /// - [3] Cramer, H., 1946. Mathematical methods of statistics.; /// Princeton University Press, Princeton.; /// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; /// Biometrics 29, 205-220.; /// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; /// test in 2xN tables. Biometrics 21, 19-33.; /// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; /// John Wiley & Sons Inc., New York.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:103,Testability,test,test,103,"////////////////////////////////////////////////////////////////////////////////; /// \f$ \chi^{2} \f$ test for comparing weighted and unweighted histograms.; ///; /// Compares the histograms' adjusted (normalized) residuals.; /// Function: Returns p-value. Other return values are specified by the 3rd parameter; ///; /// \param[in] h2 the second histogram; /// \param[in] option; /// - ""UU"" = experiment experiment comparison (unweighted-unweighted); /// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that; /// the first histogram should be unweighted; /// - ""WW"" = MC MC comparison (weighted-weighted); /// - ""NORM"" = to be used when one or both of the histograms is scaled; /// but the histogram originally was unweighted; /// - by default underflows and overflows are not included:; /// * ""OF"" = overflows included; /// * ""UF"" = underflows included; /// - ""P"" = print chi2, ndf, p_value, igood; /// - ""CHI2"" = returns chi2 instead of p-value; /// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; /// \param[in] res not empty - computes normalized residuals and returns them in this array; ///; /// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; /// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; /// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; /// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; ///; /// #### Introduction:; ///; /// A frequently used technique in data analysis is the comparison of; /// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; /// homogeneity is used widely for comparing usual (unweighted) histograms.; /// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; /// for comparison of weighted and unweighted histograms and two weighted; /// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; /// comparison two usual (unweighted) histograms.; ///; /// #### Overv",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1182,Testability,test,test,1182,"////////////////////////////////////////////////////////////////////////////////; /// \f$ \chi^{2} \f$ test for comparing weighted and unweighted histograms.; ///; /// Compares the histograms' adjusted (normalized) residuals.; /// Function: Returns p-value. Other return values are specified by the 3rd parameter; ///; /// \param[in] h2 the second histogram; /// \param[in] option; /// - ""UU"" = experiment experiment comparison (unweighted-unweighted); /// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that; /// the first histogram should be unweighted; /// - ""WW"" = MC MC comparison (weighted-weighted); /// - ""NORM"" = to be used when one or both of the histograms is scaled; /// but the histogram originally was unweighted; /// - by default underflows and overflows are not included:; /// * ""OF"" = overflows included; /// * ""UF"" = underflows included; /// - ""P"" = print chi2, ndf, p_value, igood; /// - ""CHI2"" = returns chi2 instead of p-value; /// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; /// \param[in] res not empty - computes normalized residuals and returns them in this array; ///; /// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; /// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; /// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; /// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; ///; /// #### Introduction:; ///; /// A frequently used technique in data analysis is the comparison of; /// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; /// homogeneity is used widely for comparing usual (unweighted) histograms.; /// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; /// for comparison of weighted and unweighted histograms and two weighted; /// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; /// comparison two usual (unweighted) histograms.; ///; /// #### Overv",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1620,Testability,test,test,1620,"= to be used when one or both of the histograms is scaled; /// but the histogram originally was unweighted; /// - by default underflows and overflows are not included:; /// * ""OF"" = overflows included; /// * ""UF"" = underflows included; /// - ""P"" = print chi2, ndf, p_value, igood; /// - ""CHI2"" = returns chi2 instead of p-value; /// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; /// \param[in] res not empty - computes normalized residuals and returns them in this array; ///; /// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; /// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; /// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; /// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; ///; /// #### Introduction:; ///; /// A frequently used technique in data analysis is the comparison of; /// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; /// homogeneity is used widely for comparing usual (unweighted) histograms.; /// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; /// for comparison of weighted and unweighted histograms and two weighted; /// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; /// comparison two usual (unweighted) histograms.; ///; /// #### Overview:; ///; /// Comparison of two histograms expect hypotheses that two histograms; /// represent identical distributions. To make a decision p-value should; /// be calculated. The hypotheses of identity is rejected if the p-value is; /// lower then some significance level. Traditionally significance levels; /// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; /// analysis of the residuals which is often helpful in identifying the; /// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; /// Residuals are the difference between bin contents and expected bin; /// contents. Most",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1776,Testability,test,tests,1776," ""UF"" = underflows included; /// - ""P"" = print chi2, ndf, p_value, igood; /// - ""CHI2"" = returns chi2 instead of p-value; /// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; /// \param[in] res not empty - computes normalized residuals and returns them in this array; ///; /// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; /// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; /// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; /// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; ///; /// #### Introduction:; ///; /// A frequently used technique in data analysis is the comparison of; /// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; /// homogeneity is used widely for comparing usual (unweighted) histograms.; /// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; /// for comparison of weighted and unweighted histograms and two weighted; /// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; /// comparison two usual (unweighted) histograms.; ///; /// #### Overview:; ///; /// Comparison of two histograms expect hypotheses that two histograms; /// represent identical distributions. To make a decision p-value should; /// be calculated. The hypotheses of identity is rejected if the p-value is; /// lower then some significance level. Traditionally significance levels; /// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; /// analysis of the residuals which is often helpful in identifying the; /// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; /// Residuals are the difference between bin contents and expected bin; /// contents. Most convenient for analysis are the normalized residuals. If; /// hypotheses of identity are valid then normalized residuals are; /// approximately independent and identically distributed random variables; ///",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1921,Testability,test,test,1921," ""UF"" = underflows included; /// - ""P"" = print chi2, ndf, p_value, igood; /// - ""CHI2"" = returns chi2 instead of p-value; /// - ""CHI2/NDF"" = returns \f$ \chi^{2} \f$/ndf; /// \param[in] res not empty - computes normalized residuals and returns them in this array; ///; /// The current implementation is based on the papers \f$ \chi^{2} \f$ test for comparison; /// of weighted and unweighted histograms"" in Proceedings of PHYSTAT05 and; /// ""Comparison weighted and unweighted histograms"", arXiv:physics/0605123; /// by N.Gagunashvili. This function has been implemented by Daniel Haertl in August 2006.; ///; /// #### Introduction:; ///; /// A frequently used technique in data analysis is the comparison of; /// histograms. First suggested by Pearson [1] the \f$ \chi^{2} \f$ test of; /// homogeneity is used widely for comparing usual (unweighted) histograms.; /// This paper describes the implementation modified \f$ \chi^{2} \f$ tests; /// for comparison of weighted and unweighted histograms and two weighted; /// histograms [2] as well as usual Pearson's \f$ \chi^{2} \f$ test for; /// comparison two usual (unweighted) histograms.; ///; /// #### Overview:; ///; /// Comparison of two histograms expect hypotheses that two histograms; /// represent identical distributions. To make a decision p-value should; /// be calculated. The hypotheses of identity is rejected if the p-value is; /// lower then some significance level. Traditionally significance levels; /// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; /// analysis of the residuals which is often helpful in identifying the; /// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; /// Residuals are the difference between bin contents and expected bin; /// contents. Most convenient for analysis are the normalized residuals. If; /// hypotheses of identity are valid then normalized residuals are; /// approximately independent and identically distributed random variables; ///",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2900,Testability,test,test,2900,"i^{2} \f$ test for; /// comparison two usual (unweighted) histograms.; ///; /// #### Overview:; ///; /// Comparison of two histograms expect hypotheses that two histograms; /// represent identical distributions. To make a decision p-value should; /// be calculated. The hypotheses of identity is rejected if the p-value is; /// lower then some significance level. Traditionally significance levels; /// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; /// analysis of the residuals which is often helpful in identifying the; /// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; /// Residuals are the difference between bin contents and expected bin; /// contents. Most convenient for analysis are the normalized residuals. If; /// hypotheses of identity are valid then normalized residuals are; /// approximately independent and identically distributed random variables; /// having N(0,1) distribution. Analysis of residuals expect test of above; /// mentioned properties of residuals. Notice that indirectly the analysis; /// of residuals increase the power of \f$ \chi^{2} \f$ test.; ///; /// #### Methods of comparison:; ///; /// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; /// Let us consider two histograms with the same binning and the number; /// of bins equal to r. Let us denote the number of events in the ith bin; /// in the first histogram as ni and as mi in the second one. The total; /// number of events in the first histogram is equal to:; /// \f[; /// N = \sum_{i=1}^{r} n_{i}; /// \f]; /// and; /// \f[; /// M = \sum_{i=1}^{r} m_{i}; /// \f]; /// in the second histogram. The hypothesis of identity (homogeneity) [3]; /// is that the two histograms represent random values with identical; /// distributions. It is equivalent that there exist r constants p1,...,pr,; /// such that; /// \f[; ///\sum_{i=1}^{r} p_{i}=1; /// \f]; /// and the probability of belonging to the ith bin for some measured value; ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3047,Testability,test,test,3047,"ew:; ///; /// Comparison of two histograms expect hypotheses that two histograms; /// represent identical distributions. To make a decision p-value should; /// be calculated. The hypotheses of identity is rejected if the p-value is; /// lower then some significance level. Traditionally significance levels; /// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; /// analysis of the residuals which is often helpful in identifying the; /// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; /// Residuals are the difference between bin contents and expected bin; /// contents. Most convenient for analysis are the normalized residuals. If; /// hypotheses of identity are valid then normalized residuals are; /// approximately independent and identically distributed random variables; /// having N(0,1) distribution. Analysis of residuals expect test of above; /// mentioned properties of residuals. Notice that indirectly the analysis; /// of residuals increase the power of \f$ \chi^{2} \f$ test.; ///; /// #### Methods of comparison:; ///; /// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; /// Let us consider two histograms with the same binning and the number; /// of bins equal to r. Let us denote the number of events in the ith bin; /// in the first histogram as ni and as mi in the second one. The total; /// number of events in the first histogram is equal to:; /// \f[; /// N = \sum_{i=1}^{r} n_{i}; /// \f]; /// and; /// \f[; /// M = \sum_{i=1}^{r} m_{i}; /// \f]; /// in the second histogram. The hypothesis of identity (homogeneity) [3]; /// is that the two histograms represent random values with identical; /// distributions. It is equivalent that there exist r constants p1,...,pr,; /// such that; /// \f[; ///\sum_{i=1}^{r} p_{i}=1; /// \f]; /// and the probability of belonging to the ith bin for some measured value; /// in both experiments is equal to pi. The number of events in the ith; /// bin is a rando",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3118,Testability,test,test,3118,"/// be calculated. The hypotheses of identity is rejected if the p-value is; /// lower then some significance level. Traditionally significance levels; /// 0.1, 0.05 and 0.01 are used. The comparison procedure should include an; /// analysis of the residuals which is often helpful in identifying the; /// bins of histograms responsible for a significant overall \f$ \chi^{2} \f$ value.; /// Residuals are the difference between bin contents and expected bin; /// contents. Most convenient for analysis are the normalized residuals. If; /// hypotheses of identity are valid then normalized residuals are; /// approximately independent and identically distributed random variables; /// having N(0,1) distribution. Analysis of residuals expect test of above; /// mentioned properties of residuals. Notice that indirectly the analysis; /// of residuals increase the power of \f$ \chi^{2} \f$ test.; ///; /// #### Methods of comparison:; ///; /// \f$ \chi^{2} \f$ test for comparison two (unweighted) histograms:; /// Let us consider two histograms with the same binning and the number; /// of bins equal to r. Let us denote the number of events in the ith bin; /// in the first histogram as ni and as mi in the second one. The total; /// number of events in the first histogram is equal to:; /// \f[; /// N = \sum_{i=1}^{r} n_{i}; /// \f]; /// and; /// \f[; /// M = \sum_{i=1}^{r} m_{i}; /// \f]; /// in the second histogram. The hypothesis of identity (homogeneity) [3]; /// is that the two histograms represent random values with identical; /// distributions. It is equivalent that there exist r constants p1,...,pr,; /// such that; /// \f[; ///\sum_{i=1}^{r} p_{i}=1; /// \f]; /// and the probability of belonging to the ith bin for some measured value; /// in both experiments is equal to pi. The number of events in the ith; /// bin is a random variable with a distribution approximated by a Poisson; /// probability distribution; /// \f[; ///\frac{e^{-Np_{i}}(Np_{i})^{n_{i}}}{n_{i}!}; /// \f]; //",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5386,Testability,test,test,5386,"\f[; ///\hat{p}_{i}= \frac{n_{i}+m_{i}}{N+M}; /// \f]; /// and then; /// \f[; /// X^{2} = \sum_{i=1}^{r}\frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r}\frac{(m_{i}-M\hat{p}_{i})^{2}}{M\hat{p}_{i}} =\frac{1}{MN} \sum_{i=1}^{r}\frac{(Mn_{i}-Nm_{i})^{2}}{n_{i}+m_{i}}; /// \f]; /// has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [3].; /// The comparison procedure can include an analysis of the residuals which; /// is often helpful in identifying the bins of histograms responsible for; /// a significant overall \f$ \chi^{2} \f$ value. Most convenient for; /// analysis are the adjusted (normalized) residuals [4]; /// \f[; /// r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}; /// \f]; /// If hypotheses of homogeneity are valid then residuals ri are; /// approximately independent and identically distributed random variables; /// having N(0,1) distribution. The application of the \f$ \chi^{2} \f$ test has; /// restrictions related to the value of the expected frequencies Npi,; /// Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; /// expectations must be 1 or greater for both histograms. In practical; /// cases when expected frequencies are not known the estimated expected; /// frequencies \f$ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \f$ can be used.; ///; /// #### Unweighted and weighted histograms comparison:; ///; /// A simple modification of the ideas described above can be used for the; /// comparison of the usual (unweighted) and weighted histograms. Let us; /// denote the number of events in the ith bin in the unweighted; /// histogram as ni and the common weight of events in the ith bin of the; /// weighted histogram as wi. The total number of events in the; /// unweighted histogram is equal to; ///\f[; /// N = \sum_{i=1}^{r} n_{i}; ///\f]; /// and the total weight of events in the weighted histogram is equal to; ///\f[; /// W = \sum_{i=1}^{r} w_{i}; ///\f]; /// Let us formulate ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7248,Testability,test,test,7248,"eight of events in the weighted histogram is equal to; ///\f[; /// W = \sum_{i=1}^{r} w_{i}; ///\f]; /// Let us formulate the hypothesis of identity of an unweighted histogram; /// to a weighted histogram so that there exist r constants p1,...,pr, such; /// that; ///\f[; /// \sum_{i=1}^{r} p_{i} = 1; ///\f]; /// for the unweighted histogram. The weight wi is a random variable with a; /// distribution approximated by the normal probability distribution; /// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.; /// If we replace the variance \f$ \sigma_{i}^{2} \f$; /// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of; /// events in the ith bin) and the hypothesis of identity is valid, then the; /// maximum likelihood estimator of pi,i=1,...,r, is; ///\f[; /// \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}; ///\f]; /// We may then use the test statistic; ///\f[; /// X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}; ///\f]; /// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well; /// as the original one [3], has a restriction on the expected frequencies. The; /// expected frequencies recommended for the weighted histogram is more than 25.; /// The value of the minimal expected frequency can be decreased down to 10 for; /// the case when the weights of the events are close to constant. In the case; /// of a weighted histogram if the number of events is unknown, then we can; /// apply this recommendation for the equivalent number of events as; ///\f[; /// n_{i}^{equiv} = \frac{ w_{i}^{2} }{ s_{i}^{2} }; ///\f]; /// The minimal expected frequency for an unweighted histogram must be 1. Notice; /// that any usual (unweighted) histogram can be considered as a weighted; /// histogram with events that have constant weights equal to 1.; /// The variance \f$",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7495,Testability,test,test,7495,"r, such; /// that; ///\f[; /// \sum_{i=1}^{r} p_{i} = 1; ///\f]; /// for the unweighted histogram. The weight wi is a random variable with a; /// distribution approximated by the normal probability distribution; /// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.; /// If we replace the variance \f$ \sigma_{i}^{2} \f$; /// with estimate \f$ s_{i}^{2} \f$ (sum of squares of weights of; /// events in the ith bin) and the hypothesis of identity is valid, then the; /// maximum likelihood estimator of pi,i=1,...,r, is; ///\f[; /// \hat{p}_{i} = \frac{Ww_{i}-Ns_{i}^{2}+\sqrt{(Ww_{i}-Ns_{i}^{2})^{2}+4W^{2}s_{i}^{2}n_{i}}}{2W^{2}}; ///\f]; /// We may then use the test statistic; ///\f[; /// X^{2} = \sum_{i=1}^{r} \frac{(n_{i}-N\hat{p}_{i})^{2}}{N\hat{p}_{i}} + \sum_{i=1}^{r} \frac{(w_{i}-W\hat{p}_{i})^{2}}{s_{i}^{2}}; ///\f]; /// and it has approximately a \f$ \sigma^{2}_{(r-1)} \f$ distribution [2]. This test, as well; /// as the original one [3], has a restriction on the expected frequencies. The; /// expected frequencies recommended for the weighted histogram is more than 25.; /// The value of the minimal expected frequency can be decreased down to 10 for; /// the case when the weights of the events are close to constant. In the case; /// of a weighted histogram if the number of events is unknown, then we can; /// apply this recommendation for the equivalent number of events as; ///\f[; /// n_{i}^{equiv} = \frac{ w_{i}^{2} }{ s_{i}^{2} }; ///\f]; /// The minimal expected frequency for an unweighted histogram must be 1. Notice; /// that any usual (unweighted) histogram can be considered as a weighted; /// histogram with events that have constant weights equal to 1.; /// The variance \f$ z_{i}^{2} \f$ of the difference between the weight wi; /// and the estimated expectation value of the weight is approximately equal to:; ///\f[; /// z_{i}^{2} = Var(w_{i}-W\hat{p}_{i}) = N\hat{p}_{i}(1-N\hat{p}_{i})\left(\frac{Ws_{i}^{2}}{\sqr",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10335,Testability,test,test,10335,"; ///\f[; /// \sum_{i=1}^{r} p_{i} = 1; ///\f]; /// and also expectation value of weight w1i equal to W1pi and expectation value; /// of weight w2i equal to W2pi. Weights in both the histograms are random; /// variables with distributions which can be approximated by a normal; /// probability distribution \f$ N(W_{1}p_{i},\sigma_{1i}^{2}) \f$ for the first histogram; /// and by a distribution \f$ N(W_{2}p_{i},\sigma_{2i}^{2}) \f$ for the second.; /// Here \f$ \sigma_{1i}^{2} \f$ and \f$ \sigma_{2i}^{2} \f$ are the variances; /// of w1i and w2i with estimators \f$ s_{1i}^{2} \f$ and \f$ s_{2i}^{2} \f$ respectively.; /// If the hypothesis of identity is valid, then the maximum likelihood and; /// Least Square Method estimator of pi,i=1,...,r, is; ///\f[; /// \hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}; ///\f]; /// We may then use the test statistic; ///\f[; /// X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}; ///\f]; /// and it has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [2].; /// The normalized or studentised residuals [6]; ///\f[; /// r_{i} = \frac{w_{1i}-W_{1}\hat{p}_{i}}{s_{1i}\sqrt{1 - \frac{1}{(1+W_{2}^{2}s_{1i}^{2}/W_{1}^{2}s_{2i}^{2})}}}; ///\f]; /// have approximately a normal distribution with mean equal to 0 and standard; /// deviation 1. A recommended minimal expected frequency is equal to 10 for; /// the proposed test.; ///; /// #### Numerical examples:; ///; /// The method described herein is now illustrated with an example.; /// We take a distribution; ///\f[; /// \phi(x) = \frac{2}{(x-10)^{2}+1} + \frac{1}{(x-14)^{2}+1} (1); ///\f]; /// defined on the interval [4,16]. Events distributed according to the formula; /// (1) are simulated to create the unweighted histogram. Uniformly distributed; ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:11036,Testability,test,test,11036,"}^{2} \f$ and \f$ s_{2i}^{2} \f$ respectively.; /// If the hypothesis of identity is valid, then the maximum likelihood and; /// Least Square Method estimator of pi,i=1,...,r, is; ///\f[; /// \hat{p}_{i} = \frac{w_{1i}W_{1}/s_{1i}^{2}+w_{2i}W_{2} /s_{2i}^{2}}{W_{1}^{2}/s_{1i}^{2}+W_{2}^{2}/s_{2i}^{2}}; ///\f]; /// We may then use the test statistic; ///\f[; /// X^{2} = \sum_{i=1}^{r} \frac{(w_{1i}-W_{1}\hat{p}_{i})^{2}}{s_{1i}^{2}} + \sum_{i=1}^{r} \frac{(w_{2i}-W_{2}\hat{p}_{i})^{2}}{s_{2i}^{2}} = \sum_{i=1}^{r} \frac{(W_{1}w_{2i}-W_{2}w_{1i})^{2}}{W_{1}^{2}s_{2i}^{2}+W_{2}^{2}s_{1i}^{2}}; ///\f]; /// and it has approximately a \f$ \chi^{2}_{(r-1)} \f$ distribution [2].; /// The normalized or studentised residuals [6]; ///\f[; /// r_{i} = \frac{w_{1i}-W_{1}\hat{p}_{i}}{s_{1i}\sqrt{1 - \frac{1}{(1+W_{2}^{2}s_{1i}^{2}/W_{1}^{2}s_{2i}^{2})}}}; ///\f]; /// have approximately a normal distribution with mean equal to 0 and standard; /// deviation 1. A recommended minimal expected frequency is equal to 10 for; /// the proposed test.; ///; /// #### Numerical examples:; ///; /// The method described herein is now illustrated with an example.; /// We take a distribution; ///\f[; /// \phi(x) = \frac{2}{(x-10)^{2}+1} + \frac{1}{(x-14)^{2}+1} (1); ///\f]; /// defined on the interval [4,16]. Events distributed according to the formula; /// (1) are simulated to create the unweighted histogram. Uniformly distributed; /// events are simulated for the weighted histogram with weights calculated by; /// formula (1). Each histogram has the same number of bins: 20. Fig.1 shows; /// the result of comparison of the unweighted histogram with 200 events; /// (minimal expected frequency equal to one) and the weighted histogram with; /// 500 events (minimal expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C; /// End_Macro; /// Fig 1. An example of comparison of the unweighted histogram with 200 events; /// and the weighted histogram with 500 events:; /// ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12152,Testability,test,test,12152,"a distribution; ///\f[; /// \phi(x) = \frac{2}{(x-10)^{2}+1} + \frac{1}{(x-14)^{2}+1} (1); ///\f]; /// defined on the interval [4,16]. Events distributed according to the formula; /// (1) are simulated to create the unweighted histogram. Uniformly distributed; /// events are simulated for the weighted histogram with weights calculated by; /// formula (1). Each histogram has the same number of bins: 20. Fig.1 shows; /// the result of comparison of the unweighted histogram with 200 events; /// (minimal expected frequency equal to one) and the weighted histogram with; /// 500 events (minimal expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C; /// End_Macro; /// Fig 1. An example of comparison of the unweighted histogram with 200 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histogram;; /// 2. weighted histogram;; /// 3. normalized residuals plot;; /// 4. normal Q-Q plot of residuals.; ///; /// The value of the test statistic \f$ \chi^{2} \f$ is equal to; /// 21.09 with p-value equal to 0.33, therefore the hypothesis of identity of; /// the two histograms can be accepted for 0.05 significant level. The behavior; /// of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot; /// (see Fig. 1d) of residuals are regular and we cannot identify the outliers; /// or bins with a big influence on \f$ \chi^{2} \f$.; ///; /// The second example presents the same two histograms but 17 events was added; /// to content of bin number 15 in unweighted histogram. Fig.2 shows the result; /// of comparison of the unweighted histogram with 217 events (minimal expected; /// frequency equal to one) and the weighted histogram with 500 events (minimal; /// expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C(17); /// End_Macro; /// Fig 2. An example of comparison of the unweighted histogram with 217 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histog",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13297,Testability,test,test,13297,"epted for 0.05 significant level. The behavior; /// of the normalized residuals plot (see Fig. 1c) and the normal Q-Q plot; /// (see Fig. 1d) of residuals are regular and we cannot identify the outliers; /// or bins with a big influence on \f$ \chi^{2} \f$.; ///; /// The second example presents the same two histograms but 17 events was added; /// to content of bin number 15 in unweighted histogram. Fig.2 shows the result; /// of comparison of the unweighted histogram with 217 events (minimal expected; /// frequency equal to one) and the weighted histogram with 500 events (minimal; /// expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C(17); /// End_Macro; /// Fig 2. An example of comparison of the unweighted histogram with 217 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histogram;; /// 2. weighted histogram;; /// 3. normalized residuals plot;; /// 4. normal Q-Q plot of residuals.; ///; /// The value of the test statistic \f$ \chi^{2} \f$ is equal to; /// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; /// the two histograms is rejected for 0.05 significant level. The behavior of; /// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; /// Fig. 2d) of residuals are not regular and we can identify the outlier or; /// bin with a big influence on \f$ \chi^{2} \f$.; ///; /// #### References:; ///; /// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; /// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; /// Series No. 1, London.; /// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; /// of weighted and unweighted histograms. Statistical Problems in Particle; /// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; /// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; /// Gagunashvili,N., Comparison of weighted and unweighted histograms,; /// arXiv:physics/06",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13973,Testability,test,test,13973,"17 events (minimal expected; /// frequency equal to one) and the weighted histogram with 500 events (minimal; /// expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C(17); /// End_Macro; /// Fig 2. An example of comparison of the unweighted histogram with 217 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histogram;; /// 2. weighted histogram;; /// 3. normalized residuals plot;; /// 4. normal Q-Q plot of residuals.; ///; /// The value of the test statistic \f$ \chi^{2} \f$ is equal to; /// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; /// the two histograms is rejected for 0.05 significant level. The behavior of; /// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; /// Fig. 2d) of residuals are not regular and we can identify the outlier or; /// bin with a big influence on \f$ \chi^{2} \f$.; ///; /// #### References:; ///; /// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; /// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; /// Series No. 1, London.; /// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; /// of weighted and unweighted histograms. Statistical Problems in Particle; /// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; /// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; /// Gagunashvili,N., Comparison of weighted and unweighted histograms,; /// arXiv:physics/0605123, 2006.; /// - [3] Cramer, H., 1946. Mathematical methods of statistics.; /// Princeton University Press, Princeton.; /// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; /// Biometrics 29, 205-220.; /// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; /// test in 2xN tables. Biometrics 21, 19-33.; /// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; /// John Wiley & Sons Inc., New York.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:14635,Testability,test,test,14635,"17 events (minimal expected; /// frequency equal to one) and the weighted histogram with 500 events (minimal; /// expected frequency equal to 25); /// Begin_Macro; /// ../../../tutorials/math/chi2test.C(17); /// End_Macro; /// Fig 2. An example of comparison of the unweighted histogram with 217 events; /// and the weighted histogram with 500 events:; /// 1. unweighted histogram;; /// 2. weighted histogram;; /// 3. normalized residuals plot;; /// 4. normal Q-Q plot of residuals.; ///; /// The value of the test statistic \f$ \chi^{2} \f$ is equal to; /// 32.33 with p-value equal to 0.029, therefore the hypothesis of identity of; /// the two histograms is rejected for 0.05 significant level. The behavior of; /// the normalized residuals plot (see Fig. 2c) and the normal Q-Q plot (see; /// Fig. 2d) of residuals are not regular and we can identify the outlier or; /// bin with a big influence on \f$ \chi^{2} \f$.; ///; /// #### References:; ///; /// - [1] Pearson, K., 1904. On the Theory of Contingency and Its Relation to; /// Association and Normal Correlation. Drapers' Co. Memoirs, Biometric; /// Series No. 1, London.; /// - [2] Gagunashvili, N., 2006. \f$ \sigma^{2} \f$ test for comparison; /// of weighted and unweighted histograms. Statistical Problems in Particle; /// Physics, Astrophysics and Cosmology, Proceedings of PHYSTAT05,; /// Oxford, UK, 12-15 September 2005, Imperial College Press, London, 43-44.; /// Gagunashvili,N., Comparison of weighted and unweighted histograms,; /// arXiv:physics/0605123, 2006.; /// - [3] Cramer, H., 1946. Mathematical methods of statistics.; /// Princeton University Press, Princeton.; /// - [4] Haberman, S.J., 1973. The analysis of residuals in cross-classified tables.; /// Biometrics 29, 205-220.; /// - [5] Lewontin, R.C. and Felsenstein, J., 1965. The robustness of homogeneity; /// test in 2xN tables. Biometrics 21, 19-33.; /// - [6] Seber, G.A.F., Lee, A.J., 2003, Linear Regression Analysis.; /// John Wiley & Sons Inc., New York.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5839,Usability,simpl,simple,5839,"in identifying the bins of histograms responsible for; /// a significant overall \f$ \chi^{2} \f$ value. Most convenient for; /// analysis are the adjusted (normalized) residuals [4]; /// \f[; /// r_{i} = \frac{n_{i}-N\hat{p}_{i}}{\sqrt{N\hat{p}_{i}}\sqrt{(1-N/(N+M))(1-(n_{i}+m_{i})/(N+M))}}; /// \f]; /// If hypotheses of homogeneity are valid then residuals ri are; /// approximately independent and identically distributed random variables; /// having N(0,1) distribution. The application of the \f$ \chi^{2} \f$ test has; /// restrictions related to the value of the expected frequencies Npi,; /// Mpi, i=1,...,r. A conservative rule formulated in [5] is that all the; /// expectations must be 1 or greater for both histograms. In practical; /// cases when expected frequencies are not known the estimated expected; /// frequencies \f$ M\hat{p}_{i}, N\hat{p}_{i}, i=1,...,r \f$ can be used.; ///; /// #### Unweighted and weighted histograms comparison:; ///; /// A simple modification of the ideas described above can be used for the; /// comparison of the usual (unweighted) and weighted histograms. Let us; /// denote the number of events in the ith bin in the unweighted; /// histogram as ni and the common weight of events in the ith bin of the; /// weighted histogram as wi. The total number of events in the; /// unweighted histogram is equal to; ///\f[; /// N = \sum_{i=1}^{r} n_{i}; ///\f]; /// and the total weight of events in the weighted histogram is equal to; ///\f[; /// W = \sum_{i=1}^{r} w_{i}; ///\f]; /// Let us formulate the hypothesis of identity of an unweighted histogram; /// to a weighted histogram so that there exist r constants p1,...,pr, such; /// that; ///\f[; /// \sum_{i=1}^{r} p_{i} = 1; ///\f]; /// for the unweighted histogram. The weight wi is a random variable with a; /// distribution approximated by the normal probability distribution; /// \f$ N(Wp_{i},\sigma_{i}^{2}) \f$ where \f$ \sigma_{i}^{2} \f$ is the variance of the weight wi.; /// If we replace t",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:102,Integrability,rout,routine,102,"////////////////////////////////////////////////////////////////////////////////; /// The computation routine of the Chisquare test. For the method description,; /// see Chi2Test() function.; ///; /// \return p-value; /// \param[in] h2 the second histogram; /// \param[in] option; /// - ""UU"" = experiment experiment comparison (unweighted-unweighted); /// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; /// histogram should be unweighted; /// - ""WW"" = MC MC comparison (weighted-weighted); /// - ""NORM"" = if one or both histograms is scaled; /// - ""OF"" = overflows included; /// - ""UF"" = underflows included; /// by default underflows and overflows are not included; /// \param[out] igood test output; /// - igood=0 - no problems; /// - For unweighted unweighted comparison; /// - igood=1'There is a bin in the 1st histogram with less than 1 event'; /// - igood=2'There is a bin in the 2nd histogram with less than 1 event'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// - For unweighted weighted comparison; /// - igood=1'There is a bin in the 1st histogram with less then 1 event'; /// - igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// - For weighted weighted comparison; /// - igood=1'There is a bin in the 1st histogram with less then 10 effective; /// number of events'; /// - igood=2'There is a bin in the 2nd histogram with less then 10 effective; /// number of events'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// \param[out] chi2 chisquare of the test; /// \param[out] ndf number of degrees of freedom (important, when both histograms have the same empty bins); /// \param[out] res normalized residuals for further analysis",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:127,Testability,test,test,127,"////////////////////////////////////////////////////////////////////////////////; /// The computation routine of the Chisquare test. For the method description,; /// see Chi2Test() function.; ///; /// \return p-value; /// \param[in] h2 the second histogram; /// \param[in] option; /// - ""UU"" = experiment experiment comparison (unweighted-unweighted); /// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; /// histogram should be unweighted; /// - ""WW"" = MC MC comparison (weighted-weighted); /// - ""NORM"" = if one or both histograms is scaled; /// - ""OF"" = overflows included; /// - ""UF"" = underflows included; /// by default underflows and overflows are not included; /// \param[out] igood test output; /// - igood=0 - no problems; /// - For unweighted unweighted comparison; /// - igood=1'There is a bin in the 1st histogram with less than 1 event'; /// - igood=2'There is a bin in the 2nd histogram with less than 1 event'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// - For unweighted weighted comparison; /// - igood=1'There is a bin in the 1st histogram with less then 1 event'; /// - igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// - For weighted weighted comparison; /// - igood=1'There is a bin in the 1st histogram with less then 10 effective; /// number of events'; /// - igood=2'There is a bin in the 2nd histogram with less then 10 effective; /// number of events'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// \param[out] chi2 chisquare of the test; /// \param[out] ndf number of degrees of freedom (important, when both histograms have the same empty bins); /// \param[out] res normalized residuals for further analysis",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:720,Testability,test,test,720,"////////////////////////////////////////////////////////////////////////////////; /// The computation routine of the Chisquare test. For the method description,; /// see Chi2Test() function.; ///; /// \return p-value; /// \param[in] h2 the second histogram; /// \param[in] option; /// - ""UU"" = experiment experiment comparison (unweighted-unweighted); /// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; /// histogram should be unweighted; /// - ""WW"" = MC MC comparison (weighted-weighted); /// - ""NORM"" = if one or both histograms is scaled; /// - ""OF"" = overflows included; /// - ""UF"" = underflows included; /// by default underflows and overflows are not included; /// \param[out] igood test output; /// - igood=0 - no problems; /// - For unweighted unweighted comparison; /// - igood=1'There is a bin in the 1st histogram with less than 1 event'; /// - igood=2'There is a bin in the 2nd histogram with less than 1 event'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// - For unweighted weighted comparison; /// - igood=1'There is a bin in the 1st histogram with less then 1 event'; /// - igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// - For weighted weighted comparison; /// - igood=1'There is a bin in the 1st histogram with less then 10 effective; /// number of events'; /// - igood=2'There is a bin in the 2nd histogram with less then 10 effective; /// number of events'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// \param[out] chi2 chisquare of the test; /// \param[out] ndf number of degrees of freedom (important, when both histograms have the same empty bins); /// \param[out] res normalized residuals for further analysis",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1674,Testability,test,test,1674,"////////////////////////////////////////////////////////////////////////////////; /// The computation routine of the Chisquare test. For the method description,; /// see Chi2Test() function.; ///; /// \return p-value; /// \param[in] h2 the second histogram; /// \param[in] option; /// - ""UU"" = experiment experiment comparison (unweighted-unweighted); /// - ""UW"" = experiment MC comparison (unweighted-weighted). Note that the first; /// histogram should be unweighted; /// - ""WW"" = MC MC comparison (weighted-weighted); /// - ""NORM"" = if one or both histograms is scaled; /// - ""OF"" = overflows included; /// - ""UF"" = underflows included; /// by default underflows and overflows are not included; /// \param[out] igood test output; /// - igood=0 - no problems; /// - For unweighted unweighted comparison; /// - igood=1'There is a bin in the 1st histogram with less than 1 event'; /// - igood=2'There is a bin in the 2nd histogram with less than 1 event'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// - For unweighted weighted comparison; /// - igood=1'There is a bin in the 1st histogram with less then 1 event'; /// - igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// - For weighted weighted comparison; /// - igood=1'There is a bin in the 1st histogram with less then 10 effective; /// number of events'; /// - igood=2'There is a bin in the 2nd histogram with less then 10 effective; /// number of events'; /// - igood=3'when the conditions for igood=1 and igood=2 are satisfied'; /// \param[out] chi2 chisquare of the test; /// \param[out] ndf number of degrees of freedom (important, when both histograms have the same empty bins); /// \param[out] res normalized residuals for further analysis",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18,Availability,error,errors,18,"// avoid rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Safety,avoid,avoid,3,"// avoid rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18,Availability,error,errors,18,"// avoid rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Safety,avoid,avoid,3,"// avoid rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6,Testability,TEST,TEST,6,"//THE TEST",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18,Availability,error,errors,18,"// avoid rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Safety,avoid,avoid,3,"// avoid rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18,Availability,error,errors,18,"// avoid rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Safety,avoid,avoid,3,"// avoid rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:8,Availability,error,error,8,"// flag error only when of the two histogram is zero",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:48,Availability,error,error,48,"// unweighted - weighted comparison; // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; // and can be considered as a data-theory comparison",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:52,Availability,error,error,52,"// case weighted histogram has zero bin content and error",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:23,Availability,error,error,23,"// use as approximated error as 1 scaled by a scaling ratio; // estimated from the total sum weight and sum weight squared",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10,Availability,error,error,10,"// return error because infinite discrepancy here:; // bin1 != 0 and bin2 =0 in a histogram with all errors zero",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:101,Availability,error,errors,101,"// return error because infinite discrepancy here:; // bin1 != 0 and bin2 =0 in a histogram with all errors zero",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:151,Availability,error,errors,151,"// if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; // approximate by incrementing cnt1; // LM (this need to be fixed for numerical errors)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:92,Availability,error,errors,92,"// case both histogram have zero bin contents; // (use square of content to avoid numerical errors)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:76,Safety,avoid,avoid,76,"// case both histogram have zero bin contents; // (use square of content to avoid numerical errors)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:55,Availability,error,errors,55,"// cannot treat case of booth histogram have zero zero errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:240,Availability,error,error,240,"////////////////////////////////////////////////////////////////////////////////; /// Compute and return the chisquare of this histogram with respect to a function; /// The chisquare is computed by weighting each histogram point by the bin error; /// By default the full range of the histogram is used.; /// Use option ""R"" for restricting the chisquare calculation to the given range of the function; /// Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare); /// Use option ""P"" for using the Pearson chisquare based on the expected bin errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:580,Availability,error,errors,580,"////////////////////////////////////////////////////////////////////////////////; /// Compute and return the chisquare of this histogram with respect to a function; /// The chisquare is computed by weighting each histogram point by the bin error; /// By default the full range of the histogram is used.; /// Use option ""R"" for restricting the chisquare calculation to the given range of the function; /// Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare); /// Use option ""P"" for using the Pearson chisquare based on the expected bin errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:30,Availability,error,error,30,"// default chi2 with observed error",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:296,Usability,clear,cleared,296,"////////////////////////////////////////////////////////////////////////////////; /// Remove all the content from the underflow and overflow bins, without changing the number of entries; /// After calling this method, every undeflow and overflow bins will have content 0.0; /// The Sumw2 is also cleared, since there is no more content in the bins",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:550,Availability,error,error,550,"////////////////////////////////////////////////////////////////////////////////; /// Compute integral (normalized cumulative sum of bins) w/o under/overflows; /// The result is stored in fIntegral and used by the GetRandom functions.; /// This function is automatically called by GetRandom when the fIntegral; /// array does not exist or when the number of entries in the histogram; /// has changed since the previous call to GetRandom.; /// The resulting integral is normalized to 1.; /// If the routine is called with the onlyPositive flag set an error will; /// be produced in case of negative bin content and a NaN value returned; /// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:498,Integrability,rout,routine,498,"////////////////////////////////////////////////////////////////////////////////; /// Compute integral (normalized cumulative sum of bins) w/o under/overflows; /// The result is stored in fIntegral and used by the GetRandom functions.; /// This function is automatically called by GetRandom when the fIntegral; /// array does not exist or when the number of entries in the histogram; /// has changed since the previous call to GetRandom.; /// The resulting integral is normalized to 1.; /// If the routine is called with the onlyPositive flag set an error will; /// be produced in case of negative bin content and a NaN value returned; /// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:705,Testability,test,test,705,"////////////////////////////////////////////////////////////////////////////////; /// Compute integral (normalized cumulative sum of bins) w/o under/overflows; /// The result is stored in fIntegral and used by the GetRandom functions.; /// This function is automatically called by GetRandom when the fIntegral; /// array does not exist or when the number of entries in the histogram; /// has changed since the previous call to GetRandom.; /// The resulting integral is normalized to 1.; /// If the routine is called with the onlyPositive flag set an error will; /// be produced in case of negative bin content and a NaN value returned; /// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5,Energy Efficiency,Allocate,Allocate,5,"// - Allocate space to store the integral and compute integral",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:31,Security,hash,hash,31,"// We are likely to change the hash value of this object; // with TNamed::Copy, to keep things correct, we need to; // clean up its existing entries.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:290,Deployability,update,update,290,"// The Copy above might have published 'obj' to the ListOfCleanups.; // Clone can call RecursiveRemove, for example via TCheckHashRecursiveRemoveConsistency; // when dictionary information is initialized, so we need to; // keep obj->fFunction valid during its execution and; // protect the update with the write lock.; // Reset stats parent - else cloning the stats will clone this histogram, too.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Performance,Perform,Perform,86,"////////////////////////////////////////////////////////////////////////////////; /// Perform the automatic addition of the histogram to the given directory; ///; /// Note this function is called in place when the semantic requires; /// this object to be added to a directory (I.e. when being read from; /// a TKey or being Cloned)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:326,Usability,simpl,simple,326,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from point px,py to a line.; ///; /// Compute the closest distance of approach from point px,py to elements; /// of a histogram.; /// The distance is computed in pixels units.; ///; /// #### Algorithm:; /// Currently, this simple model computes the distance from the mouse; /// to the histogram contour only.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:140,Availability,error,errors,140,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:177,Availability,error,errors,177,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:315,Availability,error,errors,315,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:150,Availability,error,errors,150,"////////////////////////////////////////////////////////////////////////////////; /// Divide this histogram by h1.; ///; /// `this = this/h1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// See the other TH1::Divide that gives the possibility to optionally; /// compute binomial errors.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Scale; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:187,Availability,error,errors,187,"////////////////////////////////////////////////////////////////////////////////; /// Divide this histogram by h1.; ///; /// `this = this/h1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// See the other TH1::Divide that gives the possibility to optionally; /// compute binomial errors.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Scale; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:336,Availability,error,errors,336,"////////////////////////////////////////////////////////////////////////////////; /// Divide this histogram by h1.; ///; /// `this = this/h1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// See the other TH1::Divide that gives the possibility to optionally; /// compute binomial errors.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Scale; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:486,Availability,error,errors,486,"////////////////////////////////////////////////////////////////////////////////; /// Divide this histogram by h1.; ///; /// `this = this/h1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// See the other TH1::Divide that gives the possibility to optionally; /// compute binomial errors.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Scale; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:545,Availability,error,errors,545,"////////////////////////////////////////////////////////////////////////////////; /// Divide this histogram by h1.; ///; /// `this = this/h1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// See the other TH1::Divide that gives the possibility to optionally; /// compute binomial errors.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Scale; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:196,Availability,error,errors,196,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:233,Availability,error,errors,233,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:388,Availability,error,errors,388,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:496,Availability,error,errors,496,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:641,Availability,error,errors,641,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:861,Availability,error,errors,861,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:954,Availability,error,error,954,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1007,Availability,error,errors,1007,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1177,Availability,error,error,1177,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by the division of h1 by h2.; ///; /// `this = c1*h1/(c2*h2)`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; /// The resulting errors are calculated assuming uncorrelated histograms.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// Please note also that in the binomial case errors are calculated using standard; /// binomial statistics, which means when b1 = b2, the error is zero.; /// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; /// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; /// error for the case b1=b2.; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:59,Availability,error,errors,59,"// Create Sumw2 if h1 or h2 have Sumw2 set, or if binomial errors are explicitly requested",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:16,Availability,error,error,16,"//in case b1=b2 error is zero; //use TGraphAsymmErrors::BayesDivide for getting the asymmetric error not equal to zero",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:95,Availability,error,error,95,"//in case b1=b2 error is zero; //use TGraphAsymmErrors::BayesDivide for getting the asymmetric error not equal to zero",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:648,Deployability,update,updated,648,"////////////////////////////////////////////////////////////////////////////////; /// Draw this histogram with options.; ///; /// Histograms are drawn via the THistPainter class. Each histogram has; /// a pointer to its own painter (to be usable in a multithreaded program).; /// The same histogram can be drawn with different options in different pads.; /// When a histogram drawn in a pad is deleted, the histogram is; /// automatically removed from the pad or pads where it was drawn.; /// If a histogram is drawn in a pad, then filled again, the new status; /// of the histogram will be automatically shown in the pad next time; /// the pad is updated. One does not need to redraw the histogram.; /// To draw the current version of a histogram in a pad, one can use; /// `h->DrawCopy();`; /// This makes a clone of the histogram. Once the clone is drawn, the original; /// histogram may be modified or deleted without affecting the aspect of the; /// clone.; /// By default, TH1::Draw clears the current pad.; ///; /// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; /// value for the maximum or the minimum scale on the plot.; ///; /// TH1::UseCurrentStyle can be used to change all histogram graphics; /// attributes to correspond to the current selected style.; /// This function must be called for each histogram.; /// In case one reads and draws many histograms from a file, one can force; /// the histograms to inherit automatically the current graphics style; /// by calling before gROOT->ForceStyle();; ///; /// See the THistPainter class for a description of all the drawing options.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1444,Modifiability,inherit,inherit,1444,"////////////////////////////////////////////////////////////////////////////////; /// Draw this histogram with options.; ///; /// Histograms are drawn via the THistPainter class. Each histogram has; /// a pointer to its own painter (to be usable in a multithreaded program).; /// The same histogram can be drawn with different options in different pads.; /// When a histogram drawn in a pad is deleted, the histogram is; /// automatically removed from the pad or pads where it was drawn.; /// If a histogram is drawn in a pad, then filled again, the new status; /// of the histogram will be automatically shown in the pad next time; /// the pad is updated. One does not need to redraw the histogram.; /// To draw the current version of a histogram in a pad, one can use; /// `h->DrawCopy();`; /// This makes a clone of the histogram. Once the clone is drawn, the original; /// histogram may be modified or deleted without affecting the aspect of the; /// clone.; /// By default, TH1::Draw clears the current pad.; ///; /// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; /// value for the maximum or the minimum scale on the plot.; ///; /// TH1::UseCurrentStyle can be used to change all histogram graphics; /// attributes to correspond to the current selected style.; /// This function must be called for each histogram.; /// In case one reads and draws many histograms from a file, one can force; /// the histograms to inherit automatically the current graphics style; /// by calling before gROOT->ForceStyle();; ///; /// See the THistPainter class for a description of all the drawing options.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:239,Usability,usab,usable,239,"////////////////////////////////////////////////////////////////////////////////; /// Draw this histogram with options.; ///; /// Histograms are drawn via the THistPainter class. Each histogram has; /// a pointer to its own painter (to be usable in a multithreaded program).; /// The same histogram can be drawn with different options in different pads.; /// When a histogram drawn in a pad is deleted, the histogram is; /// automatically removed from the pad or pads where it was drawn.; /// If a histogram is drawn in a pad, then filled again, the new status; /// of the histogram will be automatically shown in the pad next time; /// the pad is updated. One does not need to redraw the histogram.; /// To draw the current version of a histogram in a pad, one can use; /// `h->DrawCopy();`; /// This makes a clone of the histogram. Once the clone is drawn, the original; /// histogram may be modified or deleted without affecting the aspect of the; /// clone.; /// By default, TH1::Draw clears the current pad.; ///; /// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; /// value for the maximum or the minimum scale on the plot.; ///; /// TH1::UseCurrentStyle can be used to change all histogram graphics; /// attributes to correspond to the current selected style.; /// This function must be called for each histogram.; /// In case one reads and draws many histograms from a file, one can force; /// the histograms to inherit automatically the current graphics style; /// by calling before gROOT->ForceStyle();; ///; /// See the THistPainter class for a description of all the drawing options.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:989,Usability,clear,clears,989,"////////////////////////////////////////////////////////////////////////////////; /// Draw this histogram with options.; ///; /// Histograms are drawn via the THistPainter class. Each histogram has; /// a pointer to its own painter (to be usable in a multithreaded program).; /// The same histogram can be drawn with different options in different pads.; /// When a histogram drawn in a pad is deleted, the histogram is; /// automatically removed from the pad or pads where it was drawn.; /// If a histogram is drawn in a pad, then filled again, the new status; /// of the histogram will be automatically shown in the pad next time; /// the pad is updated. One does not need to redraw the histogram.; /// To draw the current version of a histogram in a pad, one can use; /// `h->DrawCopy();`; /// This makes a clone of the histogram. Once the clone is drawn, the original; /// histogram may be modified or deleted without affecting the aspect of the; /// clone.; /// By default, TH1::Draw clears the current pad.; ///; /// One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; /// value for the maximum or the minimum scale on the plot.; ///; /// TH1::UseCurrentStyle can be used to change all histogram graphics; /// attributes to correspond to the current selected style.; /// This function must be called for each histogram.; /// In case one reads and draws many histograms from a file, one can force; /// the histograms to inherit automatically the current graphics style; /// by calling before gROOT->ForceStyle();; ///; /// See the THistPainter class for a description of all the drawing options.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:689,Usability,clear,cleared,689,"////////////////////////////////////////////////////////////////////////////////; /// Draw a normalized copy of this histogram.; ///; /// A clone of this histogram is normalized to norm and drawn with option.; /// A pointer to the normalized histogram is returned.; /// The contents of the histogram copy are scaled such that the new; /// sum of weights (excluding under and overflow) is equal to norm.; /// Note that the returned normalized histogram is not added to the list; /// of histograms in the current directory in memory.; /// It is the user's responsibility to delete this histogram.; /// The kCanDelete bit is set for the returned object. If a pad containing; /// this copy is cleared, the histogram will be automatically deleted.; ///; /// See Draw for the list of options",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:27,Availability,error,error,27,"// in case of drawing with error options - scale correctly the error",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:63,Availability,error,error,63,"// in case of drawing with error options - scale correctly the error",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:32,Availability,Error,Error,32,"// do not use in this case the ""Error option "" for drawing which is enabled by default since the normalized histogram has now errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:126,Availability,error,errors,126,"// do not use in this case the ""Error option "" for drawing which is enabled by default since the normalized histogram has now errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:370,Deployability,release,released,370,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when a histogram is clicked with the locator; ///; /// If Left button clicked on the bin top value, then the content of this bin; /// is modified according to the new position of the mouse when it is released.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:162,Availability,Avail,Available,162,"////////////////////////////////////////////////////////////////////////////////; /// This function allows to do discrete Fourier transforms of TH1 and TH2.; /// Available transform types and flags are described below.; ///; /// To extract more information about the transform, use the function; /// TVirtualFFT::GetCurrentTransform() to get a pointer to the current; /// transform object.; ///; /// \param[out] h_output histogram for the output. If a null pointer is passed, a new histogram is created; /// and returned, otherwise, the provided histogram is used and should be big enough; /// \param[in] option option parameters consists of 3 parts:; /// - option on what to return; /// - ""RE"" - returns a histogram of the real part of the output; /// - ""IM"" - returns a histogram of the imaginary part of the output; /// - ""MAG""- returns a histogram of the magnitude of the output; /// - ""PH"" - returns a histogram of the phase of the output; /// - option of transform type; /// - ""R2C"" - real to complex transforms - default; /// - ""R2HC"" - real to halfcomplex (special format of storing output data,; /// results the same as for R2C); /// - ""DHT"" - discrete Hartley transform; /// real to real transforms (sine and cosine):; /// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; /// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; /// To specify the type of each dimension of a 2-dimensional real to real; /// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; /// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; /// - option of transform flag; /// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; /// performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; /// - ""EX"" (from ""exhaustive"") - the most opt",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2053,Integrability,depend,depending,2053,"tTransform() to get a pointer to the current; /// transform object.; ///; /// \param[out] h_output histogram for the output. If a null pointer is passed, a new histogram is created; /// and returned, otherwise, the provided histogram is used and should be big enough; /// \param[in] option option parameters consists of 3 parts:; /// - option on what to return; /// - ""RE"" - returns a histogram of the real part of the output; /// - ""IM"" - returns a histogram of the imaginary part of the output; /// - ""MAG""- returns a histogram of the magnitude of the output; /// - ""PH"" - returns a histogram of the phase of the output; /// - option of transform type; /// - ""R2C"" - real to complex transforms - default; /// - ""R2HC"" - real to halfcomplex (special format of storing output data,; /// results the same as for R2C); /// - ""DHT"" - discrete Hartley transform; /// real to real transforms (sine and cosine):; /// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; /// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; /// To specify the type of each dimension of a 2-dimensional real to real; /// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; /// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; /// - option of transform flag; /// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; /// performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; /// - ""EX"" (from ""exhaustive"") - the most optimal way is found; /// This option should be chosen depending on how many transforms of the same size and; /// type are going to be done. Planning is only done once, for the first transform of this; /// size and type. Default is ""ES"".; ///; /// Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX""",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1757,Performance,perform,performance,1757,"tTransform() to get a pointer to the current; /// transform object.; ///; /// \param[out] h_output histogram for the output. If a null pointer is passed, a new histogram is created; /// and returned, otherwise, the provided histogram is used and should be big enough; /// \param[in] option option parameters consists of 3 parts:; /// - option on what to return; /// - ""RE"" - returns a histogram of the real part of the output; /// - ""IM"" - returns a histogram of the imaginary part of the output; /// - ""MAG""- returns a histogram of the magnitude of the output; /// - ""PH"" - returns a histogram of the phase of the output; /// - option of transform type; /// - ""R2C"" - real to complex transforms - default; /// - ""R2HC"" - real to halfcomplex (special format of storing output data,; /// results the same as for R2C); /// - ""DHT"" - discrete Hartley transform; /// real to real transforms (sine and cosine):; /// - ""R2R_0"", ""R2R_1"", ""R2R_2"", ""R2R_3"" - discrete cosine transforms of types I-IV; /// - ""R2R_4"", ""R2R_5"", ""R2R_6"", ""R2R_7"" - discrete sine transforms of types I-IV; /// To specify the type of each dimension of a 2-dimensional real to real; /// transform, use options of form ""R2R_XX"", for example, ""R2R_02"" for a transform,; /// which is of type ""R2R_0"" in 1st dimension and ""R2R_2"" in the 2nd.; /// - option of transform flag; /// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; /// performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; /// - ""EX"" (from ""exhaustive"") - the most optimal way is found; /// This option should be chosen depending on how many transforms of the same size and; /// type are going to be done. Planning is only done once, for the first transform of this; /// size and type. Default is ""ES"".; ///; /// Examples of valid options: ""Mag R2C M"" ""Re R2R_11"" ""Im R2C ES"" ""PH R2HC EX""",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:75,Modifiability,extend,extended,75,"// this make sense if the histogram is not expanding (the x axis cannot be extended)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:415,Deployability,integrat,integrated,415,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in function fname.; ///; /// @param fname : Function name used for filling the histogram; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used to sample; ///; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents for the bin range of this histogram.; /// It is normalized to 1.; ///; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated; ///; /// One can also call TF1::GetRandom to get a random variate from a function.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:415,Integrability,integrat,integrated,415,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in function fname.; ///; /// @param fname : Function name used for filling the histogram; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used to sample; ///; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents for the bin range of this histogram.; /// It is normalized to 1.; ///; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated; ///; /// One can also call TF1::GetRandom to get a random variate from a function.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5,Energy Efficiency,Allocate,Allocate,5,"// - Allocate temporary space to store the integral and compute integral",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:408,Deployability,integrat,integrated,408,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in histogram h.; ///; /// @param h : Histogram pointer used for sampling random number; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used for sampling; ///; /// The distribution contained in the histogram h (TH1) is integrated; /// over the channel contents for the bin range of this histogram.; /// It is normalized to 1.; ///; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel ntimes random numbers are generated; ///; /// SPECIAL CASE when the target histogram has the same binning as the source.; /// in this case we simply use a poisson distribution where; /// the mean value per bin = bincontent/integral.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:408,Integrability,integrat,integrated,408,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in histogram h.; ///; /// @param h : Histogram pointer used for sampling random number; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used for sampling; ///; /// The distribution contained in the histogram h (TH1) is integrated; /// over the channel contents for the bin range of this histogram.; /// It is normalized to 1.; ///; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel ntimes random numbers are generated; ///; /// SPECIAL CASE when the target histogram has the same binning as the source.; /// in this case we simply use a poisson distribution where; /// the mean value per bin = bincontent/integral.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:861,Usability,simpl,simply,861,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in histogram h.; ///; /// @param h : Histogram pointer used for sampling random number; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used for sampling; ///; /// The distribution contained in the histogram h (TH1) is integrated; /// over the channel contents for the bin range of this histogram.; /// It is normalized to 1.; ///; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel ntimes random numbers are generated; ///; /// SPECIAL CASE when the target histogram has the same binning as the source.; /// in this case we simply use a poisson distribution where; /// the mean value per bin = bincontent/integral.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:383,Modifiability,extend,extend,383,"////////////////////////////////////////////////////////////////////////////////; /// Return Global bin number corresponding to x,y,z; ///; /// 2-D and 3-D histograms are represented with a one dimensional; /// structure. This has the advantage that all existing functions, such as; /// GetBinContent, GetBinError, GetBinFunction work for all dimensions.; /// This function tries to extend the axis if the given point belongs to an; /// under-/overflow bin AND if CanExtendAllAxes() is true.; ///; /// See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:391,Modifiability,extend,extend,391,"////////////////////////////////////////////////////////////////////////////////; /// Return Global bin number corresponding to x,y,z.; ///; /// 2-D and 3-D histograms are represented with a one dimensional; /// structure. This has the advantage that all existing functions, such as; /// GetBinContent, GetBinError, GetBinFunction work for all dimensions.; /// This function DOES NOT try to extend the axis if the given point belongs; /// to an under-/overflow bin.; ///; /// See also TH1::GetBin, TAxis::FindBin and TAxis::FindFixBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:168,Availability,avail,available,168,"////////////////////////////////////////////////////////////////////////////////; /// Fit histogram with function fname.; ///; ///; /// fname is the name of a function available in the global ROOT list of functions; /// `gROOT->GetListOfFunctions`; /// The list include any TF1 object created by the user plus some pre-defined functions; /// which are automatically created by ROOT the first time a pre-defined function is requested from `gROOT`; /// (i.e. when calling `gROOT->GetFunction(const char *name)`).; /// These pre-defined functions are:; /// - `gaus, gausn` where gausn is the normalized Gaussian; /// - `landau, landaun`; /// - `expo`; /// - `pol1,...9, chebyshev1,...9`.; ///; /// For printing the list of all available functions do:; ///; /// TF1::InitStandardFunctions(); // not needed if `gROOT->GetFunction` is called before; /// gROOT->GetListOfFunctions()->ls(); ///; /// `fname` can also be a formula that is accepted by the linear fitter containing the special operator `++`,; /// representing linear components separated by `++` sign, for example `x++sin(x)` for fitting `[0]*x+[1]*sin(x)`; ///; /// This function finds a pointer to the TF1 object with name `fname` and calls TH1::Fit(TF1 *, Option_t *, Option_t *,; /// Double_t, Double_t). See there for the fitting options and the details about fitting histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:724,Availability,avail,available,724,"////////////////////////////////////////////////////////////////////////////////; /// Fit histogram with function fname.; ///; ///; /// fname is the name of a function available in the global ROOT list of functions; /// `gROOT->GetListOfFunctions`; /// The list include any TF1 object created by the user plus some pre-defined functions; /// which are automatically created by ROOT the first time a pre-defined function is requested from `gROOT`; /// (i.e. when calling `gROOT->GetFunction(const char *name)`).; /// These pre-defined functions are:; /// - `gaus, gausn` where gausn is the normalized Gaussian; /// - `landau, landaun`; /// - `expo`; /// - `pol1,...9, chebyshev1,...9`.; ///; /// For printing the list of all available functions do:; ///; /// TF1::InitStandardFunctions(); // not needed if `gROOT->GetFunction` is called before; /// gROOT->GetListOfFunctions()->ls(); ///; /// `fname` can also be a formula that is accepted by the linear fitter containing the special operator `++`,; /// representing linear components separated by `++` sign, for example `x++sin(x)` for fitting `[0]*x+[1]*sin(x)`; ///; /// This function finds a pointer to the TF1 object with name `fname` and calls TH1::Fit(TF1 *, Option_t *, Option_t *,; /// Double_t, Double_t). See there for the fitting options and the details about fitting histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1202,Availability,error,errors,1202,"ning the fit options (see table below).; /// \param[in] goption specify a list of graphics options. See TH1::Draw for a complete list of these options.; /// \param[in] xxmin lower fitting range; /// \param[in] xxmax upper fitting range; /// \return A smart pointer to the TFitResult class; ///; /// \anchor HFitOpt; /// ### Histogram Fitting Options; ///; /// Here is the full list of fit options that can be given in the parameter `option`.; /// Several options can be used together by concatanating the strings without the need of any delimiters.; ///; /// option | description; /// -------|------------; /// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; /// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; /// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1266,Availability,error,error,1266,"t of graphics options. See TH1::Draw for a complete list of these options.; /// \param[in] xxmin lower fitting range; /// \param[in] xxmax upper fitting range; /// \return A smart pointer to the TFitResult class; ///; /// \anchor HFitOpt; /// ### Histogram Fitting Options; ///; /// Here is the full list of fit options that can be given in the parameter `option`.; /// Several options can be used together by concatanating the strings without the need of any delimiters.; ///; /// option | description; /// -------|------------; /// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; /// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; /// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searchi",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2095,Availability,error,errors,2095,"is needed for getting correct parameter uncertainties for weighted fits.; /// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting rang",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2202,Availability,avail,available,2202,"pected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; /// ""B"" | Use this option when you want to fix or set limits on one",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3905,Availability,Error,Errors,3905,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4206,Availability,error,errors,4206,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4242,Availability,error,errors,4242,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5644,Availability,avail,available,5644,"is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (th",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5792,Availability,toler,tolerance,5792,"he histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6611,Availability,error,error,6611,"T::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; /// \f]; ///; /// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; /// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.; /// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; /// because they could return a biased result.; ///; /// \anchor HFitNLL; /// ### Likelihood Fits; ///; /// When using option ""L"" a likelihood fit is used instead of the",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6645,Availability,error,error,6645,"T::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; /// \f]; ///; /// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; /// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.; /// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; /// because they could return a biased result.; ///; /// \anchor HFitNLL; /// ### Likelihood Fits; ///; /// When using option ""L"" a likelihood fit is used instead of the",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6886,Availability,error,error,6886,"T::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; /// \f]; ///; /// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; /// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.; /// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; /// because they could return a biased result.; ///; /// \anchor HFitNLL; /// ### Likelihood Fits; ///; /// When using option ""L"" a likelihood fit is used instead of the",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6956,Availability,error,errors,6956,"::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; /// \f]; ///; /// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; /// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.; /// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; /// because they could return a biased result.; ///; /// \anchor HFitNLL; /// ### Likelihood Fits; ///; /// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; /// The likelihood is built assuming a Poisson probability density function for each bin.; /// The negative log-likelihood to be minimized is; ///; /// \f[; /// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7314,Availability,error,error,7314,"///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; /// \f]; ///; /// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; /// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.; /// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; /// because they could return a biased result.; ///; /// \anchor HFitNLL; /// ### Likelihood Fits; ///; /// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; /// The likelihood is built assuming a Poisson probability density function for each bin.; /// The negative log-likelihood to be minimized is; ///; /// \f[; /// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; /// \f]; /// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; /// The exact likelihood used is the Poisson likelihood described in this paper:; /// S. Baker and R. D. Cousins, Clarification of the use of chi-square and likelihood functions in fits to histograms,; /",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:8640,Availability,error,errors,8640," ///; /// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; /// The likelihood is built assuming a Poisson probability density function for each bin.; /// The negative log-likelihood to be minimized is; ///; /// \f[; /// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; /// \f]; /// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; /// The exact likelihood used is the Poisson likelihood described in this paper:; /// S. Baker and R. D. Cousins, Clarification of the use of chi-square and likelihood functions in fits to histograms,; /// Nucl. Instrum. Meth. 221 (1984) 437.; ///; /// \f[; /// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; /// \f]; /// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; ///; /// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; /// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; /// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; /// give the same result.; ///; /// The likelihood method, although a bit slower, it is therefore the recommended method,; /// when the histogram represent counts (Poisson statistics), where the chi-square methods may; /// give incorrect results, especially in case of low statistics.; /// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; /// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; /// has the information on the sum of the weight square for each bin ( TH1::Sumw2() has been called).; /// The bin error for a weighted histogram is the square root of the sum of the weight square.; ///; /// \anchor HFitRes; /// ### Fit Result; ///; /// The function ret",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:9495,Availability,error,error,9495,"sulting from the fit.; ///; /// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; /// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; /// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; /// give the same result.; ///; /// The likelihood method, although a bit slower, it is therefore the recommended method,; /// when the histogram represent counts (Poisson statistics), where the chi-square methods may; /// give incorrect results, especially in case of low statistics.; /// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; /// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; /// has the information on the sum of the weight square for each bin ( TH1::Sumw2() has been called).; /// The bin error for a weighted histogram is the square root of the sum of the weight square.; ///; /// \anchor HFitRes; /// ### Fit Result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit which is return by an; /// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; ///; /// ~~~ {.cpp}; /// Int_t fitStatus = h->Fit(myFunc);; /// ~~~; ///; /// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; /// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; /// as shown in this example code:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10577,Availability,error,error,10577,"//; /// \anchor HFitRes; /// ### Fit Result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit which is return by an; /// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; ///; /// ~~~ {.cpp}; /// Int_t fitStatus = h->Fit(myFunc);; /// ~~~; ///; /// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; /// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; /// as shown in this example code:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also; /// directly from the fitted function that is passed to this call.; /// Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit; /// parameters with calls such as:; ///; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ##### Associated functions; ///; /// One or more object ( can be added to the list; /// of functions (fFunctions) associated to each histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of as",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10770,Availability,error,error,10770,"//; /// \anchor HFitRes; /// ### Fit Result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit which is return by an; /// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; ///; /// ~~~ {.cpp}; /// Int_t fitStatus = h->Fit(myFunc);; /// ~~~; ///; /// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; /// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; /// as shown in this example code:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also; /// directly from the fitted function that is passed to this call.; /// Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit; /// parameters with calls such as:; ///; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ##### Associated functions; ///; /// One or more object ( can be added to the list; /// of functions (fFunctions) associated to each histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of as",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:11227,Availability,error,error,11227," ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also; /// directly from the fitted function that is passed to this call.; /// Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit; /// parameters with calls such as:; ///; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ##### Associated functions; ///; /// One or more object ( can be added to the list; /// of functions (fFunctions) associated to each histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of associated functions is also persistent.; /// Given a histogram h, one can retrieve an associated function with:; ///; /// ~~~ {.cpp}; /// TF1 *myfunc = h->GetFunction(""myfunc"");; /// ~~~; /// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; ///; /// \anchor HFitStatus; /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; //",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12217,Availability,error,error,12217,"); //error on first parameter; /// ~~~; ///; /// ##### Associated functions; ///; /// One or more object ( can be added to the list; /// of functions (fFunctions) associated to each histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of associated functions is also persistent.; /// Given a histogram h, one can retrieve an associated function with:; ///; /// ~~~ {.cpp}; /// TF1 *myfunc = h->GetFunction(""myfunc"");; /// ~~~; /// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; ///; /// \anchor HFitStatus; /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; /// If other minimizers are used see their specific documenta",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12268,Availability,error,error,12268," ///; /// One or more object ( can be added to the list; /// of functions (fFunctions) associated to each histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of associated functions is also persistent.; /// Given a histogram h, one can retrieve an associated function with:; ///; /// ~~~ {.cpp}; /// TF1 *myfunc = h->GetFunction(""myfunc"");; /// ~~~; /// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; ///; /// \anchor HFitStatus; /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; /// If other minimizers are used see their specific documentation for the status code returned.; /// For example in the case of Fumili, ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12673,Availability,error,error,12673," can retrieve an associated function with:; ///; /// ~~~ {.cpp}; /// TF1 *myfunc = h->GetFunction(""myfunc"");; /// ~~~; /// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; ///; /// \anchor HFitStatus; /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; /// If other minimizers are used see their specific documentation for the status code returned.; /// For example in the case of Fumili, see TFumili::Minimize.; ///; /// \anchor HFitRange; /// ### Fitting in a range; ///; /// In order to fit in a sub-range of the histogram you have two options:; /// - pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;; /// - define a specific range in the fitted function and use the fitting option ""R"".; /// Fo",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12743,Availability,error,error,12743,"or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; ///; /// \anchor HFitStatus; /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; /// If other minimizers are used see their specific documentation for the status code returned.; /// For example in the case of Fumili, see TFumili::Minimize.; ///; /// \anchor HFitRange; /// ### Fitting in a range; ///; /// In order to fit in a sub-range of the histogram you have two options:; /// - pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;; /// - define a specific range in the fitted function and use the fitting option ""R"".; /// For example, if your histogram has a defined range between -4 and 4 and you want to fit a gaussian; /// only in the interval ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12932,Availability,error,error,12932," /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; /// If other minimizers are used see their specific documentation for the status code returned.; /// For example in the case of Fumili, see TFumili::Minimize.; ///; /// \anchor HFitRange; /// ### Fitting in a range; ///; /// In order to fit in a sub-range of the histogram you have two options:; /// - pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;; /// - define a specific range in the fitted function and use the fitting option ""R"".; /// For example, if your histogram has a defined range between -4 and 4 and you want to fit a gaussian; /// only in the interval 1 to 3, you can do:; ///; /// ~~~ {.cpp}; /// TF1 *f1 = new TF1(""f1"", ""gaus"", 1, 3);; /// histo->Fit(""f1"", """,MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:15921,Availability,error,errors,15921,"a function with 6 parameters, you can do:; ///; /// ~~~ {.cpp}; /// func->SetParameters(0, 3.1, 1.e-6, -8, 0, 100);; /// func->SetParLimits(3, -10, -4);; /// func->FixParameter(4, 0);; /// func->SetParLimits(5, 1, 1);; /// ~~~; ///; /// With this setup, parameters 0->2 can vary freely; /// Parameter 3 has boundaries [-10,-4] with initial value -8; /// Parameter 4 is fixed to 0; /// Parameter 5 is fixed to 100.; /// When the lower limit and upper limit are equal, the parameter is fixed.; /// However to fix a parameter to 0, one must call the FixParameter function.; ///; /// \anchor HFitStatBox; /// ### Fit Statistics Box; ///; /// The statistics box can display the result of the fit.; /// You can change the statistics box to display the fit parameters with; /// the TStyle::SetOptFit(mode) method. This mode has four digits.; /// mode = pcev (default = 0111); ///; /// v = 1; print name/values of parameters; /// e = 1; print errors (if e=1, v must be 1); /// c = 1; print Chisquare/Number of degrees of freedom; /// p = 1; print Probability; ///; /// For example: gStyle->SetOptFit(1011);; /// prints the fit probability, parameter names/values, and errors.; /// You can change the position of the statistics box with these lines; /// (where g is a pointer to the TGraph):; ///; /// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; /// st->SetX1NDC(newx1); //new x start position; /// st->SetX2NDC(newx2); //new x end position; ///; /// \anchor HFitExtra; /// ### Additional Notes on Fitting; ///; /// #### Fitting a histogram of dimension N with a function of dimension N-1; ///; /// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; /// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; /// For correct error scaling, the obtained parameter error are corrected as in the case when the; /// option ""W"" is used.; ///; /// #### User defined objective f",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:16146,Availability,error,errors,16146,"a function with 6 parameters, you can do:; ///; /// ~~~ {.cpp}; /// func->SetParameters(0, 3.1, 1.e-6, -8, 0, 100);; /// func->SetParLimits(3, -10, -4);; /// func->FixParameter(4, 0);; /// func->SetParLimits(5, 1, 1);; /// ~~~; ///; /// With this setup, parameters 0->2 can vary freely; /// Parameter 3 has boundaries [-10,-4] with initial value -8; /// Parameter 4 is fixed to 0; /// Parameter 5 is fixed to 100.; /// When the lower limit and upper limit are equal, the parameter is fixed.; /// However to fix a parameter to 0, one must call the FixParameter function.; ///; /// \anchor HFitStatBox; /// ### Fit Statistics Box; ///; /// The statistics box can display the result of the fit.; /// You can change the statistics box to display the fit parameters with; /// the TStyle::SetOptFit(mode) method. This mode has four digits.; /// mode = pcev (default = 0111); ///; /// v = 1; print name/values of parameters; /// e = 1; print errors (if e=1, v must be 1); /// c = 1; print Chisquare/Number of degrees of freedom; /// p = 1; print Probability; ///; /// For example: gStyle->SetOptFit(1011);; /// prints the fit probability, parameter names/values, and errors.; /// You can change the position of the statistics box with these lines; /// (where g is a pointer to the TGraph):; ///; /// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; /// st->SetX1NDC(newx1); //new x start position; /// st->SetX2NDC(newx2); //new x end position; ///; /// \anchor HFitExtra; /// ### Additional Notes on Fitting; ///; /// #### Fitting a histogram of dimension N with a function of dimension N-1; ///; /// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; /// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; /// For correct error scaling, the obtained parameter error are corrected as in the case when the; /// option ""W"" is used.; ///; /// #### User defined objective f",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:16731,Availability,error,error,16731,"s with; /// the TStyle::SetOptFit(mode) method. This mode has four digits.; /// mode = pcev (default = 0111); ///; /// v = 1; print name/values of parameters; /// e = 1; print errors (if e=1, v must be 1); /// c = 1; print Chisquare/Number of degrees of freedom; /// p = 1; print Probability; ///; /// For example: gStyle->SetOptFit(1011);; /// prints the fit probability, parameter names/values, and errors.; /// You can change the position of the statistics box with these lines; /// (where g is a pointer to the TGraph):; ///; /// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; /// st->SetX1NDC(newx1); //new x start position; /// st->SetX2NDC(newx2); //new x end position; ///; /// \anchor HFitExtra; /// ### Additional Notes on Fitting; ///; /// #### Fitting a histogram of dimension N with a function of dimension N-1; ///; /// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; /// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; /// For correct error scaling, the obtained parameter error are corrected as in the case when the; /// option ""W"" is used.; ///; /// #### User defined objective functions; ///; /// By default when fitting a chi square function is used for fitting. When option ""L"" is used; /// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; /// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; /// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; /// the file math/mathcore/src/FitUtil.cxx.; /// It is possible to specify a user defined fitting function, using option ""U"" and; /// calling the following functions:; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFit",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:16840,Availability,error,error,16840,"lues of parameters; /// e = 1; print errors (if e=1, v must be 1); /// c = 1; print Chisquare/Number of degrees of freedom; /// p = 1; print Probability; ///; /// For example: gStyle->SetOptFit(1011);; /// prints the fit probability, parameter names/values, and errors.; /// You can change the position of the statistics box with these lines; /// (where g is a pointer to the TGraph):; ///; /// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; /// st->SetX1NDC(newx1); //new x start position; /// st->SetX2NDC(newx2); //new x end position; ///; /// \anchor HFitExtra; /// ### Additional Notes on Fitting; ///; /// #### Fitting a histogram of dimension N with a function of dimension N-1; ///; /// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; /// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; /// For correct error scaling, the obtained parameter error are corrected as in the case when the; /// option ""W"" is used.; ///; /// #### User defined objective functions; ///; /// By default when fitting a chi square function is used for fitting. When option ""L"" is used; /// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; /// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; /// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; /// the file math/mathcore/src/FitUtil.cxx.; /// It is possible to specify a user defined fitting function, using option ""U"" and; /// calling the following functions:; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; //",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:16878,Availability,error,error,16878,"lues of parameters; /// e = 1; print errors (if e=1, v must be 1); /// c = 1; print Chisquare/Number of degrees of freedom; /// p = 1; print Probability; ///; /// For example: gStyle->SetOptFit(1011);; /// prints the fit probability, parameter names/values, and errors.; /// You can change the position of the statistics box with these lines; /// (where g is a pointer to the TGraph):; ///; /// TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats"");; /// st->SetX1NDC(newx1); //new x start position; /// st->SetX2NDC(newx2); //new x end position; ///; /// \anchor HFitExtra; /// ### Additional Notes on Fitting; ///; /// #### Fitting a histogram of dimension N with a function of dimension N-1; ///; /// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; /// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; /// For correct error scaling, the obtained parameter error are corrected as in the case when the; /// option ""W"" is used.; ///; /// #### User defined objective functions; ///; /// By default when fitting a chi square function is used for fitting. When option ""L"" is used; /// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; /// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; /// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; /// the file math/mathcore/src/FitUtil.cxx.; /// It is possible to specify a user defined fitting function, using option ""U"" and; /// calling the following functions:; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; //",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:17944,Availability,error,error,17944,"rected as in the case when the; /// option ""W"" is used.; ///; /// #### User defined objective functions; ///; /// By default when fitting a chi square function is used for fitting. When option ""L"" is used; /// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; /// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; /// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; /// the file math/mathcore/src/FitUtil.cxx.; /// It is possible to specify a user defined fitting function, using option ""U"" and; /// calling the following functions:; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18237,Availability,error,errors,18237,"ed in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; /// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; /// the file math/mathcore/src/FitUtil.cxx.; /// It is possible to specify a user defined fitting function, using option ""U"" and; /// calling the following functions:; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///;",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18322,Availability,error,error,18322,"valuateChi2 or FitUtil::EvaluatePoissonLogL in; /// the file math/mathcore/src/FitUtil.cxx.; /// It is possible to specify a user defined fitting function, using option ""U"" and; /// calling the following functions:; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///; ///; /// #### Warning when using the option ""0""; ///; /// When selecting the option ""0"", the fitted function is added ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18474,Availability,error,errors,18474,"; /// It is possible to specify a user defined fitting function, using option ""U"" and; /// calling the following functions:; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///; ///; /// #### Warning when using the option ""0""; ///; /// When selecting the option ""0"", the fitted function is added to; /// the list of functions of the histogram, but it is not drawn when the histogram is dr",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18503,Availability,error,errors,18503,":; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///; ///; /// #### Warning when using the option ""0""; ///; /// When selecting the option ""0"", the fitted function is added to; /// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; /// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; ///; /// ~~~ {.cpp}",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18733,Availability,error,error,18733," of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///; ///; /// #### Warning when using the option ""0""; ///; /// When selecting the option ""0"", the fitted function is added to; /// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; /// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; ///; /// ~~~ {.cpp}; /// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; /// h.Draw(); // function is not drawn; /// h.GetFunction(""",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18833,Availability,error,errors,18833,"ble_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///; ///; /// #### Warning when using the option ""0""; ///; /// When selecting the option ""0"", the fitted function is added to; /// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; /// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; ///; /// ~~~ {.cpp}; /// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; /// h.Draw(); // function is not drawn; /// h.GetFunction(""myFunction"")->ResetBit(TF1::kNotDraw);; /// h.Draw(); // function is visible again; /// ~~~; ///",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18923,Availability,error,errorp,18923,"ble_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///; ///; /// #### Warning when using the option ""0""; ///; /// When selecting the option ""0"", the fitted function is added to; /// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; /// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; ///; /// ~~~ {.cpp}; /// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; /// h.Draw(); // function is not drawn; /// h.GetFunction(""myFunction"")->ResetBit(TF1::kNotDraw);; /// h.Draw(); // function is visible again; /// ~~~; ///",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:19013,Availability,error,errors,19013,"ble_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///; ///; /// #### Warning when using the option ""0""; ///; /// When selecting the option ""0"", the fitted function is added to; /// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; /// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; ///; /// ~~~ {.cpp}; /// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; /// h.Draw(); // function is not drawn; /// h.GetFunction(""myFunction"")->ResetBit(TF1::kNotDraw);; /// h.Draw(); // function is visible again; /// ~~~; ///",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4357,Deployability,configurat,configuration,4357,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4400,Deployability,Configurat,Configuration,4400,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4901,Deployability,Configurat,Configuration,4901,"OT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5087,Deployability,configurat,configuration,5087,"ng the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the co",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6142,Integrability,depend,depending,6142," and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; /// \f]; ///; /// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; /// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the r",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12416,Integrability,depend,depends,12416,"h histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of associated functions is also persistent.; /// Given a histogram h, one can retrieve an associated function with:; ///; /// ~~~ {.cpp}; /// TF1 *myfunc = h->GetFunction(""myfunc"");; /// ~~~; /// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; ///; /// \anchor HFitStatus; /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; /// If other minimizers are used see their specific documentation for the status code returned.; /// For example in the case of Fumili, see TFumili::Minimize.; ///; /// \anchor HFitRange; /// ### Fitting in a range; ///; /// In order to fit ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12915,Integrability,depend,depending,12915," /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for the hesse return status.; /// If other minimizers are used see their specific documentation for the status code returned.; /// For example in the case of Fumili, see TFumili::Minimize.; ///; /// \anchor HFitRange; /// ### Fitting in a range; ///; /// In order to fit in a sub-range of the histogram you have two options:; /// - pass to this function the lower (`xxmin`) and upper (`xxmax`) values for the fitting range;; /// - define a specific range in the fitted function and use the fitting option ""R"".; /// For example, if your histogram has a defined range between -4 and 4 and you want to fit a gaussian; /// only in the interval 1 to 3, you can do:; ///; /// ~~~ {.cpp}; /// TF1 *f1 = new TF1(""f1"", ""gaus"", 1, 3);; /// histo->Fit(""f1"", """,MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:17328,Integrability,rout,routines,17328,"stats"");; /// st->SetX1NDC(newx1); //new x start position; /// st->SetX2NDC(newx2); //new x end position; ///; /// \anchor HFitExtra; /// ### Additional Notes on Fitting; ///; /// #### Fitting a histogram of dimension N with a function of dimension N-1; ///; /// It is possible to fit a TH2 with a TF1 or a TH3 with a TF2.; /// In this case the chi-square is computed from the squared error distance between the function values and the bin centers weighted by the bin content.; /// For correct error scaling, the obtained parameter error are corrected as in the case when the; /// option ""W"" is used.; ///; /// #### User defined objective functions; ///; /// By default when fitting a chi square function is used for fitting. When option ""L"" is used; /// a Poisson likelihood function is used. Using option ""MULTI"" a multinomial likelihood fit is used.; /// Thes functions are defined in the header Fit/Chi2Func.h or Fit/PoissonLikelihoodFCN and they; /// are implemented using the routines FitUtil::EvaluateChi2 or FitUtil::EvaluatePoissonLogL in; /// the file math/mathcore/src/FitUtil.cxx.; /// It is possible to specify a user defined fitting function, using option ""U"" and; /// calling the following functions:; ///; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(myhist)->SetFCN(MyFittingFunction);; /// ~~~; ///; /// where MyFittingFunction is of type:; ///; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero conte",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3723,Modifiability,variab,variable,3723,"leted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting range specified in the function range with `TF1::SetRange`.; /// ""B"" | Use this option when you want to fix or set limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the las",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4357,Modifiability,config,configuration,4357,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4400,Modifiability,Config,Configuration,4400,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4901,Modifiability,Config,Configuration,4901,"OT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:5087,Modifiability,config,configuration,5087,"ng the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the co",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2067,Performance,Perform,Performs,2067,"is needed for getting correct parameter uncertainties for weighted fits.; /// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""S"" | The full result of the fit is returned in the `TFitResultPtr`. This is needed to get the covariance matrix of the fit. See `TFitResult` and the base class `ROOT::Math::FitResult`.; /// ""Q"" | Quiet mode (minimum printing); /// ""V"" | Verbose mode (default is between Q and V); /// ""+"" | Adds this new fitted function to the list of fitted functions. By default, the previous function is deleted and only the last one is kept.; /// ""N"" | Does not store the graphics function, does not draw the histogram with the function after fitting.; /// ""0"" | Does not draw the histogram and the fitted function after fitting, but in contrast to option ""N"", it stores the fitted function in the histogram list of functions.; /// ""R"" | Fit using a fitting rang",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3871,Performance,multi-thread,multi-thread,3871,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3890,Performance,Perform,Perform,3890,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3982,Performance,multi-thread,multi-thread,3982,"et limits on one or more parameters and the fitting function is a predefined one (e.g gaus, expo,..), otherwise in case of pre-defined functions, some default initial values and limits will be used.; /// ""C"" | In case of linear fitting, do no calculate the chisquare (saves CPU time).; /// ""G"" | Uses the gradient implemented in `TF1::GradientPar` for the minimization. This allows to use Automatic Differentiation when it is supported by the provided TF1 function.; /// ""WIDTH"" | Scales the histogran bin content by the bin width (useful for variable bins histograms); /// ""SERIAL"" | Runs in serial mode. By defult if ROOT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4642,Performance,perform,performed,4642,"OT is built with MT support and MT is enables, the fit is perfomed in multi-thread - ""E"" Perform better Errors estimation using Minos technique; /// ""MULTITHREAD"" | Forces usage of multi-thread execution whenever possible; ///; /// The default fitting of an histogram (when no option is given) is perfomed as following:; /// - a chi-square fit (see below Chi-square Fits) computed using the bin histogram errors and excluding bins with zero errors (empty bins);; /// - the full range of the histogram is used;; /// - the default Minimizer with its default configuration is used (see below Minimizer Configuration) except for linear function;; /// - for linear functions (`polN`, `chenbyshev` or formula expressions combined using operator `++`) a linear minimization is used.; /// - only the status of the fit is returned;; /// - the fit is performed in Multithread whenever is enabled in ROOT;; /// - only the last fitted function is saved in the histogram;; /// - the histogram is drawn after fitting overalyed with the resulting fitting function; ///; /// \anchor HFitMinimizer; /// ### Minimizer Configuration; ///; /// The Fit is perfomed using the default Minimizer, defined in the `ROOT::Math::MinimizerOptions` class.; /// It is possible to change the default minimizer and its configuration parameters by calling these static functions before fitting (before calling `TH1::Fit`):; /// - `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(minimizerName, minimizerAgorithm)` for changing the minmizer and/or the corresponding algorithm.; /// For example `ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""GSLMultiMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6474,Performance,perform,performed,6474,"iMin"",""BFGS"");` will set the usage of the BFGS algorithm of the GSL multi-dimensional minimization; /// The current defaults are (""Minuit"",""Migrad"").; /// See the documentation of the `ROOT::Math::MinimizerOptions` for the available minimizers in ROOT and their corresponding algorithms.; /// - `ROOT::Math::MinimizerOptions::SetDefaultTolerance` for setting a different tolerance value for the minimization.; /// - `ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls` for setting the maximum number of function calls.; /// - `ROOT::Math::MinimizerOptions::SetDefaultPrintLevel` for changing the minimizer print level from level=0 (minimal printing) to level=3 maximum printing; ///; /// Other options are possible depending on the Minimizer used, see the corresponding documentation.; /// The default minimizer can be also set in the resource file in etc/system.rootrc. For example; ///; /// ~~~ {.cpp}; /// Root.Fitter: Minuit2; /// ~~~; ///; /// \anchor HFitChi2; /// ### Chi-square Fits; ///; /// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; /// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; ///; /// \f[; /// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; /// \f]; ///; /// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; /// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:9235,Performance,perform,perform,9235,"f the use of chi-square and likelihood functions in fits to histograms,; /// Nucl. Instrum. Meth. 221 (1984) 437.; ///; /// \f[; /// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; /// \f]; /// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; ///; /// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; /// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; /// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; /// give the same result.; ///; /// The likelihood method, although a bit slower, it is therefore the recommended method,; /// when the histogram represent counts (Poisson statistics), where the chi-square methods may; /// give incorrect results, especially in case of low statistics.; /// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; /// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; /// has the information on the sum of the weight square for each bin ( TH1::Sumw2() has been called).; /// The bin error for a weighted histogram is the square root of the sum of the weight square.; ///; /// \anchor HFitRes; /// ### Fit Result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit which is return by an; /// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; ///; /// ~~~ {.cpp}; /// Int_t fitStatus = h->Fit(myFunc);; /// ~~~; ///; /// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; /// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; /// as shown in this example code:; ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12186,Performance,perform,performed,12186,"c->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ##### Associated functions; ///; /// One or more object ( can be added to the list; /// of functions (fFunctions) associated to each histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of associated functions is also persistent.; /// Given a histogram h, one can retrieve an associated function with:; ///; /// ~~~ {.cpp}; /// TF1 *myfunc = h->GetFunction(""myfunc"");; /// ~~~; /// or by quering directly the list obtained by calling `TH1::GetListOfFunctions`.; ///; /// \anchor HFitStatus; /// ### Fit status; ///; /// The status of the fit is obtained converting the TFitResultPtr to an integer; /// independently if the fit option ""S"" is used or not:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,opt);; /// Int_t fitStatus = r;; /// ~~~; ///; /// - `status = 0` : the fit has been performed successfully (i.e no error occurred).; /// - `status < 0` : there is an error not connected with the minimization procedure, for example when a wrong function is used.; /// - `status > 0` : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; /// - `status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus`.; /// TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error; /// only in Minos but not in Migrad a fitStatus of 40 will be returned.; /// Minuit2 returns 0 in case of success and different values in migrad,minos or; /// hesse depending on the error. See in this case the documentation of; /// Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the; /// minos return status and Minuit2Minimizer::Hesse for ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10355,Security,access,access,10355,"//; /// \anchor HFitRes; /// ### Fit Result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit which is return by an; /// automatic conversion of the TFitResultPtr to an integer. One can write in this case directly:; ///; /// ~~~ {.cpp}; /// Int_t fitStatus = h->Fit(myFunc);; /// ~~~; ///; /// If the option ""S"" is instead used, TFitResultPtr behaves as a smart; /// pointer to the TFitResult object. This is useful for retrieving the full result information from the fit, such as the covariance matrix,; /// as shown in this example code:; ///; /// ~~~ {.cpp}; /// TFitResultPtr r = h->Fit(myFunc,""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi-square (but not covariance matrix) can be retrieved also; /// directly from the fitted function that is passed to this call.; /// Given a pointer to an associated fitted function `myfunc`, one can retrieve the function/fit; /// parameters with calls such as:; ///; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ##### Associated functions; ///; /// One or more object ( can be added to the list; /// of functions (fFunctions) associated to each histogram.; /// When TH1::Fit is invoked, the fitted function is added to the histogram list of functions (fFunctions).; /// If the histogram is made persistent, the list of as",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:843,Testability,log,log,843,"////////////////////////////////////////////////////////////////////////////////; /// Fit histogram with the function pointer f1.; ///; /// \param[in] f1 pointer to the function object; /// \param[in] option string defining the fit options (see table below).; /// \param[in] goption specify a list of graphics options. See TH1::Draw for a complete list of these options.; /// \param[in] xxmin lower fitting range; /// \param[in] xxmax upper fitting range; /// \return A smart pointer to the TFitResult class; ///; /// \anchor HFitOpt; /// ### Histogram Fitting Options; ///; /// Here is the full list of fit options that can be given in the parameter `option`.; /// Several options can be used together by concatanating the strings without the need of any delimiters.; ///; /// option | description; /// -------|------------; /// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; /// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; /// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikel",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:967,Testability,log,log,967,"////////////////////////////////////////////////////////////////////////////////; /// Fit histogram with the function pointer f1.; ///; /// \param[in] f1 pointer to the function object; /// \param[in] option string defining the fit options (see table below).; /// \param[in] goption specify a list of graphics options. See TH1::Draw for a complete list of these options.; /// \param[in] xxmin lower fitting range; /// \param[in] xxmax upper fitting range; /// \return A smart pointer to the TFitResult class; ///; /// \anchor HFitOpt; /// ### Histogram Fitting Options; ///; /// Here is the full list of fit options that can be given in the parameter `option`.; /// Several options can be used together by concatanating the strings without the need of any delimiters.; ///; /// option | description; /// -------|------------; /// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; /// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; /// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikel",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1361,Testability,Log,Loglikelihood,1361,"aram[in] xxmin lower fitting range; /// \param[in] xxmax upper fitting range; /// \return A smart pointer to the TFitResult class; ///; /// \anchor HFitOpt; /// ### Histogram Fitting Options; ///; /// Here is the full list of fit options that can be given in the parameter `option`.; /// Several options can be used together by concatanating the strings without the need of any delimiters.; ///; /// option | description; /// -------|------------; /// ""L"" | Uses a log likelihood method (default is chi-square method). To be used when the histogram represents counts.; /// ""WL"" | Weighted log likelihood method. To be used when the histogram has been filled with weights different than 1. This is needed for getting correct parameter uncertainties for weighted fits.; /// ""P"" | Uses Pearson chi-square method. Uses expected errors instead of the observed one (default case). The expected error is instead estimated from the square-root of the bin function value.; /// ""MULTI"" | Uses Loglikelihood method based on multi-nomial distribution. In this case the function must be normalized and one fits only the function shape.; /// ""W"" | Fit using the chi-square method and ignoring the bin uncertainties and skip empty bins.; /// ""WW"" | Fit using the chi-square method and ignoring the bin uncertainties and include the empty bins.; /// ""I"" | Uses the integral of function in the bin instead of the default bin center value.; /// ""F"" | Uses the default minimizer (e.g. Minuit) when fitting a linear function (e.g. polN) instead of the linear fitter.; /// ""U"" | Uses a user specified objective function (e.g. user providedlikelihood function) defined using `TVirtualFitter::SetFCN`; /// ""E"" | Performs a better parameter errors estimation using the Minos technique for all fit parameters.; /// ""M"" | Uses the IMPROVE algorithm (available only in TMinuit). This algorithm attempts improve the found local minimum by searching for a better one.; /// ""S"" | The full result of the fit is returned in the `TFit",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7855,Testability,log,log-likelihood,7855,"luded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.; /// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; /// because they could return a biased result.; ///; /// \anchor HFitNLL; /// ### Likelihood Fits; ///; /// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; /// The likelihood is built assuming a Poisson probability density function for each bin.; /// The negative log-likelihood to be minimized is; ///; /// \f[; /// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; /// \f]; /// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; /// The exact likelihood used is the Poisson likelihood described in this paper:; /// S. Baker and R. D. Cousins, Clarification of the use of chi-square and likelihood functions in fits to histograms,; /// Nucl. Instrum. Meth. 221 (1984) 437.; ///; /// \f[; /// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; /// \f]; /// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; ///; /// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; /// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; /// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; /// give the same result.; ///; /// The likelihood method, although a bit sl",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7927,Testability,log,log,7927,"luded from the fit. See also later the note on the treatment; /// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; /// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; /// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; /// In this case empty bins are considered in the fit.; /// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; /// because they could return a biased result.; ///; /// \anchor HFitNLL; /// ### Likelihood Fits; ///; /// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; /// The likelihood is built assuming a Poisson probability density function for each bin.; /// The negative log-likelihood to be minimized is; ///; /// \f[; /// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; /// \f]; /// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; /// The exact likelihood used is the Poisson likelihood described in this paper:; /// S. Baker and R. D. Cousins, Clarification of the use of chi-square and likelihood functions in fits to histograms,; /// Nucl. Instrum. Meth. 221 (1984) 437.; ///; /// \f[; /// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; /// \f]; /// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; ///; /// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; /// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; /// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; /// give the same result.; ///; /// The likelihood method, although a bit sl",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:8407,Testability,log,log,8407," should not be used when the bin content represent counts, especially in case of low bin statistics,; /// because they could return a biased result.; ///; /// \anchor HFitNLL; /// ### Likelihood Fits; ///; /// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; /// The likelihood is built assuming a Poisson probability density function for each bin.; /// The negative log-likelihood to be minimized is; ///; /// \f[; /// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; /// \f]; /// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; /// The exact likelihood used is the Poisson likelihood described in this paper:; /// S. Baker and R. D. Cousins, Clarification of the use of chi-square and likelihood functions in fits to histograms,; /// Nucl. Instrum. Meth. 221 (1984) 437.; ///; /// \f[; /// NLL = \sum_{i}{( f(x(i) | p ) + y(i)\log(y(i)/ f(x(i) | p )) - y(i)) }; /// \f]; /// By using this formulation, `2*NLL` can be interpreted as the chi-square resulting from the fit.; ///; /// This method should be always used when the bin content represents counts (i.e. errors are sqrt(N) ).; /// The likelihood method has the advantage of treating correctly bins with low statistics. In case of high; /// statistics/bin the distribution of the bin content becomes a normal distribution and the likelihood and the chi2 fit; /// give the same result.; ///; /// The likelihood method, although a bit slower, it is therefore the recommended method,; /// when the histogram represent counts (Poisson statistics), where the chi-square methods may; /// give incorrect results, especially in case of low statistics.; /// In case of a weighted histogram, it is possible to perform also a likelihood fit by using the; /// option ""WL"". Note a weighted histogram is a histogram which has been filled with weights and it; /// has the information on the sum of the weight square for each bin (",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:19457,Usability,undo,undo,19457,"ble_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// #### Note on treatment of empty bins; ///; /// Empty bins, which have the content equal to zero AND error equal to zero,; /// are excluded by default from the chi-square fit, but they are considered in the likelihood fit.; /// since they affect the likelihood if the function value in these bins is not negligible.; /// Note that if the histogram is having bins with zero content and non zero-errors they are considered as; /// any other bins in the fit. Instead bins with zero error and non-zero content are by default excluded in the chi-squared fit.; /// In general, one should not fit a histogram with non-empty bins and zero errors.; ///; /// If the bin errors are not known, one should use the fit option ""W"", which gives a weight=1 for each bin (it is an unweighted least-square; /// fit). When using option ""WW"" the empty bins will be also considered in the chi-square fit with an error of 1.; /// Note that in this fitting case (option ""W"" or ""WW"") the resulting fitted parameter errors; /// are corrected by the obtained chi2 value using this scaling expression:; /// `errorp *= sqrt(chisquare/(ndf-1))` as it is done when fitting a TGraph with; /// no point errors.; ///; /// #### Excluding points; ///; /// You can use TF1::RejectPoint inside your fitting function to exclude some points; /// within a certain range from the fit. See the tutorial `fit/fitExclude.C`.; ///; ///; /// #### Warning when using the option ""0""; ///; /// When selecting the option ""0"", the fitted function is added to; /// the list of functions of the histogram, but it is not drawn when the histogram is drawn.; /// You can undo this behaviour resetting its corresponding bit in the TF1 object as following:; ///; /// ~~~ {.cpp}; /// h.Fit(""myFunction"", ""0""); // fit, store function but do not draw; /// h.Draw(); // function is not drawn; /// h.GetFunction(""myFunction"")->ResetBit(TF1::kNotDraw);; /// h.Draw(); // function is visible again; /// ~~~; ///",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7,Modifiability,plugin,plugin,7,"// use plugin manager to create instance of TFitEditor",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:433,Availability,error,error,433,"////////////////////////////////////////////////////////////////////////////////; /// Return a histogram containing the asymmetry of this histogram with h2,; /// where the asymmetry is defined as:; ///; /// ~~~ {.cpp}; /// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; /// ~~~; ///; /// works for 1D, 2D, etc. histograms; /// c2 is an optional argument that gives a relative weight between the two; /// histograms, and dc2 is the error on this weight. This is useful, for example,; /// when forming an asymmetry between two histograms from 2 different data sets that; /// need to be normalized to each other in some way. The function calculates; /// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; ///; /// example: assuming 'h1' and 'h2' are already filled; ///; /// ~~~ {.cpp}; /// h3 = h1->GetAsymmetry(h2); /// ~~~; ///; /// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; /// h1 and h2 are left intact.; ///; /// Note that it is the user's responsibility to manage the created histogram.; /// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; ///; /// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; ///; /// clone the histograms so top and bottom will have the; /// correct dimensions:; /// Sumw2 just makes sure the errors will be computed properly; /// when we form sums and ratios below.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:657,Availability,error,errors,657,"////////////////////////////////////////////////////////////////////////////////; /// Return a histogram containing the asymmetry of this histogram with h2,; /// where the asymmetry is defined as:; ///; /// ~~~ {.cpp}; /// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; /// ~~~; ///; /// works for 1D, 2D, etc. histograms; /// c2 is an optional argument that gives a relative weight between the two; /// histograms, and dc2 is the error on this weight. This is useful, for example,; /// when forming an asymmetry between two histograms from 2 different data sets that; /// need to be normalized to each other in some way. The function calculates; /// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; ///; /// example: assuming 'h1' and 'h2' are already filled; ///; /// ~~~ {.cpp}; /// h3 = h1->GetAsymmetry(h2); /// ~~~; ///; /// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; /// h1 and h2 are left intact.; ///; /// Note that it is the user's responsibility to manage the created histogram.; /// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; ///; /// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; ///; /// clone the histograms so top and bottom will have the; /// correct dimensions:; /// Sumw2 just makes sure the errors will be computed properly; /// when we form sums and ratios below.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1327,Availability,error,errors,1327,"////////////////////////////////////////////////////////////////////////////////; /// Return a histogram containing the asymmetry of this histogram with h2,; /// where the asymmetry is defined as:; ///; /// ~~~ {.cpp}; /// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; /// ~~~; ///; /// works for 1D, 2D, etc. histograms; /// c2 is an optional argument that gives a relative weight between the two; /// histograms, and dc2 is the error on this weight. This is useful, for example,; /// when forming an asymmetry between two histograms from 2 different data sets that; /// need to be normalized to each other in some way. The function calculates; /// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; ///; /// example: assuming 'h1' and 'h2' are already filled; ///; /// ~~~ {.cpp}; /// h3 = h1->GetAsymmetry(h2); /// ~~~; ///; /// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; /// h1 and h2 are left intact.; ///; /// Note that it is the user's responsibility to manage the created histogram.; /// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; ///; /// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; ///; /// clone the histograms so top and bottom will have the; /// correct dimensions:; /// Sumw2 just makes sure the errors will be computed properly; /// when we form sums and ratios below.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1190,Energy Efficiency,adapt,adapted,1190,"////////////////////////////////////////////////////////////////////////////////; /// Return a histogram containing the asymmetry of this histogram with h2,; /// where the asymmetry is defined as:; ///; /// ~~~ {.cpp}; /// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; /// ~~~; ///; /// works for 1D, 2D, etc. histograms; /// c2 is an optional argument that gives a relative weight between the two; /// histograms, and dc2 is the error on this weight. This is useful, for example,; /// when forming an asymmetry between two histograms from 2 different data sets that; /// need to be normalized to each other in some way. The function calculates; /// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; ///; /// example: assuming 'h1' and 'h2' are already filled; ///; /// ~~~ {.cpp}; /// h3 = h1->GetAsymmetry(h2); /// ~~~; ///; /// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; /// h1 and h2 are left intact.; ///; /// Note that it is the user's responsibility to manage the created histogram.; /// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; ///; /// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; ///; /// clone the histograms so top and bottom will have the; /// correct dimensions:; /// Sumw2 just makes sure the errors will be computed properly; /// when we form sums and ratios below.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1190,Modifiability,adapt,adapted,1190,"////////////////////////////////////////////////////////////////////////////////; /// Return a histogram containing the asymmetry of this histogram with h2,; /// where the asymmetry is defined as:; ///; /// ~~~ {.cpp}; /// Asymmetry = (h1 - h2)/(h1 + h2) where h1 = this; /// ~~~; ///; /// works for 1D, 2D, etc. histograms; /// c2 is an optional argument that gives a relative weight between the two; /// histograms, and dc2 is the error on this weight. This is useful, for example,; /// when forming an asymmetry between two histograms from 2 different data sets that; /// need to be normalized to each other in some way. The function calculates; /// the errors assuming Poisson statistics on h1 and h2 (that is, dh = sqrt(h)).; ///; /// example: assuming 'h1' and 'h2' are already filled; ///; /// ~~~ {.cpp}; /// h3 = h1->GetAsymmetry(h2); /// ~~~; ///; /// then 'h3' is created and filled with the asymmetry between 'h1' and 'h2';; /// h1 and h2 are left intact.; ///; /// Note that it is the user's responsibility to manage the created histogram.; /// The name of the returned histogram will be `Asymmetry_nameOfh1-nameOfh2`; ///; /// code proposed by Jason Seely (seely@mit.edu) and adapted by R.Brun; ///; /// clone the histograms so top and bottom will have the; /// correct dimensions:; /// Sumw2 just makes sure the errors will be computed properly; /// when we form sums and ratios below.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:47,Availability,error,errors,47,"// now loop over bins to calculate the correct errors; // the reason this error calculation looks complex is because of c2",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:74,Availability,error,error,74,"// now loop over bins to calculate the correct errors; // the reason this error calculation looks complex is because of c2",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:65,Availability,error,error,65,"// here some bin contents are written into variables to make the error; // calculation a little more legible:",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:43,Modifiability,variab,variables,43,"// here some bin contents are written into variables to make the error; // calculation a little more legible:",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:53,Availability,error,errors,53,"// make sure there are some events, if not, then the errors are set = 0; // automatically.; //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18,Availability,error,errors,18,"// computation of errors by Christos Leonidopoulos",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:490,Energy Efficiency,power,power,490,"////////////////////////////////////////////////////////////////////////////////; /// Number of effective entries of the histogram.; ///; /// \f[; /// neff = \frac{(\sum Weights )^2}{(\sum Weight^2 )}; /// \f]; ///; /// In case of an unweighted histogram this number is equivalent to the; /// number of entries of the histogram.; /// For a weighted histogram, this number corresponds to the hypothetical number of unweighted entries; /// a histogram would need to have the same statistical power as this weighted histogram.; /// Note: The underflow/overflow are included if one has set the TH1::StatOverFlows flag; /// and if the statistics has been computed at filling time.; /// If a range is set in the histogram the number is computed from the given range.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:246,Modifiability,variab,variable,246,"////////////////////////////////////////////////////////////////////////////////; /// Compute Quantiles for this histogram; /// Quantile x_p := Q(p) is defined as the value x_p such that the cumulative; /// probability distribution Function F of variable X yields:; ///; /// ~~~ {.cpp}; /// F(x_p) = Pr(X <= x_p) = p with 0 <= p <= 1.; /// x_p = Q(p) = F_inv(p); /// ~~~; ///; /// For instance the median x_0.5 of a distribution is defined as that value; /// of the random variable X for which the distribution function equals 0.5:; ///; /// ~~~ {.cpp}; /// F(x_0.5) = Probability(X < x_0.5) = 0.5; /// x_0.5 = Q(0.5); /// ~~~; ///; /// \author Eddy Offermann; /// code from Eddy Offermann, Renaissance; ///; /// \param[in] n maximum size of array xp and size of array p (if given); /// \param[out] xp array to be filled with nq quantiles evaluated at (p). Memory has to be preallocated by caller.; /// If p is null (default value), then xp is actually set to the (first n) histogram bin edges; /// \param[in] p array of cumulative probabilities where quantiles should be evaluated.; /// - if p is null, the CDF of the histogram will be used instead as array, and will; /// have a size = number of bins + 1 in h. It will correspond to the; /// quantiles calculated at the lowest edge of the histogram (quantile=0) and; /// all the upper edges of the bins. (nbins might be > n).; /// - if p is not null, it is assumed to contain at least n values.; /// \return value nq (<=n) with the number of quantiles computed; ///; /// Note that the Integral of the histogram is automatically recomputed; /// if the number of entries is different of the number of entries when; /// the integral was computed last time. In case you do not use the Fill; /// functions to fill your histogram, but SetBinContent, you must call; /// TH1::ComputeIntegral before calling this function.; ///; /// Getting quantiles xp from two histograms and storing results in a TGraph,; /// a so-called QQ-plot; ///; /// ~~~ {.cpp}; /// ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:473,Modifiability,variab,variable,473,"////////////////////////////////////////////////////////////////////////////////; /// Compute Quantiles for this histogram; /// Quantile x_p := Q(p) is defined as the value x_p such that the cumulative; /// probability distribution Function F of variable X yields:; ///; /// ~~~ {.cpp}; /// F(x_p) = Pr(X <= x_p) = p with 0 <= p <= 1.; /// x_p = Q(p) = F_inv(p); /// ~~~; ///; /// For instance the median x_0.5 of a distribution is defined as that value; /// of the random variable X for which the distribution function equals 0.5:; ///; /// ~~~ {.cpp}; /// F(x_0.5) = Probability(X < x_0.5) = 0.5; /// x_0.5 = Q(0.5); /// ~~~; ///; /// \author Eddy Offermann; /// code from Eddy Offermann, Renaissance; ///; /// \param[in] n maximum size of array xp and size of array p (if given); /// \param[out] xp array to be filled with nq quantiles evaluated at (p). Memory has to be preallocated by caller.; /// If p is null (default value), then xp is actually set to the (first n) histogram bin edges; /// \param[in] p array of cumulative probabilities where quantiles should be evaluated.; /// - if p is null, the CDF of the histogram will be used instead as array, and will; /// have a size = number of bins + 1 in h. It will correspond to the; /// quantiles calculated at the lowest edge of the histogram (quantile=0) and; /// all the upper edges of the bins. (nbins might be > n).; /// - if p is not null, it is assumed to contain at least n values.; /// \return value nq (<=n) with the number of quantiles computed; ///; /// Note that the Integral of the histogram is automatically recomputed; /// if the number of entries is different of the number of entries when; /// the integral was computed last time. In case you do not use the Fill; /// functions to fill your histogram, but SetBinContent, you must call; /// TH1::ComputeIntegral before calling this function.; ///; /// Getting quantiles xp from two histograms and storing results in a TGraph,; /// a so-called QQ-plot; ///; /// ~~~ {.cpp}; /// ",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:288,Integrability,rout,routine,288,"////////////////////////////////////////////////////////////////////////////////; /// Least squares lpolynomial fitting without weights.; ///; /// \param[in] n number of points to fit; /// \param[in] m number of parameters; /// \param[in] a array of parameters; ///; /// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun; /// (E.Keil. revised by B.Schorr, 23.10.1981.)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:122,Integrability,rout,routine,122,"////////////////////////////////////////////////////////////////////////////////; /// Extracted from CERN Program library routine DSEQN.; ///; /// Translated to C++ by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1059,Security,access,access,1059,"////////////////////////////////////////////////////////////////////////////////; /// Return Global bin number corresponding to binx,y,z.; ///; /// 2-D and 3-D histograms are represented with a one dimensional; /// structure.; /// This has the advantage that all existing functions, such as; /// GetBinContent, GetBinError, GetBinFunction work for all dimensions.; ///; /// In case of a TH1x, returns binx directly.; /// see TH1::GetBinXYZ for the inverse transformation.; ///; /// Convention for numbering bins; ///; /// For all histogram types: nbins, xlow, xup; ///; /// - bin = 0; underflow bin; /// - bin = 1; first bin with low-edge xlow INCLUDED; /// - bin = nbins; last bin with upper-edge xup EXCLUDED; /// - bin = nbins+1; overflow bin; ///; /// In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; /// For example, assuming a 3-D histogram with binx,biny,binz, the function; ///; /// ~~~ {.cpp}; /// Int_t bin = h->GetBin(binx,biny,binz);; /// ~~~; ///; /// returns a global/linearized bin number. This global bin is useful; /// to access the bin information independently of the dimension.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:743,Security,access,access,743,"////////////////////////////////////////////////////////////////////////////////; /// Return content of bin number bin.; ///; /// Implemented in TH1C,S,F,D; ///; /// Convention for numbering bins; ///; /// For all histogram types: nbins, xlow, xup; ///; /// - bin = 0; underflow bin; /// - bin = 1; first bin with low-edge xlow INCLUDED; /// - bin = nbins; last bin with upper-edge xup EXCLUDED; /// - bin = nbins+1; overflow bin; ///; /// In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; /// For example, assuming a 3-D histogram with binx,biny,binz, the function; ///; /// ~~~ {.cpp}; /// Int_t bin = h->GetBin(binx,biny,binz);; /// ~~~; ///; /// returns a global/linearized bin number. This global bin is useful; /// to access the bin information independently of the dimension.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Energy Efficiency,Reduce,Reduce,86,"////////////////////////////////////////////////////////////////////////////////; /// Reduce the number of bins for the axis passed in the option to the number of bins having a label.; /// The method will remove only the extra bins existing after the last ""labeled"" bin.; /// Note that if there are ""un-labeled"" bins present between ""labeled"" bins they will not be removed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:21,Availability,error,error,21,"// reset content and error; //now loop on all bins and refill",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:428,Availability,down,down,428,"////////////////////////////////////////////////////////////////////////////////; /// Sort bins with labels or set option(s) to draw axis with labels; /// \param[in] option; /// - ""a"" sort by alphabetic order; /// - "">"" sort by decreasing values; /// - ""<"" sort by increasing values; /// - ""h"" draw labels horizontal; /// - ""v"" draw labels vertical; /// - ""u"" draw labels up (end of label right adjusted); /// - ""d"" draw labels down (start of label left adjusted); ///; /// In case not all bins have labels sorting will work only in the case; /// the first `n` consecutive bins have all labels and sorting will be performed on; /// those label bins.; ///; /// \param[in] ax axis",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:614,Performance,perform,performed,614,"////////////////////////////////////////////////////////////////////////////////; /// Sort bins with labels or set option(s) to draw axis with labels; /// \param[in] option; /// - ""a"" sort by alphabetic order; /// - "">"" sort by decreasing values; /// - ""<"" sort by increasing values; /// - ""h"" draw labels horizontal; /// - ""v"" draw labels vertical; /// - ""u"" draw labels up (end of label right adjusted); /// - ""d"" draw labels down (start of label left adjusted); ///; /// In case not all bins have labels sorting will work only in the case; /// the first `n` consecutive bins have all labels and sorting will be performed on; /// those label bins.; ///; /// \param[in] ax axis",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:133,Availability,error,error,133,"// case where label bins are consecutive starting from first bin will work; // calling before a TH1::LabelsDeflate() will avoid this error message",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:139,Integrability,message,message,139,"// case where label bins are consecutive starting from first bin will work; // calling before a TH1::LabelsDeflate() will avoid this error message",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:122,Safety,avoid,avoid,122,"// case where label bins are consecutive starting from first bin will work; // calling before a TH1::LabelsDeflate() will avoid this error message",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:7,Deployability,Update,UpdateBinCOntent,7,"// use UpdateBinCOntent to not screw up histogram entries",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:27,Testability,test,tested,27,"// case of 3D (needs to be tested)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Testability,Test,Test,86,"////////////////////////////////////////////////////////////////////////////////; /// Test if two double are almost equal.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Testability,Test,Test,86,"////////////////////////////////////////////////////////////////////////////////; /// Test if a double is almost an integer.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Testability,Test,Test,86,"////////////////////////////////////////////////////////////////////////////////; /// Test if the binning is equidistant.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:270,Availability,error,errors,270,"////////////////////////////////////////////////////////////////////////////////; /// Add all histograms in the collection to this histogram.; /// This function computes the min/max for the x axis,; /// compute a new number of bins, if necessary,; /// add bin contents, errors and statistics.; /// If all histograms have bin labels, bins with identical labels; /// will be merged, no matter what their order is.; /// If overflows are present and limits are different the function will fail.; /// The function returns the total number of entries in the result histogram; /// if the merge is successful, -1 otherwise.; ///; /// Possible option:; /// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; /// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; /// (enabled by default) slows down the merging; ///; /// IMPORTANT remark. The axis x may have different number; /// of bins and different limits, BUT the largest bin width must be; /// a multiple of the smallest bin width and the upper limit must also; /// be a multiple of the bin width.; /// Example:; ///; /// ~~~ {.cpp}; /// void atest() {; /// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; /// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; /// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; /// TRandom r;; /// for (Int_t i=0;i<10000;i++) {; /// h1->Fill(r.Gaus(-55,10));; /// h2->Fill(r.Gaus(55,10));; /// h3->Fill(r.Gaus(0,10));; /// }; ///; /// TList *list = new TList;; /// list->Add(h1);; /// list->Add(h2);; /// list->Add(h3);; /// TH1F *h = (TH1F*)h1->Clone(""h"");; /// h->Reset();; /// h->Merge(list);; /// h->Draw();; /// }; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:909,Availability,down,down,909,"////////////////////////////////////////////////////////////////////////////////; /// Add all histograms in the collection to this histogram.; /// This function computes the min/max for the x axis,; /// compute a new number of bins, if necessary,; /// add bin contents, errors and statistics.; /// If all histograms have bin labels, bins with identical labels; /// will be merged, no matter what their order is.; /// If overflows are present and limits are different the function will fail.; /// The function returns the total number of entries in the result histogram; /// if the merge is successful, -1 otherwise.; ///; /// Possible option:; /// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; /// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; /// (enabled by default) slows down the merging; ///; /// IMPORTANT remark. The axis x may have different number; /// of bins and different limits, BUT the largest bin width must be; /// a multiple of the smallest bin width and the upper limit must also; /// be a multiple of the bin width.; /// Example:; ///; /// ~~~ {.cpp}; /// void atest() {; /// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; /// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; /// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; /// TRandom r;; /// for (Int_t i=0;i<10000;i++) {; /// h1->Fill(r.Gaus(-55,10));; /// h2->Fill(r.Gaus(55,10));; /// h3->Fill(r.Gaus(0,10));; /// }; ///; /// TList *list = new TList;; /// list->Add(h1);; /// list->Add(h2);; /// list->Add(h3);; /// TH1F *h = (TH1F*)h1->Clone(""h"");; /// h->Reset();; /// h->Merge(list);; /// h->Draw();; /// }; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:801,Performance,perform,perform,801,"////////////////////////////////////////////////////////////////////////////////; /// Add all histograms in the collection to this histogram.; /// This function computes the min/max for the x axis,; /// compute a new number of bins, if necessary,; /// add bin contents, errors and statistics.; /// If all histograms have bin labels, bins with identical labels; /// will be merged, no matter what their order is.; /// If overflows are present and limits are different the function will fail.; /// The function returns the total number of entries in the result histogram; /// if the merge is successful, -1 otherwise.; ///; /// Possible option:; /// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; /// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; /// (enabled by default) slows down the merging; ///; /// IMPORTANT remark. The axis x may have different number; /// of bins and different limits, BUT the largest bin width must be; /// a multiple of the smallest bin width and the upper limit must also; /// be a multiple of the bin width.; /// Example:; ///; /// ~~~ {.cpp}; /// void atest() {; /// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; /// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; /// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; /// TRandom r;; /// for (Int_t i=0;i<10000;i++) {; /// h1->Fill(r.Gaus(-55,10));; /// h2->Fill(r.Gaus(55,10));; /// h3->Fill(r.Gaus(0,10));; /// }; ///; /// TList *list = new TList;; /// list->Add(h1);; /// list->Add(h2);; /// list->Add(h3);; /// TH1F *h = (TH1F*)h1->Clone(""h"");; /// h->Reset();; /// h->Merge(list);; /// h->Draw();; /// }; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:153,Availability,error,errors,153,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation:; ///; /// `this = this*c1*f1`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:190,Availability,error,errors,190,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation:; ///; /// `this = this*c1*f1`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:328,Availability,error,errors,328,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation:; ///; /// `this = this*c1*f1`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation:; ///; /// `this = this*c1*f1`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:157,Availability,error,errors,157,"////////////////////////////////////////////////////////////////////////////////; /// Multiply this histogram by h1.; ///; /// `this = this*h1`; ///; /// If errors of this are available (TH1::Sumw2), errors are recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:176,Availability,avail,available,176,"////////////////////////////////////////////////////////////////////////////////; /// Multiply this histogram by h1.; ///; /// `this = this*h1`; ///; /// If errors of this are available (TH1::Sumw2), errors are recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:200,Availability,error,errors,200,"////////////////////////////////////////////////////////////////////////////////; /// Multiply this histogram by h1.; ///; /// `this = this*h1`; ///; /// If errors of this are available (TH1::Sumw2), errors are recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:376,Availability,error,errors,376,"////////////////////////////////////////////////////////////////////////////////; /// Multiply this histogram by h1.; ///; /// `this = this*h1`; ///; /// If errors of this are available (TH1::Sumw2), errors are recalculated.; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:200,Availability,error,errors,200,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by multiplication of h1 by h2.; ///; /// `this = (c1*h1)*(c2*h2)`; ///; /// If errors of this are available (TH1::Sumw2), errors are recalculated.; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:219,Availability,avail,available,219,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by multiplication of h1 by h2.; ///; /// `this = (c1*h1)*(c2*h2)`; ///; /// If errors of this are available (TH1::Sumw2), errors are recalculated.; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:243,Availability,error,errors,243,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by multiplication of h1 by h2.; ///; /// `this = (c1*h1)*(c2*h2)`; ///; /// If errors of this are available (TH1::Sumw2), errors are recalculated.; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:426,Availability,error,errors,426,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by multiplication of h1 by h2.; ///; /// `this = (c1*h1)*(c2*h2)`; ///; /// If errors of this are available (TH1::Sumw2), errors are recalculated.; /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:195,Deployability,Update,Update,195,"////////////////////////////////////////////////////////////////////////////////; /// Control routine to paint any kind of histograms.; ///; /// This function is automatically called by TCanvas::Update.; /// (see TH1::Draw for the list of options)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:94,Integrability,rout,routine,94,"////////////////////////////////////////////////////////////////////////////////; /// Control routine to paint any kind of histograms.; ///; /// This function is automatically called by TCanvas::Update.; /// (see TH1::Draw for the list of options)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:592,Availability,error,errors,592,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this histogram; ///; /// #### case 1 xbins=0; ///; /// If newname is blank (default), the current histogram is modified and; /// a pointer to it is returned.; ///; /// If newname is not blank, the current histogram is not modified, and a; /// new histogram is returned which is a Clone of the current histogram; /// with its name set to newname.; ///; /// The parameter ngroup indicates how many bins of this have to be merged; /// into one bin of the result.; ///; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; /// h1->Rebin(5); //merges five bins in one in h1; /// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; /// // merging 5 bins of h1 in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned histogram is reduced; /// to the upper edge of the last bin that can make a complete; /// group. The remaining bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// #### case 2 xbins!=0; ///; /// A new histogram is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created histogram.; /// The array xbins must contain ngroup+1 elements that represent the low-edges; /// of the bins.; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// NOTE: The bin edges specified in xbins should correspond to bin edges; /// in the original histogram. If a bin edge in the new histogram is; /// in the middle of a bin in the original histogram, all entries i",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:657,Availability,error,errors,657,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this histogram; ///; /// #### case 1 xbins=0; ///; /// If newname is blank (default), the current histogram is modified and; /// a pointer to it is returned.; ///; /// If newname is not blank, the current histogram is not modified, and a; /// new histogram is returned which is a Clone of the current histogram; /// with its name set to newname.; ///; /// The parameter ngroup indicates how many bins of this have to be merged; /// into one bin of the result.; ///; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; /// h1->Rebin(5); //merges five bins in one in h1; /// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; /// // merging 5 bins of h1 in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned histogram is reduced; /// to the upper edge of the last bin that can make a complete; /// group. The remaining bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// #### case 2 xbins!=0; ///; /// A new histogram is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created histogram.; /// The array xbins must contain ngroup+1 elements that represent the low-edges; /// of the bins.; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// NOTE: The bin edges specified in xbins should correspond to bin edges; /// in the original histogram. If a bin edge in the new histogram is; /// in the middle of a bin in the original histogram, all entries i",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1689,Availability,error,errors,1689,"f this have to be merged; /// into one bin of the result.; ///; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; /// h1->Rebin(5); //merges five bins in one in h1; /// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; /// // merging 5 bins of h1 in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned histogram is reduced; /// to the upper edge of the last bin that can make a complete; /// group. The remaining bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// #### case 2 xbins!=0; ///; /// A new histogram is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created histogram.; /// The array xbins must contain ngroup+1 elements that represent the low-edges; /// of the bins.; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// NOTE: The bin edges specified in xbins should correspond to bin edges; /// in the original histogram. If a bin edge in the new histogram is; /// in the middle of a bin in the original histogram, all entries in; /// the split bin in the original histogram will be transfered to the; /// lower of the two possible bins in the new histogram. This is; /// probably not what you want. A warning message is emitted in this; /// case; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1754,Availability,error,errors,1754,"f this have to be merged; /// into one bin of the result.; ///; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; /// h1->Rebin(5); //merges five bins in one in h1; /// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; /// // merging 5 bins of h1 in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned histogram is reduced; /// to the upper edge of the last bin that can make a complete; /// group. The remaining bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// #### case 2 xbins!=0; ///; /// A new histogram is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created histogram.; /// The array xbins must contain ngroup+1 elements that represent the low-edges; /// of the bins.; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// NOTE: The bin edges specified in xbins should correspond to bin edges; /// in the original histogram. If a bin edge in the new histogram is; /// in the middle of a bin in the original histogram, all entries in; /// the split bin in the original histogram will be transfered to the; /// lower of the two possible bins in the new histogram. This is; /// probably not what you want. A warning message is emitted in this; /// case; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1173,Energy Efficiency,reduce,reduced,1173,"//////////////////////////////////////////////////////////////////; /// Rebin this histogram; ///; /// #### case 1 xbins=0; ///; /// If newname is blank (default), the current histogram is modified and; /// a pointer to it is returned.; ///; /// If newname is not blank, the current histogram is not modified, and a; /// new histogram is returned which is a Clone of the current histogram; /// with its name set to newname.; ///; /// The parameter ngroup indicates how many bins of this have to be merged; /// into one bin of the result.; ///; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; /// h1->Rebin(5); //merges five bins in one in h1; /// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; /// // merging 5 bins of h1 in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned histogram is reduced; /// to the upper edge of the last bin that can make a complete; /// group. The remaining bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// #### case 2 xbins!=0; ///; /// A new histogram is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created histogram.; /// The array xbins must contain ngroup+1 elements that represent the low-edges; /// of the bins.; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// NOTE: The bin edges specified in xbins should correspond to bin edges; /// in the original histogram. If a bin edge in the new histogram is; /// in the middle of a bin in the original histogram, all entries in; /// the sp",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2183,Integrability,message,message,2183,"f this have to be merged; /// into one bin of the result.; ///; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; /// h1->Rebin(5); //merges five bins in one in h1; /// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; /// // merging 5 bins of h1 in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned histogram is reduced; /// to the upper edge of the last bin that can make a complete; /// group. The remaining bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// #### case 2 xbins!=0; ///; /// A new histogram is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created histogram.; /// The array xbins must contain ngroup+1 elements that represent the low-edges; /// of the bins.; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// NOTE: The bin edges specified in xbins should correspond to bin edges; /// in the original histogram. If a bin edge in the new histogram is; /// in the middle of a bin in the original histogram, all entries in; /// the split bin in the original histogram will be transfered to the; /// lower of the two possible bins in the new histogram. This is; /// probably not what you want. A warning message is emitted in this; /// case; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1510,Modifiability,variab,variable,1510,"f this have to be merged; /// into one bin of the result.; ///; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; /// h1->Rebin(5); //merges five bins in one in h1; /// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; /// // merging 5 bins of h1 in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned histogram is reduced; /// to the upper edge of the last bin that can make a complete; /// group. The remaining bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// #### case 2 xbins!=0; ///; /// A new histogram is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created histogram.; /// The array xbins must contain ngroup+1 elements that represent the low-edges; /// of the bins.; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// NOTE: The bin edges specified in xbins should correspond to bin edges; /// in the original histogram. If a bin edge in the new histogram is; /// in the middle of a bin in the original histogram, all entries in; /// the split bin in the original histogram will be transfered to the; /// lower of the two possible bins in the new histogram. This is; /// probably not what you want. A warning message is emitted in this; /// case; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2452,Modifiability,variab,variable,2452,"f this have to be merged; /// into one bin of the result.; ///; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// h1->Rebin(); //merges two bins in one in h1: previous contents of h1 are lost; /// h1->Rebin(5); //merges five bins in one in h1; /// TH1F *hnew = dynamic_cast<TH1F*>(h1->Rebin(5,""hnew"")); // creates a new histogram hnew; /// // merging 5 bins of h1 in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned histogram is reduced; /// to the upper edge of the last bin that can make a complete; /// group. The remaining bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// #### case 2 xbins!=0; ///; /// A new histogram is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created histogram.; /// The array xbins must contain ngroup+1 elements that represent the low-edges; /// of the bins.; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// NOTE: The bin edges specified in xbins should correspond to bin edges; /// in the original histogram. If a bin edge in the new histogram is; /// in the middle of a bin in the original histogram, all entries in; /// the split bin in the original histogram will be transfered to the; /// lower of the two possible bins in the new histogram. This is; /// probably not what you want. A warning message is emitted in this; /// case; ///; /// examples: if h1 is an existing TH1F histogram with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// h1->Rebin(24,""hnew"",xbins); //creates a new variable bin size histogram hnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:49,Modifiability,variab,variable,49,"// in the case that xbins is given (rebinning in variable bins), ngroup is; // the new number of bins and number of grouped bins is not constant.; // when looping for setting the contents for the new histogram we; // need to loop on all bins of original histogram. Then set ngroup=nbins",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12,Modifiability,extend,extend,12,"//reset can extend bit to avoid an axis extension in SetBinContent",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:26,Safety,avoid,avoid,26,"//reset can extend bit to avoid an axis extension in SetBinContent",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Modifiability,variab,variable,3,"// variable bin sizes",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20,Availability,error,errors,20,"//this also changes errors array (if any)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:279,Modifiability,variab,variables,279,"////////////////////////////////////////////////////////////////////////////////; /// finds new limits for the axis so that *point* is within the range and; /// the limits are compatible with the previous ones (see TH1::Merge).; /// new limits are put into *newMin* and *newMax* variables.; /// axis - axis whose limits are to be recomputed; /// point - point that should fit within the new axis limits; /// newMin - new minimum will be stored here; /// newMax - new maximum will be stored here.; /// false if failed (e.g. if the initial axis limits are wrong; /// or the new range is more than \f$ 2^{64} \f$ times the old one).",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:449,Availability,error,errors,449,"////////////////////////////////////////////////////////////////////////////////; /// Histogram is resized along axis such that x is in the axis range.; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The algorithm works for 1-d, 2-D and 3-D histograms.; /// The axis must be extendable before invoking this function.; /// Ex:; ///; /// ~~~ {.cpp}; /// h->GetXaxis()->SetCanExtend(kTRUE);; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:405,Modifiability,extend,extended,405,"////////////////////////////////////////////////////////////////////////////////; /// Histogram is resized along axis such that x is in the axis range.; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The algorithm works for 1-d, 2-D and 3-D histograms.; /// The axis must be extendable before invoking this function.; /// Ex:; ///; /// ~~~ {.cpp}; /// h->GetXaxis()->SetCanExtend(kTRUE);; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:552,Modifiability,extend,extendable,552,"////////////////////////////////////////////////////////////////////////////////; /// Histogram is resized along axis such that x is in the axis range.; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The algorithm works for 1-d, 2-D and 3-D histograms.; /// The axis must be extendable before invoking this function.; /// Ex:; ///; /// ~~~ {.cpp}; /// h->GetXaxis()->SetCanExtend(kTRUE);; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:36,Availability,Error,Errors,36,"//reset only Integral, contents and Errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:193,Availability,error,errors,193,"////////////////////////////////////////////////////////////////////////////////; /// Multiply this histogram by a constant c1.; ///; /// `this = c1*this`; ///; /// Note that both contents and errors (if any) are scaled.; /// This function uses the services of TH1::Add; ///; /// IMPORTANT NOTE: Sumw2() is called automatically when scaling.; /// If you are not interested in the histogram statistics you can call; /// Sumw2(kFALSE) or use the option ""nosw2""; ///; /// One can scale a histogram such that the bins integral is equal to; /// the normalization parameter via TH1::Scale(Double_t norm), where norm; /// is the desired normalization divided by the integral of the histogram.; ///; /// If option contains ""width"" the bin contents and errors are divided; /// by the bin width.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:744,Availability,error,errors,744,"////////////////////////////////////////////////////////////////////////////////; /// Multiply this histogram by a constant c1.; ///; /// `this = c1*this`; ///; /// Note that both contents and errors (if any) are scaled.; /// This function uses the services of TH1::Add; ///; /// IMPORTANT NOTE: Sumw2() is called automatically when scaling.; /// If you are not interested in the histogram statistics you can call; /// Sumw2(kFALSE) or use the option ""nosw2""; ///; /// One can scale a histogram such that the bins integral is equal to; /// the normalization parameter via TH1::Scale(Double_t norm), where norm; /// is the desired normalization divided by the integral of the histogram.; ///; /// If option contains ""width"" the bin contents and errors are divided; /// by the bin width.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:13,Availability,error,errors,13,"// store bin errors when scaling since cannot anymore be computed as sqrt(N)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10,Availability,error,errors,10,"// update errors; // update global histograms statistics",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Deployability,update,update,3,"// update errors; // update global histograms statistics",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:21,Deployability,update,update,21,"// update errors; // update global histograms statistics",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:115,Modifiability,extend,extendable,115,"////////////////////////////////////////////////////////////////////////////////; /// Returns true if all axes are extendable.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:159,Availability,mask,mask,159,"////////////////////////////////////////////////////////////////////////////////; /// Make the histogram axes extendable / not extendable according to the bit mask; /// returns the previous bit mask specifying which axes are extendable",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:194,Availability,mask,mask,194,"////////////////////////////////////////////////////////////////////////////////; /// Make the histogram axes extendable / not extendable according to the bit mask; /// returns the previous bit mask specifying which axes are extendable",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:110,Modifiability,extend,extendable,110,"////////////////////////////////////////////////////////////////////////////////; /// Make the histogram axes extendable / not extendable according to the bit mask; /// returns the previous bit mask specifying which axes are extendable",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:127,Modifiability,extend,extendable,127,"////////////////////////////////////////////////////////////////////////////////; /// Make the histogram axes extendable / not extendable according to the bit mask; /// returns the previous bit mask specifying which axes are extendable",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:225,Modifiability,extend,extendable,225,"////////////////////////////////////////////////////////////////////////////////; /// Make the histogram axes extendable / not extendable according to the bit mask; /// returns the previous bit mask specifying which axes are extendable",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:178,Modifiability,extend,extended,178,"///////////////////////////////////////////////////////////////////////////////; /// Internal function used in TH1::Fill to see which axis is full alphanumeric,; /// i.e. can be extended and is alphanumeric",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:236,Availability,error,errors,236,"////////////////////////////////////////////////////////////////////////////////; /// When this static function is called with `sumw2=kTRUE`, all new; /// histograms will automatically activate the storage; /// of the sum of squares of errors, ie TH1::Sumw2 is automatically called.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:399,Energy Efficiency,Energy,Energy,399,"////////////////////////////////////////////////////////////////////////////////; /// Smooth array xx, translation of Hbook routine `hsmoof.F`.; /// Based on algorithm 353QH twice presented by J. Friedman; /// in [Proc. of the 1974 CERN School of Computing, Norway, 11-24 August, 1974](https://cds.cern.ch/record/186223).; /// See also Section 4.2 in [J. Friedman, Data Analysis Techniques for High Energy Physics](https://www.slac.stanford.edu/pubs/slacreports/reports16/slac-r-176.pdf).",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:124,Integrability,rout,routine,124,"////////////////////////////////////////////////////////////////////////////////; /// Smooth array xx, translation of Hbook routine `hsmoof.F`.; /// Based on algorithm 353QH twice presented by J. Friedman; /// in [Proc. of the 1974 CERN School of Computing, Norway, 11-24 August, 1974](https://cds.cern.ch/record/186223).; /// See also Section 4.2 in [J. Friedman, Data Analysis Techniques for High Energy Physics](https://www.slac.stanford.edu/pubs/slacreports/reports16/slac-r-176.pdf).",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:316,Availability,Error,Errors,316,"////////////////////////////////////////////////////////////////////////////////; /// Smooth bin contents of this histogram.; /// if option contains ""R"" smoothing is applied only to the bins; /// defined in the X axis range (default is to smooth all bins); /// Bin contents are replaced by their smooth values.; /// Errors (if any) are not modified.; /// the smoothing procedure is repeated ntimes (default=1)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:267,Availability,error,errors,267,"////////////////////////////////////////////////////////////////////////////////; /// Print some global quantities for this histogram.; /// \param[in] option; /// - ""base"" is given, number of bins and ranges are also printed; /// - ""range"" is given, bin contents and errors are also printed; /// for all bins in the current range (default 1-->nbins); /// - ""all"" is given, bin contents and errors are also printed; /// for all bins including under and overflows.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:390,Availability,error,errors,390,"////////////////////////////////////////////////////////////////////////////////; /// Print some global quantities for this histogram.; /// \param[in] option; /// - ""base"" is given, number of bins and ranges are also printed; /// - ""range"" is given, bin contents and errors are also printed; /// for all bins in the current range (default 1-->nbins); /// - ""all"" is given, bin contents and errors are also printed; /// for all bins including under and overflows.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:152,Availability,error,errors,152,"////////////////////////////////////////////////////////////////////////////////; /// Using the current bin info, recompute the arrays for contents and errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.; /// \param[in] option; /// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; /// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; /// This option is used; /// - if ""M"" is specified, resets also Minimum and Maximum",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:219,Availability,Error,Errors,219,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.; /// \param[in] option; /// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; /// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; /// This option is used; /// - if ""M"" is specified, resets also Minimum and Maximum",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:290,Availability,Error,Errors,290,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.; /// \param[in] option; /// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; /// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; /// This option is used; /// - if ""M"" is specified, resets also Minimum and Maximum",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:33,Modifiability,extend,extending,33,"// The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:61,Modifiability,Extend,ExtendAxis,61,"// The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:171,Deployability,update,update,171,"// Setting fBuffer[0] = 0 is like resetting the buffer but not deleting it; // But what is the sense of calling BufferEmpty() ? For making the axes ?; // BufferEmpty will update contents that later will be; // reset in calling TH1D::Reset. For this we need to reset the stats afterwards; // It may be needed for computing the axis limits....",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:10,Testability,log,logic,10,"//special logic to support the case where the same object is; //added multiple times in fFunctions.; //This case happens when the same object is added with different; //drawing modes",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:501,Availability,error,error,501,"////////////////////////////////////////////////////////////////////////////////; /// Save the histogram as .csv, .tsv or .txt. In case of any other extension, fall; /// back to TObject::SaveAs, which saves as a .C macro (but with the file name; /// extension specified by the user); ///; /// The Under/Overflow bins are also exported (as first and last lines); /// The fist 2 columns are the lower and upper edges of the bins; /// Column 3 contains the bin contents; /// The last column contains the error in y. If errors are not present, the column; /// is left empty; ///; /// The result can be immediately imported into Excel, gnuplot, Python or whatever,; /// without the needing to install pyroot, etc.; ///; /// \param filename the name of the file where to store the histogram; /// \param option some tuning options; ///; /// The file extension defines the delimiter used:; /// - `.csv` : comma; /// - `.tsv` : tab; /// - `.txt` : space; ///; /// If option = ""title"" a title line is generated. If the y-axis has a title,; /// this title is displayed as column 3 name, otherwise, it shows ""BinContent""",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:516,Availability,error,errors,516,"////////////////////////////////////////////////////////////////////////////////; /// Save the histogram as .csv, .tsv or .txt. In case of any other extension, fall; /// back to TObject::SaveAs, which saves as a .C macro (but with the file name; /// extension specified by the user); ///; /// The Under/Overflow bins are also exported (as first and last lines); /// The fist 2 columns are the lower and upper edges of the bins; /// Column 3 contains the bin contents; /// The last column contains the error in y. If errors are not present, the column; /// is left empty; ///; /// The result can be immediately imported into Excel, gnuplot, Python or whatever,; /// without the needing to install pyroot, etc.; ///; /// \param filename the name of the file where to store the histogram; /// \param option some tuning options; ///; /// The file extension defines the delimiter used:; /// - `.csv` : comma; /// - `.tsv` : tab; /// - `.txt` : space; ///; /// If option = ""title"" a title line is generated. If the y-axis has a title,; /// this title is displayed as column 3 name, otherwise, it shows ""BinContent""",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:688,Deployability,install,install,688,"////////////////////////////////////////////////////////////////////////////////; /// Save the histogram as .csv, .tsv or .txt. In case of any other extension, fall; /// back to TObject::SaveAs, which saves as a .C macro (but with the file name; /// extension specified by the user); ///; /// The Under/Overflow bins are also exported (as first and last lines); /// The fist 2 columns are the lower and upper edges of the bins; /// Column 3 contains the bin contents; /// The last column contains the error in y. If errors are not present, the column; /// is left empty; ///; /// The result can be immediately imported into Excel, gnuplot, Python or whatever,; /// without the needing to install pyroot, etc.; ///; /// \param filename the name of the file where to store the histogram; /// \param option some tuning options; ///; /// The file extension defines the delimiter used:; /// - `.csv` : comma; /// - `.tsv` : tab; /// - `.txt` : space; ///; /// If option = ""title"" a title line is generated. If the y-axis has a title,; /// this title is displayed as column 3 name, otherwise, it shows ""BinContent""",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:12,Availability,error,errors,12,"// save bin errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:225,Availability,error,error,225,"////////////////////////////////////////////////////////////////////////////////; /// For axis = 1,2 or 3 returns the mean value of the histogram along; /// X,Y or Z axis.; ///; /// For axis = 11, 12, 13 returns the standard error of the mean value; /// of the histogram along X, Y or Z axis; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned mean is; /// the (unbinned) one calculated at fill time. If a range has been set, however,; /// the mean is calculated using the bins in range, as described above; THIS; /// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; /// the range. To ensure that the returned mean (and all other statistics) is; /// always that of the binned data stored in the histogram, call TH1::ResetStats.; /// See TH1::GetStats.; ///; /// Return mean value of this histogram along the X axis.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:734,Integrability,depend,depends,734,"////////////////////////////////////////////////////////////////////////////////; /// For axis = 1,2 or 3 returns the mean value of the histogram along; /// X,Y or Z axis.; ///; /// For axis = 11, 12, 13 returns the standard error of the mean value; /// of the histogram along X, Y or Z axis; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned mean is; /// the (unbinned) one calculated at fill time. If a range has been set, however,; /// the mean is calculated using the bins in range, as described above; THIS; /// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; /// the range. To ensure that the returned mean (and all other statistics) is; /// always that of the binned data stored in the histogram, call TH1::ResetStats.; /// See TH1::GetStats.; ///; /// Return mean value of this histogram along the X axis.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:8,Availability,error,error,8,"// mean error = StdDev / sqrt( Neff )",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:102,Availability,error,error,102,"////////////////////////////////////////////////////////////////////////////////; /// Return standard error of mean of this histogram along the X axis.; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// Also note, that although the definition of standard error doesn't include the; /// assumption of normality, many uses of this feature implicitly assume it.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned value is; /// the (unbinned) one calculated at fill time. If a range has been set, however,; /// the value is calculated using the bins in range, as described above; THIS; /// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; /// the range. To ensure that the returned value (and all other statistics) is; /// always that of the binned data stored in the histogram, call TH1::ResetStats.; /// See TH1::GetStats.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:611,Availability,error,error,611,"////////////////////////////////////////////////////////////////////////////////; /// Return standard error of mean of this histogram along the X axis.; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// Also note, that although the definition of standard error doesn't include the; /// assumption of normality, many uses of this feature implicitly assume it.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned value is; /// the (unbinned) one calculated at fill time. If a range has been set, however,; /// the value is calculated using the bins in range, as described above; THIS; /// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; /// the range. To ensure that the returned value (and all other statistics) is; /// always that of the binned data stored in the histogram, call TH1::ResetStats.; /// See TH1::GetStats.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:760,Integrability,depend,depends,760,"////////////////////////////////////////////////////////////////////////////////; /// Return standard error of mean of this histogram along the X axis.; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// Also note, that although the definition of standard error doesn't include the; /// assumption of normality, many uses of this feature implicitly assume it.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned value is; /// the (unbinned) one calculated at fill time. If a range has been set, however,; /// the value is calculated using the bins in range, as described above; THIS; /// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; /// the range. To ensure that the returned value (and all other statistics) is; /// always that of the binned data stored in the histogram, call TH1::ResetStats.; /// See TH1::GetStats.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:362,Availability,error,error,362,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Standard Deviation (Sigma).; /// The Sigma estimate is computed as; /// \f[; /// \sqrt{\frac{1}{N}(\sum(x_i-x_{mean})^2)}; /// \f]; /// For axis = 1,2 or 3 returns the Sigma value of the histogram along; /// X, Y or Z axis; /// For axis = 11, 12 or 13 returns the error of StdDev estimation along; /// X, Y or Z axis for Normal distribution; ///; /// Note that the mean value/sigma is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned standard; /// deviation is the (unbinned) one calculated at fill time. If a range has been; /// set, however, the standard deviation is calculated using the bins in range,; /// as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use; /// TAxis::SetRange(0, 0) to unset the range. To ensure that the returned standard; /// deviation (and all other statistics) is always that of the binned data stored; /// in the histogram, call TH1::ResetStats. See TH1::GetStats.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:880,Integrability,depend,depends,880,"////////////////////////////////////////////////////////////////////////////////; /// Returns the Standard Deviation (Sigma).; /// The Sigma estimate is computed as; /// \f[; /// \sqrt{\frac{1}{N}(\sum(x_i-x_{mean})^2)}; /// \f]; /// For axis = 1,2 or 3 returns the Sigma value of the histogram along; /// X, Y or Z axis; /// For axis = 11, 12 or 13 returns the error of StdDev estimation along; /// X, Y or Z axis for Normal distribution; ///; /// Note that the mean value/sigma is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned standard; /// deviation is the (unbinned) one calculated at fill time. If a range has been; /// set, however, the standard deviation is calculated using the bins in range,; /// as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use; /// TAxis::SetRange(0, 0) to unset the range. To ensure that the returned standard; /// deviation (and all other statistics) is always that of the binned data stored; /// in the histogram, call TH1::ResetStats. See TH1::GetStats.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:32,Availability,error,error,32,"// The right formula for StdDev error depends on 4th momentum (see Kendall-Stuart Vol 1 pag 243); // formula valid for only gaussian distribution ( 4-th momentum = 3 * sigma^4 )",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:38,Integrability,depend,depends,38,"// The right formula for StdDev error depends on 4th momentum (see Kendall-Stuart Vol 1 pag 243); // formula valid for only gaussian distribution ( 4-th momentum = 3 * sigma^4 )",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:93,Availability,error,error,93,"////////////////////////////////////////////////////////////////////////////////; /// Return error of standard deviation estimation for Normal distribution; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// Value returned is standard deviation of sample standard deviation.; /// Note that it is an approximated value which is valid only in the case that the; /// original data distribution is Normal. The correct one would require; /// the 4-th momentum value, which cannot be accurately estimated from a histogram since; /// the x-information for all entries is not kept.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned value is; /// the (unbinned) one calculated at fill time. If a range has been set, however,; /// the value is calculated using the bins in range, as described above; THIS; /// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; /// the range. To ensure that the returned value (and all other statistics) is; /// always that of the binned data stored in the histogram, call TH1::ResetStats.; /// See TH1::GetStats.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:974,Integrability,depend,depends,974,"////////////////////////////////////////////////////////////////////////////////; /// Return error of standard deviation estimation for Normal distribution; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.; ///; /// Value returned is standard deviation of sample standard deviation.; /// Note that it is an approximated value which is valid only in the case that the; /// original data distribution is Normal. The correct one would require; /// the 4-th momentum value, which cannot be accurately estimated from a histogram since; /// the x-information for all entries is not kept.; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. By default, if no range has been set, the returned value is; /// the (unbinned) one calculated at fill time. If a range has been set, however,; /// the value is calculated using the bins in range, as described above; THIS; /// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; /// the range. To ensure that the returned value (and all other statistics) is; /// always that of the binned data stored in the histogram, call TH1::ResetStats.; /// See TH1::GetStats.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:229,Availability,error,error,229,"////////////////////////////////////////////////////////////////////////////////; /// - For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; /// - For axis = 11, 12 or 13 returns the approximate standard error of skewness; /// of the histogram along x, y or z axis; ///; ///Note, that since third and fourth moment are not calculated; ///at the fill time, skewness and its standard error are computed bin by bin; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. See TH1::GetMean and TH1::GetStdDev.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:407,Availability,error,error,407,"////////////////////////////////////////////////////////////////////////////////; /// - For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; /// - For axis = 11, 12 or 13 returns the approximate standard error of skewness; /// of the histogram along x, y or z axis; ///; ///Note, that since third and fourth moment are not calculated; ///at the fill time, skewness and its standard error are computed bin by bin; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. See TH1::GetMean and TH1::GetStdDev.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:482,Integrability,depend,depends,482,"////////////////////////////////////////////////////////////////////////////////; /// - For axis = 1, 2 or 3 returns skewness of the histogram along x, y or z axis.; /// - For axis = 11, 12 or 13 returns the approximate standard error of skewness; /// of the histogram along x, y or z axis; ///; ///Note, that since third and fourth moment are not calculated; ///at the fill time, skewness and its standard error are computed bin by bin; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. See TH1::GetMean and TH1::GetStdDev.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:19,Availability,error,error,19,"//compute standard error of skewness; // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:262,Availability,error,error,262,"////////////////////////////////////////////////////////////////////////////////; /// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; /// Kurtosis(gaussian(0, 1)) = 0.; /// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; /// of the histogram along x, y or z axis; ////; /// Note, that since third and fourth moment are not calculated; /// at the fill time, kurtosis and its standard error are computed bin by bin; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. See TH1::GetMean and TH1::GetStdDev.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:443,Availability,error,error,443,"////////////////////////////////////////////////////////////////////////////////; /// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; /// Kurtosis(gaussian(0, 1)) = 0.; /// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; /// of the histogram along x, y or z axis; ////; /// Note, that since third and fourth moment are not calculated; /// at the fill time, kurtosis and its standard error are computed bin by bin; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. See TH1::GetMean and TH1::GetStdDev.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:518,Integrability,depend,depends,518,"////////////////////////////////////////////////////////////////////////////////; /// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; /// Kurtosis(gaussian(0, 1)) = 0.; /// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; /// of the histogram along x, y or z axis; ////; /// Note, that since third and fourth moment are not calculated; /// at the fill time, kurtosis and its standard error are computed bin by bin; ///; /// IMPORTANT NOTE: The returned value depends on how the histogram statistics; /// are calculated. See TH1::GetMean and TH1::GetStdDev.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:19,Availability,error,error,19,"//compute standard error of skewness; // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:702,Integrability,depend,dependent,702,"////////////////////////////////////////////////////////////////////////////////; /// fill the array stats from the contents of this histogram; /// The array stats must be correctly dimensioned in the calling program.; ///; /// ~~~ {.cpp}; /// stats[0] = sumw; /// stats[1] = sumw2; /// stats[2] = sumwx; /// stats[3] = sumwx2; /// ~~~; ///; /// If no axis-subrange is specified (via TAxis::SetRange), the array stats; /// is simply a copy of the statistics quantities computed at filling time.; /// If a sub-range is specified, the function recomputes these quantities; /// from the bin contents in the current axis range.; ///; /// IMPORTANT NOTE: This means that the returned statistics are context-dependent.; /// If TAxis::kAxisRange, the returned statistics are dependent on the binning;; /// otherwise, they are a copy of the histogram statistics computed at fill time,; /// which are unbinned by default (calling TH1::ResetStats forces them to use; /// binned statistics). You can reset TAxis::kAxisRange using TAxis::SetRange(0, 0).; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:768,Integrability,depend,dependent,768,"////////////////////////////////////////////////////////////////////////////////; /// fill the array stats from the contents of this histogram; /// The array stats must be correctly dimensioned in the calling program.; ///; /// ~~~ {.cpp}; /// stats[0] = sumw; /// stats[1] = sumw2; /// stats[2] = sumwx; /// stats[3] = sumwx2; /// ~~~; ///; /// If no axis-subrange is specified (via TAxis::SetRange), the array stats; /// is simply a copy of the statistics quantities computed at filling time.; /// If a sub-range is specified, the function recomputes these quantities; /// from the bin contents in the current axis range.; ///; /// IMPORTANT NOTE: This means that the returned statistics are context-dependent.; /// If TAxis::kAxisRange, the returned statistics are dependent on the binning;; /// otherwise, they are a copy of the histogram statistics computed at fill time,; /// which are unbinned by default (calling TH1::ResetStats forces them to use; /// binned statistics). You can reset TAxis::kAxisRange using TAxis::SetRange(0, 0).; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:426,Usability,simpl,simply,426,"////////////////////////////////////////////////////////////////////////////////; /// fill the array stats from the contents of this histogram; /// The array stats must be correctly dimensioned in the calling program.; ///; /// ~~~ {.cpp}; /// stats[0] = sumw; /// stats[1] = sumw2; /// stats[2] = sumwx; /// stats[3] = sumwx2; /// ~~~; ///; /// If no axis-subrange is specified (via TAxis::SetRange), the array stats; /// is simply a copy of the statistics quantities computed at filling time.; /// If a sub-range is specified, the function recomputes these quantities; /// from the bin contents in the current axis range.; ///; /// IMPORTANT NOTE: This means that the returned statistics are context-dependent.; /// If TAxis::kAxisRange, the returned statistics are dependent on the binning;; /// otherwise, they are a copy of the histogram statistics computed at fill time,; /// which are unbinned by default (calling TH1::ResetStats forces them to use; /// binned statistics). You can reset TAxis::kAxisRange using TAxis::SetRange(0, 0).; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined range (see TAxis::SetRange). By default the range includes; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:149,Availability,error,error,149,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [binx1,binx2] and its error.; ///; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x.; /// the error is computed using error propagation from the bin errors assuming that; /// all the bins are uncorrelated",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:372,Availability,error,error,372,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [binx1,binx2] and its error.; ///; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x.; /// the error is computed using error propagation from the bin errors assuming that; /// all the bins are uncorrelated",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:396,Availability,error,error,396,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [binx1,binx2] and its error.; ///; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x.; /// the error is computed using error propagation from the bin errors assuming that; /// all the bins are uncorrelated",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:427,Availability,error,errors,427,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [binx1,binx2] and its error.; ///; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x.; /// the error is computed using error propagation from the bin errors assuming that; /// all the bins are uncorrelated",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:140,Availability,error,error,140,"////////////////////////////////////////////////////////////////////////////////; /// Internal function compute integral and optionally the error between the limits; /// specified by the bin number values working for all histograms (1D, 2D and 3D)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:98,Testability,test,test,98,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:201,Testability,test,test,201,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:233,Testability,test,test,233,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:331,Testability,Test,Test,331,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:352,Testability,test,test,352,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:850,Testability,test,test,850,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:933,Testability,test,test,933,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:956,Testability,test,test,956,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1113,Testability,test,test,1113,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using the Anderson-Darling 2 sample test.; ///; /// The AD 2 sample test formula are derived from the paper; /// F.W Scholz, M.A. Stephens ""k-Sample Anderson-Darling Test"".; ///; /// The test is implemented in root in the ROOT::Math::GoFTest class; /// It is the same formula ( (6) in the paper), and also shown in; /// [this preprint](http://arxiv.org/pdf/0804.0380v1.pdf); ///; /// Binned data are considered as un-binned data; /// with identical observation happening in the bin center.; ///; /// \param[in] h2 Pointer to 1D histogram; /// \param[in] option is a character string to specify options; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""T"" Return the normalized A-D test statistic; ///; /// - Note1: Underflow and overflow are not considered in the test; /// - Note2: The test works only for un-weighted histogram (i.e. representing counts); /// - Note3: The histograms are not required to have the same X axis; /// - Note4: The test works only for 1-dimensional histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:132,Testability,test,test,132,"////////////////////////////////////////////////////////////////////////////////; /// Same function as above but returning also the test statistic value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:58,Testability,test,test,58,"// empty the buffer. Probably we could add as an unbinned test",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1660,Energy Efficiency,adapt,adapted,1660,"so valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test; /// in case of histograms with low statistics.; ///; /// NOTE3 (Jan Conrad, Fred James); /// ""The returned value PROB is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1701,Integrability,rout,routine,1701,"so valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test; /// in case of histograms with low statistics.; ///; /// NOTE3 (Jan Conrad, Fred James); /// ""The returned value PROB is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2760,Integrability,depend,depending,2760,"1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test; /// in case of histograms with low statistics.; ///; /// NOTE3 (Jan Conrad, Fred James); /// ""The returned value PROB is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the values of; /// PROB for binned data will be shifted slightly higher than expected,; /// depending on the effects of the binning. For example, when comparing two; /// uniform distributions of 500 events in 100 bins, the values of PROB,; /// instead of being exactly uniformly distributed between zero and one, have; /// a mean value of about 0.56. We can apply a useful; /// rule: As long as the bin width is small compared with any significant; /// physical effect (for example the experimental resolution) then the binning; /// cannot have an important effect. Therefore, we believe that for all; /// practical purposes, the probability value PROB is calculated correctly; /// provided the user is aware that:; ///; /// 1. The value of PROB should not be expected to have exactly the correct; /// distribution for binned data.; /// 2. The user is responsible for seeing to it that the bin widths are; /// small compared with any physical phenomena of interest.; /// 3. The effect of binning (if any) is always to make the value of PROB; /// slightly too bi",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1660,Modifiability,adapt,adapted,1660,"so valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test; /// in case of histograms with low statistics.; ///; /// NOTE3 (Jan Conrad, Fred James); /// ""The returned value PROB is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:2362,Security,access,access,2362,"nks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test; /// in case of histograms with low statistics.; ///; /// NOTE3 (Jan Conrad, Fred James); /// ""The returned value PROB is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the values of; /// PROB for binned data will be shifted slightly higher than expected,; /// depending on the effects of the binning. For example, when comparing two; /// uniform distributions of 500 events in 100 bins, the values of PROB,; /// instead of being exactly uniformly distributed between zero and one, have; /// a mean value of about 0.56. We can apply a useful; /// rule: As long as the bin width is small compared with any significant; /// physical effect (for example the experimental resolution) then the binning; /// cannot have an important effect. Therefore, we believe that for all; /// practical purposes, the probability value PROB is calculated correctly; /// provided the user is aware that:; ///; /// 1. The value of PROB should not be expected t",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:98,Testability,test,test,98,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using Kolmogorov test.; /// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; /// and not for binned data as in the case of the histogram (see NOTE 3 below).; /// So, before using this method blindly, read the NOTE 3.; ///; /// Default: Ignore under- and overflow bins in comparison; ///; /// \param[in] h2 histogram; /// \param[in] option is a character string to specify options; /// - ""U"" include Underflows in test (also for 2-dim); /// - ""O"" include Overflows (also valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test;",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:182,Testability,test,test,182,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using Kolmogorov test.; /// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; /// and not for binned data as in the case of the histogram (see NOTE 3 below).; /// So, before using this method blindly, read the NOTE 3.; ///; /// Default: Ignore under- and overflow bins in comparison; ///; /// \param[in] h2 histogram; /// \param[in] option is a character string to specify options; /// - ""U"" include Underflows in test (also for 2-dim); /// - ""O"" include Overflows (also valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test;",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:227,Testability,test,test,227,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using Kolmogorov test.; /// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; /// and not for binned data as in the case of the histogram (see NOTE 3 below).; /// So, before using this method blindly, read the NOTE 3.; ///; /// Default: Ignore under- and overflow bins in comparison; ///; /// \param[in] h2 histogram; /// \param[in] option is a character string to specify options; /// - ""U"" include Underflows in test (also for 2-dim); /// - ""O"" include Overflows (also valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test;",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:617,Testability,test,test,617,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// this histogram and h2, using Kolmogorov test.; /// Note that the KolmogorovTest (KS) test should in theory be used only for unbinned data; /// and not for binned data as in the case of the histogram (see NOTE 3 below).; /// So, before using this method blindly, read the NOTE 3.; ///; /// Default: Ignore under- and overflow bins in comparison; ///; /// \param[in] h2 histogram; /// \param[in] option is a character string to specify options; /// - ""U"" include Underflows in test (also for 2-dim); /// - ""O"" include Overflows (also valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test;",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1593,Testability,test,test,1593,"so valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test; /// in case of histograms with low statistics.; ///; /// NOTE3 (Jan Conrad, Fred James); /// ""The returned value PROB is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1773,Testability,test,test,1773,"so valid for 2-dim); /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; /// - ""X"" Run the pseudo experiments post-processor with the following procedure:; /// make pseudoexperiments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test; /// in case of histograms with low statistics.; ///; /// NOTE3 (Jan Conrad, Fred James); /// ""The returned value PROB is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1948,Testability,test,test,1948,"eriments based on random values from the parent distribution,; /// compare the KS distance of the pseudoexperiment to the parent; /// distribution, and count all the KS values above the value; /// obtained from the original data to Monte Carlo distribution.; /// The number of pseudo-experiments nEXPT is by default 1000, and; /// it can be changed by specifying the option as ""X=number"",; /// for example ""X=10000"" for 10000 toys.; /// The function returns the probability.; /// (thanks to Ben Kilminster to submit this procedure). Note that; /// this option ""X"" is much slower.; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF; ///; /// NOTE1; /// A good description of the Kolmogorov test can be seen at:; /// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; ///; /// NOTE2; /// see also alternative function TH1::Chi2Test; /// The Kolmogorov test is assumed to give better results than Chi2Test; /// in case of histograms with low statistics.; ///; /// NOTE3 (Jan Conrad, Fred James); /// ""The returned value PROB is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the values of; /// PROB for binned data will be shifted slightly higher than expected,; /// depending on the effects of the binning. For example, when comparing two; /// uniform distributions of 500 events in 100 bins, the values of PROB,; /// instead of being exactly uniformly distrib",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3931,Testability,test,test,3931," is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the values of; /// PROB for binned data will be shifted slightly higher than expected,; /// depending on the effects of the binning. For example, when comparing two; /// uniform distributions of 500 events in 100 bins, the values of PROB,; /// instead of being exactly uniformly distributed between zero and one, have; /// a mean value of about 0.56. We can apply a useful; /// rule: As long as the bin width is small compared with any significant; /// physical effect (for example the experimental resolution) then the binning; /// cannot have an important effect. Therefore, we believe that for all; /// practical purposes, the probability value PROB is calculated correctly; /// provided the user is aware that:; ///; /// 1. The value of PROB should not be expected to have exactly the correct; /// distribution for binned data.; /// 2. The user is responsible for seeing to it that the bin widths are; /// small compared with any physical phenomena of interest.; /// 3. The effect of binning (if any) is always to make the value of PROB; /// slightly too big. That is, setting an acceptance criterion of (PROB>0.05; /// will assure that at most 5% of truly compatible histograms are rejected,; /// and usually somewhat less.""; ///; /// Note also that for GoF test of unbinned data ROOT provides also the class; /// ROOT::Math::GoFTest. The class has also method for doing one sample tests; /// (i.e. comparing the data with a given distribution).",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:4055,Testability,test,tests,4055," is calculated such that it will be; /// uniformly distributed between zero and one for compatible histograms,; /// provided the data are not binned (or the number of bins is very large; /// compared with the number of events). Users who have access to unbinned; /// data and wish exact confidence levels should therefore not put their data; /// into histograms, but should call directly TMath::KolmogorovTest. On; /// the other hand, since TH1 is a convenient way of collecting data and; /// saving space, this function has been provided. However, the values of; /// PROB for binned data will be shifted slightly higher than expected,; /// depending on the effects of the binning. For example, when comparing two; /// uniform distributions of 500 events in 100 bins, the values of PROB,; /// instead of being exactly uniformly distributed between zero and one, have; /// a mean value of about 0.56. We can apply a useful; /// rule: As long as the bin width is small compared with any significant; /// physical effect (for example the experimental resolution) then the binning; /// cannot have an important effect. Therefore, we believe that for all; /// practical purposes, the probability value PROB is calculated correctly; /// provided the user is aware that:; ///; /// 1. The value of PROB should not be expected to have exactly the correct; /// distribution for binned data.; /// 2. The user is responsible for seeing to it that the bin widths are; /// small compared with any physical phenomena of interest.; /// 3. The effect of binning (if any) is always to make the value of PROB; /// slightly too big. That is, setting an acceptance criterion of (PROB>0.05; /// will assure that at most 5% of truly compatible histograms are rejected,; /// and usually somewhat less.""; ///; /// Note also that for GoF test of unbinned data ROOT provides also the class; /// ROOT::Math::GoFTest. The class has also method for doing one sample tests; /// (i.e. comparing the data with a given distribution).",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:58,Testability,test,test,58,"// empty the buffer. Probably we could add as an unbinned test",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:54,Availability,error,errors,54,"// calculate the effective entries.; // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:42,Testability,Test,Test,42,"// Find largest difference for Kolmogorov Test",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:30,Availability,error,errors,30,"// case h1 is exact (has zero errors)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:20,Availability,error,errors,20,"// case h2 has zero errors",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:354,Availability,error,errors,354,"// X option. Run Pseudo-experiments to determine NULL distribution of the; // KS distance. We can find the probability from the number of pseudo-experiment that have a; // KS distance larger than the one opbserved in the data.; // We use the histogram with the largest statistics as a parent distribution for the NULL.; // Note if one histogram has zero errors is considered as a function. In that case we use it; // as parent distribution for the toys.; //",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:18,Availability,error,error,18,"// This numerical error condition should never occur:",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:175,Testability,log,log,175,"////////////////////////////////////////////////////////////////////////////////; /// Return the value of contour number ""level"" in Pad coordinates.; /// ie: if the Pad is in log scale along Z it returns le log of the contour level; /// value. See GetContour to return the array of all contour levels",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:207,Testability,log,log,207,"////////////////////////////////////////////////////////////////////////////////; /// Return the value of contour number ""level"" in Pad coordinates.; /// ie: if the Pad is in log scale along Z it returns le log of the contour level; /// value. See GetContour to return the array of all contour levels",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:47,Testability,log,log,47,"// In case of user defined contours and Pad in log scale along Z,; // fContour.fArray doesn't contain the log of the contour whereas it does; // in case of equidistant contours.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:106,Testability,log,log,106,"// In case of user defined contours and Pad in log scale along Z,; // fContour.fArray doesn't contain the log of the contour whereas it does; // in case of equidistant contours.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:568,Energy Efficiency,efficient,efficient,568,"///////////////////////////////////////////////////////////////////////////////; /// Retrieve the minimum and maximum values in the histogram; ///; /// This will not return a cached value and will always search the; /// histogram for the min and max values. The user can condition whether; /// or not to call this with the GetMinimumStored() and GetMaximumStored(); /// methods. If the cache is empty, then the value will be -1111. Users; /// can then use the SetMinimum() or SetMaximum() methods to cache the results.; /// For example, the following recipe will make efficient use of this method; /// and the cached minimum and maximum values.; //; /// \code{.cpp}; /// Double_t currentMin = pHist->GetMinimumStored();; /// Double_t currentMax = pHist->GetMaximumStored();; /// if ((currentMin == -1111) || (currentMax == -1111)) {; /// pHist->GetMinimumAndMaximum(currentMin, currentMax);; /// pHist->SetMinimum(currentMin);; /// pHist->SetMaximum(currentMax);; /// }; /// \endcode; ///; /// \param min reference to variable that will hold found minimum value; /// \param max reference to variable that will hold found maximum value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1018,Modifiability,variab,variable,1018,"///////////////////////////////////////////////////////////////////////////////; /// Retrieve the minimum and maximum values in the histogram; ///; /// This will not return a cached value and will always search the; /// histogram for the min and max values. The user can condition whether; /// or not to call this with the GetMinimumStored() and GetMaximumStored(); /// methods. If the cache is empty, then the value will be -1111. Users; /// can then use the SetMinimum() or SetMaximum() methods to cache the results.; /// For example, the following recipe will make efficient use of this method; /// and the cached minimum and maximum values.; //; /// \code{.cpp}; /// Double_t currentMin = pHist->GetMinimumStored();; /// Double_t currentMax = pHist->GetMaximumStored();; /// if ((currentMin == -1111) || (currentMax == -1111)) {; /// pHist->GetMinimumAndMaximum(currentMin, currentMax);; /// pHist->SetMinimum(currentMin);; /// pHist->SetMaximum(currentMax);; /// }; /// \endcode; ///; /// \param min reference to variable that will hold found minimum value; /// \param max reference to variable that will hold found maximum value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:1091,Modifiability,variab,variable,1091,"///////////////////////////////////////////////////////////////////////////////; /// Retrieve the minimum and maximum values in the histogram; ///; /// This will not return a cached value and will always search the; /// histogram for the min and max values. The user can condition whether; /// or not to call this with the GetMinimumStored() and GetMaximumStored(); /// methods. If the cache is empty, then the value will be -1111. Users; /// can then use the SetMinimum() or SetMaximum() methods to cache the results.; /// For example, the following recipe will make efficient use of this method; /// and the cached minimum and maximum values.; //; /// \code{.cpp}; /// Double_t currentMin = pHist->GetMinimumStored();; /// Double_t currentMax = pHist->GetMaximumStored();; /// if ((currentMin == -1111) || (currentMax == -1111)) {; /// pHist->GetMinimumAndMaximum(currentMin, currentMax);; /// pHist->SetMinimum(currentMin);; /// pHist->SetMaximum(currentMax);; /// }; /// \endcode; ///; /// \param min reference to variable that will hold found minimum value; /// \param max reference to variable that will hold found maximum value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:175,Performance,cache,cached,175,"///////////////////////////////////////////////////////////////////////////////; /// Retrieve the minimum and maximum values in the histogram; ///; /// This will not return a cached value and will always search the; /// histogram for the min and max values. The user can condition whether; /// or not to call this with the GetMinimumStored() and GetMaximumStored(); /// methods. If the cache is empty, then the value will be -1111. Users; /// can then use the SetMinimum() or SetMaximum() methods to cache the results.; /// For example, the following recipe will make efficient use of this method; /// and the cached minimum and maximum values.; //; /// \code{.cpp}; /// Double_t currentMin = pHist->GetMinimumStored();; /// Double_t currentMax = pHist->GetMaximumStored();; /// if ((currentMin == -1111) || (currentMax == -1111)) {; /// pHist->GetMinimumAndMaximum(currentMin, currentMax);; /// pHist->SetMinimum(currentMin);; /// pHist->SetMaximum(currentMax);; /// }; /// \endcode; ///; /// \param min reference to variable that will hold found minimum value; /// \param max reference to variable that will hold found maximum value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:386,Performance,cache,cache,386,"///////////////////////////////////////////////////////////////////////////////; /// Retrieve the minimum and maximum values in the histogram; ///; /// This will not return a cached value and will always search the; /// histogram for the min and max values. The user can condition whether; /// or not to call this with the GetMinimumStored() and GetMaximumStored(); /// methods. If the cache is empty, then the value will be -1111. Users; /// can then use the SetMinimum() or SetMaximum() methods to cache the results.; /// For example, the following recipe will make efficient use of this method; /// and the cached minimum and maximum values.; //; /// \code{.cpp}; /// Double_t currentMin = pHist->GetMinimumStored();; /// Double_t currentMax = pHist->GetMaximumStored();; /// if ((currentMin == -1111) || (currentMax == -1111)) {; /// pHist->GetMinimumAndMaximum(currentMin, currentMax);; /// pHist->SetMinimum(currentMin);; /// pHist->SetMaximum(currentMax);; /// }; /// \endcode; ///; /// \param min reference to variable that will hold found minimum value; /// \param max reference to variable that will hold found maximum value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:500,Performance,cache,cache,500,"///////////////////////////////////////////////////////////////////////////////; /// Retrieve the minimum and maximum values in the histogram; ///; /// This will not return a cached value and will always search the; /// histogram for the min and max values. The user can condition whether; /// or not to call this with the GetMinimumStored() and GetMaximumStored(); /// methods. If the cache is empty, then the value will be -1111. Users; /// can then use the SetMinimum() or SetMaximum() methods to cache the results.; /// For example, the following recipe will make efficient use of this method; /// and the cached minimum and maximum values.; //; /// \code{.cpp}; /// Double_t currentMin = pHist->GetMinimumStored();; /// Double_t currentMax = pHist->GetMaximumStored();; /// if ((currentMin == -1111) || (currentMax == -1111)) {; /// pHist->GetMinimumAndMaximum(currentMin, currentMax);; /// pHist->SetMinimum(currentMin);; /// pHist->SetMaximum(currentMax);; /// }; /// \endcode; ///; /// \param min reference to variable that will hold found minimum value; /// \param max reference to variable that will hold found maximum value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:610,Performance,cache,cached,610,"///////////////////////////////////////////////////////////////////////////////; /// Retrieve the minimum and maximum values in the histogram; ///; /// This will not return a cached value and will always search the; /// histogram for the min and max values. The user can condition whether; /// or not to call this with the GetMinimumStored() and GetMaximumStored(); /// methods. If the cache is empty, then the value will be -1111. Users; /// can then use the SetMinimum() or SetMaximum() methods to cache the results.; /// For example, the following recipe will make efficient use of this method; /// and the cached minimum and maximum values.; //; /// \code{.cpp}; /// Double_t currentMin = pHist->GetMinimumStored();; /// Double_t currentMax = pHist->GetMaximumStored();; /// if ((currentMin == -1111) || (currentMax == -1111)) {; /// pHist->GetMinimumAndMaximum(currentMin, currentMax);; /// pHist->SetMinimum(currentMin);; /// pHist->SetMaximum(currentMax);; /// }; /// \endcode; ///; /// \param min reference to variable that will hold found minimum value; /// \param max reference to variable that will hold found maximum value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:207,Availability,error,errors,207,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x axis parameters.; ///; /// The X axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:226,Availability,error,errors,226,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x axis parameters.; ///; /// The X axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:231,Availability,error,errors,231,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x axis parameters with variable bin sizes.; ///; /// The X axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:250,Availability,error,errors,250,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x axis parameters with variable bin sizes.; ///; /// The X axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:118,Modifiability,variab,variable,118,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x axis parameters with variable bin sizes.; ///; /// The X axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:219,Availability,error,errors,219,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x and y axis parameters.; ///; /// The X and Y axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:238,Availability,error,errors,238,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x and y axis parameters.; ///; /// The X and Y axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:243,Availability,error,errors,243,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x and y axis parameters with variable bin sizes.; ///; /// The X and Y axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:262,Availability,error,errors,262,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x and y axis parameters with variable bin sizes.; ///; /// The X and Y axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:124,Modifiability,variab,variable,124,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x and y axis parameters with variable bin sizes.; ///; /// The X and Y axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:225,Availability,error,errors,225,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x, y and z axis parameters.; ///; /// The X, Y and Z axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:244,Availability,error,errors,244,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x, y and z axis parameters.; ///; /// The X, Y and Z axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:249,Availability,error,errors,249,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x, y and z axis parameters with variable bin sizes.; ///; /// The X, Y and Z axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; /// zBins is supposed to be of length nz+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:268,Availability,error,errors,268,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x, y and z axis parameters with variable bin sizes.; ///; /// The X, Y and Z axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; /// zBins is supposed to be of length nz+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:127,Modifiability,variab,variable,127,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x, y and z axis parameters with variable bin sizes.; ///; /// The X, Y and Z axis parameters are modified.; /// The bins content array is resized; /// if errors (Sumw2) the errors array is resized; /// The previous bin contents are lost; /// To change only the axis limits, see TAxis::SetRange; /// xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; /// zBins is supposed to be of length nz+1",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:98,Availability,error,errors,98,"////////////////////////////////////////////////////////////////////////////////; /// Replace bin errors by values in array error.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:124,Availability,error,error,124,"////////////////////////////////////////////////////////////////////////////////; /// Replace bin errors by values in array error.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:60,Deployability,update,update,60,"// Histograms are named objects in a THashList.; // We must update the hashlist if we change the name; // We protect this operation",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:71,Security,hash,hashlist,71,"// Histograms are named objects in a THashList.; // We must update the hashlist if we change the name; // We protect this operation",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:60,Deployability,update,update,60,"// Histograms are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:71,Security,hash,hashlist,71,"// Histograms are named objects in a THashList.; // We must update the hashlist if we change the name",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:271,Availability,error,error,271,"////////////////////////////////////////////////////////////////////////////////; /// Create structure to store sum of squares of weights.; ///; /// if histogram is already filled, the sum of squares of weights; /// is filled with the existing bin contents; ///; /// The error per bin will be computed as sqrt(sum of squares of weight); /// for each bin.; ///; /// This function is automatically called when the histogram is created; /// if the static function TH1::SetDefaultSumw2 has been called before.; /// If flag = false the structure containing the sum of the square of weights; /// is rest and it will be empty, but it is not deleted (i.e. GetSumw2()->fN = 0)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,Usability,clear,clear,3,"// clear the array if existing - do nothing otherwise",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:102,Availability,error,error,102,"////////////////////////////////////////////////////////////////////////////////; /// Return value of error associated to bin number bin.; ///; /// if the sum of squares of weights has been defined (via Sumw2),; /// this function returns the sqrt(sum of w2).; /// otherwise it returns the sqrt(contents) for this bin.",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:99,Availability,error,error,99,"////////////////////////////////////////////////////////////////////////////////; /// Return lower error associated to bin number bin.; ///; /// The error will depend on the statistic option used will return; /// the binContent - lower interval value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:149,Availability,error,error,149,"////////////////////////////////////////////////////////////////////////////////; /// Return lower error associated to bin number bin.; ///; /// The error will depend on the statistic option used will return; /// the binContent - lower interval value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:160,Integrability,depend,depend,160,"////////////////////////////////////////////////////////////////////////////////; /// Return lower error associated to bin number bin.; ///; /// The error will depend on the statistic option used will return; /// the binContent - lower interval value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:99,Availability,error,error,99,"////////////////////////////////////////////////////////////////////////////////; /// Return upper error associated to bin number bin.; ///; /// The error will depend on the statistic option used will return; /// the binContent - upper interval value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:149,Availability,error,error,149,"////////////////////////////////////////////////////////////////////////////////; /// Return upper error associated to bin number bin.; ///; /// The error will depend on the statistic option used will return; /// the binContent - upper interval value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:160,Integrability,depend,depend,160,"////////////////////////////////////////////////////////////////////////////////; /// Return upper error associated to bin number bin.; ///; /// The error will depend on the statistic option used will return; /// the binContent - upper interval value",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:98,Availability,Error,Error,98,"////////////////////////////////////////////////////////////////////////////////; /// Set the bin Error; /// Note that this resets the bin eror option to be of Normal Type and for the; /// non-empty bin the bin error is set by default to the square root of their content.; /// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); /// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; /// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; ///; /// See convention for numbering bins in TH1::GetBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:211,Availability,error,error,211,"////////////////////////////////////////////////////////////////////////////////; /// Set the bin Error; /// Note that this resets the bin eror option to be of Normal Type and for the; /// non-empty bin the bin error is set by default to the square root of their content.; /// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); /// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; /// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; ///; /// See convention for numbering bins in TH1::GetBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:448,Availability,error,error,448,"////////////////////////////////////////////////////////////////////////////////; /// Set the bin Error; /// Note that this resets the bin eror option to be of Normal Type and for the; /// non-empty bin the bin error is set by default to the square root of their content.; /// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); /// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; /// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; ///; /// See convention for numbering bins in TH1::GetBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:488,Availability,error,error,488,"////////////////////////////////////////////////////////////////////////////////; /// Set the bin Error; /// Note that this resets the bin eror option to be of Normal Type and for the; /// non-empty bin the bin error is set by default to the square root of their content.; /// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); /// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; /// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; ///; /// See convention for numbering bins in TH1::GetBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:564,Availability,error,error,564,"////////////////////////////////////////////////////////////////////////////////; /// Set the bin Error; /// Note that this resets the bin eror option to be of Normal Type and for the; /// non-empty bin the bin error is set by default to the square root of their content.; /// Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent); /// he needs then to provide also the corresponding bin error (using SetBinError) since the bin error; /// will not be recalculated after setting the content and a default error = 0 will be used for those bins.; ///; /// See convention for numbering bins in TH1::GetBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:17,Availability,error,error,17,"// reset the bin error option",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Integrability,Interface,Interface,86,"////////////////////////////////////////////////////////////////////////////////; /// Interface to TSpectrum::Search.; /// The function finds peaks in this histogram where the width is > sigma; /// and the peak maximum greater than threshold*maximum bin content of this.; /// For more details see TSpectrum::Search.; /// Note the difference in the default value for option compared to TSpectrum::Search; /// option="""" by default (instead of ""goff"").",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:383,Availability,Avail,Available,383,"////////////////////////////////////////////////////////////////////////////////; /// For a given transform (first parameter), fills the histogram (second parameter); /// with the transform output data, specified in the third parameter; /// If the 2nd parameter h_output is empty, a new histogram (TH1D or TH2D) is created; /// and the user is responsible for deleting it.; ///; /// Available options:; /// - ""RE"" - real part of the output; /// - ""IM"" - imaginary part of the output; /// - ""MAG"" - magnitude of the output; /// - ""PH"" - phase of the output",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:90,Deployability,update,update,90,"////////////////////////////////////////////////////////////////////////////////; /// Raw update of bin content on internal data structure; /// see convention for numbering bins in TH1::GetBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type char (one byte per channel); /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type char (one byte per channel); /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type short; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type short; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type integer; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type integer; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type long64; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type long64; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type float; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type float; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type double; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:116,Modifiability,variab,variable,116,"////////////////////////////////////////////////////////////////////////////////; /// Create a 1-Dim histogram with variable bins of type double; /// (see TH1::TH1 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1K.cxx:115,Availability,error,error,115,"////////////////////////////////////////////////////////////////////////////////; /// Return content of global bin error.",MatchSource.CODE_COMMENT,hist/hist/src/TH1K.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1K.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1K.cxx:211,Modifiability,variab,variable,211,"////////////////////////////////////////////////////////////////////////////////; /// Save primitive as a C++ statement(s) on output stream out; /// Note the following restrictions in the code generated:; /// - variable bin size not implemented; /// - Objects in list of functions not saved (fits); /// - Contours not saved",MatchSource.CODE_COMMENT,hist/hist/src/TH1K.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1K.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:13,Performance,perform,performing,13,"/// Function performing the actual merge",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:167,Energy Efficiency,power,power-of-,167,"/////////////////////////////////////////////////////////////////////////////////////////; /// Determine final boundaries and number of bins for histograms created in power-of-2; /// autobin mode.; ///; /// Return kTRUE if compatible, updating fNewXaxis accordingly; return kFALSE if something; /// wrong.; ///; /// The histograms are not merge-compatible if; ///; /// 1. have different variable-size bins; /// 2. larger bin size is not an integer multiple of the smaller one; /// 3. the final estimated range is smalle then the bin size; ///",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:387,Modifiability,variab,variable-size,387,"/////////////////////////////////////////////////////////////////////////////////////////; /// Determine final boundaries and number of bins for histograms created in power-of-2; /// autobin mode.; ///; /// Return kTRUE if compatible, updating fNewXaxis accordingly; return kFALSE if something; /// wrong.; ///; /// The histograms are not merge-compatible if; ///; /// 1. have different variable-size bins; /// 2. larger bin size is not an integer multiple of the smaller one; /// 3. the final estimated range is smalle then the bin size; ///",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:27,Energy Efficiency,power,power-of-,27,"// They must be created in power-of-2 autobin mode",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:20,Integrability,message,message,20,"// do here to print message only one time",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:70,Modifiability,extend,extended,70,"// Check compatibility of axis that have labels with axis that can be extended",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:64,Modifiability,extend,extended,64,"// it is sufficient to have a consistent label axis that can be extended",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:62,Modifiability,extend,extended,62,"// If histograms have labels but corresponding axes cannot be extended use bin center mode",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:72,Modifiability,extend,extended,72,"// special case for this histogram when is empty; // and axis cannot be extended (because it is the default)",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:141,Modifiability,extend,extendable,141,"// we don't need to check anymore for the case of non empty histograms containing labels.; // If we have some labels set and the axis is not extendable the LabelsMerge function handles; // that case correctly and falls back to a numeric merge",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:35,Safety,avoid,avoid,35,"// Reset fH0, if already added, to avoid double counting",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:10,Modifiability,extend,extend,10,"// we can extend eventually the axis if histogram is capable of doing it; // by using FindBin",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:118,Safety,detect,detected,118,"// do we need to support case when there are bins with labels and bins without them ??; // this case should have been detected before when examining the histograms",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:36,Modifiability,extend,extended,36,"// use find bin in case axis can be extended",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h:7,Energy Efficiency,power,power-of-,7,"// P2 (power-of-2) algorithm: all histogram have limits",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h:57,Safety,avoid,avoid,57,"// The list contains fHClone, so let's clear it first to avoid; // accessing deleted memory later [we 'could' have just removed; // fHClone from the list]",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h:67,Security,access,accessing,67,"// The list contains fHClone, so let's clear it first to avoid; // accessing deleted memory later [we 'could' have just removed; // fHClone from the list]",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h:39,Usability,clear,clear,39,"// The list contains fHClone, so let's clear it first to avoid; // accessing deleted memory later [we 'could' have just removed; // fHClone from the list]",MatchSource.CODE_COMMENT,hist/hist/src/TH1Merger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1404,Modifiability,variab,variable,1404,"entation); \class TH2I; \brief 2-D histogram with an int per channel (see TH1 documentation); \class TH2L; \brief 2-D histogram with a long64 per channel (see TH1 documentation); \class TH2F; \brief 2-D histogram with a float per channel (see TH1 documentation); \class TH2D; \brief 2-D histogram with a double per channel (see TH1 documentation); @}; */; /** \class TH2; Service class for 2-D histogram classes. - TH2C a 2-D histogram with one byte per cell (char). Maximum bin content = 127; - TH2S a 2-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; - TH2I a 2-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax2 ""*""); - TH2L a 2-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax2 ""**""); - TH2F a 2-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax2 ""***""); - TH2D a 2-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax2 ""****""). <sup>; \anchor intmax2 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor llongmax2 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; \anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); </sup>. */; ////////////////////////////////////////////////////////////////////////////////; /// 2-D histogram default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1583,Modifiability,variab,variable,1583,"entation); \class TH2I; \brief 2-D histogram with an int per channel (see TH1 documentation); \class TH2L; \brief 2-D histogram with a long64 per channel (see TH1 documentation); \class TH2F; \brief 2-D histogram with a float per channel (see TH1 documentation); \class TH2D; \brief 2-D histogram with a double per channel (see TH1 documentation); @}; */; /** \class TH2; Service class for 2-D histogram classes. - TH2C a 2-D histogram with one byte per cell (char). Maximum bin content = 127; - TH2S a 2-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; - TH2I a 2-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax2 ""*""); - TH2L a 2-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax2 ""**""); - TH2F a 2-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax2 ""***""); - TH2D a 2-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax2 ""****""). <sup>; \anchor intmax2 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor llongmax2 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor floatmax2 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; \anchor doublemax2 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); </sup>. */; ////////////////////////////////////////////////////////////////////////////////; /// 2-D histogram default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:219,Safety,avoid,avoid,219,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for fix bin size 2-D histograms.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`,; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins along the X axis; /// \param[in] xlow low edge of the X axis first bin; /// \param[in] xup upper edge of the X axis last bin (not included in last bin); /// \param[in] nbinsy number of bins along the Y axis; /// \param[in] ylow low edge of the Y axis first bin; /// \param[in] yup upper edge of the Y axis last bin (not included in last bin)",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X axis) 2-D histograms using an input array; /// of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins along the Y axis; /// \param[in] ylow low edge of the Y axis first bin; /// \param[in] yup upper edge of the Y axis last bin (not included in last bin)",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:237,Safety,avoid,avoid,237,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X axis) 2-D histograms using an input array; /// of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins along the Y axis; /// \param[in] ylow low edge of the Y axis first bin; /// \param[in] yup upper edge of the Y axis last bin (not included in last bin)",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:111,Modifiability,variab,variable,111,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Double_t variable bin size (along Y axis) 2-D histograms.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins along the X axis; /// \param[in] xlow low edge of the X axis first bin; /// \param[in] xup upper edge of the X axis last bin (not included in last bin); /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:205,Safety,avoid,avoid,205,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Double_t variable bin size (along Y axis) 2-D histograms.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins along the X axis; /// \param[in] xlow low edge of the X axis first bin; /// \param[in] xup upper edge of the X axis last bin (not included in last bin); /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:111,Modifiability,variab,variable,111,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Double_t variable bin size 2-D histograms.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:190,Safety,avoid,avoid,190,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Double_t variable bin size 2-D histograms.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X and Y axis) 2-D histograms using input; /// arrays of type float.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type float and size nbinsy+1",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:240,Safety,avoid,avoid,240,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X and Y axis) 2-D histograms using input; /// arrays of type float.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type float and size nbinsy+1",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:74,Modifiability,extend,extended,74,"// skip computation of the statistics along axis that have labels (can be extended and are alphanumeric)",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:70,Availability,mask,mask,70,"// skip statistics along x axis, for only one axis no need to use bit mask from GetAxisLabelStatus",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:410,Deployability,integrat,integrated,410,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in function fname.; ///; /// @param fname : Function name used for filling the histogram; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used to sample; ///; /// The distribution contained in the function fname (TF2) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated; ///; /// One can also call TF2::GetRandom2 to get a random variate from a function.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:410,Integrability,integrat,integrated,410,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in function fname.; ///; /// @param fname : Function name used for filling the histogram; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used to sample; ///; /// The distribution contained in the function fname (TF2) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated; ///; /// One can also call TF2::GetRandom2 to get a random variate from a function.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate temporary space to store the integral and compute integral",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:408,Deployability,integrat,integrated,408,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in histogram h.; ///; /// @param h : Histogram pointer used for sampling random number; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used for sampling; ///; /// The distribution contained in the histogram h (TH2) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:408,Integrability,integrat,integrated,408,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in histogram h.; ///; /// @param h : Histogram pointer used for sampling random number; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used for sampling; ///; /// The distribution contained in the histogram h (TH2) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:2567,Security,access,access,2567,"result of the fit; /// - ""R"" means fit the function in the specified function range; /// - ""G2"" merge 2 consecutive bins along X; /// - ""G3"" merge 3 consecutive bins along X; /// - ""G4"" merge 4 consecutive bins along X; /// - ""G5"" merge 5 consecutive bins along X; /// - ""S"" sliding merge: merge n consecutive bins along X accordingly to what Gn is given.; /// It makes sense when used together with a Gn option; ///; /// The generated histograms are returned by adding them to arr, if arr is not NULL.; /// arr's SetOwner() is called, to signal that it is the user's responsibility to; /// delete the histograms, possibly by deleting the array.; /// ~~~ {.cpp}; /// TObjArray aSlices;; /// h2->FitSlicesX(func, 0, -1, 0, ""QNR"", &aSlices);; /// ~~~; /// will already delete the histograms once aSlice goes out of scope. aSlices will; /// contain the histogram for the i-th parameter of the fit function at aSlices[i];; /// aSlices[n] (n being the number of parameters) contains the chi2 distribution of; /// the fits.; ///; /// If arr is NULL, the generated histograms are added to the list of objects; /// in the current directory. It is the user's responsibility to delete; /// these histograms.; ///; /// Example: Assume a 2-d histogram h2; /// ~~~ {.cpp}; /// Root > h2->FitSlicesX(); produces 4 TH1D histograms; /// with h2_0 containing parameter 0(Constant) for a Gaus fit; /// of each bin in Y projected along X; /// with h2_1 containing parameter 1(Mean) for a gaus fit; /// with h2_2 containing parameter 2(StdDev) for a gaus fit; /// with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; ///; /// Root > h2->FitSlicesX(0,15,22,10);; /// same as above, but only for bins 15 to 22 along Y; /// and only for bins in Y for which the corresponding projection; /// along X has more than cut bins filled.; /// ~~~; /// NOTE: To access the generated histograms in the current directory, do eg:; /// ~~~ {.cpp}; /// TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:2572,Security,access,access,2572,"// - ""G2"" merge 2 consecutive bins along Y; /// - ""G3"" merge 3 consecutive bins along Y; /// - ""G4"" merge 4 consecutive bins along Y; /// - ""G5"" merge 5 consecutive bins along Y; /// - ""S"" sliding merge: merge n consecutive bins along Y accordingly to what Gn is given.; /// It makes sense when used together with a Gn option; ///; /// The generated histograms are returned by adding them to arr, if arr is not NULL.; /// arr's SetOwner() is called, to signal that it is the user's responsibility to; /// delete the histograms, possibly by deleting the array.; /// ~~~ {.cpp}; /// TObjArray aSlices;; /// h2->FitSlicesY(func, 0, -1, 0, ""QNR"", &aSlices);; /// ~~~; /// will already delete the histograms once aSlice goes out of scope. aSlices will; /// contain the histogram for the i-th parameter of the fit function at aSlices[i];; /// aSlices[n] (n being the number of parameters) contains the chi2 distribution of; /// the fits.; ///; /// If arr is NULL, the generated histograms are added to the list of objects; /// in the current directory. It is the user's responsibility to delete; /// these histograms.; ///; /// Example: Assume a 2-d histogram h2; /// ~~~ {.cpp}; /// Root > h2->FitSlicesY(); produces 4 TH1D histograms; /// with h2_0 containing parameter 0(Constant) for a Gaus fit; /// of each bin in X projected along Y; /// with h2_1 containing parameter 1(Mean) for a gaus fit; /// with h2_2 containing parameter 2(StdDev) for a gaus fit; /// with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; ///; /// Root > h2->FitSlicesY(0,15,22,10);; /// same as above, but only for bins 15 to 22 along X; /// and only for bins in X for which the corresponding projection; /// along Y has more than cut bins filled.; /// ~~~; ///; /// NOTE: To access the generated histograms in the current directory, do eg:; /// ~~~ {.cpp}; /// TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");; /// ~~~; ///; /// A complete example of this function is given in tutorial:fitslicesy.C.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:491,Usability,simpl,simply,491,"////////////////////////////////////////////////////////////////////////////////; /// Fill the array stats from the contents of this histogram; /// The array stats must be correctly dimensioned in the calling program.; /// ~~~ {.cpp}; /// stats[0] = sumw; /// stats[1] = sumw2; /// stats[2] = sumwx; /// stats[3] = sumwx2; /// stats[4] = sumwy; /// stats[5] = sumwy2; /// stats[6] = sumwxy; /// ~~~; ///; /// If no axis-subranges are specified (via TAxis::SetRange), the array stats; /// is simply a copy of the statistics quantities computed at filling time.; /// If sub-ranges are specified, the function recomputes these quantities; /// from the bin contents in the current axis ranges.; ///; /// Note that the mean value/StdDev is computed using the bins in the currently; /// defined ranges (see TAxis::SetRange). By default the ranges include; /// all bins from 1 to nbins included, excluding underflows and overflows.; /// To force the underflows and overflows in the computation, one must; /// call the static function TH1::StatOverflows(kTRUE) before filling; /// the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:3,Safety,avoid,avoid,3,"// avoid some extra multiplications at the expense of some clarity",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:224,Availability,error,error,224,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; /// for a 2-D histogram. Calculates also the integral error using error propagation; /// from the bin errors assuming that all the bins are uncorrelated.; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x and in y.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:236,Availability,error,error,236,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; /// for a 2-D histogram. Calculates also the integral error using error propagation; /// from the bin errors assuming that all the bins are uncorrelated.; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x and in y.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:272,Availability,error,errors,272,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; /// for a 2-D histogram. Calculates also the integral error using error propagation; /// from the bin errors assuming that all the bins are uncorrelated.; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x and in y.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1008,Energy Efficiency,adapt,adapted,1008,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// - ""U"" include Underflows in test; /// - ""O"" include Overflows; /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in 2D the order for generating the pseudo-CDF is; /// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; /// other from the y axis and the maximum distance is the average of the two maximum; /// distances obtained.; ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1049,Integrability,rout,routine,1049,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// - ""U"" include Underflows in test; /// - ""O"" include Overflows; /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in 2D the order for generating the pseudo-CDF is; /// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; /// other from the y axis and the maximum distance is the average of the two maximum; /// distances obtained.; ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1008,Modifiability,adapt,adapted,1008,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// - ""U"" include Underflows in test; /// - ""O"" include Overflows; /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in 2D the order for generating the pseudo-CDF is; /// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; /// other from the y axis and the maximum distance is the average of the two maximum; /// distances obtained.; ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:98,Testability,test,test,98,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// - ""U"" include Underflows in test; /// - ""O"" include Overflows; /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in 2D the order for generating the pseudo-CDF is; /// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; /// other from the y axis and the maximum distance is the average of the two maximum; /// distances obtained.; ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:182,Testability,test,test,182,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// - ""U"" include Underflows in test; /// - ""O"" include Overflows; /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in 2D the order for generating the pseudo-CDF is; /// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; /// other from the y axis and the maximum distance is the average of the two maximum; /// distances obtained.; ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:339,Testability,test,test,339,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// - ""U"" include Underflows in test; /// - ""O"" include Overflows; /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in 2D the order for generating the pseudo-CDF is; /// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; /// other from the y axis and the maximum distance is the average of the two maximum; /// distances obtained.; ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:593,Testability,test,test,593,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// - ""U"" include Underflows in test; /// - ""O"" include Overflows; /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in 2D the order for generating the pseudo-CDF is; /// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; /// other from the y axis and the maximum distance is the average of the two maximum; /// distances obtained.; ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:662,Testability,test,test,662,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// - ""U"" include Underflows in test; /// - ""O"" include Overflows; /// - ""N"" include comparison of normalizations; /// - ""D"" Put out a line of ""Debug"" printout; /// - ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in 2D the order for generating the pseudo-CDF is; /// arbitrary, two pairs of pseudo-CDF are used, one starting from the x axis the; /// other from the y axis and the maximum distance is the average of the two maximum; /// distances obtained.; ///; /// Code adapted by Rene Brun from original HBOOK routine HDIFF",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:54,Availability,error,errors,54,"// calculate the effective entries.; // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1)",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:18,Availability,error,error,18,"// This numerical error condition should never occur:",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:221,Availability,error,error,221,"////////////////////////////////////////////////////////////////////////////////; /// Override TH1::Rebin as TH2::RebinX; /// Rebinning in variable binning as for TH1 is not allowed; /// If a non-null pointer is given an error is flagged; /// see RebinX and Rebin2D",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:139,Modifiability,variab,variable,139,"////////////////////////////////////////////////////////////////////////////////; /// Override TH1::Rebin as TH2::RebinX; /// Rebinning in variable binning as for TH1 is not allowed; /// If a non-null pointer is given an error is flagged; /// see RebinX and Rebin2D",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:467,Availability,error,errors,467,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; ///; /// if newname is not blank a new temporary histogram hnew is created.; /// else the current histogram is modified (default); /// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; /// have to me merged into one bin of hnew; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if hpxpy is an existing TH2 histogram with 40 x 40 bins; /// ~~~ {.cpp}; /// hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one in hpxpy; /// // Carefull: previous contents of hpxpy are lost; /// hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; /// TH2 *hnew = hpxpy->RebinY(5,""hnew""); // creates a new histogram hnew; /// // merging 5 bins of h1 along the yaxis in one bin; /// ~~~; ///; /// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; /// along the xaxis/yaxis the top limit(s) of the rebinned histogram; /// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; /// ybin=newybins*nygroup and the corresponding bins are added to; /// the overflow bin.; /// Statistics will be recomputed from the new bin contents.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:532,Availability,error,errors,532,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; ///; /// if newname is not blank a new temporary histogram hnew is created.; /// else the current histogram is modified (default); /// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; /// have to me merged into one bin of hnew; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if hpxpy is an existing TH2 histogram with 40 x 40 bins; /// ~~~ {.cpp}; /// hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one in hpxpy; /// // Carefull: previous contents of hpxpy are lost; /// hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; /// TH2 *hnew = hpxpy->RebinY(5,""hnew""); // creates a new histogram hnew; /// // merging 5 bins of h1 along the yaxis in one bin; /// ~~~; ///; /// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; /// along the xaxis/yaxis the top limit(s) of the rebinned histogram; /// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; /// ybin=newybins*nygroup and the corresponding bins are added to; /// the overflow bin.; /// Statistics will be recomputed from the new bin contents.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:3,Modifiability,variab,variable,3,"// variable bin sizes in x or y, don't treat both cases separately",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:16,Availability,error,errors,16,"// changes also errors array (if any)",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:15,Availability,error,errors,15,"//changes also errors array",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:85,Safety,avoid,avoid,85,"// reset the existing histogram and set always the new binning for the axis; // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 )",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:8,Modifiability,variab,variable,8,"// case variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:8,Modifiability,variab,variable,8,"// case variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:52,Availability,avail,available,52,"// Fill the profile histogram; // no entries/bin is available so can fill only using bin content as weight; // implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:280,Deployability,integrat,integrated,280,"// Fill the profile histogram; // no entries/bin is available so can fill only using bin content as weight; // implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:280,Integrability,integrat,integrated,280,"// Fill the profile histogram; // no entries/bin is available so can fill only using bin content as weight; // implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:22,Deployability,update,update,22,"// the following fill update wrongly the fBinSumw2- need to save it before",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:807,Availability,error,error,807,"////////////////////////////////////////////////////////////////////////////////; /// Project a 2-D histogram into a profile histogram along X.; ///; /// The projection is made from the channels along the Y axis; /// ranging from firstybin to lastybin included.; /// By default, bins 1 to ny are included; /// When all bins are included, the number of entries in the projection; /// is set to the number of entries of the 2-D histogram, otherwise; /// the number of entries is incremented by 1 for all non empty cells.; ///; /// if option ""d"" is specified, the profile is drawn in the current pad.; ///; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; ///; /// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; /// One must create a graphical cut (mouse or C++) and specify the name; /// of the cut between [] in the option.; /// For example, with a TCutG named ""cutg"", one can call:; /// myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; /// To invert the cut, it is enough to put a ""-"" in front of its name:; /// myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; /// It is possible to apply several cuts ("","" means logical AND):; /// myhist->ProfileX("" "",firstybin,lastybin,""[cutg1,cutg2]"");; ///; /// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; /// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; /// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; ///; /// NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile.; ///; /// NOTE that the default under- / overflow behavior differs from what ProjectionX; /// does! Profiles take the bin center into",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1724,Availability,error,error,1724,"D histogram, otherwise; /// the number of entries is incremented by 1 for all non empty cells.; ///; /// if option ""d"" is specified, the profile is drawn in the current pad.; ///; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; ///; /// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; /// One must create a graphical cut (mouse or C++) and specify the name; /// of the cut between [] in the option.; /// For example, with a TCutG named ""cutg"", one can call:; /// myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; /// To invert the cut, it is enough to put a ""-"" in front of its name:; /// myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; /// It is possible to apply several cuts ("","" means logical AND):; /// myhist->ProfileX("" "",firstybin,lastybin,""[cutg1,cutg2]"");; ///; /// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; /// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; /// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; ///; /// NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile.; ///; /// NOTE that the default under- / overflow behavior differs from what ProjectionX; /// does! Profiles take the bin center into account, so here the under- and overflow; /// bins are ignored by default.; ///; /// NOTE that the return profile histogram is computed using the Y bin center values instead of; /// the real Y values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; /// correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770)",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1411,Testability,log,logical,1411," number of entries of the 2-D histogram, otherwise; /// the number of entries is incremented by 1 for all non empty cells.; ///; /// if option ""d"" is specified, the profile is drawn in the current pad.; ///; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; ///; /// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; /// One must create a graphical cut (mouse or C++) and specify the name; /// of the cut between [] in the option.; /// For example, with a TCutG named ""cutg"", one can call:; /// myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; /// To invert the cut, it is enough to put a ""-"" in front of its name:; /// myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; /// It is possible to apply several cuts ("","" means logical AND):; /// myhist->ProfileX("" "",firstybin,lastybin,""[cutg1,cutg2]"");; ///; /// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; /// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; /// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; ///; /// NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile.; ///; /// NOTE that the default under- / overflow behavior differs from what ProjectionX; /// does! Profiles take the bin center into account, so here the under- and overflow; /// bins are ignored by default.; ///; /// NOTE that the return profile histogram is computed using the Y bin center values instead of; /// the real Y values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; /// correct profile histogram that would be obtained when filling it directly with the or",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:813,Availability,error,error,813,"////////////////////////////////////////////////////////////////////////////////; /// Project a 2-D histogram into a profile histogram along Y.; ///; /// The projection is made from the channels along the X axis; /// ranging from firstxbin to lastxbin included.; /// By default, bins 1 to nx are included; /// When all bins are included, the number of entries in the projection; /// is set to the number of entries of the 2-D histogram, otherwise; /// the number of entries is incremented by 1 for all non empty cells.; ///; /// if option ""d"" is specified, the profile is drawn in the current pad.; ///; /// if option ""o"" , the original axis range of the target axis will be; /// kept, but only bins inside the selected range will be filled.; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; /// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; ///; /// One must create a graphical cut (mouse or C++) and specify the name; /// of the cut between [] in the option.; /// For example, with a TCutG named ""cutg"", one can call:; /// myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; /// To invert the cut, it is enough to put a ""-"" in front of its name:; /// myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; /// It is possible to apply several cuts:; /// myhist->ProfileY("" "",firstybin,lastybin,""[cutg1,cutg2]"");; ///; /// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; /// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; /// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; ///; /// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the profile.; ///; /// NOTE that the default under- / overflow behavior differs from what ProjectionX; /// does! Profiles take the bin center into account, so here ",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1706,Availability,error,error,1706," entries of the 2-D histogram, otherwise; /// the number of entries is incremented by 1 for all non empty cells.; ///; /// if option ""d"" is specified, the profile is drawn in the current pad.; ///; /// if option ""o"" , the original axis range of the target axis will be; /// kept, but only bins inside the selected range will be filled.; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; /// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; ///; /// One must create a graphical cut (mouse or C++) and specify the name; /// of the cut between [] in the option.; /// For example, with a TCutG named ""cutg"", one can call:; /// myhist->ProfileY("" "",firstybin,lastybin,""[cutg]"");; /// To invert the cut, it is enough to put a ""-"" in front of its name:; /// myhist->ProfileY("" "",firstybin,lastybin,""[-cutg]"");; /// It is possible to apply several cuts:; /// myhist->ProfileY("" "",firstybin,lastybin,""[cutg1,cutg2]"");; ///; /// NOTE that if a TProfile named ""name"" exists in the current directory or pad with; /// a compatible axis the profile is reset and filled again with the projected contents of the TH2.; /// In the case of axis incompatibility an error is reported and a NULL pointer is returned.; ///; /// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the profile.; ///; /// NOTE that the default under- / overflow behavior differs from what ProjectionX; /// does! Profiles take the bin center into account, so here the under- and overflow; /// bins are ignored by default.; ///; /// NOTE that the return profile histogram is computed using the X bin center values instead of; /// the real X values which are used to fill the 2d histogram. Therefore the obtained profile is just an approximation of the; /// correct profile histogram that would be obtained when filling it directly with the original data (see ROOT-7770)",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,Performance,perform,performing,118,"////////////////////////////////////////////////////////////////////////////////; /// Internal (protected) method for performing projection on the X or Y axis; /// called by ProjectionX or ProjectionY",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:85,Safety,avoid,avoid,85,"// reset the existing histogram and set always the new binning for the axis; // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 )",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:8,Modifiability,variab,variable,8,"// case variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:8,Modifiability,variab,variable,8,"// case variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:172,Deployability,integrat,integrated,172,"// implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins; // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:172,Integrability,integrat,integrated,172,"// implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins; // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:261,Modifiability,extend,extendable,261,"// implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins; // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:295,Modifiability,extend,extendable,295,"// implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins; // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:309,Safety,avoid,avoid,309,"// implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins; // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:23,Availability,error,error,23,"// sum bin content and error if needed",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:41,Availability,error,error,41,"// re-compute the entries; // in case of error calculation (i.e. when Sumw2() is set); // use the effective entries for the entries; // since this is the only way to estimate them",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:6,Safety,avoid,avoid,6,"// to avoid numerical rounding",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:684,Availability,error,errors,684,"////////////////////////////////////////////////////////////////////////////////; /// Project a 2-D histogram into a 1-D histogram along X.; ///; /// The projection is always of the type TH1D.; /// The projection is made from the channels along the Y axis; /// ranging from firstybin to lastybin included.; /// By default, all bins including under- and overflow are included.; /// The number of entries in the projection is estimated from the; /// number of effective entries for all the cells included in the projection.; ///; /// To exclude the underflow bins in Y, use firstybin=1.; /// To exclude the overflow bins in Y, use lastybin=nx.; ///; /// if option ""e"" is specified, the errors are computed.; /// if option ""d"" is specified, the projection is drawn in the current pad.; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; /// One must create a graphical cut (mouse or C++) and specify the name; /// of the cut between [] in the option.; /// For example, with a TCutG named ""cutg"", one can call:; /// myhist->ProjectionX("" "",firstybin,lastybin,""[cutg]"");; /// To invert the cut, it is enough to put a ""-"" in front of its name:; /// myhist->ProjectionX("" "",firstybin,lastybin,""[-cutg]"");; /// It is possible to apply several cuts:; /// myhist->ProjectionX("" "",firstybin,lastybin,""[cutg1,cutg2]"");; ///; /// NOTE that if a TH1D named ""name"" exists in the current directory or pad; /// the histogram is reset and filled again with the projected contents of the TH2.; ///; /// NOTE that the X axis attributes of the TH2 are copied to the X axis of the projection.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:683,Availability,error,errors,683,"////////////////////////////////////////////////////////////////////////////////; /// Project a 2-D histogram into a 1-D histogram along Y.; ///; /// The projection is always of the type TH1D.; /// The projection is made from the channels along the X axis; /// ranging from firstxbin to lastxbin included.; /// By default, all bins including under- and overflow are included.; /// The number of entries in the projection is estimated from the; /// number of effective entries for all the cells included in the projection; ///; /// To exclude the underflow bins in X, use firstxbin=1.; /// To exclude the overflow bins in X, use lastxbin=nx.; ///; /// if option ""e"" is specified, the errors are computed.; /// if option ""d"" is specified, the projection is drawn in the current pad.; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; /// One must create a graphical cut (mouse or C++) and specify the name; /// of the cut between [] in the option.; /// For example, with a TCutG named ""cutg"", one can call:; /// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; /// To invert the cut, it is enough to put a ""-"" in front of its name:; /// myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; /// It is possible to apply several cuts:; /// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg1,cutg2]"");; ///; /// NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; /// a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; /// In the case of axis incompatibility, an error is reported and a NULL pointer is returned.; ///; /// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1719,Availability,error,error,1719,"////////////////////////////////////////////////////////////////////////////////; /// Project a 2-D histogram into a 1-D histogram along Y.; ///; /// The projection is always of the type TH1D.; /// The projection is made from the channels along the X axis; /// ranging from firstxbin to lastxbin included.; /// By default, all bins including under- and overflow are included.; /// The number of entries in the projection is estimated from the; /// number of effective entries for all the cells included in the projection; ///; /// To exclude the underflow bins in X, use firstxbin=1.; /// To exclude the overflow bins in X, use lastxbin=nx.; ///; /// if option ""e"" is specified, the errors are computed.; /// if option ""d"" is specified, the projection is drawn in the current pad.; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; /// One must create a graphical cut (mouse or C++) and specify the name; /// of the cut between [] in the option.; /// For example, with a TCutG named ""cutg"", one can call:; /// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; /// To invert the cut, it is enough to put a ""-"" in front of its name:; /// myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; /// It is possible to apply several cuts:; /// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg1,cutg2]"");; ///; /// NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; /// a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; /// In the case of axis incompatibility, an error is reported and a NULL pointer is returned.; ///; /// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:308,Availability,error,error,308,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X distribution of quantiles in the other variable Y; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal. According to this approximate formula the error on the quantile is; /// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; /// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; /// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; /// a normal distribution.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:454,Availability,error,error,454,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X distribution of quantiles in the other variable Y; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal. According to this approximate formula the error on the quantile is; /// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; /// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; /// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; /// a normal distribution.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:757,Availability,error,error,757,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X distribution of quantiles in the other variable Y; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal. According to this approximate formula the error on the quantile is; /// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; /// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; /// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; /// a normal distribution.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:139,Modifiability,variab,variable,139,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X distribution of quantiles in the other variable Y; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal. According to this approximate formula the error on the quantile is; /// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; /// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; /// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; /// a normal distribution.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:392,Modifiability,variab,variable,392,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X distribution of quantiles in the other variable Y; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal. According to this approximate formula the error on the quantile is; /// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; /// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; /// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; /// a normal distribution.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:705,Modifiability,variab,variable,705,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X distribution of quantiles in the other variable Y; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal. According to this approximate formula the error on the quantile is; /// estimated as sqrt( p (1-p) / ( n * f(q)^2) ), where p is the probability content of the quantile and; /// n is the number of events used to compute the quantile and f(q) is the probability distribution for the; /// other variable evaluated at the obtained quantile. In the error estimation the probability is then assumed to be; /// a normal distribution.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:308,Availability,error,error,308,"////////////////////////////////////////////////////////////////////////////////; /// Compute the Y distribution of quantiles in the other variable X; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:139,Modifiability,variab,variable,139,"////////////////////////////////////////////////////////////////////////////////; /// Compute the Y distribution of quantiles in the other variable X; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:392,Modifiability,variab,variable,392,"////////////////////////////////////////////////////////////////////////////////; /// Compute the Y distribution of quantiles in the other variable X; /// name is the name of the returned histogram; /// prob is the probability content for the quantile (0.5 is the default for the median); /// An approximate error for the quantile is computed assuming that the distribution in; /// the other variable is normal.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:11,Availability,error,error,11,"// compute error using normal approximation; // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; // where f(xq) is the p.d.f value at the quantile xq",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:57,Availability,error,error,57,"// compute error using normal approximation; // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; // where f(xq) is the p.d.f value at the quantile xq",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:11,Availability,error,errors,11,"// set the errors to zero in case of small statistics",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:85,Integrability,Interface,Interface,85,"////////////////////////////////////////////////////////////////////////////////; ///Interface to TSpectrum2::Search; ///the function finds peaks in this histogram where the width is > sigma; ///and the peak maximum greater than threshold*maximum bin content of this.; ///for more details see TSpectrum::Search.; ///note the difference in the default value for option compared to TSpectrum2::Search; ///option="""" by default (instead of ""goff"")",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:522,Availability,Error,Errors,522,"////////////////////////////////////////////////////////////////////////////////; /// Smooth bin contents of this 2-d histogram using kernel algorithms; /// similar to the ones used in the raster graphics community.; /// Bin contents in the active range are replaced by their smooth values.; /// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; /// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; /// normalization accordingly.; /// If Errors are defined via Sumw2, they are also scaled and computed.; /// However, note the resulting errors will be correlated between different-bins, so; /// the errors should not be used blindly to perform any calculation involving several bins,; /// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; ///; /// 3 kernels are proposed k5a, k5b and k3a.; /// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); /// k5b is a bit more stronger in smoothing; /// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; /// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; /// via the option argument.; /// If TAxis::SetRange has been called on the x or/and y axis, only the bins; /// in the specified range are smoothed.; /// In the current implementation if the first argument is not used (default value=1).; ///; /// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:620,Availability,error,errors,620,"////////////////////////////////////////////////////////////////////////////////; /// Smooth bin contents of this 2-d histogram using kernel algorithms; /// similar to the ones used in the raster graphics community.; /// Bin contents in the active range are replaced by their smooth values.; /// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; /// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; /// normalization accordingly.; /// If Errors are defined via Sumw2, they are also scaled and computed.; /// However, note the resulting errors will be correlated between different-bins, so; /// the errors should not be used blindly to perform any calculation involving several bins,; /// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; ///; /// 3 kernels are proposed k5a, k5b and k3a.; /// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); /// k5b is a bit more stronger in smoothing; /// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; /// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; /// via the option argument.; /// If TAxis::SetRange has been called on the x or/and y axis, only the bins; /// in the specified range are smoothed.; /// In the current implementation if the first argument is not used (default value=1).; ///; /// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:682,Availability,error,errors,682,"////////////////////////////////////////////////////////////////////////////////; /// Smooth bin contents of this 2-d histogram using kernel algorithms; /// similar to the ones used in the raster graphics community.; /// Bin contents in the active range are replaced by their smooth values.; /// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; /// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; /// normalization accordingly.; /// If Errors are defined via Sumw2, they are also scaled and computed.; /// However, note the resulting errors will be correlated between different-bins, so; /// the errors should not be used blindly to perform any calculation involving several bins,; /// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; ///; /// 3 kernels are proposed k5a, k5b and k3a.; /// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); /// k5b is a bit more stronger in smoothing; /// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; /// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; /// via the option argument.; /// If TAxis::SetRange has been called on the x or/and y axis, only the bins; /// in the specified range are smoothed.; /// In the current implementation if the first argument is not used (default value=1).; ///; /// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:435,Modifiability,extend,extends,435,"////////////////////////////////////////////////////////////////////////////////; /// Smooth bin contents of this 2-d histogram using kernel algorithms; /// similar to the ones used in the raster graphics community.; /// Bin contents in the active range are replaced by their smooth values.; /// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; /// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; /// normalization accordingly.; /// If Errors are defined via Sumw2, they are also scaled and computed.; /// However, note the resulting errors will be correlated between different-bins, so; /// the errors should not be used blindly to perform any calculation involving several bins,; /// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; ///; /// 3 kernels are proposed k5a, k5b and k3a.; /// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); /// k5b is a bit more stronger in smoothing; /// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; /// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; /// via the option argument.; /// If TAxis::SetRange has been called on the x or/and y axis, only the bins; /// in the specified range are smoothed.; /// In the current implementation if the first argument is not used (default value=1).; ///; /// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:1477,Modifiability,Extend,Extended,1477,"////////////////////////////////////////////////////////////////////////////////; /// Smooth bin contents of this 2-d histogram using kernel algorithms; /// similar to the ones used in the raster graphics community.; /// Bin contents in the active range are replaced by their smooth values.; /// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; /// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; /// normalization accordingly.; /// If Errors are defined via Sumw2, they are also scaled and computed.; /// However, note the resulting errors will be correlated between different-bins, so; /// the errors should not be used blindly to perform any calculation involving several bins,; /// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; ///; /// 3 kernels are proposed k5a, k5b and k3a.; /// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); /// k5b is a bit more stronger in smoothing; /// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; /// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; /// via the option argument.; /// If TAxis::SetRange has been called on the x or/and y axis, only the bins; /// in the specified range are smoothed.; /// In the current implementation if the first argument is not used (default value=1).; ///; /// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:719,Performance,perform,perform,719,"////////////////////////////////////////////////////////////////////////////////; /// Smooth bin contents of this 2-d histogram using kernel algorithms; /// similar to the ones used in the raster graphics community.; /// Bin contents in the active range are replaced by their smooth values.; /// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; /// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; /// normalization accordingly.; /// If Errors are defined via Sumw2, they are also scaled and computed.; /// However, note the resulting errors will be correlated between different-bins, so; /// the errors should not be used blindly to perform any calculation involving several bins,; /// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; ///; /// 3 kernels are proposed k5a, k5b and k3a.; /// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); /// k5b is a bit more stronger in smoothing; /// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; /// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; /// via the option argument.; /// If TAxis::SetRange has been called on the x or/and y axis, only the bins; /// in the specified range are smoothed.; /// In the current implementation if the first argument is not used (default value=1).; ///; /// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:4613,Availability,down,down,4613,"ll the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell and calls `IsInside()`; only on that bins. This reduces considerably the number of bins on which `IsInside()`; is called and therefore speed up by a huge factor the filling compare to the brute force; approach where `IsInside()` is called for all bins. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, `AddBin()` calls the; `AddBinToPartition()` method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the `ChangePartition()` method.; `ChangePartition()` deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times `Fill()` will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When `Fill()`; is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; */; ////////////////////////////////////////////////////////////////////////////////; /// Default Constructor. No boundaries specified.",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:2031,Deployability,update,updated,2031,"d location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by `Fill()`. The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. `TH2Poly` implements a partitioning algorithm to speed up bins' filling; (see the ""Partitioning Algorithm"" section for details).; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of `TList`s.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; `ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. The following very simple macro shows how to build and fill a `TH2Poly`:; ~~~ {.cpp}; {; auto h2p = new TH2Poly();. Double_t x1[] = {0, 5, 6};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, 3};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(4, x2, y2);; h2p->AddBin(5, x3, y3);. h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; }; ~~~. More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoney",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:2039,Deployability,continuous,continuously,2039,"d location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by `Fill()`. The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. `TH2Poly` implements a partitioning algorithm to speed up bins' filling; (see the ""Partitioning Algorithm"" section for details).; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of `TList`s.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; `ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. The following very simple macro shows how to build and fill a `TH2Poly`:; ~~~ {.cpp}; {; auto h2p = new TH2Poly();. Double_t x1[] = {0, 5, 6};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, 3};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(4, x2, y2);; h2p->AddBin(5, x3, y3);. h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; }; ~~~. More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoney",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3962,Energy Efficiency,reduce,reduces,3962," Partitioning Algorithm; The partitioning algorithm forms an essential part of the `TH2Poly`; class. It is implemented to speed up the filling of bins. With the brute force approach, the filling is done in the following way: An; iterator loops over all bins in the `TH2Poly` and invokes the; method `IsInside()` for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is filled. Looping over all the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell and calls `IsInside()`; only on that bins. This reduces considerably the number of bins on which `IsInside()`; is called and therefore speed up by a huge factor the filling compare to the brute force; approach where `IsInside()` is called for all bins. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, `AddBin()` calls the; `AddBinToPartition()` method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the `ChangePartition()` method.; `ChangePartition()` deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times `Fill()` will be called. Although",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:5207,Energy Efficiency,efficient,efficient,5207,"ll the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell and calls `IsInside()`; only on that bins. This reduces considerably the number of bins on which `IsInside()`; is called and therefore speed up by a huge factor the filling compare to the brute force; approach where `IsInside()` is called for all bins. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, `AddBin()` calls the; `AddBinToPartition()` method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the `ChangePartition()` method.; `ChangePartition()` deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times `Fill()` will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When `Fill()`; is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; */; ////////////////////////////////////////////////////////////////////////////////; /// Default Constructor. No boundaries specified.",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:1228,Modifiability,extend,extends,1228," `TH2PolyBin` is a very simple class containing the vertices (stored; as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal; bin as well as several related functions. Essentially, a `TH2Poly` is a TList of `TH2PolyBin` objects; with methods to manipulate them. Bins are defined using one of the `AddBin()` methods. The bin definition; should be done before filling. The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); `. `w` is the weight.; If no weight is specified, it is assumed to be 1. Not all histogram's area need to be binned. Filling an area without bins,; will falls into the overflows. Adding a bin is not retroactive; it doesn't; affect previous fillings. A `Fill()` call, that; was previously ignored due to the lack of a bin at the specified location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by `Fill()`. The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. `TH2Poly` implements a partitioning algorithm to speed up bins' filling; (see the ""Partitioning Algorithm"" section for details).; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of `TList`s.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; `ChangePartition(Int_t, In",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:1456,Modifiability,extend,extend,1456," `TH2PolyBin` objects; with methods to manipulate them. Bins are defined using one of the `AddBin()` methods. The bin definition; should be done before filling. The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); `. `w` is the weight.; If no weight is specified, it is assumed to be 1. Not all histogram's area need to be binned. Filling an area without bins,; will falls into the overflows. Adding a bin is not retroactive; it doesn't; affect previous fillings. A `Fill()` call, that; was previously ignored due to the lack of a bin at the specified location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by `Fill()`. The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. `TH2Poly` implements a partitioning algorithm to speed up bins' filling; (see the ""Partitioning Algorithm"" section for details).; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of `TList`s.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; `ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. ",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:4656,Modifiability,enhance,enhance,4656,"ll the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell and calls `IsInside()`; only on that bins. This reduces considerably the number of bins on which `IsInside()`; is called and therefore speed up by a huge factor the filling compare to the brute force; approach where `IsInside()` is called for all bins. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, `AddBin()` calls the; `AddBinToPartition()` method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the `ChangePartition()` method.; `ChangePartition()` deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times `Fill()` will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When `Fill()`; is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; */; ////////////////////////////////////////////////////////////////////////////////; /// Default Constructor. No boundaries specified.",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:4598,Safety,avoid,avoid,4598,"ll the bin is; very slow. The alternative is to divide the histogram into virtual rectangular regions; called ""cells"". Each cell stores the pointers of the bins intersecting it.; When a coordinate is to be filled, the method finds which cell the coordinate; falls into. Since the cells are rectangular, this can be done very quickly.; It then only loops over the bins associated with that cell and calls `IsInside()`; only on that bins. This reduces considerably the number of bins on which `IsInside()`; is called and therefore speed up by a huge factor the filling compare to the brute force; approach where `IsInside()` is called for all bins. The addition of bins to the appropriate cells is done when the bin is added; to the histogram. To do this, `AddBin()` calls the; `AddBinToPartition()` method.; This method adds the input bin to the partitioning matrix. The number of partition cells per axis can be specified in the constructor.; If it is not specified, the default value of 25 along each axis will be; assigned. This value was chosen because it is small enough to avoid slowing; down AddBin(), while being large enough to enhance Fill() by a considerable; amount. Regardless of how it is initialized at construction time, it can be; changed later with the `ChangePartition()` method.; `ChangePartition()` deletes the; old partition matrix and generates a new one with the specified number of cells; on each axis. The optimum number of partition cells per axis changes with the number of; times `Fill()` will be called. Although partitioning greatly speeds up; filling, it also adds a constant time delay into the code. When `Fill()`; is to be called many times, it is more efficient to divide the histogram into; a large number cells. However, if the histogram is to be filled only a few; times, it is better to divide into a small number of cells.; */; ////////////////////////////////////////////////////////////////////////////////; /// Default Constructor. No boundaries specified.",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:269,Usability,simpl,simple,269,"/** \class TH2Poly; \ingroup Histograms; 2D Histogram with Polygonal Bins. ## Overview; `TH2Poly` is a 2D Histogram class (TH2) allowing to define polygonal; bins of arbitrary shape. Each bin in the `TH2Poly` histogram is a `TH2PolyBin` object.; `TH2PolyBin` is a very simple class containing the vertices (stored; as `TGraph`s or `TMultiGraph`s ) and contents of the polygonal; bin as well as several related functions. Essentially, a `TH2Poly` is a TList of `TH2PolyBin` objects; with methods to manipulate them. Bins are defined using one of the `AddBin()` methods. The bin definition; should be done before filling. The histogram can be filled with `Fill(Double_t x, Double_t y, Double_t w); `. `w` is the weight.; If no weight is specified, it is assumed to be 1. Not all histogram's area need to be binned. Filling an area without bins,; will falls into the overflows. Adding a bin is not retroactive; it doesn't; affect previous fillings. A `Fill()` call, that; was previously ignored due to the lack of a bin at the specified location, is; not reconsidered when that location is binned later. If there are two overlapping bins, the first one in the list will be incremented; by `Fill()`. The histogram may automatically extends its limits if a bin outside the; histogram limits is added. This is done when the default constructor (with no; arguments) is used. It generates a histogram with no limits along the X and Y; axis. Adding bins to it will extend it up to a proper size. `TH2Poly` implements a partitioning algorithm to speed up bins' filling; (see the ""Partitioning Algorithm"" section for details).; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of `TList`s.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The par",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:2478,Usability,simpl,simple,2478,"mplements a partitioning algorithm to speed up bins' filling; (see the ""Partitioning Algorithm"" section for details).; The partitioning algorithm divides the histogram into regions called cells.; The bins that each cell intersects are recorded in an array of `TList`s.; When a coordinate in the histogram is to be filled; the method (quickly) finds; which cell the coordinate belongs. It then only loops over the bins; intersecting that cell to find the bin the input coordinate corresponds to.; The partitioning of the histogram is updated continuously as each bin is added.; The default number of cells on each axis is 25. This number could be set to; another value in the constructor or adjusted later by calling the; `ChangePartition(Int_t, Int_t)` method. The partitioning algorithm is; considerably faster than the brute force algorithm (i.e. checking if each bin; contains the input coordinates), especially if the histogram is to be filled; many times. The following very simple macro shows how to build and fill a `TH2Poly`:; ~~~ {.cpp}; {; auto h2p = new TH2Poly();. Double_t x1[] = {0, 5, 6};; Double_t y1[] = {0, 0, 5};; Double_t x2[] = {0, -1, -1, 0};; Double_t y2[] = {0, 0, -1, 3};; Double_t x3[] = {4, 3, 0, 1, 2.4};; Double_t y3[] = {4, 3.7, 1, 3.7, 2.5};. h2p->AddBin(3, x1, y1);; h2p->AddBin(4, x2, y2);; h2p->AddBin(5, x3, y3);. h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; }; ~~~. More examples can be found in th2polyBoxes.C, th2polyEurope.C, th2polyHoneycomb.C; and th2polyUSA.C. ## Partitioning Algorithm; The partitioning algorithm forms an essential part of the `TH2Poly`; class. It is implemented to speed up the filling of bins. With the brute force approach, the filling is done in the following way: An; iterator loops over all bins in the `TH2Poly` and invokes the; method `IsInside()` for each of them.; This method checks if the input location is in that bin. If the filling; coordinate is inside, the bin is f",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3,Energy Efficiency,allocate,allocate,3,"// allocate arrays",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:166,Performance,optimiz,optimize,166,"// add bins in the fCells partition. We need to add the TH2PolyBin objects; // of the new copied histograms. For this we call AddBinToPartition; // we could probably optimize this by implementing a copy of the partition",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:34,Modifiability,extend,extend,34,"// if structure fsumw2 is created extend it",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:54,Modifiability,extend,extends,54,"// If the bin lies outside histogram boundaries, then extends the boundaries.; // Also changes the partition information accordingly",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this + c1*h1.",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:128,Safety,risk,risks,128,"// statistics can be preserved only in case of positive coefficients; // otherwise with negative c1 (histogram subtraction) one risks to get negative variances",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:84,Integrability,depend,depending,84,"// need to initialize to zero s1 and s2 since; // GetStats fills only used elements depending on dimension and type",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:48,Deployability,Update,UpdateBinContent,48,"// get number of entries now because afterwards UpdateBinContent will change it",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3,Performance,Perform,Perform,3,"// Perform the Add.",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3,Deployability,update,update,3,"// update statistics (do here to avoid changes by SetBinContent)",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:33,Safety,avoid,avoid,33,"// update statistics (do here to avoid changes by SetBinContent)",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:170,Safety,safe,safe,170,"// TH1::Clone relies on ::Copy to implemented by the derived class.; // Until this is implemented, revert to the much slower default version; // (and possibly non-thread safe).",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:86,Usability,Clear,Clears,86,"////////////////////////////////////////////////////////////////////////////////; /// Clears the contents of all bins in the histogram.",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3,Usability,Clear,Clears,3,"// Clears the bin contents",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3,Usability,Clear,Clears,3,"// Clears the statistics",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:3,Usability,Clear,Clears,3,"// Clears the bin contents",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:106,Deployability,update,updated,106,"// need to recompute integral in case SetBinContent was called.; // fTsumw cannot be used since it is not updated in that case",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:107,Availability,error,error,107,"////////////////////////////////////////////////////////////////////////////////; /// Returns the value of error associated to bin number bin.; /// If the sum of squares of weights has been defined (via Sumw2),; /// this function returns the sqrt(sum of w2).; /// otherwise it returns the sqrt(contents) for this bin.; /// Bins are in range [1:nbins] and for bin < 0 in range [-9:-1] it returns errors for overflow bins.; /// See also TH2Poly::GetBinContent",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:395,Availability,error,errors,395,"////////////////////////////////////////////////////////////////////////////////; /// Returns the value of error associated to bin number bin.; /// If the sum of squares of weights has been defined (via Sumw2),; /// this function returns the sqrt(sum of w2).; /// otherwise it returns the sqrt(contents) for this bin.; /// Bins are in range [1:nbins] and for bin < 0 in range [-9:-1] it returns errors for overflow bins.; /// See also TH2Poly::GetBinContent",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:98,Availability,Error,Error,98,"////////////////////////////////////////////////////////////////////////////////; /// Set the bin Error.; /// Re-implementation for TH2Poly given the different bin indexing in the; /// stored squared error array.; /// See also notes in TH1::SetBinError; ///; /// Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:200,Availability,error,error,200,"////////////////////////////////////////////////////////////////////////////////; /// Set the bin Error.; /// Re-implementation for TH2Poly given the different bin indexing in the; /// stored squared error array.; /// See also notes in TH1::SetBinError; ///; /// Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:332,Availability,error,errors,332,"////////////////////////////////////////////////////////////////////////////////; /// Set the bin Error.; /// Re-implementation for TH2Poly given the different bin indexing in the; /// stored squared error array.; /// See also notes in TH1::SetBinError; ///; /// Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:109,Safety,safe,safer,109,"//histogram pointer has by default the histogram name.; //however, in case histogram has no directory, it is safer to add a; //incremental suffix",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:12,Availability,error,errors,12,"// save bin errors",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:117,Safety,avoid,avoid,117,"////////////////////////////////////////////////////////////////////////////////; // RE-implement dummy functions to avoid users calling the; // corresponding implementations in TH1 or TH2; ////////////////////////////////////////////////////////////////////////////////; ////////////////////////////////////////////////////////////////////////////////; /// NOT IMPLEMENTED for TH2Poly",MatchSource.CODE_COMMENT,hist/hist/src/TH2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:1632,Modifiability,variab,variable,1632,"ith a float per channel (see TH1 documentation); \class TH3D; \brief 3-D histogram with a double per channel (see TH1 documentation); @}; */; /** \class TH3; \ingroup Histograms; The 3-D histogram classes derived from the 1-D histogram classes.; All operations are supported (fill, fit).; Drawing is currently restricted to one single option.; A cloud of points is drawn. The number of points is proportional to; cell content. - TH3C a 3-D histogram with one byte per cell (char). Maximum bin content = 127; - TH3S a 3-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; - TH3I a 3-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax3 ""*""); - TH3L a 3-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax3 ""**""); - TH3F a 3-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax3 ""***""); - TH3D a 3-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax3 ""****""). <sup>; \anchor intmax3 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor llongmax3 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; \anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); </sup>; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:1811,Modifiability,variab,variable,1811,"ith a float per channel (see TH1 documentation); \class TH3D; \brief 3-D histogram with a double per channel (see TH1 documentation); @}; */; /** \class TH3; \ingroup Histograms; The 3-D histogram classes derived from the 1-D histogram classes.; All operations are supported (fill, fit).; Drawing is currently restricted to one single option.; A cloud of points is drawn. The number of points is proportional to; cell content. - TH3C a 3-D histogram with one byte per cell (char). Maximum bin content = 127; - TH3S a 3-D histogram with two bytes per cell (short integer). Maximum bin content = 32767; - TH3I a 3-D histogram with four bytes per cell (32 bit integer). Maximum bin content = INT_MAX (\ref intmax3 ""*""); - TH3L a 3-D histogram with eight bytes per cell (64 bit integer). Maximum bin content = LLONG_MAX (\ref llongmax3 ""**""); - TH3F a 3-D histogram with four bytes per cell (float). Maximum precision 7 digits, maximum integer bin content = +/-16777216 (\ref floatmax3 ""***""); - TH3D a 3-D histogram with eight bytes per cell (double). Maximum precision 14 digits, maximum integer bin content = +/-9007199254740992 (\ref doublemax3 ""****""). <sup>; \anchor intmax3 (*) INT_MAX = 2147483647 is the [maximum value for a variable of type int.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor llongmax3 (**) LLONG_MAX = 9223372036854775807 is the [maximum value for a variable of type long64.](https://docs.microsoft.com/en-us/cpp/c-language/cpp-integer-limits)<br>; \anchor floatmax3 (***) 2^24 = 16777216 is the [maximum integer that can be properly represented by a float32 with 23-bit mantissa.](https://stackoverflow.com/a/3793950/7471760)<br>; \anchor doublemax3 (****) 2^53 = 9007199254740992 is the [maximum integer that can be properly represented by a double64 with 52-bit mantissa.](https://stackoverflow.com/a/3793950/7471760); </sup>; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:219,Safety,avoid,avoid,219,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for fix bin size 3-D histograms.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`,; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins along the X axis; /// \param[in] xlow low edge of the X axis first bin; /// \param[in] xup upper edge of the X axis last bin (not included in last bin); /// \param[in] nbinsy number of bins along the Y axis; /// \param[in] ylow low edge of the Y axis first bin; /// \param[in] yup upper edge of the Y axis last bin (not included in last bin); /// \param[in] nbinsz number of bins along the Z axis; /// \param[in] zlow low edge of the Z axis first bin; /// \param[in] zup upper edge of the Z axis last bin (not included in last bin)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; /// arrays of type float.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type float and size nbinsy+1; /// \param[in] nbinsz number of bins; /// \param[in] zbins array of low-edges for each bin.; /// This is an array of type float and size nbinsz+1",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:243,Safety,avoid,avoid,243,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; /// arrays of type float.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type float and size nbinsy+1; /// \param[in] nbinsz number of bins; /// \param[in] zbins array of low-edges for each bin.; /// This is an array of type float and size nbinsz+1",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; /// arrays of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1; /// \param[in] nbinsz number of bins; /// \param[in] zbins array of low-edges for each bin.; /// This is an array of type double and size nbinsz+1",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:244,Safety,avoid,avoid,244,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; /// arrays of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1; /// \param[in] nbinsz number of bins; /// \param[in] zbins array of low-edges for each bin.; /// This is an array of type double and size nbinsz+1",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:74,Modifiability,extend,extended,74,"// skip computation of the statistics along axis that have labels (can be extended and are aphanumeric)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:74,Modifiability,extend,extended,74,"// skip computation of the statistics along axis that have labels (can be extended and are aphanumeric)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:74,Modifiability,extend,extended,74,"// skip computation of the statistics along axis that have labels (can be extended and are aphanumeric)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:74,Modifiability,extend,extended,74,"// skip computation of the statistics along axis that have labels (can be extended and are aphanumeric)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:70,Availability,mask,mask,70,"// skip computation for x axis : for only one axis no need to use bit mask",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:70,Availability,mask,mask,70,"// skip computation for y axis : for only one axis no need to use bit mask",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:70,Availability,mask,mask,70,"// skip computation for z axis : for only one axis no need to use bit mask",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:409,Deployability,integrat,integrated,409,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in function fname.; ///; /// @param fname : Function name used for filling the historam; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used to sample; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated; ///; /// N.B. By dfault this methods approximates the integral of the function in each bin with the; /// function value at the center of the bin, mutiplied by the bin width; ///; /// One can also call TF1::GetRandom to get a random variate from a function.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:409,Integrability,integrat,integrated,409,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in function fname.; ///; /// @param fname : Function name used for filling the historam; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used to sample; ///; /// The distribution contained in the function fname (TF1) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated; ///; /// N.B. By dfault this methods approximates the integral of the function in each bin with the; /// function value at the center of the bin, mutiplied by the bin width; ///; /// One can also call TF1::GetRandom to get a random variate from a function.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate temporary space to store the integral and compute integral",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:407,Deployability,integrat,integrated,407,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in histogram h.; ///; /// @param h : Histogram pointer used for smpling random number; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used for sampling; ///; /// The distribution contained in the histogram h (TH3) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:407,Integrability,integrat,integrated,407,"////////////////////////////////////////////////////////////////////////////////; /// Fill histogram following distribution in histogram h.; ///; /// @param h : Histogram pointer used for smpling random number; /// @param ntimes : number of times the histogram is filled; /// @param rng : (optional) Random number generator used for sampling; ///; /// The distribution contained in the histogram h (TH3) is integrated; /// over the channel contents.; /// It is normalized to 1.; /// Getting one random number implies:; /// - Generating a random number between 0 and 1 (say r1); /// - Look in which bin in the normalized integral r1 corresponds to; /// - Fill histogram channel; /// ntimes random numbers are generated",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:1503,Security,access,access,1503,"////////////////////////////////////////////////////////////////////////////////; /// Project slices along Z in case of a 3-D histogram, then fit each slice; /// with function f1 and make a 2-d histogram for each fit parameter; /// Only cells in the bin range [binminx,binmaxx] and [binminy,binmaxy] are considered.; /// if f1=0, a gaussian is assumed; /// Before invoking this function, one can set a subrange to be fitted along Z; /// via f1->SetRange(zmin,zmax); /// The argument option (default=""QNR"") can be used to change the fit options.; /// ""Q"" means Quiet mode; /// ""N"" means do not show the result of the fit; /// ""R"" means fit the function in the specified function range; ///; /// Note that the generated histograms are added to the list of objects; /// in the current directory. It is the user's responsibility to delete; /// these histograms.; ///; /// Example: Assume a 3-d histogram h3; /// Root > h3->FitSlicesZ(); produces 4 TH2D histograms; /// with h3_0 containing parameter 0(Constant) for a Gaus fit; /// of each cell in X,Y projected along Z; /// with h3_1 containing parameter 1(Mean) for a gaus fit; /// with h3_2 containing parameter 2(StdDev) for a gaus fit; /// with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit; ///; /// Root > h3->Fit(0,15,22,0,0,10);; /// same as above, but only for bins 15 to 22 along X; /// and only for cells in X,Y for which the corresponding projection; /// along Z has more than cut bins filled.; ///; /// NOTE: To access the generated histograms in the current directory, do eg:; /// TH2D *h3_1 = (TH2D*)gDirectory->Get(""h3_1"");",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:44,Modifiability,variab,variable,44,"// return first bin that is used in case of variable bin size axis",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:53,Modifiability,inherit,inherit,53,"// code duplication unavoidable because TH3 does not inherit from TH2",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:224,Availability,error,error,224,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; /// for a 3-D histogram. Calculates also the integral error using error propagation; /// from the bin errors assuming that all the bins are uncorrelated.; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x, y and in z.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:236,Availability,error,error,236,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; /// for a 3-D histogram. Calculates also the integral error using error propagation; /// from the bin errors assuming that all the bins are uncorrelated.; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x, y and in z.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:272,Availability,error,errors,272,"////////////////////////////////////////////////////////////////////////////////; /// Return integral of bin contents in range [binx1,binx2],[biny1,biny2],[binz1,binz2]; /// for a 3-D histogram. Calculates also the integral error using error propagation; /// from the bin errors assuming that all the bins are uncorrelated.; /// By default the integral is computed as the sum of bin contents in the range.; /// if option ""width"" is specified, the integral is the sum of; /// the bin contents multiplied by the bin width in x, y and in z.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:98,Testability,test,test,98,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// ""U"" include Underflows in test; /// ""O"" include Overflows; /// ""N"" include comparison of normalizations; /// ""D"" Put out a line of ""Debug"" printout; /// ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; /// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; /// The average of all the maximum distances obtained is used in the tests.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:182,Testability,test,test,182,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// ""U"" include Underflows in test; /// ""O"" include Overflows; /// ""N"" include comparison of normalizations; /// ""D"" Put out a line of ""Debug"" printout; /// ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; /// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; /// The average of all the maximum distances obtained is used in the tests.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:337,Testability,test,test,337,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// ""U"" include Underflows in test; /// ""O"" include Overflows; /// ""N"" include comparison of normalizations; /// ""D"" Put out a line of ""Debug"" printout; /// ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; /// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; /// The average of all the maximum distances obtained is used in the tests.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:583,Testability,test,test,583,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// ""U"" include Underflows in test; /// ""O"" include Overflows; /// ""N"" include comparison of normalizations; /// ""D"" Put out a line of ""Debug"" printout; /// ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; /// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; /// The average of all the maximum distances obtained is used in the tests.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:652,Testability,test,test,652,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// ""U"" include Underflows in test; /// ""O"" include Overflows; /// ""N"" include comparison of normalizations; /// ""D"" Put out a line of ""Debug"" printout; /// ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; /// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; /// The average of all the maximum distances obtained is used in the tests.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:970,Testability,test,tests,970,"////////////////////////////////////////////////////////////////////////////////; /// Statistical test of compatibility in shape between; /// THIS histogram and h2, using Kolmogorov test.; /// Default: Ignore under- and overflow bins in comparison; ///; /// option is a character string to specify options; /// ""U"" include Underflows in test; /// ""O"" include Overflows; /// ""N"" include comparison of normalizations; /// ""D"" Put out a line of ""Debug"" printout; /// ""M"" Return the Maximum Kolmogorov distance instead of prob; ///; /// The returned function value is the probability of test; /// (much less than one means NOT compatible); ///; /// The KS test uses the distance between the pseudo-CDF's obtained; /// from the histogram. Since in more than 1D the order for generating the pseudo-CDF is; /// arbitrary, we use the pseudo-CDF's obtained from all the possible 6 combinations of the 3 axis.; /// The average of all the maximum distances obtained is used in the tests.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:54,Availability,error,errors,54,"// calculate the effective entries.; // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:18,Availability,error,error,18,"// This numerical error condition should never occur:",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:623,Availability,error,errors,623,"////////////////////////////////////////////////////////////////////////////////; /// Project a 3-D histogram into a 1-D histogram along X.; ///; /// The projection is always of the type TH1D.; /// The projection is made from the cells along the X axis; /// ranging from iymin to iymax and izmin to izmax included.; /// By default, underflow and overflows are included in both the Y and Z axis.; /// By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow in Y will be excluded; /// By setting izmin=1 and izmax=NbinsZ the underflow and/or overflow in Z will be excluded; ///; /// if option ""e"" is specified, the errors are computed.; /// if option ""d"" is specified, the projection is drawn in the current pad.; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// NOTE that if a TH1D named ""name"" exists in the current directory or pad; /// the histogram is reset and filled again with the projected contents of the TH3.; ///; /// implemented using Project3D",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:622,Availability,error,errors,622,"////////////////////////////////////////////////////////////////////////////////; /// Project a 3-D histogram into a 1-D histogram along Y.; ///; /// The projection is always of the type TH1D.; /// The projection is made from the cells along the Y axis; /// ranging from ixmin to ixmax and izmin to izmax included.; /// By default, underflow and overflow are included in both the X and Z axis.; /// By setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow in X will be excluded; /// By setting izmin=1 and izmax=NbinsZ the underflow and/or overflow in Z will be excluded; ///; /// if option ""e"" is specified, the errors are computed.; /// if option ""d"" is specified, the projection is drawn in the current pad.; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// NOTE that if a TH1D named ""name"" exists in the current directory or pad,; /// the histogram is reset and filled again with the projected contents of the TH3.; ///; /// implemented using Project3D",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:680,Availability,error,errors,680,"////////////////////////////////////////////////////////////////////////////////; /// Project a 3-D histogram into a 1-D histogram along Z.; ///; /// The projection is always of the type TH1D.; /// The projection is made from the cells along the Z axis; /// ranging from ixmin to ixmax and iymin to iymax included.; /// By default, bins 1 to nx and 1 to ny are included; /// By default, underflow and overflow are included in both the X and Y axis.; /// By Setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow in X will be excluded; /// By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded; ///; /// if option ""e"" is specified, the errors are computed.; /// if option ""d"" is specified, the projection is drawn in the current pad.; /// if option ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// NOTE that if a TH1D named ""name"" exists in the current directory or pad,; /// the histogram is reset and filled again with the projected contents of the TH3.; ///; /// implemented using Project3D",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Performance,perform,performing,102,"////////////////////////////////////////////////////////////////////////////////; /// internal method performing the projection to 1D histogram; /// called from TH3::Project3D",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:225,Testability,Test,TestBit,225,"// save previous axis range and bits; // Int_t iminOld1 = axis1->GetFirst();; // Int_t imaxOld1 = axis1->GetLast();; // Int_t iminOld2 = axis2->GetFirst();; // Int_t imaxOld2 = axis2->GetLast();; // Bool_t hadRange1 = axis1->TestBit(TAxis::kAxisRange);; // Bool_t hadRange2 = axis2->TestBit(TAxis::kAxisRange);; // need to cast-away constness to set range",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:283,Testability,Test,TestBit,283,"// save previous axis range and bits; // Int_t iminOld1 = axis1->GetFirst();; // Int_t imaxOld1 = axis1->GetLast();; // Int_t iminOld2 = axis2->GetFirst();; // Int_t imaxOld2 = axis2->GetLast();; // Bool_t hadRange1 = axis1->TestBit(TAxis::kAxisRange);; // Bool_t hadRange2 = axis2->TestBit(TAxis::kAxisRange);; // need to cast-away constness to set range",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:44,Testability,Test,TestBit,44,"// // restore original range; // if (axis1->TestBit(TAxis::kAxisRange)) {; // if (hadRange1) const_cast<TAxis*>(axis1)->SetRange(iminOld1,imaxOld1);; // if (axis2->TestBit(TAxis::kAxisRange)) const_cast<TAxis*>(axis2)->SetRange(iminOld2,imaxOld2);; // // we need also to restore the original bits; // draw in current pad",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:164,Testability,Test,TestBit,164,"// // restore original range; // if (axis1->TestBit(TAxis::kAxisRange)) {; // if (hadRange1) const_cast<TAxis*>(axis1)->SetRange(iminOld1,imaxOld1);; // if (axis2->TestBit(TAxis::kAxisRange)) const_cast<TAxis*>(axis2)->SetRange(iminOld2,imaxOld2);; // // we need also to restore the original bits; // draw in current pad",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:103,Performance,perform,performing,103,"////////////////////////////////////////////////////////////////////////////////; /// internal methdod performing the projection to 1D histogram; /// called from other TH3::DoProject1D",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:12,Availability,error,errors,12,"// Activate errors",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:37,Modifiability,extend,extendable,37,"// if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:71,Modifiability,extend,extendable,71,"// if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:85,Safety,avoid,avoid,85,"// if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:26,Deployability,integrat,integrated,26,"// loop on the bins to be integrated (outbin should be called inbin)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:26,Integrability,integrat,integrated,26,"// loop on the bins to be integrated (outbin should be called inbin)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:28,Availability,error,errors,28,"// sum the bin contents and errors if needed",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:14,Availability,error,error,14,"// in case of error calculation (i.e. when Sumw2() is set); // use the effective entries for the entries; // since this is the only way to estimate them",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:6,Safety,avoid,avoid,6,"// to avoid numerical rounding",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Performance,perform,performing,102,"////////////////////////////////////////////////////////////////////////////////; /// internal method performing the projection to a 2D histogram; /// called from TH3::Project3D",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:70,Modifiability,variab,variable,70,"// set bins for mixed axis do not exists - need to set afterwards the variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:12,Availability,error,errors,12,"// Activate errors",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:26,Deployability,integrat,integrated,26,"// loop on the bins to be integrated (outbin should be called inbin)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:26,Integrability,integrat,integrated,26,"// loop on the bins to be integrated (outbin should be called inbin)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:28,Availability,error,errors,28,"// sum the bin contents and errors if needed",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:6,Safety,avoid,avoid,6,"// to avoid numerical rounding",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:1143,Availability,error,errors,1143,"ion parameter, which may contain a combination of the characters x,y,z,e; /// - option = ""x"" return the x projection into a TH1D histogram; /// - option = ""y"" return the y projection into a TH1D histogram; /// - option = ""z"" return the z projection into a TH1D histogram; /// - option = ""xy"" return the x versus y projection into a TH2D histogram; /// - option = ""yx"" return the y versus x projection into a TH2D histogram; /// - option = ""xz"" return the x versus z projection into a TH2D histogram; /// - option = ""zx"" return the z versus x projection into a TH2D histogram; /// - option = ""yz"" return the y versus z projection into a TH2D histogram; /// - option = ""zy"" return the z versus y projection into a TH2D histogram; ///; /// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; ///; /// option = ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// If option contains the string ""e"", errors are computed; ///; /// The projection is made for the selected bins only.; /// To select a bin range along an axis, use TAxis::SetRange, eg; /// h3.GetYaxis()->SetRange(23,56);; ///; /// NOTE 1: The generated histogram is named th3name + option; /// eg if the TH3* h histogram is named ""myhist"", then; /// h->Project3D(""xy""); produces a TH2D histogram named ""myhist_xy""; /// if a histogram of the same type already exists, it is overwritten.; /// The following sequence; /// h->Project3D(""xy"");; /// h->Project3D(""xy2"");; /// will generate two TH2D histograms named ""myhist_xy"" and ""myhist_xy2""; /// A different name can be generated by attaching a string to the option; /// For example h->Project3D(""name_xy"") will generate an histogram with the name: h3dname_name_xy.; ///; /// NOTE 2: If an histogram of the same type and with the same name already exists in current Directory,; /// the histogram is reset and filled again with the projected contents of the TH3.; ///; /// NOTE 3: The number of entries in t",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:135,Integrability,depend,depending,135,"////////////////////////////////////////////////////////////////////////////////; /// Project a 3-d histogram into 1 or 2-d histograms depending on the; /// option parameter, which may contain a combination of the characters x,y,z,e; /// - option = ""x"" return the x projection into a TH1D histogram; /// - option = ""y"" return the y projection into a TH1D histogram; /// - option = ""z"" return the z projection into a TH1D histogram; /// - option = ""xy"" return the x versus y projection into a TH2D histogram; /// - option = ""yx"" return the y versus x projection into a TH2D histogram; /// - option = ""xz"" return the x versus z projection into a TH2D histogram; /// - option = ""zx"" return the z versus x projection into a TH2D histogram; /// - option = ""yz"" return the y versus z projection into a TH2D histogram; /// - option = ""zy"" return the z versus y projection into a TH2D histogram; ///; /// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; ///; /// option = ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// If option contains the string ""e"", errors are computed; ///; /// The projection is made for the selected bins only.; /// To select a bin range along an axis, use TAxis::SetRange, eg; /// h3.GetYaxis()->SetRange(23,56);; ///; /// NOTE 1: The generated histogram is named th3name + option; /// eg if the TH3* h histogram is named ""myhist"", then; /// h->Project3D(""xy""); produces a TH2D histogram named ""myhist_xy""; /// if a histogram of the same type already exists, it is overwritten.; /// The following sequence; /// h->Project3D(""xy"");; /// h->Project3D(""xy2"");; /// will generate two TH2D histograms named ""myhist_xy"" and ""myhist_xy2""; /// A different name can be generated by attaching a string to the option; /// For example h->Project3D(""name_xy"") will generate an histogram with the name: h3dname_name_xy.; ///; /// NOTE 2: If an histogram of the same type and with the same name already",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:2926,Safety,avoid,avoid,2926,"""b"" horizontal; ///; /// option = ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// If option contains the string ""e"", errors are computed; ///; /// The projection is made for the selected bins only.; /// To select a bin range along an axis, use TAxis::SetRange, eg; /// h3.GetYaxis()->SetRange(23,56);; ///; /// NOTE 1: The generated histogram is named th3name + option; /// eg if the TH3* h histogram is named ""myhist"", then; /// h->Project3D(""xy""); produces a TH2D histogram named ""myhist_xy""; /// if a histogram of the same type already exists, it is overwritten.; /// The following sequence; /// h->Project3D(""xy"");; /// h->Project3D(""xy2"");; /// will generate two TH2D histograms named ""myhist_xy"" and ""myhist_xy2""; /// A different name can be generated by attaching a string to the option; /// For example h->Project3D(""name_xy"") will generate an histogram with the name: h3dname_name_xy.; ///; /// NOTE 2: If an histogram of the same type and with the same name already exists in current Directory,; /// the histogram is reset and filled again with the projected contents of the TH3.; ///; /// NOTE 3: The number of entries in the projected histogram is estimated from the number of; /// effective entries for all the cells included in the projection.; ///; /// NOTE 4: underflow/overflow are included by default in the projection; /// To exclude underflow and/or overflow (for both axis in case of a projection to a 1D histogram) use option ""NUF"" and/or ""NOF""; /// With SetRange() you can have all bins except underflow/overflow only if you set the axis bit range as; /// following after having called SetRange: axis->SetRange(1, axis->GetNbins());; ///; /// NOTE 5: If TH1::AddDirectory is set to false, a new histogram is always created and the ownership of the; /// returned pointer is delegated to the user. Be sure in this case to call `delete` on it after it's no longer needed,; /// to avoid memory leaks.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:82,Deployability,update,update,82,"// to use Fill for setting the bin contents of the Profile; // the following fill update wrongly the fBinSumw2- need to save it before",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:70,Modifiability,variab,variable,70,"// set bins for mixed axis do not exists - need to set afterwards the variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:26,Deployability,integrat,integrated,26,"// loop on the bins to be integrated (outbin should be called inbin)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:26,Integrability,integrat,integrated,26,"// loop on the bins to be integrated (outbin should be called inbin)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:22,Deployability,update,update,22,"// the following fill update wrongly the fBinSumw2- need to save it before",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:6,Safety,avoid,avoid,6,"// to avoid numerical rounding",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:1775,Availability,error,error,1775,"// option = ""xy"" return the x versus y projection into a TProfile2D histogram; /// option = ""yx"" return the y versus x projection into a TProfile2D histogram; /// option = ""xz"" return the x versus z projection into a TProfile2D histogram; /// option = ""zx"" return the z versus x projection into a TProfile2D histogram; /// option = ""yz"" return the y versus z projection into a TProfile2D histogram; /// option = ""zy"" return the z versus y projection into a TProfile2D histogram; /// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; ///; /// option = ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// The projection is made for the selected bins only.; /// To select a bin range along an axis, use TAxis::SetRange, eg; /// h3.GetYaxis()->SetRange(23,56);; ///; /// NOTE 1: The generated histogram is named th3name + ""_p"" + option; /// eg if the TH3* h histogram is named ""myhist"", then; /// h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; /// The following sequence; /// h->Project3DProfile(""xy"");; /// h->Project3DProfile(""xy2"");; /// will generate two TProfile2D histograms named ""myhist_pxy"" and ""myhist_pxy2""; /// So, passing additional characters in the option string one can customize the name.; ///; /// NOTE 2: If a profile of the same type already exists with compatible axes,; /// the profile is reset and filled again with the projected contents of the TH3.; /// In the case of axes incompatibility, an error is reported and a NULL pointer is returned.; ///; /// NOTE 3: The number of entries in the projected profile is estimated from the number of; /// effective entries for all the cells included in the projection.; ///; /// NOTE 4: underflow/overflow are by default excluded from the projection; /// (Note that this is a different default behavior compared to the projection to an histogram); /// To include the underflow and/or overflow use option ""UF"" and/or ""OF""",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:140,Integrability,depend,depending,140,"////////////////////////////////////////////////////////////////////////////////; /// Project a 3-d histogram into a 2-d profile histograms depending; /// on the option parameter; /// option may contain a combination of the characters x,y,z; /// option = ""xy"" return the x versus y projection into a TProfile2D histogram; /// option = ""yx"" return the y versus x projection into a TProfile2D histogram; /// option = ""xz"" return the x versus z projection into a TProfile2D histogram; /// option = ""zx"" return the z versus x projection into a TProfile2D histogram; /// option = ""yz"" return the y versus z projection into a TProfile2D histogram; /// option = ""zy"" return the z versus y projection into a TProfile2D histogram; /// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal; ///; /// option = ""o"" original axis range of the target axes will be; /// kept, but only bins inside the selected range will be filled.; ///; /// The projection is made for the selected bins only.; /// To select a bin range along an axis, use TAxis::SetRange, eg; /// h3.GetYaxis()->SetRange(23,56);; ///; /// NOTE 1: The generated histogram is named th3name + ""_p"" + option; /// eg if the TH3* h histogram is named ""myhist"", then; /// h->Project3D(""xy""); produces a TProfile2D histogram named ""myhist_pxy"".; /// The following sequence; /// h->Project3DProfile(""xy"");; /// h->Project3DProfile(""xy2"");; /// will generate two TProfile2D histograms named ""myhist_pxy"" and ""myhist_pxy2""; /// So, passing additional characters in the option string one can customize the name.; ///; /// NOTE 2: If a profile of the same type already exists with compatible axes,; /// the profile is reset and filled again with the projected contents of the TH3.; /// In the case of axes incompatibility, an error is reported and a NULL pointer is returned.; ///; /// NOTE 3: The number of entries in the projected profile is estimated from the number of; /// effective entries for all the cells included in the projection.; ///; /// ",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:481,Availability,error,errors,481,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.; ///; /// if newname is not blank a new temporary histogram hnew is created.; /// else the current histogram is modified (default); /// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; /// have to me merged into one bin of hnew; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins; /// hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz; /// // Carefull: previous contents of hpxpy are lost; /// hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz; /// TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew; /// // merging 5 bins of h1 along the yaxis in one bin; ///; /// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; /// along the xaxis/yaxis the top limit(s) of the rebinned histogram; /// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; /// ybin=newybins*nygroup and the corresponding bins are added to; /// the overflow bin.; /// Statistics will be recomputed from the new bin contents.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:546,Availability,error,errors,546,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together.; ///; /// if newname is not blank a new temporary histogram hnew is created.; /// else the current histogram is modified (default); /// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; /// have to me merged into one bin of hnew; /// If the original histogram has errors stored (via Sumw2), the resulting; /// histograms has new errors correctly calculated.; ///; /// examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins; /// hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz; /// // Carefull: previous contents of hpxpy are lost; /// hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz; /// TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew; /// // merging 5 bins of h1 along the yaxis in one bin; ///; /// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; /// along the xaxis/yaxis the top limit(s) of the rebinned histogram; /// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; /// ybin=newybins*nygroup and the corresponding bins are added to; /// the overflow bin.; /// Statistics will be recomputed from the new bin contents.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:3,Modifiability,variab,variable,3,"// variable bin sizes in x or y, don't treat both cases separately",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:15,Availability,error,errors,15,"//changes also errors array (if any)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:15,Availability,error,errors,15,"//changes also errors array",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:101,Performance,perform,performing,101,"////////////////////////////////////////////////////////////////////////////////; /// static methdod performing the projection to 1D histogram",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:101,Performance,perform,performing,101,"////////////////////////////////////////////////////////////////////////////////; /// static methdod performing the projection to 2D histogram",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms.; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms.; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms.; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms.; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,Modifiability,variab,variable,102,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size 3-D histograms; /// (see TH3::TH3 for explanation of parameters)",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Reset this histogram: contents, errors, etc.",MatchSource.CODE_COMMENT,hist/hist/src/TH3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:217,Performance,optimiz,optimize,217,"/** \class THLimitsFinder; \ingroup Histograms; Class to compute nice axis limits. This class is called by default by the histogramming system; and also by TTree::Draw, TTreePlayer::DrawSelect. TGaxis use it also to; optimize axis labels. A different finder may be specified via THLimitsFinder::SetFinder.; */; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:259,Performance,optimiz,optimized,259,"////////////////////////////////////////////////////////////////////////////////; /// Compute the best axis limits for the X axis.; ///; /// If the bit kIsInteger is set, the number of channels is also recomputed.; /// The axis parameters are replaced by the optimized parameters.; ///; /// Example:; /// With the input parameters xmin=-1.467 and xmax=2.344, the function; /// will compute better limits -1.8 and 2.7 and store them in the axis.",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:265,Performance,optimiz,optimized,265,"////////////////////////////////////////////////////////////////////////////////; /// Compute the best axis limits for the X and Y axis.; ///; /// If the bit kIsInteger is set, the number of channels is also recomputed.; /// The axis parameters are replaced by the optimized parameters",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:268,Performance,optimiz,optimized,268,"////////////////////////////////////////////////////////////////////////////////; /// Compute the best axis limits for the X, Y and Z axis.; ///; /// If the bit kIsInteger is set, the number of channels is also recomputed.; /// The axis parameters are replaced by the optimized parameters",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:247,Performance,Optimiz,Optimized,247,"////////////////////////////////////////////////////////////////////////////////; /// Static function to compute reasonable axis limits; ///; /// Input parameters:; ///; /// \param[in] A1,A2 : Original axis limits; /// \param[in] BinLow,BinHigh : Optimized axis limits. They should be initialized by the; /// calling method for instance to 0.; /// \param[out] nold : Original number of divisions.; /// \param[out] nbins : Optimized number of divisions.; /// \param[out] BinWidth : Optimized bin width. It should be initialized by the; /// calling method for instance to 0.; /// \param[in] option : ""T"" means Time axis.",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:422,Performance,Optimiz,Optimized,422,"////////////////////////////////////////////////////////////////////////////////; /// Static function to compute reasonable axis limits; ///; /// Input parameters:; ///; /// \param[in] A1,A2 : Original axis limits; /// \param[in] BinLow,BinHigh : Optimized axis limits. They should be initialized by the; /// calling method for instance to 0.; /// \param[out] nold : Original number of divisions.; /// \param[out] nbins : Optimized number of divisions.; /// \param[out] BinWidth : Optimized bin width. It should be initialized by the; /// calling method for instance to 0.; /// \param[in] option : ""T"" means Time axis.",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:481,Performance,Optimiz,Optimized,481,"////////////////////////////////////////////////////////////////////////////////; /// Static function to compute reasonable axis limits; ///; /// Input parameters:; ///; /// \param[in] A1,A2 : Original axis limits; /// \param[in] BinLow,BinHigh : Optimized axis limits. They should be initialized by the; /// calling method for instance to 0.; /// \param[out] nold : Original number of divisions.; /// \param[out] nbins : Optimized number of divisions.; /// \param[out] BinWidth : Optimized bin width. It should be initialized by the; /// calling method for instance to 0.; /// \param[in] option : ""T"" means Time axis.",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:60,Integrability,rout,routine,60,"// if nold == -1 , program uses binwidth input from calling routine",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:66,Safety,avoid,avoid,66,"//in the above statement, it is important to subtract 1e-10; //to avoid precision problems if the tests below; // Round mantissa",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:98,Testability,test,tests,98,"//in the above statement, it is important to subtract 1e-10; //to avoid precision problems if the tests below; // Round mantissa",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:86,Performance,Optimiz,Optimize,86,"////////////////////////////////////////////////////////////////////////////////; /// Optimize axis limits.; ///; /// When isInter=kTRUE, the function makes an integer binwidth; /// and recompute the number of bins accordingly.",MatchSource.CODE_COMMENT,hist/hist/src/THLimitsFinder.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx:3,Integrability,Wrap,Wrap,3,"// Wrap around if needed",MatchSource.CODE_COMMENT,hist/hist/src/THn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx:1429,Availability,error,errors,1429,"three dimensions,; and if a large fraction of all bins are filled.; Better alternatives are; - THnSparse if a fraction of all bins are filled; - TTree. The major problem of THn is the memory use caused by n-dimensional; histogramming: a THnD with 8 dimensions and 100 bins per dimension needs; more than 2.5GB of RAM!. To construct a THn object you must use one of its templated, derived; classes:. THnD (typedef for THnT<Double_t>): bin content held by a Double_t,; THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,; THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; THnC (typedef for THnT<Char_t>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);. ## Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. ## Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call. hn->GetAxis(12)->SetRange(from_bin, to_bin);. ## Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF.; */",MatchSource.CODE_COMMENT,hist/hist/src/THn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx:1516,Energy Efficiency,allocate,allocated,1516,"three dimensions,; and if a large fraction of all bins are filled.; Better alternatives are; - THnSparse if a fraction of all bins are filled; - TTree. The major problem of THn is the memory use caused by n-dimensional; histogramming: a THnD with 8 dimensions and 100 bins per dimension needs; more than 2.5GB of RAM!. To construct a THn object you must use one of its templated, derived; classes:. THnD (typedef for THnT<Double_t>): bin content held by a Double_t,; THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,; THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; THnC (typedef for THnT<Char_t>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);. ## Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. ## Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call. hn->GetAxis(12)->SetRange(from_bin, to_bin);. ## Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF.; */",MatchSource.CODE_COMMENT,hist/hist/src/THn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx:1615,Energy Efficiency,reduce,reduced,1615,"three dimensions,; and if a large fraction of all bins are filled.; Better alternatives are; - THnSparse if a fraction of all bins are filled; - TTree. The major problem of THn is the memory use caused by n-dimensional; histogramming: a THnD with 8 dimensions and 100 bins per dimension needs; more than 2.5GB of RAM!. To construct a THn object you must use one of its templated, derived; classes:. THnD (typedef for THnT<Double_t>): bin content held by a Double_t,; THnF (typedef for THnT<Float_t>): bin content held by a Float_t,; THnL (typedef for THnT<Long64_t>): bin content held by a Long64_t,; THnI (typedef for THnT<Int_t>): bin content held by an Int_t,; THnS (typedef for THnT<Short_t>): bin content held by a Short_t,; THnC (typedef for THnT<Char_t>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2F h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnF hn(""hn"", ""hn"", 2, bins, xmin, xmax);. ## Filling; A THn is filled just like a regular histogram, using; THn::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram.; Storage is allocated when the first bin content is stored. ## Projections; The dimensionality of a THn can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THn. See the Projection() members. To only project parts of the; histogram, call. hn->GetAxis(12)->SetRange(from_bin, to_bin);. ## Conversion from other histogram classes; The static factory function THn::CreateHn() can be used to create a THn; from a TH1, TH2, TH3, THnSparse and (for copying) even from a THn. The; created THn will have compatble storage type, i.e. calling CreateHn() on; a TH2F will create a THnF.; */",MatchSource.CODE_COMMENT,hist/hist/src/THn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx:127,Integrability,interface,interface,127,"////////////////////////////////////////////////////////////////////////////////; /// Create an iterator over all bins. Public interface is THnIter.",MatchSource.CODE_COMMENT,hist/hist/src/THn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx:108,Availability,error,errors,108,"////////////////////////////////////////////////////////////////////////////////; /// Enable calculation of errors",MatchSource.CODE_COMMENT,hist/hist/src/THn.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THn.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:102,Integrability,interface,interfaces,102,"/** \class THnBase; \ingroup Hist; Multidimensional histogram base.; Defines common functionality and interfaces for THn, THnSparse.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:188,Integrability,depend,depending,188,"////////////////////////////////////////////////////////////////////////////////; /// Create an empty histogram with name and title with a given; /// set of axes. Create a TH1D/TH2D/TH3D, depending on the number; /// of elements in axes.",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:15,Modifiability,extend,extend,15,"// axis cannot extend to underflow/overflows (fix ROOT-8781)",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:39,Integrability,depend,depending,39,"// Create the corresponding THnSparse, depending on the storage; // type of the TH1. The class name will be ""TH??\0"" where the first; // ? is 1,2 or 3 and the second ? indicates the storage as C, S,; // I, L, F or D.",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:151,Availability,error,error,151,"////////////////////////////////////////////////////////////////////////////////; /// Fill the THnBase with the bins of hist that have content; /// or error != 0.",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:713,Availability,Error,Errors,713,"////////////////////////////////////////////////////////////////////////////////; /// Fit a THnSparse with function f; ///; /// since the data is sparse by default a likelihood fit is performed; /// merging all the regions with empty bins for better performance efficiency; ///; /// Since the THnSparse is not drawn no graphics options are passed; /// Here is the list of possible options; ///; /// = ""I"" Use integral of function in bin instead of value at bin center; /// = ""X"" Use chi2 method (default is log-likelihood method); /// = ""U"" Use a User specified fitting algorithm (via SetFCN); /// = ""Q"" Quiet mode (minimum printing); /// = ""V"" Verbose mode (default is between Q and V); /// = ""E"" Perform better Errors estimation using Minos technique; /// = ""B"" Use this option when you want to fix one or more parameters; /// and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; /// = ""M"" More. Improve fit results; /// = ""R"" Use the Range specified in the function range",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:184,Performance,perform,performed,184,"////////////////////////////////////////////////////////////////////////////////; /// Fit a THnSparse with function f; ///; /// since the data is sparse by default a likelihood fit is performed; /// merging all the regions with empty bins for better performance efficiency; ///; /// Since the THnSparse is not drawn no graphics options are passed; /// Here is the list of possible options; ///; /// = ""I"" Use integral of function in bin instead of value at bin center; /// = ""X"" Use chi2 method (default is log-likelihood method); /// = ""U"" Use a User specified fitting algorithm (via SetFCN); /// = ""Q"" Quiet mode (minimum printing); /// = ""V"" Verbose mode (default is between Q and V); /// = ""E"" Perform better Errors estimation using Minos technique; /// = ""B"" Use this option when you want to fix one or more parameters; /// and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; /// = ""M"" More. Improve fit results; /// = ""R"" Use the Range specified in the function range",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:250,Performance,perform,performance,250,"////////////////////////////////////////////////////////////////////////////////; /// Fit a THnSparse with function f; ///; /// since the data is sparse by default a likelihood fit is performed; /// merging all the regions with empty bins for better performance efficiency; ///; /// Since the THnSparse is not drawn no graphics options are passed; /// Here is the list of possible options; ///; /// = ""I"" Use integral of function in bin instead of value at bin center; /// = ""X"" Use chi2 method (default is log-likelihood method); /// = ""U"" Use a User specified fitting algorithm (via SetFCN); /// = ""Q"" Quiet mode (minimum printing); /// = ""V"" Verbose mode (default is between Q and V); /// = ""E"" Perform better Errors estimation using Minos technique; /// = ""B"" Use this option when you want to fix one or more parameters; /// and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; /// = ""M"" More. Improve fit results; /// = ""R"" Use the Range specified in the function range",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:698,Performance,Perform,Perform,698,"////////////////////////////////////////////////////////////////////////////////; /// Fit a THnSparse with function f; ///; /// since the data is sparse by default a likelihood fit is performed; /// merging all the regions with empty bins for better performance efficiency; ///; /// Since the THnSparse is not drawn no graphics options are passed; /// Here is the list of possible options; ///; /// = ""I"" Use integral of function in bin instead of value at bin center; /// = ""X"" Use chi2 method (default is log-likelihood method); /// = ""U"" Use a User specified fitting algorithm (via SetFCN); /// = ""Q"" Quiet mode (minimum printing); /// = ""V"" Verbose mode (default is between Q and V); /// = ""E"" Perform better Errors estimation using Minos technique; /// = ""B"" Use this option when you want to fix one or more parameters; /// and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; /// = ""M"" More. Improve fit results; /// = ""R"" Use the Range specified in the function range",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:507,Testability,log,log-likelihood,507,"////////////////////////////////////////////////////////////////////////////////; /// Fit a THnSparse with function f; ///; /// since the data is sparse by default a likelihood fit is performed; /// merging all the regions with empty bins for better performance efficiency; ///; /// Since the THnSparse is not drawn no graphics options are passed; /// Here is the list of possible options; ///; /// = ""I"" Use integral of function in bin instead of value at bin center; /// = ""X"" Use chi2 method (default is log-likelihood method); /// = ""U"" Use a User specified fitting algorithm (via SetFCN); /// = ""Q"" Quiet mode (minimum printing); /// = ""V"" Verbose mode (default is between Q and V); /// = ""E"" Perform better Errors estimation using Minos technique; /// = ""B"" Use this option when you want to fix one or more parameters; /// and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; /// = ""M"" More. Improve fit results; /// = ""R"" Use the Range specified in the function range",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:243,Availability,error,error,243,"////////////////////////////////////////////////////////////////////////////////; /// \brief THnBase::GetBinCenter; /// \param idx an array of bin index in each dimension.; /// \return vector of bin centers in each dimension; empty in case of error.; /// \note Throws error if size is different from nDimensions.; /// \sa GetAxis(dim)::GetBinCenter(idx) as an alternative",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:268,Availability,error,error,268,"////////////////////////////////////////////////////////////////////////////////; /// \brief THnBase::GetBinCenter; /// \param idx an array of bin index in each dimension.; /// \return vector of bin centers in each dimension; empty in case of error.; /// \note Throws error if size is different from nDimensions.; /// \sa GetAxis(dim)::GetBinCenter(idx) as an alternative",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:318,Availability,error,errors,318,"////////////////////////////////////////////////////////////////////////////////; /// Project all bins into a ndim-dimensional THn / THnSparse (whatever; /// *this is) or if (ndim < 4 and !wantNDim) a TH1/2/3 histogram,; /// keeping only axes in dim (specifying ndim dimensions).; /// If ""option"" contains:; /// - ""E"" errors will be calculated.; /// - ""A"" ranges of the target axes will be ignored.; /// - ""O"" original axis range of the target axes will be; /// kept, but only bins inside the selected range; /// will be filled.",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:2,Energy Efficiency,allocate,allocate,2,/*allocate*/,MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:16,Availability,error,error,16,"// only _after_ error calculation, or sqrt(v) is taken into account!",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:41,Availability,error,error,41,"// re-compute the entries; // in case of error calculation (i.e. when Sumw2() is set); // use the effective entries for the entries; // since this is the only way to estimate them",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:6,Safety,avoid,avoid,6,"// to avoid numerical rounding",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:105,Availability,error,errors,105,"////////////////////////////////////////////////////////////////////////////////; /// Scale contents and errors of this histogram by c:; /// this = this * c; /// It does not modify the histogram's number of entries.",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:24,Availability,error,errors,24,"// Scale the contents & errors",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:11,Availability,error,error,11,"// Trigger error calculation if h has it",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:34,Energy Efficiency,reduce,reduce,34,"// Expand the exmap if needed, to reduce collisions",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:3,Energy Efficiency,allocate,allocate,3,/* allocate*/,MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:2,Energy Efficiency,allocate,allocate,2,/*allocate*/,MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:16,Availability,error,error,16,"// only _after_ error calculation, or sqrt(v) is taken into account!",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:11,Availability,error,error,11,"// Trigger error calculation if h has it",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:135,Availability,error,errors,135,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c*f1; /// if errors are defined, errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after; /// calling Multiply()",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:155,Availability,error,errors,155,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c*f1; /// if errors are defined, errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after; /// calling Multiply()",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:293,Availability,error,errors,293,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c*f1; /// if errors are defined, errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after; /// calling Multiply()",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c*f1; /// if errors are defined, errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after; /// calling Multiply()",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:252,Availability,error,errors,252,"////////////////////////////////////////////////////////////////////////////////; /// Divide this histogram by h; /// this = this/(h); /// Note that if h has Sumw2 set, Sumw2 is automatically called for; /// this if not already set.; /// The resulting errors are calculated assuming uncorrelated content.",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:11,Availability,error,error,11,"// Trigger error calculation if h has it",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:305,Availability,error,errors,305,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by multiplication of h1 by h2; /// this = (c1*h1)/(c2*h2); /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; /// this if not already set.; /// The resulting errors are calculated assuming uncorrelated content.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:410,Availability,error,errors,410,"////////////////////////////////////////////////////////////////////////////////; /// Replace contents of this histogram by multiplication of h1 by h2; /// this = (c1*h1)/(c2*h2); /// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; /// this if not already set.; /// The resulting errors are calculated assuming uncorrelated content.; /// However, if option =""B"" is specified, Binomial errors are computed.; /// In this case c1 and c2 do not make real sense and they are ignored.",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:11,Availability,error,error,11,"// Trigger error calculation if h1 or h2 have it",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:3,Modifiability,variab,variable,3,"// variable bins",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:2,Energy Efficiency,allocate,allocate,2,/*allocate*/,MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:16,Availability,error,error,16,"// only _after_ error calculation, or sqrt(v) is taken into account!",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear the histogram",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:3,Energy Efficiency,allocate,allocate,3,"// allocate integral array",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:275,Availability,error,error,275,"////////////////////////////////////////////////////////////////////////////////; /// Print one bin. If ""idx"" is != -1 use that to determine the bin,; /// otherwise (if ""idx"" == -1) use the coordinate in ""bin"".; /// If ""options"" contains:; /// - '0': only print bins with an error or content != 0; /// Return whether the bin was printed (depends on options)",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:338,Integrability,depend,depends,338,"////////////////////////////////////////////////////////////////////////////////; /// Print one bin. If ""idx"" is != -1 use that to determine the bin,; /// otherwise (if ""idx"" == -1) use the coordinate in ""bin"".; /// If ""options"" contains:; /// - '0': only print bins with an error or content != 0; /// Return whether the bin was printed (depends on options)",MatchSource.CODE_COMMENT,hist/hist/src/THnBase.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnChain.cxx:3,Performance,Perform,Perform,3,"// Perform projection.",MatchSource.CODE_COMMENT,hist/hist/src/THnChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnChain.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnChain.cxx:103,Deployability,update,updated,103,"/// Copy the properties of all axes to a histogram.; ///; /// \param hs histogram whose axes should be updated",MatchSource.CODE_COMMENT,hist/hist/src/THnChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnChain.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnChain.cxx:97,Modifiability,inherit,inherit,97,"// We would prefer to directly use `TH1::CheckEqualAxes` here;; // however it is protected so we inherit the parts we care about.; // FIXME(bbannier): It appears that functionality like `TH1::CheckEqualAxes` could; // just as well live in `TAxis` so that anyone using axes could make use of it.",MatchSource.CODE_COMMENT,hist/hist/src/THnChain.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnChain.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:674,Integrability,depend,depend,674,"/** \class THnSparseCoordCompression; THnSparseCoordCompression is a class used by THnSparse internally. It; represents a compacted n-dimensional array of bin coordinates (indices).; As the total number of bins in each dimension is known by THnSparse, bin; indices can be compacted to only use the amount of bins needed by the total; number of bins in each dimension. E.g. for a THnSparse with; {15, 100, 2, 20, 10, 100} bins per dimension, a bin index will only occupy; 28 bits (4+7+1+5+4+7), i.e. less than a 32bit integer. The tricky part is; the fast compression and decompression, the platform-independent storage; (think of endianness: the bits of the number 0x123456 depend on the; platform), and the hashing needed by THnSparseArrayChunk.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:708,Security,hash,hashing,708,"/** \class THnSparseCoordCompression; THnSparseCoordCompression is a class used by THnSparse internally. It; represents a compacted n-dimensional array of bin coordinates (indices).; As the total number of bins in each dimension is known by THnSparse, bin; indices can be compacted to only use the amount of bins needed by the total; number of bins in each dimension. E.g. for a THnSparse with; {15, 100, 2, 20, 10, 100} bins per dimension, a bin index will only occupy; 28 bits (4+7+1+5+4+7), i.e. less than a 32bit integer. The tricky part is; the fast compression and decompression, the platform-independent storage; (think of endianness: the bits of the number 0x123456 depend on the; platform), and the hashing needed by THnSparseArrayChunk.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:29,Energy Efficiency,allocate,allocated,29,"// return the number of bits allocated by the number ""n""",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:213,Security,hash,hash,213,"////////////////////////////////////////////////////////////////////////////////; /// Given the cbin coordinates coord_in, calculate (""compact""); /// the bin coordinates and return them in buf_in.; /// Return the hash value.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:254,Integrability,depend,depending,254,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:100,Security,hash,hash,100,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:374,Security,hash,hash,374,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:418,Security,hash,hash,418,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:484,Security,hash,hash,484,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1078,Security,hash,hash,1078,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1170,Security,hash,hash,1170,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1182,Security,hash,hash,1182,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1211,Security,hash,hash,1211,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1321,Security,hash,hash,1321,"/*; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from bin indexes. ULong64_t THnSparseCoordCompression::GetHashFromCoords(const Int_t* coord) const; {; // Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash. if (fCoordBufferSize <= 8) {; // fits into a Long64_t; ULong64_t hash1 = 0;; for (Int_t i = 0; i < fNdimensions; ++i) {; hash1 += coord[i] << fBitOffsets[i];; }; return hash1;; }. // else: doesn't fit into a Long64_t:; memset(coord, 0, fCoordBufferSize);; for (Int_t i = 0; i < fNdimensions; ++i) {; const Int_t offset = fBitOffsets[i] / 8;; const Int_t shift = fBitOffsets[i] % 8;; ULong64_t val = coord[i];. Char_t* pbuf = fCoordBuffer + offset;; *pbuf += 0xff & (val << shift);; val = val >> (8 - shift);; while (val) {; ++pbuf;; *pbuf += 0xff & val;; val = val >> 8;; }; }. ULong64_t hash = 5381;; Char_t* str = fCoordBuffer;; while (str - fCoordBuffer < fCoordBufferSize) {; hash *= 5;; hash += *(str++);; }; return hash;; }; */; ////////////////////////////////////////////////////////////////////////////////; /// Calculate hash from compact bin index.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:46,Integrability,depend,depending,46,"// Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:166,Security,hash,hash,166,"// Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:210,Security,hash,hash,210,"// Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:276,Security,hash,hash,276,"// Bins are addressed in two different modes, depending; // on whether the compact bin index fits into a Long64_t or not.; // If it does, we can use it as a ""perfect hash"" for the TExMap.; // If not we build a hash from the compact bin index, and use that; // as the TExMap's hash.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3,Security,hash,hash,3,"// hash for current coordinates; 0 if not calculated",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:181,Availability,error,errors,181,"/** \class THnSparseArrayChunk; THnSparseArrayChunk is used internally by THnSparse.; THnSparse stores its (dynamic size) array of bin coordinates and their; contents (and possibly errors) in a TObjArray of THnSparseArrayChunk. Each; of the chunks holds an array of THnSparseCompactBinCoord and the content; (a TArray*), which is created outside (by the templated derived classes of; THnSparse) and passed in at construction time.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:205,Availability,error,errors,205,"////////////////////////////////////////////////////////////////////////////////; /// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; /// and create an ArrayF for errors if ""errors"" is true.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:216,Availability,error,errors,216,"////////////////////////////////////////////////////////////////////////////////; /// (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; /// and create an ArrayF for errors if ""errors"" is true.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:129,Energy Efficiency,allocate,allocated,129,"// When streaming out only the filled chunk is saved.; // When reading back only the memory needed for that filled part gets; // allocated. We need to check whether the allowed chunk size is; // bigger than the allocated size. If fCoordinateAllocationSize is; // set to -1 this chunk has been allocated by the streamer and the; // buffer allocation size is defined by [fCoordinatesSize]. In that; // case we need to compare fCoordinatesSize to; // fSingleCoordinateSize * fContent->GetSize(); // to determine whether we need to expand the buffer.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:211,Energy Efficiency,allocate,allocated,211,"// When streaming out only the filled chunk is saved.; // When reading back only the memory needed for that filled part gets; // allocated. We need to check whether the allowed chunk size is; // bigger than the allocated size. If fCoordinateAllocationSize is; // set to -1 this chunk has been allocated by the streamer and the; // buffer allocation size is defined by [fCoordinatesSize]. In that; // case we need to compare fCoordinatesSize to; // fSingleCoordinateSize * fContent->GetSize(); // to determine whether we need to expand the buffer.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:293,Energy Efficiency,allocate,allocated,293,"// When streaming out only the filled chunk is saved.; // When reading back only the memory needed for that filled part gets; // allocated. We need to check whether the allowed chunk size is; // bigger than the allocated size. If fCoordinateAllocationSize is; // set to -1 this chunk has been allocated by the streamer and the; // buffer allocation size is defined by [fCoordinatesSize]. In that; // case we need to compare fCoordinatesSize to; // fSingleCoordinateSize * fContent->GetSize(); // to determine whether we need to expand the buffer.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:14,Energy Efficiency,allocate,allocate,14,"// need to re-allocate:",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:105,Availability,error,errors,105,"////////////////////////////////////////////////////////////////////////////////; /// Turn on support of errors",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1541,Availability,error,errors,1541,"def for THnSparseT<ArrayD>): bin content held by a Double_t,; - THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; - THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; - THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; - THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; - THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);. ## Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram. Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). ## Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be. std::cout << hs.GetBinContent(0, coord);; std::cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << std::endl;. ## Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial sparsehist.C; shows the turn",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:37,Energy Efficiency,Efficient,Efficient,37,"/** \class THnSparse; \ingroup Hist. Efficient multidimensional histogram. Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; only a small fraction of bins is filled. A 10-dimensional histogram with 10; bins per dimension has 10^10 bins; in a naive implementation this will not; fit in memory. THnSparse only allocates memory for the bins that have; non-zero bin content instead, drastically reducing both the memory usage; and the access time. To construct a THnSparse object you must use one of its templated, derived; classes:; - THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; - THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; - THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; - THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; - THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; - THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);. ## Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram. Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). ## Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnS",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:333,Energy Efficiency,allocate,allocates,333,"/** \class THnSparse; \ingroup Hist. Efficient multidimensional histogram. Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; only a small fraction of bins is filled. A 10-dimensional histogram with 10; bins per dimension has 10^10 bins; in a naive implementation this will not; fit in memory. THnSparse only allocates memory for the bins that have; non-zero bin content instead, drastically reducing both the memory usage; and the access time. To construct a THnSparse object you must use one of its templated, derived; classes:; - THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; - THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; - THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; - THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; - THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; - THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);. ## Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram. Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). ## Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnS",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1625,Energy Efficiency,allocate,allocated,1625,"): bin content held by a Float_t,; - THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; - THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; - THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; - THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);. ## Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram. Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). ## Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be. std::cout << hs.GetBinContent(0, coord);; std::cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << std::endl;. ## Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. U",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:2838,Energy Efficiency,reduce,reduced,2838,"he number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be. std::cout << hs.GetBinContent(0, coord);; std::cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << std::endl;. ## Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call. THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. ## Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3507,Energy Efficiency,allocate,allocated,3507," The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call. THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. ## Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:456,Security,access,access,456,"/** \class THnSparse; \ingroup Hist. Efficient multidimensional histogram. Use a THnSparse instead of TH1 / TH2 / TH3 / array for histogramming when; only a small fraction of bins is filled. A 10-dimensional histogram with 10; bins per dimension has 10^10 bins; in a naive implementation this will not; fit in memory. THnSparse only allocates memory for the bins that have; non-zero bin content instead, drastically reducing both the memory usage; and the access time. To construct a THnSparse object you must use one of its templated, derived; classes:; - THnSparseD (typedef for THnSparseT<ArrayD>): bin content held by a Double_t,; - THnSparseF (typedef for THnSparseT<ArrayF>): bin content held by a Float_t,; - THnSparseL (typedef for THnSparseT<ArrayL64>): bin content held by a Long64_t,; - THnSparseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; - THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; - THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);. ## Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram. Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). ## Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnS",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:1764,Security,Access,Access,1764,"rseI (typedef for THnSparseT<ArrayI>): bin content held by an Int_t,; - THnSparseS (typedef for THnSparseT<ArrayS>): bin content held by a Short_t,; - THnSparseC (typedef for THnSparseT<ArrayC>): bin content held by a Char_t,. They take name and title, the number of dimensions, and for each dimension; the number of bins, the minimal, and the maximal value on the dimension's; axis. A TH2 h(""h"",""h"",10, 0., 10., 20, -5., 5.) would correspond to. Int_t bins[2] = {10, 20};; Double_t xmin[2] = {0., -5.};; Double_t xmax[2] = {10., 5.};; THnSparseD hs(""hs"", ""hs"", 2, bins, xmin, xmax);. ## Filling; A THnSparse is filled just like a regular histogram, using; THnSparse::Fill(x, weight), where x is a n-dimensional Double_t value.; To take errors into account, Sumw2() must be called before filling the; histogram. Bins are allocated as needed; the status of the allocation can be observed; by GetSparseFractionBins(), GetSparseFractionMem(). ## Fast Bin Content Access; When iterating over a THnSparse one should only look at filled bins to save; processing time. The number of filled bins is returned by; THnSparse::GetNbins(); the bin content for each (linear) bin number can; be retrieved by THnSparse::GetBinContent(linidx, (Int_t*)coord).; After the call, coord will contain the bin coordinate of each axis for the bin; with linear index linidx. A possible call would be. std::cout << hs.GetBinContent(0, coord);; std::cout <<"" is the content of bin [x = "" << coord[0] ""; << "" | y = "" << coord[1] << ""]"" << std::endl;. ## Efficiency; TH1 and TH2 are generally faster than THnSparse for one and two dimensional; distributions. THnSparse becomes competitive for a sparsely filled TH3; with large numbers of bins per dimension. The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dim",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3797,Security,hash,hash,3797," The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call. THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. ## Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3843,Security,hash,hash,3843," The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call. THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. ## Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3965,Security,hash,hash,3965," The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call. THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. ## Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:4190,Security,hash,hash,4190," The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call. THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. ## Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:4392,Security,hash,hash,4392," The tutorial sparsehist.C; shows the turning point. On a AMD64 with 8GB memory, THnSparse ""wins""; starting with a TH3 with 30 bins per dimension. Using a THnSparse for a; one-dimensional histogram is only reasonable if it has a huge number of bins. ## Projections; The dimensionality of a THnSparse can be reduced by projecting it to; 1, 2, 3, or n dimensions, which can be represented by a TH1, TH2, TH3, or; a THnSparse. See the Projection() members. To only project parts of the; histogram, call. THnSparse::GetAxis(12)->SetRange(from_bin, to_bin);. ## Internal Representation; An entry for a filled bin consists of its n-dimensional coordinates and; its bin content. The coordinates are compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin.; */",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:140,Energy Efficiency,allocate,allocate,140,"////////////////////////////////////////////////////////////////////////////////; /// Get the bin index for the n dimensional tuple x,; /// allocate one if it doesn't exist yet and ""allocate"" is true.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:182,Energy Efficiency,allocate,allocate,182,"////////////////////////////////////////////////////////////////////////////////; /// Get the bin index for the n dimensional tuple x,; /// allocate one if it doesn't exist yet and ""allocate"" is true.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:158,Energy Efficiency,allocate,allocate,158,"////////////////////////////////////////////////////////////////////////////////; /// Get the bin index for the n dimensional tuple addressed by ""name"",; /// allocate one if it doesn't exist yet and ""allocate"" is true.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:200,Energy Efficiency,allocate,allocate,200,"////////////////////////////////////////////////////////////////////////////////; /// Get the bin index for the n dimensional tuple addressed by ""name"",; /// allocate one if it doesn't exist yet and ""allocate"" is true.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:150,Energy Efficiency,allocate,allocate,150,"////////////////////////////////////////////////////////////////////////////////; /// Get the bin index for the n dimensional coordinates coord,; /// allocate one if it doesn't exist yet and ""allocate"" is true.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:192,Energy Efficiency,allocate,allocate,192,"////////////////////////////////////////////////////////////////////////////////; /// Get the bin index for the n dimensional coordinates coord,; /// allocate one if it doesn't exist yet and ""allocate"" is true.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:104,Availability,error,error,104,"////////////////////////////////////////////////////////////////////////////////; /// Get square of the error of bin addressed by linidx as; /// \f$\sum weight^{2}\f$; /// If errors are not enabled (via Sumw2() or CalculateErrors()); /// return contents.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:175,Availability,error,errors,175,"////////////////////////////////////////////////////////////////////////////////; /// Get square of the error of bin addressed by linidx as; /// \f$\sum weight^{2}\f$; /// If errors are not enabled (via Sumw2() or CalculateErrors()); /// return contents.",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:169,Energy Efficiency,allocate,allocate,169,"////////////////////////////////////////////////////////////////////////////////; /// Return the index for fCurrentBinIndex.; /// If it doesn't exist then return -1, or allocate a new bin if allocate is set",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:191,Energy Efficiency,allocate,allocate,191,"////////////////////////////////////////////////////////////////////////////////; /// Return the index for fCurrentBinIndex.; /// If it doesn't exist then return -1, or allocate a new bin if allocate is set",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:3,Energy Efficiency,allocate,allocate,3,"// allocate bin in chunk",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:29,Security,hash,hash,29,"// store translation between hash and bin",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error of bin with index ""bin"" to ""e"", enable errors if needed",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:135,Availability,error,errors,135,"////////////////////////////////////////////////////////////////////////////////; /// Set error of bin with index ""bin"" to ""e"", enable errors if needed",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:10,Availability,error,error,10,"// enable error calculation",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:97,Availability,error,error,97,"////////////////////////////////////////////////////////////////////////////////; /// Add ""e"" to error of bin with index ""bin"", enable errors if needed",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:135,Availability,error,errors,135,"////////////////////////////////////////////////////////////////////////////////; /// Add ""e"" to error of bin with index ""bin"", enable errors if needed",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:10,Availability,error,error,10,"// enable error calculation",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:108,Availability,error,errors,108,"////////////////////////////////////////////////////////////////////////////////; /// Enable calculation of errors",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear the histogram",MatchSource.CODE_COMMENT,hist/hist/src/THnSparse.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnSparse.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:3134,Availability,avail,available,3134,"round of the histograms is erased before drawing the; histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; THStack on top of another plot. If the patterns used to draw the histograms in the; stack are transparent, then the plot behind will be visible. See the THistPainter class for the list of valid histograms' painting options. Example;. Begin_Macro(source); {; auto hs = new THStack(""hs"","""");; auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; TText T; T.SetTextFont(42); T.SetTextAlign(21);; cs->Divide(2,2);; cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; }; End_Macro. A more complex example:. Begin_Macro(source); ../../../tutorials/hist/hstack.C; End_Macro. Note that picking is supported for all drawing modes. \since **ROOT version 6.07/07:**; Stacks of 2D histograms can also be painted as candle plots:; \since **ROOT version 6.09/02:**; Stacks of 2D histograms can also be painted as violin plots, combinations of candle and; violin plots are possible as well:. Begin_Macro(source); ../../../tutorials/hist/candleplotstack.C; End_Macro. Automatic coloring according to the current palette is available as shown in the; following example:. Begin_Macro(source); ../../../tutorials/hist/thstackpalettecolor.C; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// constructor with name and title",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:1469,Safety,avoid,avoids,1469,"### Stack painting. By default, histograms are shown stacked:; - the first histogram is painted; - then the sum of the first and second histograms is painted, and so on. The axis ranges are computed automatically along the X and Y axes to display the complete; histogram collection. Warning: Histogram bins with negative content may produce wrong plots. ### Stack's drawing options. The specific stack's drawing options are:. - **NOSTACK** If option ""nostack"" is specified, histograms are all painted in the same pad; as if the option ""same"" had been specified. - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; next to each other as bar plots. - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is painted into a separate pad. - **NOCLEAR** By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; THStack on top of another plot. If the patterns used to draw the histograms in the; stack are transparent, then the plot behind will be visible. See the THistPainter class for the list of valid histograms' painting options. Example;. Begin_Macro(source); {; auto hs = new THStack(""hs"","""");; auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; TText T; T.SetTextFont(42); T.SetTextAlign(21);; cs->Divide(2,2);; cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; cs->cd(3); hs->Draw(""nostackb"")",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:1838,Testability,test,test,1838,"e option ""same"" had been specified. - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; next to each other as bar plots. - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is painted into a separate pad. - **NOCLEAR** By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; THStack on top of another plot. If the patterns used to draw the histograms in the; stack are transparent, then the plot behind will be visible. See the THistPainter class for the list of valid histograms' painting options. Example;. Begin_Macro(source); {; auto hs = new THStack(""hs"","""");; auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; TText T; T.SetTextFont(42); T.SetTextAlign(21);; cs->Divide(2,2);; cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; }; End_Macro. A more complex example:. Begin_Macro(source); ../../../tutorials/hist/hstack.C; End_Macro. Note that picking is supported for all drawing modes. \since **ROOT version 6.07/07:**; Stacks of 2D histograms can also be painted as candle plots:; \since **ROOT version 6.09/02:**; Stacks of 2D histograms can also be painted as violin plots, combinations of candle and; violin plots are possible ",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:1957,Testability,test,test,1957,"e option ""same"" had been specified. - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; next to each other as bar plots. - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is painted into a separate pad. - **NOCLEAR** By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; THStack on top of another plot. If the patterns used to draw the histograms in the; stack are transparent, then the plot behind will be visible. See the THistPainter class for the list of valid histograms' painting options. Example;. Begin_Macro(source); {; auto hs = new THStack(""hs"","""");; auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; TText T; T.SetTextFont(42); T.SetTextAlign(21);; cs->Divide(2,2);; cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; }; End_Macro. A more complex example:. Begin_Macro(source); ../../../tutorials/hist/hstack.C; End_Macro. Note that picking is supported for all drawing modes. \since **ROOT version 6.07/07:**; Stacks of 2D histograms can also be painted as candle plots:; \since **ROOT version 6.09/02:**; Stacks of 2D histograms can also be painted as violin plots, combinations of candle and; violin plots are possible ",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:2077,Testability,test,test,2077,"e option ""same"" had been specified. - **NOSTACKB** If the option ""nostackb"" is specified histograms are all painted on the same pad; next to each other as bar plots. - **PADS** if option ""pads"" is specified, the current pad/canvas is subdivided into; a number of pads equal to the number of histograms and each histogram; is painted into a separate pad. - **NOCLEAR** By default the background of the histograms is erased before drawing the; histograms. The option ""noclear"" avoids this behavior. This is useful when drawing a; THStack on top of another plot. If the patterns used to draw the histograms in the; stack are transparent, then the plot behind will be visible. See the THistPainter class for the list of valid histograms' painting options. Example;. Begin_Macro(source); {; auto hs = new THStack(""hs"","""");; auto h1 = new TH1F(""h1"",""test hstack"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; auto h2 = new TH1F(""h2"",""test hstack"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; auto h3 = new TH1F(""h3"",""test hstack"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; auto cs = new TCanvas(""cs"",""cs"",10,10,700,900);; TText T; T.SetTextFont(42); T.SetTextAlign(21);; cs->Divide(2,2);; cs->cd(1); hs->Draw(); T.DrawTextNDC(.5,.95,""Default drawing option"");; cs->cd(2); hs->Draw(""nostack""); T.DrawTextNDC(.5,.95,""Option \""nostack\"""");; cs->cd(3); hs->Draw(""nostackb""); T.DrawTextNDC(.5,.95,""Option \""nostackb\"""");; cs->cd(4); hs->Draw(""lego1""); T.DrawTextNDC(.5,.95,""Option \""lego1\"""");; }; End_Macro. A more complex example:. Begin_Macro(source); ../../../tutorials/hist/hstack.C; End_Macro. Note that picking is supported for all drawing modes. \since **ROOT version 6.07/07:**; Stacks of 2D histograms can also be painted as candle plots:; \since **ROOT version 6.09/02:**; Stacks of 2D histograms can also be painted as violin plots, combinations of candle and; violin plots are possible ",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:448,Integrability,depend,depends,448,"////////////////////////////////////////////////////////////////////////////////; /// Returns a pointer to the histogram used to draw the axis.; /// Takes into account the two following cases:; /// 1- option 'A' was specified in THStack::Draw. Return fHistogram; /// 2- user had called TPad::DrawFrame. return pointer to hframe histogram; ///; /// IMPORTANT NOTES; /// - You must call Draw before calling this function. The returned histogram; /// depends on the selected Draw options.; /// - This function returns a pointer to an intermediate fixed bin size; /// histogram used to set the range and for picking.; /// You cannot use this histogram to return the bin information.; /// You must get a pointer to one of the histograms in the stack,; /// the first one, for example.",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:249,Integrability,depend,depends,249,"////////////////////////////////////////////////////////////////////////////////; /// Get the x-axis of the histogram used to draw the stack.; ///; /// IMPORTANT NOTE; /// You must call Draw before calling this function. The returned histogram; /// depends on the selected Draw options.",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:249,Integrability,depend,depends,249,"////////////////////////////////////////////////////////////////////////////////; /// Get the y-axis of the histogram used to draw the stack.; ///; /// IMPORTANT NOTE; /// You must call Draw before calling this function. The returned histogram; /// depends on the selected Draw options.",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:249,Integrability,depend,depends,249,"////////////////////////////////////////////////////////////////////////////////; /// Get the z-axis of the histogram used to draw the stack.; ///; /// IMPORTANT NOTE; /// You must call Draw before calling this function. The returned histogram; /// depends on the selected Draw options.",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx:212,Availability,error,error,212,"////////////////////////////////////////////////////////////////////////////////; /// Merge the THStack in the TList into this stack.; /// Returns the total number of histograms in the result or -1 in case of an error.",MatchSource.CODE_COMMENT,hist/hist/src/THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:884,Energy Efficiency,Energy,Energy,884,"// // @(#)root/hist:$Id$; // Authors: Bartolomeu Rabacal 07/2010; /**********************************************************************; * *; * Copyright (c) 2006 , ROOT MathLib Team *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; * *; **********************************************************************/; /** \class TKDE; \ingroup Hist; Kernel Density Estimation class.; The three main references are:; 1. ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; 2. ""Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS:; Stata module for univariate kernel density estimation.""; 3. ""Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer.""; 4. ""Cranmer KS, Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" - e-Print Archive: hep ex/0011057. The algorithm is briefly described in (4). A binned version is also implemented to address the; performance issue due to its data size dependance.; */",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:1121,Integrability,depend,dependance,1121,"// // @(#)root/hist:$Id$; // Authors: Bartolomeu Rabacal 07/2010; /**********************************************************************; * *; * Copyright (c) 2006 , ROOT MathLib Team *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; * *; **********************************************************************/; /** \class TKDE; \ingroup Hist; Kernel Density Estimation class.; The three main references are:; 1. ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; 2. ""Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS:; Stata module for univariate kernel density estimation.""; 3. ""Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer.""; 4. ""Cranmer KS, Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" - e-Print Archive: hep ex/0011057. The algorithm is briefly described in (4). A binned version is also implemented to address the; performance issue due to its data size dependance.; */",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:1082,Performance,perform,performance,1082,"// // @(#)root/hist:$Id$; // Authors: Bartolomeu Rabacal 07/2010; /**********************************************************************; * *; * Copyright (c) 2006 , ROOT MathLib Team *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; * *; **********************************************************************/; /** \class TKDE; \ingroup Hist; Kernel Density Estimation class.; The three main references are:; 1. ""Scott DW, Multivariate Density Estimation. Theory, Practice and Visualization. New York: Wiley"",; 2. ""Jann Ben - ETH Zurich, Switzerland -, Univariate kernel density estimation document for KDENS:; Stata module for univariate kernel density estimation.""; 3. ""Hardle W, Muller M, Sperlich S, Werwatz A, Nonparametric and Semiparametric Models. Springer.""; 4. ""Cranmer KS, Kernel Estimation in High-Energy; Physics. Computer Physics Communications 136:198-207,2001"" - e-Print Archive: hep ex/0011057. The algorithm is briefly described in (4). A binned version is also implemented to address the; performance issue due to its data size dependance.; */",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:33,Energy Efficiency,adapt,adaptive,33,"// Sets User option for fixed or adaptive iteration",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:33,Modifiability,adapt,adaptive,33,"// Sets User option for fixed or adaptive iteration",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:109,Energy Efficiency,adapt,adaptive,109,"// Factor which can be used to tune the smoothing.; // It is used as multiplicative factor for the fixed and adaptive bandwidth.; // A value < 1 will reproduce better the tails but oversmooth the peak; // while a factor > 1 will overestimate the tail",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:109,Modifiability,adapt,adaptive,109,"// Factor which can be used to tune the smoothing.; // It is used as multiplicative factor for the fixed and adaptive bandwidth.; // A value < 1 will reproduce better the tails but oversmooth the peak; // while a factor > 1 will overestimate the tail",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:31,Performance,tune,tune,31,"// Factor which can be used to tune the smoothing.; // It is used as multiplicative factor for the fixed and adaptive bandwidth.; // A value < 1 will reproduce better the tails but oversmooth the peak; // while a factor > 1 will overestimate the tail",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:103,Energy Efficiency,adapt,adaptive,103,"// when of reading from a file fKernelFunction is a nullptr; // we need to recreate Kernel class (with adaptive weights if needed) and; // recreate kernel function pointer",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:103,Modifiability,adapt,adaptive,103,"// when of reading from a file fKernelFunction is a nullptr; // we need to recreate Kernel class (with adaptive weights if needed) and; // recreate kernel function pointer",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:11,Availability,robust,robust,11,"// Sigma's robust estimator",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:83,Safety,avoid,avoid,83,"// kernel function pointer must be set to null before calling SetKernelFunction to avoid memory leaks",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:55,Availability,Error,Error,55,"// Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:36,Deployability,Integrat,Integrated,36,"// Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:36,Integrability,Integrat,Integrated,36,"// Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:12,Energy Efficiency,adapt,adaptive,12,"// Gets the adaptive weights (bandwidths) for TKernel internal computation",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:12,Modifiability,adapt,adaptive,12,"// Gets the adaptive weights (bandwidths) for TKernel internal computation",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:26,Energy Efficiency,adapt,adaptive,26,"// we will store computed adaptive weights in weights",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:26,Modifiability,adapt,adaptive,26,"// we will store computed adaptive weights in weights",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:14,Energy Efficiency,Power,Power,14,"// 1 / TMath::Power(2 * TMath::Pi(), .5) * TMath::Exp(-.5). Approximated geometric mean over pointwise data (the KDE function is substituted by the ""real Gaussian"" pdf) and proportional to sigma. Used directly when the mirroring is enabled, otherwise computed from the data; // not sure for this special case for mirror. This results in a much smaller bandwidth for mirror case",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:7,Energy Efficiency,adapt,adaptive,7,"// set adaptive weights in fWeights matrix",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:7,Modifiability,adapt,adaptive,7,"// set adaptive weights in fWeights matrix",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:10,Energy Efficiency,adapt,adaptive,10,"//printf(""adaptive bandwidth factor % f weight 0 %f , %f \n"",fKDE->fAdaptiveBandwidthFactor, weights[0],fWeights[0] );",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:10,Modifiability,adapt,adaptive,10,"//printf(""adaptive bandwidth factor % f weight 0 %f , %f \n"",fKDE->fAdaptiveBandwidthFactor, weights[0],fWeights[0] );",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:124,Availability,error,errors,124,"////////////////////////////////////////////////////////////////////////////////; /// Draws either the KDE functions or its errors; // @param opt : Drawing options:; // - """" (default) - draw just the kde; // - ""same"" draw on top of existing pad; // - ""Errors"" draw a TGraphErrors with the point and errors; // -""confidenceinterval"" draw KDE + conf interval functions (default is 95%); // -""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; // - Extra options can be passed in opt for the drawing of the corresponding TF1 or TGraph; //; // NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); // and GetGraphWithErrors() return the corresponding drawn objects (which are managed by the TKDE); // They can be used to changes style, color, etc..; ////",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:252,Availability,Error,Errors,252,"////////////////////////////////////////////////////////////////////////////////; /// Draws either the KDE functions or its errors; // @param opt : Drawing options:; // - """" (default) - draw just the kde; // - ""same"" draw on top of existing pad; // - ""Errors"" draw a TGraphErrors with the point and errors; // -""confidenceinterval"" draw KDE + conf interval functions (default is 95%); // -""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; // - Extra options can be passed in opt for the drawing of the corresponding TF1 or TGraph; //; // NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); // and GetGraphWithErrors() return the corresponding drawn objects (which are managed by the TKDE); // They can be used to changes style, color, etc..; ////",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:299,Availability,error,errors,299,"////////////////////////////////////////////////////////////////////////////////; /// Draws either the KDE functions or its errors; // @param opt : Drawing options:; // - """" (default) - draw just the kde; // - ""same"" draw on top of existing pad; // - ""Errors"" draw a TGraphErrors with the point and errors; // -""confidenceinterval"" draw KDE + conf interval functions (default is 95%); // -""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; // - Extra options can be passed in opt for the drawing of the corresponding TF1 or TGraph; //; // NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); // and GetGraphWithErrors() return the corresponding drawn objects (which are managed by the TKDE); // They can be used to changes style, color, etc..; ////",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:118,Availability,error,errors,118,"///////////////////////////////////////////////////////////////////////; /// Draws a TGraphErrors with KDE values and errors",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:123,Availability,error,errors,123,"///////////////////////////////////////////////////////////////////////; /// return a TGraphErrors with the KDE values and errors; /// The return object is managed by the user",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:37,Energy Efficiency,adapt,adaptive,37,"// Returns the bandwidth for the non adaptive KDE",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:37,Modifiability,adapt,adaptive,37,"// Returns the bandwidth for the non adaptive KDE",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:34,Energy Efficiency,adapt,adaptive,34,"// Returns the bandwidths for the adaptive KDE",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:34,Modifiability,adapt,adaptive,34,"// Returns the bandwidths for the adaptive KDE",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:37,Energy Efficiency,adapt,adaptive,37,"// Returns the bandwidth for the non adaptive KDE",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:37,Modifiability,adapt,adaptive,37,"// Returns the bandwidth for the non adaptive KDE",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:33,Energy Efficiency,adapt,adaptive,33,"// Returns the bandwidth for the adaptive KDE",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:33,Modifiability,adapt,adaptive,33,"// Returns the bandwidth for the adaptive KDE",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:111,Energy Efficiency,adapt,adaptive,111,"//(useBins) ? fKDE->fSumOfCounts : fKDE->fNEvents;; //if (!useCount) nSum = fKDE->fNEvents;; // in case of non-adaptive fWeights is a vector of size 1",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:111,Modifiability,adapt,adaptive,111,"//(useBins) ? fKDE->fSumOfCounts : fKDE->fNEvents;; //if (!useCount) nSum = fKDE->fNEvents;; // in case of non-adaptive fWeights is a vector of size 1",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:37,Availability,down,down,37,"// uncommenting following line slows down so keep computation for; // zero bincounts; //if (binCount <= 0) continue;",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:11,Availability,robust,robust,11,"// compute robust sigma using midspread",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:11,Availability,robust,robust,11,"// Sigma's robust estimator; //printf(""weight case - stat: m = %f, s= %f, sr = %f \n"",fMean, fSigma, midspread);",MatchSource.CODE_COMMENT,hist/hist/src/TKDE.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:686,Availability,avail,available,686,"// @(#)root/hist:$Id$; // Author: Christophe.Delaere@cern.ch 21/08/2002; ///////////////////////////////////////////////////////////////////////////; //; // TLimit; //; // Class to compute 95% CL limits; //; // adapted from the mclimit code from Tom Junk (CLs method); // see http://root.cern/root/doc/TomJunk.pdf; // see http://cern.ch/thomasj/searchlimits/ecl.html; // see: Tom Junk,NIM A434, p. 435-443, 1999; //; // see also the following interesting references:; // Alex Read, ""Presentation of search results: the CLs technique""; // Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; // http://www.iop.org/EJ/abstract/0954-3899/28/10/313/; //; // A nice article is also available in the CERN yellow report with the proceeding; // of the 2000 CERN workshop on confidence intervals.; //; // Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; // CERN 2000-005 (30 May 2000); //; ///////////////////////////////////////////////////////////////////////////; /** \class TLimit; \legacy{TLimit, Consider switching to RooStats.}; \ingroup Hist; Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006].; See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details. It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. The class TLimitDataSource takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. The class TConfidenceLevel represents the final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and ",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:211,Energy Efficiency,adapt,adapted,211,"// @(#)root/hist:$Id$; // Author: Christophe.Delaere@cern.ch 21/08/2002; ///////////////////////////////////////////////////////////////////////////; //; // TLimit; //; // Class to compute 95% CL limits; //; // adapted from the mclimit code from Tom Junk (CLs method); // see http://root.cern/root/doc/TomJunk.pdf; // see http://cern.ch/thomasj/searchlimits/ecl.html; // see: Tom Junk,NIM A434, p. 435-443, 1999; //; // see also the following interesting references:; // Alex Read, ""Presentation of search results: the CLs technique""; // Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; // http://www.iop.org/EJ/abstract/0954-3899/28/10/313/; //; // A nice article is also available in the CERN yellow report with the proceeding; // of the 2000 CERN workshop on confidence intervals.; //; // Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; // CERN 2000-005 (30 May 2000); //; ///////////////////////////////////////////////////////////////////////////; /** \class TLimit; \legacy{TLimit, Consider switching to RooStats.}; \ingroup Hist; Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006].; See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details. It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. The class TLimitDataSource takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. The class TConfidenceLevel represents the final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and ",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:1415,Integrability,wrap,wrapped,1415,"resting references:; // Alex Read, ""Presentation of search results: the CLs technique""; // Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; // http://www.iop.org/EJ/abstract/0954-3899/28/10/313/; //; // A nice article is also available in the CERN yellow report with the proceeding; // of the 2000 CERN workshop on confidence intervals.; //; // Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; // CERN 2000-005 (30 May 2000); //; ///////////////////////////////////////////////////////////////////////////; /** \class TLimit; \legacy{TLimit, Consider switching to RooStats.}; \ingroup Hist; Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006].; See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details. It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. The class TLimitDataSource takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. The class TConfidenceLevel represents the final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm... From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. ~~~{.cpp}; TFile* infile=new TFile(""",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:211,Modifiability,adapt,adapted,211,"// @(#)root/hist:$Id$; // Author: Christophe.Delaere@cern.ch 21/08/2002; ///////////////////////////////////////////////////////////////////////////; //; // TLimit; //; // Class to compute 95% CL limits; //; // adapted from the mclimit code from Tom Junk (CLs method); // see http://root.cern/root/doc/TomJunk.pdf; // see http://cern.ch/thomasj/searchlimits/ecl.html; // see: Tom Junk,NIM A434, p. 435-443, 1999; //; // see also the following interesting references:; // Alex Read, ""Presentation of search results: the CLs technique""; // Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; // http://www.iop.org/EJ/abstract/0954-3899/28/10/313/; //; // A nice article is also available in the CERN yellow report with the proceeding; // of the 2000 CERN workshop on confidence intervals.; //; // Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)""; // CERN 2000-005 (30 May 2000); //; ///////////////////////////////////////////////////////////////////////////; /** \class TLimit; \legacy{TLimit, Consider switching to RooStats.}; \ingroup Hist; Algorithm to compute 95% CL limits using the Likelihood ratio semi-bayesian method. Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006].; See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details. It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. The class TLimitDataSource takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. The class TConfidenceLevel represents the final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and ",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:2172,Performance,perform,performed,2172,"n method. Implemented by C. Delaere from the mclimit code written by Tom Junk [HEP-EX/9902006].; See [http://cern.ch/thomasj/searchlimits/ecl.html](http://cern.ch/thomasj/searchlimits/ecl.html) for more details. It takes signal, background and data histograms wrapped in a; TLimitDataSource as input and runs a set of Monte Carlo experiments in; order to compute the limits. If needed, inputs are fluctuated according; to systematics. The output is a TConfidenceLevel. The class TLimitDataSource takes the signal, background and data histograms as well as different; systematics sources to form the TLimit input. The class TConfidenceLevel represents the final result of the TLimit algorithm. It is created just after the; time-consuming part and can be stored in a TFile for further processing.; It contains light methods to return CLs, CLb and other interesting; quantities. The actual algorithm... From an input (TLimitDataSource) it produces an output TConfidenceLevel.; For this, nmc Monte Carlo experiments are performed.; As usual, the larger this number, the longer the compute time,; but the better the result. Supposing that there is a plotfile.root file containing 3 histograms; (signal, background and data), you can imagine doing things like:. ~~~{.cpp}; TFile* infile=new TFile(""plotfile.root"",""READ"");; infile->cd();; TH1* sh=(TH1*)infile->Get(""signal"");; TH1* bh=(TH1*)infile->Get(""background"");; TH1* dh=(TH1*)infile->Get(""data"");; TLimitDataSource* mydatasource = new TLimitDataSource(sh,bh,dh);; TConfidenceLevel *myconfidence = TLimit::ComputeLimit(mydatasource,50000);; std::cout << "" CLs : "" << myconfidence->CLs() << std::endl;; std::cout << "" CLsb : "" << myconfidence->CLsb() << std::endl;; std::cout << "" CLb : "" << myconfidence->CLb() << std::endl;; std::cout << ""< CLs > : "" << myconfidence->GetExpectedCLs_b() << std::endl;; std::cout << ""< CLsb > : "" << myconfidence->GetExpectedCLsb_b() << std::endl;; std::cout << ""< CLb > : "" << myconfidence->GetExpectedCLb_b() << std",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:18,Testability,log,log,18,"// precompute the log(1+s/b)'s in an array to speed up computation; // background-free bins are set to have a maximum t.s. value; // for protection (corresponding to s/b of about 5E8)",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:109,Availability,error,errors,109,"// accumulate MC experiments. Hold the test statistic function fixed, but; // fluctuate s and b within syst. errors for computing probabilities of; // having that outcome. (Alex Read's prescription -- errors are on the ensemble,; // not on the observed test statistic. This technique does not split outcomes.); // keep the tstats as sum log(1+s/b). convert to -2lnQ when preparing the results; // (reason -- like to keep the < signs right)",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:201,Availability,error,errors,201,"// accumulate MC experiments. Hold the test statistic function fixed, but; // fluctuate s and b within syst. errors for computing probabilities of; // having that outcome. (Alex Read's prescription -- errors are on the ensemble,; // not on the observed test statistic. This technique does not split outcomes.); // keep the tstats as sum log(1+s/b). convert to -2lnQ when preparing the results; // (reason -- like to keep the < signs right)",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:39,Testability,test,test,39,"// accumulate MC experiments. Hold the test statistic function fixed, but; // fluctuate s and b within syst. errors for computing probabilities of; // having that outcome. (Alex Read's prescription -- errors are on the ensemble,; // not on the observed test statistic. This technique does not split outcomes.); // keep the tstats as sum log(1+s/b). convert to -2lnQ when preparing the results; // (reason -- like to keep the < signs right)",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:253,Testability,test,test,253,"// accumulate MC experiments. Hold the test statistic function fixed, but; // fluctuate s and b within syst. errors for computing probabilities of; // having that outcome. (Alex Read's prescription -- errors are on the ensemble,; // not on the observed test statistic. This technique does not split outcomes.); // keep the tstats as sum log(1+s/b). convert to -2lnQ when preparing the results; // (reason -- like to keep the < signs right)",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:337,Testability,log,log,337,"// accumulate MC experiments. Hold the test statistic function fixed, but; // fluctuate s and b within syst. errors for computing probabilities of; // having that outcome. (Alex Read's prescription -- errors are on the ensemble,; // not on the observed test statistic. This technique does not split outcomes.); // keep the tstats as sum log(1+s/b). convert to -2lnQ when preparing the results; // (reason -- like to keep the < signs right)",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:102,Availability,error,errors,102,"// lrs and lrb are the LR's (no logs) = prob(s+b)/prob(b) for; // that choice of s and b within syst. errors in the ensemble. These are; // the MC experiment weights for relating the s+b and b PDF's of the unsmeared; // test statistic (in which cas one can use another test statistic if one likes).; // Now produce the output object.; // The final quantities are computed on-demand form the arrays tss, tsb, lrs and lrb.",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:32,Testability,log,logs,32,"// lrs and lrb are the LR's (no logs) = prob(s+b)/prob(b) for; // that choice of s and b within syst. errors in the ensemble. These are; // the MC experiment weights for relating the s+b and b PDF's of the unsmeared; // test statistic (in which cas one can use another test statistic if one likes).; // Now produce the output object.; // The final quantities are computed on-demand form the arrays tss, tsb, lrs and lrb.",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:220,Testability,test,test,220,"// lrs and lrb are the LR's (no logs) = prob(s+b)/prob(b) for; // that choice of s and b within syst. errors in the ensemble. These are; // the MC experiment weights for relating the s+b and b PDF's of the unsmeared; // test statistic (in which cas one can use another test statistic if one likes).; // Now produce the output object.; // The final quantities are computed on-demand form the arrays tss, tsb, lrs and lrb.",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:269,Testability,test,test,269,"// lrs and lrb are the LR's (no logs) = prob(s+b)/prob(b) for; // that choice of s and b within syst. errors in the ensemble. These are; // the MC experiment weights for relating the s+b and b PDF's of the unsmeared; // test statistic (in which cas one can use another test statistic if one likes).; // Now produce the output object.; // The final quantities are computed on-demand form the arrays tss, tsb, lrs and lrb.",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx:11,Testability,Log,LogLikelihood,11,"// Compute LogLikelihood (static function)",MatchSource.CODE_COMMENT,hist/hist/src/TLimit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimitDataSource.cxx:168,Availability,error,error,168,"////////////////////////////////////////////////////////////////////////////////; /// Adds a channel with signal, background and data given as input.; /// In addition, error sources are defined.; /// TH1 are here used for convenience: each bin has to be seen as; /// an error source (relative).; /// names is an array of strings containing the names of the sources.; /// Sources with the same name are correlated.",MatchSource.CODE_COMMENT,hist/hist/src/TLimitDataSource.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimitDataSource.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimitDataSource.cxx:270,Availability,error,error,270,"////////////////////////////////////////////////////////////////////////////////; /// Adds a channel with signal, background and data given as input.; /// In addition, error sources are defined.; /// TH1 are here used for convenience: each bin has to be seen as; /// an error source (relative).; /// names is an array of strings containing the names of the sources.; /// Sources with the same name are correlated.",MatchSource.CODE_COMMENT,hist/hist/src/TLimitDataSource.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TLimitDataSource.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:900,Availability,reliab,reliably,900,"// @(#)root/hist:$Id$; // Author: Christian Holm Christensen 07/11/2000; /** \class TMultiDimFit; \ingroup Hist. Multidimensional Fits in ROOT.; ## Overview; A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given i",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:1640,Availability,error,errors,1640,"sists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow). \f[; \left(\mathbf{x}_j, D_j, E_j\right)\quad,; \f]; where \f$\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})\f$ are \f$ N\f$ independent; variables, \f$ D_j\f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the param",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:2523,Availability,error,error,2523,"ound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow). \f[; \left(\mathbf{x}_j, D_j, E_j\right)\quad,; \f]; where \f$\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})\f$ are \f$ N\f$ independent; variables, \f$ D_j\f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the parameterization; \f[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$, and the \f$ L\f$ coefficients \f$ c_l\f$, so that \f$ S\f$ is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that \f$ S\f$ will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered mi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3412,Availability,error,error,3412,"f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the parameterization; \f[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$, and the \f$ L\f$ coefficients \f$ c_l\f$, so that \f$ S\f$ is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that \f$ S\f$ will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered minimized when. \f[; R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon; \f]; Optionally, the user may impose a functional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:12076,Availability,Error,Errors,12076,"\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) can be written as; \f[; \mathsf{F} = \mathsf{W}\mathsf{B}; \f]; where; \f{eqnarray*}{; b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}; & \mbox{if} & i < j\\; 1 & \mbox{if} & i = j\\; 0 & \mbox{if} & i > j; \f}; Consequently, \f$\mathsf{B}\f$ is an upper triangle matrix, which can be; readily inverted. So we now evaluate; \f[; \mathsf{F}\mathsf{B}^{-1} = \mathsf{W}; \f]; The model \f$\mathsf{W}\mathbf{a}\f$ can therefore be written as; \f$(\mathsf{F}\mathsf{B}^{-1})\mathbf{a} = \mathsf{F}(\mathsf{B}^{-1}\mathbf{a})\,.\f$. The original model \f$\mathsf{F}\mathbf{c}\f$ is therefore identical with; this if; \f[; \mathbf{c} = \left(\mathsf{B}^{-1}\mathbf{a}\right) =; \left[\mathbf{a}^T\l",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:13434,Availability,error,errors,13434,"*}{; b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}; & \mbox{if} & i < j\\; 1 & \mbox{if} & i = j\\; 0 & \mbox{if} & i > j; \f}; Consequently, \f$\mathsf{B}\f$ is an upper triangle matrix, which can be; readily inverted. So we now evaluate; \f[; \mathsf{F}\mathsf{B}^{-1} = \mathsf{W}; \f]; The model \f$\mathsf{W}\mathbf{a}\f$ can therefore be written as; \f$(\mathsf{F}\mathsf{B}^{-1})\mathbf{a} = \mathsf{F}(\mathsf{B}^{-1}\mathbf{a})\,.\f$. The original model \f$\mathsf{F}\mathbf{c}\f$ is therefore identical with; this if; \f[; \mathbf{c} = \left(\mathsf{B}^{-1}\mathbf{a}\right) =; \left[\mathbf{a}^T\left(\mathsf{B}^{-1}\right)^T\right]^T\,.; \f]; The reason we use \f$\left(\mathsf{B}^{-1}\right)^T\f$ rather then; \f$\mathsf{B}^{-1}\f$ is to save storage, since \f$\left(\mathsf{B}^{-1}\right)^T\f$; can be stored in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. D",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16647,Availability,error,error,16647,"{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16917,Availability,error,error,16917,"e \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Computations*.; John Hopkins University Press, Baltimore, 3 edition, 1996.; - <a name=""minuit""></a>F. James. *Minuit*. Long writeup D506, CERN, 1998.; - <a name=""wind72""></a>H. Wind. *Function p",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17595,Availability,Error,Error,17595,"$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Computations*.; John Hopkins University Press, Baltimore, 3 edition, 1996.; - <a name=""minuit""></a>F. James. *Minuit*. Long writeup D506, CERN, 1998.; - <a name=""wind72""></a>H. Wind. *Function parameterization*. Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; - <a name=""wind81""></a>H. Wind. 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation. Yellow report EP/81-12, CERN, 1981. [1]: classTMultiDimFit.html#bevington; [2]: classTMultiDimFit.html#mudifi; [4]: classTMultiDimFit.html#minuit; [5]: classTMultiDimFit.html#wind72; [6]: classTMultiDimFit.html#wind81; [9]: classTMultiDimFit.html#eq:dS2; */",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:357,Energy Efficiency,energy,energy,357,"// @(#)root/hist:$Id$; // Author: Christian Holm Christensen 07/11/2000; /** \class TMultiDimFit; \ingroup Hist. Multidimensional Fits in ROOT.; ## Overview; A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given i",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:412,Energy Efficiency,charge,charged,412,"// @(#)root/hist:$Id$; // Author: Christian Holm Christensen 07/11/2000; /** \class TMultiDimFit; \ingroup Hist. Multidimensional Fits in ROOT.; ## Overview; A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given i",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3650,Energy Efficiency,power,powers,3650,"rod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$, and the \f$ L\f$ coefficients \f$ c_l\f$, so that \f$ S\f$ is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that \f$ S\f$ will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered minimized when. \f[; R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon; \f]; Optionally, the user may impose a functional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the depen",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4391,Energy Efficiency,power,power,4391,"tlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered minimized when. \f[; R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon; \f]; Optionally, the user may impose a functional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4568,Energy Efficiency,power,power,4568,"nctional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4713,Energy Efficiency,power,power,4713,"efficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)). The functions \f$ F_l\f$ are",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4752,Energy Efficiency,power,power,4752,"efficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)). The functions \f$ F_l\f$ are",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:5082,Energy Efficiency,power,power,5082,"max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)). The functions \f$ F_l\f$ are generally not orthogonal, which means one will; have to evaluate all possible \f$ F_l\f$'s over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the *modified Gram-Schmidt; orthogonalisation* algorithm [5] [3] to the; functions \f$ F_l\f$, we can evaluate the contribution to the reduction of; \f$ S\f$ from each function in turn, and we may delay the actual inv",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:5288,Energy Efficiency,power,power,5288,"max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)). The functions \f$ F_l\f$ are generally not orthogonal, which means one will; have to evaluate all possible \f$ F_l\f$'s over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the *modified Gram-Schmidt; orthogonalisation* algorithm [5] [3] to the; functions \f$ F_l\f$, we can evaluate the contribution to the reduction of; \f$ S\f$ from each function in turn, and we may delay the actual inv",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:5499,Energy Efficiency,reduce,reduce,5499,"taining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)). The functions \f$ F_l\f$ are generally not orthogonal, which means one will; have to evaluate all possible \f$ F_l\f$'s over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the *modified Gram-Schmidt; orthogonalisation* algorithm [5] [3] to the; functions \f$ F_l\f$, we can evaluate the contribution to the reduction of; \f$ S\f$ from each function in turn, and we may delay the actual inversion; of the curvature-matrix (TMultiDimFit::MakeGramSchmidt). So we are let to consider an \f$ M\times L\f$ matrix \f$\mathsf{F}\f$, an; element of which is given by; \f[; f_{jl} = F_j\left(x_{1j} , x_{2j}, \ldots, x_{Nj}\right); = F_l(\mathbf{x}_j)\, \quad\mbox{with}~j=1,2,\ldots,M,; \f]; where \f$ j\f$ labels the \f$ M\f$ row",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:5596,Energy Efficiency,reduce,reduce,5596,"taining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)). The functions \f$ F_l\f$ are generally not orthogonal, which means one will; have to evaluate all possible \f$ F_l\f$'s over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the *modified Gram-Schmidt; orthogonalisation* algorithm [5] [3] to the; functions \f$ F_l\f$, we can evaluate the contribution to the reduction of; \f$ S\f$ from each function in turn, and we may delay the actual inversion; of the curvature-matrix (TMultiDimFit::MakeGramSchmidt). So we are let to consider an \f$ M\times L\f$ matrix \f$\mathsf{F}\f$, an; element of which is given by; \f[; f_{jl} = F_j\left(x_{1j} , x_{2j}, \ldots, x_{Nj}\right); = F_l(\mathbf{x}_j)\, \quad\mbox{with}~j=1,2,\ldots,M,; \f]; where \f$ j\f$ labels the \f$ M\f$ row",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11959,Energy Efficiency,reduce,reduced,11959," readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) can be written as; \f[; \mathsf{F} = \mathsf{W}\mathsf{B}; \f]; where; \f{eqnarray*}{; b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}; & \mbox{if} & i < j\\; 1 & \mbox{if} & i = j\\; 0 & \mbox{if} & i > j; \f}; Consequently, \f$\mathsf{B}\f$ is an upper triangle matrix, which can be; readily inverted. So we now evaluate; \f[; \mathsf{F}\mathsf{B}^{-1} = \mathsf{W}; \f]; The model \f$\mathsf{W}\mathbf{a}\f$ can therefore be written as; \f$(\mathsf{F}\mathsf{B}^{-",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17254,Energy Efficiency,reduce,reduced,17254,"er the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Computations*.; John Hopkins University Press, Baltimore, 3 edition, 1996.; - <a name=""minuit""></a>F. James. *Minuit*. Long writeup D506, CERN, 1998.; - <a name=""wind72""></a>H. Wind. *Function parameterization*. Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; - <a name=""wind81""></a>H. Wind. 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation. Yellow report EP/81-12, CERN, 1981.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17387,Energy Efficiency,reduce,reduced,17387,"er the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Computations*.; John Hopkins University Press, Baltimore, 3 edition, 1996.; - <a name=""minuit""></a>F. James. *Minuit*. Long writeup D506, CERN, 1998.; - <a name=""wind72""></a>H. Wind. *Function parameterization*. Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; - <a name=""wind81""></a>H. Wind. 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation. Yellow report EP/81-12, CERN, 1981.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:757,Integrability,depend,dependent,757,"// @(#)root/hist:$Id$; // Author: Christian Holm Christensen 07/11/2000; /** \class TMultiDimFit; \ingroup Hist. Multidimensional Fits in ROOT.; ## Overview; A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given i",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:927,Integrability,depend,dependence,927,"// @(#)root/hist:$Id$; // Author: Christian Holm Christensen 07/11/2000; /** \class TMultiDimFit; \ingroup Hist. Multidimensional Fits in ROOT.; ## Overview; A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given i",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:1142,Integrability,depend,dependent,1142,"00; /** \class TMultiDimFit; \ingroup Hist. Multidimensional Fits in ROOT.; ## Overview; A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quant",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:2054,Integrability,depend,dependent,2054,"mple of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow). \f[; \left(\mathbf{x}_j, D_j, E_j\right)\quad,; \f]; where \f$\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})\f$ are \f$ N\f$ independent; variables, \f$ D_j\f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the parameterization; \f[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$,",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:2092,Integrability,depend,depends,2092,"mple of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow). \f[; \left(\mathbf{x}_j, D_j, E_j\right)\quad,; \f]; where \f$\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})\f$ are \f$ N\f$ independent; variables, \f$ D_j\f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the parameterization; \f[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$,",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:2461,Integrability,depend,dependent,2461,"ound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow). \f[; \left(\mathbf{x}_j, D_j, E_j\right)\quad,; \f]; where \f$\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})\f$ are \f$ N\f$ independent; variables, \f$ D_j\f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the parameterization; \f[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$, and the \f$ L\f$ coefficients \f$ c_l\f$, so that \f$ S\f$ is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that \f$ S\f$ will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered mi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4632,Integrability,depend,dependent,4632,"nctional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:7627,Integrability,depend,dependent,7627,"ample and \f$ l\f$ labels; \f$ L\f$ functions of \f$ N\f$ variables, and \f$ L \leq M\f$. That is, \f$ f_{jl}\f$ is; the term (or function) numbered \f$ l\f$ evaluated at the data point; \f$ j\f$. We have to normalise \f$\mathbf{x}_j\f$ to \f$ [-1,1]\f$ for this to; succeed [5] (TMultiDimFit::MakeNormalized). We then define a; matrix \f$\mathsf{W}\f$ of which the columns \f$\mathbf{w}_j\f$ are given by; \f{eqnarray*}{; \mathbf{w}_1 &=& \mathbf{f}_1 = F_1\left(\mathbf x_1\right)\\; \mathbf{w}_l &=& \mathbf{f}_l - \sum^{l-1}_{k=1} \frac{\mathbf{f}_l \bullet; \mathbf{w}_k}{\mathbf{w}_k^2}\mathbf{w}_k\,.; \f}; and \f$\mathbf{w}_{l}\f$ is the component of \f$\mathbf{f}_{l} \f$ orthogonal; to \f$\mathbf{w}_{1}, \ldots, \mathbf{w}_{l-1}\f$. Hence we obtain [3],; \f[; \mathbf{w}_k\bullet\mathbf{w}_l = 0\quad\mbox{if}~k \neq l\quad.; \f]; We now take as a new model \f$\mathsf{W}\mathbf{a}\f$. We thus want to; minimize; \f[; S\equiv \left(\mathbf{D} - \mathsf{W}\mathbf{a}\right)^2\quad,; \f]; where \f$\mathbf{D} = \left(D_1,\ldots,D_M\right)\f$ is a vector of the; dependent quantity in the sample. Differentiation with respect to; \f$ a_j\f$ gives, using [6], <a name=""eq:dS2""></a>; \f[; \mathbf{D}\bullet\mathbf{w}_l - a_l\mathbf{w}_l^2 = 0; \f]; or; \f[; a_l = \frac{\mathbf{D}_l\bullet\mathbf{w}_l}{\mathbf{w}_l^2}; \f]; Let \f$ S_j\f$ be the sum of squares of residuals when taking \f$ j\f$ functions; into account. Then; \f[; S_l = \left[\mathbf{D} - \sum^l_{k=1} a_k\mathbf{w}_k\right]^2; = \mathbf{D}^2 - 2\mathbf{D} \sum^l_{k=1} a_k\mathbf{w}_k; + \sum^l_{k=1} a_k^2\mathbf{w}_k^2; \f]; Using [9], we see that; \f{eqnarray*}{; S_l &=& \mathbf{D}^2 - 2 \sum^l_{k=1} a_k^2\mathbf{w}_k^2 +; \sum^j_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\; &=& \mathbf{D}^2 - \sum^l_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\; &=& \mathbf{D}^2 - \sum^l_{k=1} \frac{\left(\mathbf D\bullet \mathbf; w_k\right)}{\mathbf w_k^2}; \f}; So for each new function \f$ F_l\f$ included in the model, we get a; reduction of the",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:14360,Integrability,depend,dependence,14360,"red in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Princi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:14567,Integrability,depend,dependent,14567,"(TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16593,Integrability,depend,dependent,16593,"{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:1331,Modifiability,variab,variables,1331,"terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; <I>least squares</I> fitting procedure applied to a representative; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class <TT>TMultiDimFit</TT> implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package [2].; Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:2416,Modifiability,variab,variables,2416,"ound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow). \f[; \left(\mathbf{x}_j, D_j, E_j\right)\quad,; \f]; where \f$\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})\f$ are \f$ N\f$ independent; variables, \f$ D_j\f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the parameterization; \f[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$, and the \f$ L\f$ coefficients \f$ c_l\f$, so that \f$ S\f$ is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that \f$ S\f$ will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered mi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:2575,Modifiability,parameteriz,parameterization,2575,"ound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow). \f[; \left(\mathbf{x}_j, D_j, E_j\right)\quad,; \f]; where \f$\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})\f$ are \f$ N\f$ independent; variables, \f$ D_j\f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the parameterization; \f[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$, and the \f$ L\f$ coefficients \f$ c_l\f$, so that \f$ S\f$ is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that \f$ S\f$ will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered mi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:2944,Modifiability,variab,variable,2944,"on, and I refer these two excellents; text for more information. And example of usage is given in multidimfit.C. ## The Method; Let \f$ D \f$ by the dependent quantity of interest, which depends smoothly; on the observable quantities \f$ x_1, \ldots, x_N \f$ which we'll denote by; \f$\mathbf{x}\f$. Given a training sample of \f$ M\f$ tuples of the form, (TMultiDimFit::AddRow). \f[; \left(\mathbf{x}_j, D_j, E_j\right)\quad,; \f]; where \f$\mathbf{x}_j = (x_{1,j},\ldots,x_{N,j})\f$ are \f$ N\f$ independent; variables, \f$ D_j\f$ is the known, quantity dependent at \f$\mathbf{x}_j\f$ and \f$ E_j\f$ is; the square error in \f$ D_j\f$, the class will try to find the parameterization; \f[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$, and the \f$ L\f$ coefficients \f$ c_l\f$, so that \f$ S\f$ is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that \f$ S\f$ will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered minimized when. \f[; R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon; \f]; Optionally, the user may impose a functional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3665,Modifiability,variab,variable,3665,"rod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \f]; such that. \f[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \f]; is minimal. Here \f$p_{li}(x_i)\f$ are monomials, or Chebyshev or Legendre; polynomials, labelled \f$l = 1, \ldots, L\f$, in each variable \f$ x_i\f$,\f$ i=1, \ldots, N\f$. So what TMultiDimFit does, is to determine the number of terms \f$ L\f$, and then \f$ L\f$ terms; (or functions) \f$ F_l\f$, and the \f$ L\f$ coefficients \f$ c_l\f$, so that \f$ S\f$ is minimal; (TMultiDimFit::FindParameterization). Of course it's more than a little unlikely that \f$ S\f$ will ever become; exact zero as a result of the procedure outlined below. Therefore, the; user is asked to provide a minimum relative error \f$ \epsilon\f$ (TMultiDimFit::SetMinRelativeError),; and \f$ S\f$ will be considered minimized when. \f[; R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon; \f]; Optionally, the user may impose a functional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the depen",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4424,Modifiability,variab,variable,4424,"iveError),; and \f$ S\f$ will be considered minimized when. \f[; R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon; \f]; Optionally, the user may impose a functional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4577,Modifiability,variab,variable,4577,"nctional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:5297,Modifiability,variab,variable,5297,"max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)). The functions \f$ F_l\f$ are generally not orthogonal, which means one will; have to evaluate all possible \f$ F_l\f$'s over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the *modified Gram-Schmidt; orthogonalisation* algorithm [5] [3] to the; functions \f$ F_l\f$, we can evaluate the contribution to the reduction of; \f$ S\f$ from each function in turn, and we may delay the actual inv",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:6614,Modifiability,variab,variables,6614,"ram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see [2.3](TMultiFimFit.html#sec:selectiondetail)). The functions \f$ F_l\f$ are generally not orthogonal, which means one will; have to evaluate all possible \f$ F_l\f$'s over all data-points before; finding the most significant [1]. We can, however, do; better then that. By applying the *modified Gram-Schmidt; orthogonalisation* algorithm [5] [3] to the; functions \f$ F_l\f$, we can evaluate the contribution to the reduction of; \f$ S\f$ from each function in turn, and we may delay the actual inversion; of the curvature-matrix (TMultiDimFit::MakeGramSchmidt). So we are let to consider an \f$ M\times L\f$ matrix \f$\mathsf{F}\f$, an; element of which is given by; \f[; f_{jl} = F_j\left(x_{1j} , x_{2j}, \ldots, x_{Nj}\right); = F_l(\mathbf{x}_j)\, \quad\mbox{with}~j=1,2,\ldots,M,; \f]; where \f$ j\f$ labels the \f$ M\f$ rows in the training sample and \f$ l\f$ labels; \f$ L\f$ functions of \f$ N\f$ variables, and \f$ L \leq M\f$. That is, \f$ f_{jl}\f$ is; the term (or function) numbered \f$ l\f$ evaluated at the data point; \f$ j\f$. We have to normalise \f$\mathbf{x}_j\f$ to \f$ [-1,1]\f$ for this to; succeed [5] (TMultiDimFit::MakeNormalized). We then define a; matrix \f$\mathsf{W}\f$ of which the columns \f$\mathbf{w}_j\f$ are given by; \f{eqnarray*}{; \mathbf{w}_1 &=& \mathbf{f}_1 = F_1\left(\mathbf x_1\right)\\; \mathbf{w}_l &=& \mathbf{f}_l - \sum^{l-1}_{k=1} \frac{\mathbf{f}_l \bullet; \mathbf{w}_k}{\mathbf{w}_k^2}\mathbf{w}_k\,.; \f}; and \f$\mathbf{w}_{l}\f$ is the component of \f$\mathbf{f}_{l} \f$ orthogonal; to \f$\mathbf{w}_{1}, \ldots, \mathbf{w}_{l-1}\f$. Hence we obtain [3],; \f[; \mathbf{w}_k\bullet\mathbf{w}_l = 0\quad\mbox{if}~k \neq l\quad.; \f]; We now take as a new model \f$\mathsf{W}\mathbf{a}\f$. We t",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:12099,Modifiability,parameteriz,parameterization,12099,"\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) can be written as; \f[; \mathsf{F} = \mathsf{W}\mathsf{B}; \f]; where; \f{eqnarray*}{; b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}; & \mbox{if} & i < j\\; 1 & \mbox{if} & i = j\\; 0 & \mbox{if} & i > j; \f}; Consequently, \f$\mathsf{B}\f$ is an upper triangle matrix, which can be; readily inverted. So we now evaluate; \f[; \mathsf{F}\mathsf{B}^{-1} = \mathsf{W}; \f]; The model \f$\mathsf{W}\mathbf{a}\f$ can therefore be written as; \f$(\mathsf{F}\mathsf{B}^{-1})\mathbf{a} = \mathsf{F}(\mathsf{B}^{-1}\mathbf{a})\,.\f$. The original model \f$\mathsf{F}\mathbf{c}\f$ is therefore identical with; this if; \f[; \mathbf{c} = \left(\mathsf{B}^{-1}\mathbf{a}\right) =; \left[\mathbf{a}^T\l",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:13905,Modifiability,variab,variables,13905,"B}^{-1}\mathbf{a})\,.\f$. The original model \f$\mathsf{F}\mathbf{c}\f$ is therefore identical with; this if; \f[; \mathbf{c} = \left(\mathsf{B}^{-1}\mathbf{a}\right) =; \left[\mathbf{a}^T\left(\mathsf{B}^{-1}\right)^T\right]^T\,.; \f]; The reason we use \f$\left(\mathsf{B}^{-1}\right)^T\f$ rather then; \f$\mathsf{B}^{-1}\f$ is to save storage, since \f$\left(\mathsf{B}^{-1}\right)^T\f$; can be stored in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:14080,Modifiability,variab,variables,14080,"^{-1}\right)^T\right]^T\,.; \f]; The reason we use \f$\left(\mathsf{B}^{-1}\right)^T\f$ rather then; \f$\mathsf{B}^{-1}\f$ is to save storage, since \f$\left(\mathsf{B}^{-1}\right)^T\f$; can be stored in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (usi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:14136,Modifiability,variab,variables,14136,"^{-1}\right)^T\right]^T\,.; \f]; The reason we use \f$\left(\mathsf{B}^{-1}\right)^T\f$ rather then; \f$\mathsf{B}^{-1}\f$ is to save storage, since \f$\left(\mathsf{B}^{-1}\right)^T\f$; can be stored in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (usi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:14249,Modifiability,variab,variable,14249,"^{-1}\right)^T\right]^T\,.; \f]; The reason we use \f$\left(\mathsf{B}^{-1}\right)^T\f$ rather then; \f$\mathsf{B}^{-1}\f$ is to save storage, since \f$\left(\mathsf{B}^{-1}\right)^T\f$; can be stored in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (usi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:14402,Modifiability,variab,variables,14402,"red in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Princi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:15659,Modifiability,variab,variables,15659,"ent values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the sq",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:15854,Modifiability,parameteriz,parameterization,15854,"ximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mat",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16236,Modifiability,parameteriz,parameterization,16236,"strained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples in",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16342,Modifiability,parameteriz,parameterization,16342,"strained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples in",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16556,Modifiability,variab,variables,16556,"{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16703,Modifiability,parameteriz,parameterization,16703,"bservation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Compu",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17989,Modifiability,parameteriz,parameterization,17989,"$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Computations*.; John Hopkins University Press, Baltimore, 3 edition, 1996.; - <a name=""minuit""></a>F. James. *Minuit*. Long writeup D506, CERN, 1998.; - <a name=""wind72""></a>H. Wind. *Function parameterization*. Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; - <a name=""wind81""></a>H. Wind. 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation. Yellow report EP/81-12, CERN, 1981. [1]: classTMultiDimFit.html#bevington; [2]: classTMultiDimFit.html#mudifi; [4]: classTMultiDimFit.html#minuit; [5]: classTMultiDimFit.html#wind72; [6]: classTMultiDimFit.html#wind81; [9]: classTMultiDimFit.html#eq:dS2; */",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:4603,Performance,perform,perform,4603,"nctional expression by specifying; the powers of each variable in \f$ L\f$ specified functions \f$ F_1, \ldots,F_L\f$ (TMultiDimFit::SetPowers).; In that case, only the coefficients \f$ c_l\f$ is calculated by the class. ## Limiting the Number of Terms; As always when dealing with fits, there's a real chance of *over fitting*. As is well-known, it's; always possible to fit an \f$ N-1\f$ polynomial in \f$ x\f$ to \f$ N\f$ points \f$ (x,y)\f$ with; \f$\chi^2 = 0\f$, but the polynomial is not likely to fit new data at all [1].; Therefore, the user is asked to provide an upper limit, \f$ L_{max}\f$ to the number of terms in; \f$ D_p\f$ (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of \f$ F_l\f$ to choose from, the; user is asked to give the maximum power. \f$ P_{max,i}\f$, of each variable; \f$ x_i\f$ to be considered in the minimization of \f$ S\f$ (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable \f$ i\f$, is; to perform a regular fit to the dependent quantity \f$ D\f$, using a; polynomial only in \f$ x_i\f$. The maximum power is \f$ P_{max,i}\f$ is then the; power that does not significantly improve the one-dimensional; least-square fit over \f$ x_i\f$ to \f$ D\f$ [5]. There are still a huge amount of possible choices for \f$ F_l\f$; in fact; there are \f$\prod_{i=1}^{N} (P_{max,i} + 1)\f$ possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a *power control limit*, \f$ Q\f$ (TMultiDimFit::SetPowerLimit), and a function; \f$ F_l\f$ is only accepted if; \f[; Q_l = \sum_{i=1}^{N} \frac{P_{li}}{P_{max,i}} < Q; \f]; where \f$ P_{li}\f$ is the leading power of variable \f$ x_i\f$ in function \f$ F_l\f$ (TMultiDimFit::MakeCandidates).; So the number of functions increase with \f$ Q\f$ (1, 2 is fine, 5 is way out). ## Gram-Schmidt Orthogonalisation; To further reduce the number of functions in the final expression,; only those functions that significantly reduce \f$ S\f$ ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:8932,Performance,perform,performed,8932,"ares of residuals when taking \f$ j\f$ functions; into account. Then; \f[; S_l = \left[\mathbf{D} - \sum^l_{k=1} a_k\mathbf{w}_k\right]^2; = \mathbf{D}^2 - 2\mathbf{D} \sum^l_{k=1} a_k\mathbf{w}_k; + \sum^l_{k=1} a_k^2\mathbf{w}_k^2; \f]; Using [9], we see that; \f{eqnarray*}{; S_l &=& \mathbf{D}^2 - 2 \sum^l_{k=1} a_k^2\mathbf{w}_k^2 +; \sum^j_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\; &=& \mathbf{D}^2 - \sum^l_{k=1} a_k^2\mathbf{w}_k^2\nonumber\\; &=& \mathbf{D}^2 - \sum^l_{k=1} \frac{\left(\mathbf D\bullet \mathbf; w_k\right)}{\mathbf w_k^2}; \f}; So for each new function \f$ F_l\f$ included in the model, we get a; reduction of the sum of squares of residuals of \f$a_l^2\mathbf{w}_l^2\f$,; where \f$\mathbf{w}_l\f$ is given by [4] and \f$ a_l\f$ by [9]. Thus, using; the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; *before* the matrix inversion. ## Function Selection Based on Residual; Supposing that \f$ L-1\f$ steps of the procedure have been performed, the; problem now is to consider the \f$L^{\mbox{th}}\f$ function. The sum of squares of residuals can be written as; \f[; S_L = \textbf{D}^T\bullet\textbf{D} -; \sum^L_{l=1}a^2_l\left(\textbf{w}_l^T\bullet\textbf{w}_l\right); \f]; where the relation [9] have been taken into account. The; contribution of the \f$L^{\mbox{th}}\f$ function to the reduction of S, is; given by; \f[; \Delta S_L = a^2_L\left(\textbf{w}_L^T\bullet\textbf{w}_L\right); \f]; Two test are now applied to decide whether this \f$L^{\mbox{th}}\f$; function is to be included in the final expression, or not. ## Test 1; Denoting by \f$ H_{L-1}\f$ the subspace spanned by \f$\textbf{w}_1,\ldots,\textbf{w}_{L-1}\f$; the function \f$\textbf{w}_L\f$ is by construction (see 4) the projection of the function; \f$ F_L\f$ onto the direction perpendicular to \f$ H_{L-1}\f$. Now, if the; length of \f$\textbf{w}_L\f$ (given by \f$\textbf{w}_L\bullet\textbf{w}_L\f$); is very small compared to the length of \f$\t",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11254,Performance,perform,performing,11254,"$ \\phi \\f$ between \\f$\\textbf{w}_L\\f$ and \\f$\\textbf{D}\\f$"". ## Test 2; Let \f$\textbf{D}\f$ be the data vector to be fitted. As illustrated in; figure 1, the \f$L^{\mbox{th}}\f$ function \f$\textbf{w}_L\f$; will contribute significantly to the reduction of \f$ S\f$, if the angle; \f$\phi^\prime\f$ between \f$\textbf{w}_L\f$ and \f$\textbf{D}\f$ is smaller than; an upper limit \f$ \phi \f$, defined by the user (MultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) c",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11802,Performance,perform,perform,11802,"nd \f$\textbf{D}\f$ is smaller than; an upper limit \f$ \phi \f$, defined by the user (MultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) can be written as; \f[; \mathsf{F} = \mathsf{W}\mathsf{B}; \f]; where; \f{eqnarray*}{; b_{ij} = \frac{\mathbf{f}_j \bullet \mathbf{w}_i}{\mathbf{w}_i^2}; & \mbox{if} & i < j\\; 1 & \mbox{if} & i = j\\; 0 & \mbox{if} & i > j; \f}; Consequently, \f$\mathsf{B}\f$ is an upper triangle matrix, which can be; readily inverted. So we now evalua",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:13985,Performance,perform,perform,13985,"B}^{-1}\mathbf{a})\,.\f$. The original model \f$\mathsf{F}\mathbf{c}\f$ is therefore identical with; this if; \f[; \mathbf{c} = \left(\mathsf{B}^{-1}\mathbf{a}\right) =; \left[\mathbf{a}^T\left(\mathsf{B}^{-1}\right)^T\right]^T\,.; \f]; The reason we use \f$\left(\mathsf{B}^{-1}\right)^T\f$ rather then; \f$\mathsf{B}^{-1}\f$ is to save storage, since \f$\left(\mathsf{B}^{-1}\right)^T\f$; can be stored in the same matrix as \f$\mathsf{B}\f$ (TMultiDimFit::MakeCoefficients).; The errors in the coefficients is calculated by inverting the curvature matrix; of the non-orthogonal functions \f$ f_{lj}\f$ [1] (TMultiDimFit::MakeCoefficientErrors). ## Considerations; It's important to realize that the training sample should be; representative of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a *interpolation*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:15112,Performance,Perform,Perform,15112,"d; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:15336,Performance,Perform,Perform,15336,"5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tu",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:9398,Testability,test,test,9398,"athbf{D}^2 - \sum^l_{k=1} \frac{\left(\mathbf D\bullet \mathbf; w_k\right)}{\mathbf w_k^2}; \f}; So for each new function \f$ F_l\f$ included in the model, we get a; reduction of the sum of squares of residuals of \f$a_l^2\mathbf{w}_l^2\f$,; where \f$\mathbf{w}_l\f$ is given by [4] and \f$ a_l\f$ by [9]. Thus, using; the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; *before* the matrix inversion. ## Function Selection Based on Residual; Supposing that \f$ L-1\f$ steps of the procedure have been performed, the; problem now is to consider the \f$L^{\mbox{th}}\f$ function. The sum of squares of residuals can be written as; \f[; S_L = \textbf{D}^T\bullet\textbf{D} -; \sum^L_{l=1}a^2_l\left(\textbf{w}_l^T\bullet\textbf{w}_l\right); \f]; where the relation [9] have been taken into account. The; contribution of the \f$L^{\mbox{th}}\f$ function to the reduction of S, is; given by; \f[; \Delta S_L = a^2_L\left(\textbf{w}_L^T\bullet\textbf{w}_L\right); \f]; Two test are now applied to decide whether this \f$L^{\mbox{th}}\f$; function is to be included in the final expression, or not. ## Test 1; Denoting by \f$ H_{L-1}\f$ the subspace spanned by \f$\textbf{w}_1,\ldots,\textbf{w}_{L-1}\f$; the function \f$\textbf{w}_L\f$ is by construction (see 4) the projection of the function; \f$ F_L\f$ onto the direction perpendicular to \f$ H_{L-1}\f$. Now, if the; length of \f$\textbf{w}_L\f$ (given by \f$\textbf{w}_L\bullet\textbf{w}_L\f$); is very small compared to the length of \f$\textbf{f}_L\f$ this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; \f$ \theta \f$ between the two vectors \f$\textbf{w}_L\f$ \f$ \textbf {f}_L\f$; (see also figure 1) and requiring that it's; *greater* then a threshold value which the user must set (TMultiDimFit::SetMinAngle). \image html multidimfit_img86.gif ""Figure 1: (a) angle \\f$\\theta\\f$ between \\f$",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:9526,Testability,Test,Test,9526," [4] and \f$ a_l\f$ by [9]. Thus, using; the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; *before* the matrix inversion. ## Function Selection Based on Residual; Supposing that \f$ L-1\f$ steps of the procedure have been performed, the; problem now is to consider the \f$L^{\mbox{th}}\f$ function. The sum of squares of residuals can be written as; \f[; S_L = \textbf{D}^T\bullet\textbf{D} -; \sum^L_{l=1}a^2_l\left(\textbf{w}_l^T\bullet\textbf{w}_l\right); \f]; where the relation [9] have been taken into account. The; contribution of the \f$L^{\mbox{th}}\f$ function to the reduction of S, is; given by; \f[; \Delta S_L = a^2_L\left(\textbf{w}_L^T\bullet\textbf{w}_L\right); \f]; Two test are now applied to decide whether this \f$L^{\mbox{th}}\f$; function is to be included in the final expression, or not. ## Test 1; Denoting by \f$ H_{L-1}\f$ the subspace spanned by \f$\textbf{w}_1,\ldots,\textbf{w}_{L-1}\f$; the function \f$\textbf{w}_L\f$ is by construction (see 4) the projection of the function; \f$ F_L\f$ onto the direction perpendicular to \f$ H_{L-1}\f$. Now, if the; length of \f$\textbf{w}_L\f$ (given by \f$\textbf{w}_L\bullet\textbf{w}_L\f$); is very small compared to the length of \f$\textbf{f}_L\f$ this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; \f$ \theta \f$ between the two vectors \f$\textbf{w}_L\f$ \f$ \textbf {f}_L\f$; (see also figure 1) and requiring that it's; *greater* then a threshold value which the user must set (TMultiDimFit::SetMinAngle). \image html multidimfit_img86.gif ""Figure 1: (a) angle \\f$\\theta\\f$ between \\f$\\textbf{w}_l\\f$ and \\f$\\textbf{f}_L\\f$, (b) angle \\f$ \\phi \\f$ between \\f$\\textbf{w}_L\\f$ and \\f$\\textbf{D}\\f$"". ## Test 2; Let \f$\textbf{D}\f$ be the data vector to be fitted. As illustrated in; figure 1, the \f$L^{\mbox{th}}\f$ function \f$\textbf{w}_L\f$; will",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:10035,Testability,test,test,10035,"\right); \f]; where the relation [9] have been taken into account. The; contribution of the \f$L^{\mbox{th}}\f$ function to the reduction of S, is; given by; \f[; \Delta S_L = a^2_L\left(\textbf{w}_L^T\bullet\textbf{w}_L\right); \f]; Two test are now applied to decide whether this \f$L^{\mbox{th}}\f$; function is to be included in the final expression, or not. ## Test 1; Denoting by \f$ H_{L-1}\f$ the subspace spanned by \f$\textbf{w}_1,\ldots,\textbf{w}_{L-1}\f$; the function \f$\textbf{w}_L\f$ is by construction (see 4) the projection of the function; \f$ F_L\f$ onto the direction perpendicular to \f$ H_{L-1}\f$. Now, if the; length of \f$\textbf{w}_L\f$ (given by \f$\textbf{w}_L\bullet\textbf{w}_L\f$); is very small compared to the length of \f$\textbf{f}_L\f$ this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; \f$ \theta \f$ between the two vectors \f$\textbf{w}_L\f$ \f$ \textbf {f}_L\f$; (see also figure 1) and requiring that it's; *greater* then a threshold value which the user must set (TMultiDimFit::SetMinAngle). \image html multidimfit_img86.gif ""Figure 1: (a) angle \\f$\\theta\\f$ between \\f$\\textbf{w}_l\\f$ and \\f$\\textbf{f}_L\\f$, (b) angle \\f$ \\phi \\f$ between \\f$\\textbf{w}_L\\f$ and \\f$\\textbf{D}\\f$"". ## Test 2; Let \f$\textbf{D}\f$ be the data vector to be fitted. As illustrated in; figure 1, the \f$L^{\mbox{th}}\f$ function \f$\textbf{w}_L\f$; will contribute significantly to the reduction of \f$ S\f$, if the angle; \f$\phi^\prime\f$ between \f$\textbf{w}_L\f$ and \f$\textbf{D}\f$ is smaller than; an upper limit \f$ \phi \f$, defined by the user (MultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:10504,Testability,Test,Test,10504,"; Denoting by \f$ H_{L-1}\f$ the subspace spanned by \f$\textbf{w}_1,\ldots,\textbf{w}_{L-1}\f$; the function \f$\textbf{w}_L\f$ is by construction (see 4) the projection of the function; \f$ F_L\f$ onto the direction perpendicular to \f$ H_{L-1}\f$. Now, if the; length of \f$\textbf{w}_L\f$ (given by \f$\textbf{w}_L\bullet\textbf{w}_L\f$); is very small compared to the length of \f$\textbf{f}_L\f$ this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; \f$ \theta \f$ between the two vectors \f$\textbf{w}_L\f$ \f$ \textbf {f}_L\f$; (see also figure 1) and requiring that it's; *greater* then a threshold value which the user must set (TMultiDimFit::SetMinAngle). \image html multidimfit_img86.gif ""Figure 1: (a) angle \\f$\\theta\\f$ between \\f$\\textbf{w}_l\\f$ and \\f$\\textbf{f}_L\\f$, (b) angle \\f$ \\phi \\f$ between \\f$\\textbf{w}_L\\f$ and \\f$\\textbf{D}\\f$"". ## Test 2; Let \f$\textbf{D}\f$ be the data vector to be fitted. As illustrated in; figure 1, the \f$L^{\mbox{th}}\f$ function \f$\textbf{w}_L\f$; will contribute significantly to the reduction of \f$ S\f$, if the angle; \f$\phi^\prime\f$ between \f$\textbf{w}_L\f$ and \f$\textbf{D}\f$ is smaller than; an upper limit \f$ \phi \f$, defined by the user (MultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functi",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11177,Testability,Test,TestFunction,11177,"tbf{w}_L\f$ \f$ \textbf {f}_L\f$; (see also figure 1) and requiring that it's; *greater* then a threshold value which the user must set (TMultiDimFit::SetMinAngle). \image html multidimfit_img86.gif ""Figure 1: (a) angle \\f$\\theta\\f$ between \\f$\\textbf{w}_l\\f$ and \\f$\\textbf{f}_L\\f$, (b) angle \\f$ \\phi \\f$ between \\f$\\textbf{w}_L\\f$ and \\f$\\textbf{D}\\f$"". ## Test 2; Let \f$\textbf{D}\f$ be the data vector to be fitted. As illustrated in; figure 1, the \f$L^{\mbox{th}}\f$ function \f$\textbf{w}_L\f$; will contribute significantly to the reduction of \f$ S\f$, if the angle; \f$\phi^\prime\f$ between \f$\textbf{w}_L\f$ and \f$\textbf{D}\f$ is smaller than; an upper limit \f$ \phi \f$, defined by the user (MultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is th",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11277,Testability,test,test,11277,"$ \\phi \\f$ between \\f$\\textbf{w}_L\\f$ and \\f$\\textbf{D}\\f$"". ## Test 2; Let \f$\textbf{D}\f$ be the data vector to be fitted. As illustrated in; figure 1, the \f$L^{\mbox{th}}\f$ function \f$\textbf{w}_L\f$; will contribute significantly to the reduction of \f$ S\f$, if the angle; \f$\phi^\prime\f$ between \f$\textbf{w}_L\f$ and \f$\textbf{D}\f$ is smaller than; an upper limit \f$ \phi \f$, defined by the user (MultiDimFit::SetMaxAngle). However, the method automatically readjusts the value of this angle; while fitting is in progress, in order to make the selection criteria; less and less difficult to be fulfilled. The result is that the; functions contributing most to the reduction of \f$ S\f$ are chosen first; (TMultiDimFit::TestFunction). In case \f$ \phi \f$ isn't defined, an alternative method of; performing this second test is used: The \f$L^{\mbox{th}}\f$; function \f$\textbf{f}_L\f$ is accepted if (refer also to equation (13)); \f[; \Delta S_L > \frac{S_{L-1}}{L_{max}-L}; \f]; where \f$ S_{L-1}\f$ is the sum of the \f$ L-1\f$ first residuals from the; \f$ L-1\f$ functions previously accepted; and \f$ L_{max}\f$ is the total number; of functions allowed in the final expression of the fit (defined by; user). From this we see, that by restricting \f$ L_{max}\f$ -- the number of; terms in the final model -- the fit is more difficult to perform,; since the above selection criteria is more limiting. The more coefficients we evaluate, the more the sum of squares of; residuals \f$ S\f$ will be reduced. We can evaluate \f$ S\f$ before inverting; \f$\mathsf{B}\f$ as shown below. ## Coefficients and Coefficient Errors; Having found a parameterization, that is the \f$ F_l\f$'s and \f$ L\f$, that; minimizes \f$ S\f$, we still need to determine the coefficients; \f$ c_l\f$. However, it's a feature of how we choose the significant; functions, that the evaluation of the \f$ c_l\f$'s becomes trivial [5]. To derive; \f$\mathbf{c}\f$, we first note that; equation (4) c",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:15783,Testability,Test,Test,15783,"ximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mat",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16224,Testability,Test,Testing,16224,"strained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples in",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16296,Testability,test,testing,16296,"strained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples in",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16417,Testability,test,test,16417,"{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16774,Testability,test,test,16774,"bservation \f$\mathbf{x}\f$ within the domain of; the parameterization, using the result from the Principal Component; Analysis.; 2. Determine \f$\mathbf{P}^\prime\f$ as before.; 3. Determine \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Compu",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16932,Testability,test,test,16932,"e \f$\mathbf{x}^\prime\f$ as before.; 4. Use the result of the fit to determine \f$\mathbf{Q}^\prime\f$.; 5. Transform back to \f$\mathbf{P}\f$ from \f$\mathbf{Q}^\prime\f$, using; the result from the Principal Component Analysis. ## Testing the parameterization; The class also provides functionality for testing the, over the; training sample, found parameterization (TMultiDimFit::Fit). This is done by passing; the class a test sample of \f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Computations*.; John Hopkins University Press, Baltimore, 3 edition, 1996.; - <a name=""minuit""></a>F. James. *Minuit*. Long writeup D506, CERN, 1998.; - <a name=""wind72""></a>H. Wind. *Function p",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17459,Testability,test,test,17459,"f$ M_t\f$ tuples of the form; \f$(\mathbf{x}_{t,j},D_{t,j}, E_{t,j})\f$, where \f$\mathbf{x}_{t,j}\f$ are the independent; variables, \f$ D_{t,j}\f$ the known, dependent quantity, and \f$ E_{t,j}\f$ is; the square error in \f$ D_{t,j}\f$ (TMultiDimFit::AddTestRow). The parameterization is then evaluated at every \f$\mathbf{x}_t\f$ in the; test sample, and; \f[; S_t \equiv \sum_{j=1}^{M_t} \left(D_{t,j} -; D_p\left(\mathbf{x}_{t,j}\right)\right)^2; \f]; is evaluated. The relative error over the test sample; \f[; R_t = \frac{S_t}{\sum_{j=1}^{M_t} D_{t,j}^2}; \f]; should not be to low or high compared to \f$ R\f$ from the training; sample. Also, multiple correlation coefficient from both samples should; be fairly close, otherwise one of the samples is not representative of; the problem. A large difference in the reduced \f$ \chi^2\f$ over the two; samples indicate an over fit, and the maximum number of terms in the; parameterisation should be reduced. It's possible to use [4] to further improve the fit, using the test sample. Christian Holm. ## Bibliography; - <a name=""bevington""></a> Philip R. Bevington and D. Keith Robinson. *Data Reduction and Error Analysis for; the Physical Sciences*. McGraw-Hill, 2 edition, 1992.; - <a name=""mudifi""></a> R. Brun et al. *Long writeup DD/75-23*, CERN, 1980.; - Gene H. Golub and Charles F. van Loan. *Matrix Computations*.; John Hopkins University Press, Baltimore, 3 edition, 1996.; - <a name=""minuit""></a>F. James. *Minuit*. Long writeup D506, CERN, 1998.; - <a name=""wind72""></a>H. Wind. *Function parameterization*. Proceedings of the 1972 CERN Computing and Data Processing; School, volume 72-21 of Yellow report. CERN, 1972.; - <a name=""wind81""></a>H. Wind. 1. principal component analysis, 2. pattern recognition for track; finding, 3. interpolation and functional representation. Yellow report EP/81-12, CERN, 1981. [1]: classTMultiDimFit.html#bevington; [2]: classTMultiDimFit.html#mudifi; [4]: classTMultiDimFit.html#minuit; [5]: class",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:14842,Usability,simpl,simple,14842,"on*, rather then a *extrapolation* [5]. Also, the independent variables \f$ x_{i}\f$ need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables \f$ \xi_{i}\f$ to a set of linear independent variables; \f$ x_{i}\f$, using a *Principal Components Analysis* (see TPrincipal), and; then use the transformed variable as input to this class [5] [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. 1. Define \f$\mathbf{P} = (P_1, \ldots, P_5)\f$ are the 5 dependent; quantities that define a track.; 2. Compute, for \f$ M\f$ different values of \f$\mathbf{P}\f$, the tracks; through the magnetic field, and determine the corresponding; \f$\mathbf{x} = (x_1, \ldots, x_N)\f$.; 3. Use the simulated observations to determine, with a simple; approximation, the values of \f$\mathbf{P}_j\f$. We call these values; \f$\mathbf{P}^\prime_j, j = 1, \ldots, M\f$.; 4. Determine from \f$\mathbf{x}\f$ a set of at least five relevant; coordinates \f$\mathbf{x}^\prime\f$, using contrains, *or; alternative:*; 5. Perform a Principal Component Analysis (using TPrincipal), and use; to get a linear transformation \f$\mathbf{x} \rightarrow \mathbf{x}^\prime\f$, so that; \f$\mathbf{x}^\prime\f$ are constrained and linear independent.; 6. Perform a Principal Component Analysis on; \f$Q_i = P_i / P^\prime_i\, i = 1, \ldots, 5\f$, to get linear; indenpendent (among themselves, but not independent of \f$\mathbf{x}\f$) quantities; \f$\mathbf{Q}^\prime\f$; 7. For each component \f$Q^\prime_i\f$ make a multidimensional fit,; using \f$\mathbf{x}^\prime\f$ as the variables, thus determining a set of; coefficients \f$\mathbf{c}_i\f$. To process data, using this parameterisation, do; 1. Test wether the observation \f$\mathbf{x}\f$ within the domai",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:208,Availability,error,error,208,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:516,Availability,error,error,516,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:581,Availability,error,error,581,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:161,Integrability,depend,dependent,161,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:226,Integrability,depend,dependent,226,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:610,Integrability,depend,dependent,610,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:134,Modifiability,variab,variables,134,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:293,Modifiability,parameteriz,parameterization,293,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:332,Modifiability,variab,variables,332,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the training sample to be used for the; /// parameterization.; /// The mean of the variables and quantity is calculated on the fly,; /// as outlined in TPrincipal::AddRow.; /// This sample should be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3,Deployability,Update,Update,3,"// Update the maximum value for this component",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3,Deployability,Update,Update,3,"// Update the minimum value for this component",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:208,Availability,error,error,208,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:415,Availability,error,error,415,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:480,Availability,error,error,480,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:161,Integrability,depend,dependent,161,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:226,Integrability,depend,dependent,226,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:509,Integrability,depend,dependent,509,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:134,Modifiability,variab,variables,134,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:301,Modifiability,parameteriz,parameterization,301,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:253,Testability,test,test,253,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:289,Testability,test,test,289,"////////////////////////////////////////////////////////////////////////////////; /// Add a row consisting of fNVariables independent variables, the; /// known, dependent quantity, and optionally, the square error in; /// the dependent quantity, to the test sample to be used for the; /// test of the parameterization.; /// This sample needn't be representative of the problem at hand.; /// Please note, that if no error is given Poisson statistics is; /// assumed and the square error is set to the value of dependent; /// quantity. See also the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:116,Modifiability,variab,variables,116,"////////////////////////////////////////////////////////////////////////////////; /// Clear internal structures and variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear internal structures and variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:20,Integrability,depend,dependent,20,"// Training sample, dependent quantity",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:32,Modifiability,variab,variables,32,"// Training sample, independent variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3,Testability,Test,Test,3,"// Test sample",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3,Energy Efficiency,Power,Powers,3,"// Powers",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:95,Modifiability,parameteriz,parameterization,95,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate parameterization at point x. Optional argument coeff is; /// a vector of coefficients for the parameterisation, fNCoefficients; /// elements long.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:48,Modifiability,variab,variable,48,"// Evaluate the factor (polynomial) in the j-th variable.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:112,Availability,error,error,112,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate parameterization error at point x. Optional argument coeff is; /// a vector of coefficients for the parameterisation, fNCoefficients; /// elements long.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:95,Modifiability,parameteriz,parameterization,95,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate parameterization error at point x. Optional argument coeff is; /// a vector of coefficients for the parameterisation, fNCoefficients; /// elements long.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17,Availability,Error,Error,17,"// std::cout << ""Error coef "" << i << "" -> "" << fCoefficientsRMS(i) << std::endl;",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:48,Modifiability,variab,variable,48,"// Evaluate the factor (polynomial) in the j-th variable.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:155,Energy Efficiency,power,powers,155,"////////////////////////////////////////////////////////////////////////////////; /// PRIVATE METHOD:; /// Calculate the control parameter from the passed powers",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:130,Energy Efficiency,power,power,130,"////////////////////////////////////////////////////////////////////////////////; /// PRIVATE METHOD:; /// Evaluate function with power p at variable value x",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:141,Modifiability,variab,variable,141,"////////////////////////////////////////////////////////////////////////////////; /// PRIVATE METHOD:; /// Evaluate function with power p at variable value x",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:95,Modifiability,parameteriz,parameterization,95,"////////////////////////////////////////////////////////////////////////////////; /// Find the parameterization; ///; /// Options:; /// None so far; ///; /// For detailed description of what this entails, please refer to the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:131,Testability,test,test,131,"////////////////////////////////////////////////////////////////////////////////; /// Try to fit the found parameterisation to the test sample.; ///; /// Options; /// M use Minuit to improve coefficients; ///; /// Also, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:36,Testability,test,test,36,"// Calculate the residuals over the test sample",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:39,Modifiability,variab,variable,39,"// use big enough string buffer to get variable name which is not used",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:36,Energy Efficiency,power,powers,36,"// The temporary array to store the powers in. We don't need to; // initialize this array however.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:21,Modifiability,variab,variables,21,"// store of `control variables'",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:31,Modifiability,variab,variables,31,"// We've better initialize the variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:13,Performance,load,loadable,13,"// Call over-loadable method Select, as to allow the user to; // interfere with the selection of functions.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:52,Energy Efficiency,power,powers,52,"// Store the control value, so we can sort array of powers; // later on",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:13,Energy Efficiency,power,powers,13,"// Store the powers in powers array.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:23,Energy Efficiency,power,powers,23,"// Store the powers in powers array.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:47,Energy Efficiency,power,power,47,"// If all variables have reached their maximum power, then we; // break out of the loop",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:10,Modifiability,variab,variables,10,"// If all variables have reached their maximum power, then we; // break out of the loop",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:8,Energy Efficiency,power,power,8,"// Next power in variable i",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17,Modifiability,variab,variable,17,"// Next power in variable i",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:12,Energy Efficiency,power,powers,12,"// Copy the powers to working arrays",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:27,Energy Efficiency,power,powers,27,"// Now we need to sort the powers according to least `control; // variable'",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:66,Modifiability,variab,variable,66,"// Now we need to sort the powers according to least `control; // variable'",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:123,Testability,test,test,123,"////////////////////////////////////////////////////////////////////////////////; /// Calculate Chi square over either the test sample. The optional; /// argument coeff is a vector of coefficients to use in the; /// evaluation of the parameterisation. If coeff == 0, then the found; /// coefficients is used.; /// Used my MINUIT for fit (see TMultDimFit::Fit)",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:394,Modifiability,variab,variables,394,"////////////////////////////////////////////////////////////////////////////////; /// Generate the file `<filename>` with .C appended if argument doesn't; /// end in .cxx or .C. The contains the implementation of the; /// function:; ///; /// `Double_t <funcname>(Double_t *x)`; ///; /// which does the same as TMultiDimFit::Eval. Please refer to this; /// method.; ///; /// Further, the static variables:; ///; /// Int_t gNVariables; /// Int_t gNCoefficients; /// Double_t gDMean; /// Double_t gXMean[]; /// Double_t gXMin[]; /// Double_t gXMax[]; /// Double_t gCoefficient[]; /// Int_t gPower[]; ///; /// are initialized. The only ROOT header file needed is Rtypes.h; ///; /// See TMultiDimFit::MakeRealCode for a list of options",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:119,Availability,error,errors,119,"////////////////////////////////////////////////////////////////////////////////; /// PRIVATE METHOD:; /// Compute the errors on the coefficients. For this to be done, the; /// curvature matrix of the non-orthogonal functions, is computed.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:16,Modifiability,variab,variable,16,"// G.Q. added m variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:24,Modifiability,variab,variable,24,"// Index of sample j of variable i",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:24,Modifiability,variab,variable,24,"// Index of sample j of variable i; // l = j * fNVariables + k; // G.Q.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:9,Testability,test,test,9,"// First test, but only if didn't user specify",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:138,Integrability,message,message,138,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:340,Integrability,depend,dependent,340,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:415,Integrability,depend,dependent,415,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:518,Integrability,depend,dependent,518,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:229,Modifiability,parameteriz,parameterization,229,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:314,Modifiability,variab,variables,314,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:350,Modifiability,variab,variables,350,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:390,Modifiability,variab,variables,390,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:425,Modifiability,variab,variables,425,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:483,Modifiability,variab,variables,483,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:528,Modifiability,variab,variable,528,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:613,Testability,test,test,613,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis. This message; /// should be sent after having read all data points, but before; /// finding the parameterization; ///; /// Options:; /// A All the below; /// X Original independent variables; /// D Original dependent variables; /// N Normalised independent variables; /// S Shifted dependent variables; /// R1 Residuals versus normalised independent variables; /// R2 Residuals versus dependent variable; /// R3 Residuals computed on training sample; /// R4 Residuals computed on test sample; ///; /// For a description of these quantities, refer to; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:11,Modifiability,variab,variable,11,"// Counter variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:25,Modifiability,variab,variables,25,"// Histogram of original variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:25,Integrability,depend,dependent,25,"// Histogram of original dependent variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:35,Modifiability,variab,variable,35,"// Histogram of original dependent variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:28,Modifiability,variab,variables,28,"// Histograms of normalized variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:24,Integrability,depend,dependent,24,"// Histogram of shifted dependent variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:34,Modifiability,variab,variable,34,"// Histogram of shifted dependent variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:52,Modifiability,variab,variables,52,"// Residual from training sample versus independent variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:41,Integrability,depend,dependent,41,"// Residual from training sample versus. dependent variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:51,Modifiability,variab,variable,51,"// Residual from training sample versus. dependent variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:1606,Energy Efficiency,power,powers,1606,"////////////////////////////////////////////////////////////////////////////////; /// Generate the file `<classname>MDF.cxx` which contains the; /// implementation of the method:; ///; /// `Double_t <classname>::%MDF(Double_t *x)`; ///; /// which does the same as TMultiDimFit::Eval. Please refer to this; /// method.; ///; /// Further, the public static members:; /// \code{.cpp}; /// Int_t <classname>::fgNVariables; /// Int_t <classname>::fgNCoefficients; /// Double_t <classname>::fgDMean; /// Double_t <classname>::fgXMean[] //[fgNVariables]; /// Double_t <classname>::fgXMin[] //[fgNVariables]; /// Double_t <classname>::fgXMax[] //[fgNVariables]; /// Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; /// Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]; /// \endcode; ///; /// are initialized, and assumed to exist. The class declaration is; /// assumed to be in `<classname>.h` and assumed to be provided by the; /// user.; ///; /// \see TMultiDimFit::MakeRealCode for a list of options; ///; /// The minimal class definition is:; /// \code{.cpp}; /// class <classname> {; /// public:; /// Int_t <classname>::fgNVariables; // Number of variables; /// Int_t <classname>::fgNCoefficients; // Number of terms; /// Double_t <classname>::fgDMean; // Mean from training sample; /// Double_t <classname>::fgXMean[]; // Mean from training sample; /// Double_t <classname>::fgXMin[]; // Min from training sample; /// Double_t <classname>::fgXMax[]; // Max from training sample; /// Double_t <classname>::fgCoefficient[]; // Coefficients; /// Int_t <classname>::fgPower[]; // Function powers; ///; /// Double_t Eval(Double_t *x);; /// };; /// \endcode; ///; /// Whether the method `<classname>::%Eval` should be static or not, is; /// up to the user.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:1167,Modifiability,variab,variables,1167,"////////////////////////////////////////////////////////////////////////////////; /// Generate the file `<classname>MDF.cxx` which contains the; /// implementation of the method:; ///; /// `Double_t <classname>::%MDF(Double_t *x)`; ///; /// which does the same as TMultiDimFit::Eval. Please refer to this; /// method.; ///; /// Further, the public static members:; /// \code{.cpp}; /// Int_t <classname>::fgNVariables; /// Int_t <classname>::fgNCoefficients; /// Double_t <classname>::fgDMean; /// Double_t <classname>::fgXMean[] //[fgNVariables]; /// Double_t <classname>::fgXMin[] //[fgNVariables]; /// Double_t <classname>::fgXMax[] //[fgNVariables]; /// Double_t <classname>::fgCoefficient[] //[fgNCoeffficents]; /// Int_t <classname>::fgPower[] //[fgNCoeffficents*fgNVariables]; /// \endcode; ///; /// are initialized, and assumed to exist. The class declaration is; /// assumed to be in `<classname>.h` and assumed to be provided by the; /// user.; ///; /// \see TMultiDimFit::MakeRealCode for a list of options; ///; /// The minimal class definition is:; /// \code{.cpp}; /// class <classname> {; /// public:; /// Int_t <classname>::fgNVariables; // Number of variables; /// Int_t <classname>::fgNCoefficients; // Number of terms; /// Double_t <classname>::fgDMean; // Mean from training sample; /// Double_t <classname>::fgXMean[]; // Mean from training sample; /// Double_t <classname>::fgXMin[]; // Min from training sample; /// Double_t <classname>::fgXMax[]; // Max from training sample; /// Double_t <classname>::fgCoefficient[]; // Coefficients; /// Int_t <classname>::fgPower[]; // Function powers; ///; /// Double_t Eval(Double_t *x);; /// };; /// \endcode; ///; /// Whether the method `<classname>::%Eval` should be static or not, is; /// up to the user.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:43,Modifiability,variab,variables,43,"// Fill histograms of original independent variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:25,Modifiability,variab,variables,25,"// Normalise independent variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:45,Modifiability,variab,variables,45,"// Fill histograms of normalised independent variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:24,Integrability,depend,dependent,24,"// Shift min and max of dependent variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:34,Modifiability,variab,variable,34,"// Shift min and max of dependent variable",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:29,Modifiability,variab,variables,29,"// Shift mean of independent variables",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:116,Modifiability,parameteriz,parameterization,116,"////////////////////////////////////////////////////////////////////////////////; /// PRIVATE METHOD:; /// Find the parameterization over the training sample. A full account; /// of the algorithm is given in the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17,Integrability,message,message,17,"// Print a happy message",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:39,Testability,test,test,39,"// This function is no good!; // First test is in MakeGramSchmidt",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:3,Testability,Test,Test,3,"// Test if this function contributes to the fit",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:187,Modifiability,parameteriz,parameterization,187,"////////////////////////////////////////////////////////////////////////////////; /// PRIVATE METHOD:; /// This is the method that actually generates the code for the; /// evaluation the parameterization on some point.; /// It's called by TMultiDimFit::MakeCode and TMultiDimFit::MakeMethod.; ///; /// The options are: NONE so far",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17,Availability,error,error,17,"// Assignment to error coefficients vector.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:17,Energy Efficiency,power,powers,17,"// Assignment to powers vector.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:328,Energy Efficiency,power,powers,328,"////////////////////////////////////////////////////////////////////////////////; /// Selection method. User can override this method for specialized; /// selection of acceptable functions in fit. Default is to select; /// all. This message is sent during the build-up of the function; /// candidates table once for each set of powers in; /// variables. Notice, that the argument array contains the powers; /// PLUS ONE. For example, to De select the function; /// f = x1^2 * x2^4 * x3^5,; /// this method should return kFALSE if given the argument; /// { 3, 4, 6 }",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:399,Energy Efficiency,power,powers,399,"////////////////////////////////////////////////////////////////////////////////; /// Selection method. User can override this method for specialized; /// selection of acceptable functions in fit. Default is to select; /// all. This message is sent during the build-up of the function; /// candidates table once for each set of powers in; /// variables. Notice, that the argument array contains the powers; /// PLUS ONE. For example, to De select the function; /// f = x1^2 * x2^4 * x3^5,; /// this method should return kFALSE if given the argument; /// { 3, 4, 6 }",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:233,Integrability,message,message,233,"////////////////////////////////////////////////////////////////////////////////; /// Selection method. User can override this method for specialized; /// selection of acceptable functions in fit. Default is to select; /// all. This message is sent during the build-up of the function; /// candidates table once for each set of powers in; /// variables. Notice, that the argument array contains the powers; /// PLUS ONE. For example, to De select the function; /// f = x1^2 * x2^4 * x3^5,; /// this method should return kFALSE if given the argument; /// { 3, 4, 6 }",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:343,Modifiability,variab,variables,343,"////////////////////////////////////////////////////////////////////////////////; /// Selection method. User can override this method for specialized; /// selection of acceptable functions in fit. Default is to select; /// all. This message is sent during the build-up of the function; /// candidates table once for each set of powers in; /// variables. Notice, that the argument array contains the powers; /// PLUS ONE. For example, to De select the function; /// f = x1^2 * x2^4 * x3^5,; /// this method should return kFALSE if given the argument; /// { 3, 4, 6 }",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:343,Modifiability,variab,variable,343,"////////////////////////////////////////////////////////////////////////////////; /// Define a user function. The input array must be of the form; /// (p11, ..., p1N, ... ,pL1, ..., pLN); /// Where N is the dimension of the data sample, L is the number of; /// terms (given in terms) and the first number, labels the term, the; /// second the variable. More information is given in the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:213,Modifiability,variab,variable,213,"////////////////////////////////////////////////////////////////////////////////; /// Set the user parameter for the function selection. The bigger the; /// limit, the more functions are used. The meaning of this variable; /// is defined in the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:102,Energy Efficiency,power,power,102,"////////////////////////////////////////////////////////////////////////////////; /// Set the maximum power to be considered in the fit for each; /// variable. See also; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:150,Modifiability,variab,variable,150,"////////////////////////////////////////////////////////////////////////////////; /// Set the maximum power to be considered in the fit for each; /// variable. See also; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:114,Availability,error,error,114,"////////////////////////////////////////////////////////////////////////////////; /// Set the acceptable relative error for when sum of square; /// residuals is considered minimized. For a full account, refer to; /// the; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:107,Testability,Test,Test,107,"////////////////////////////////////////////////////////////////////////////////; /// PRIVATE METHOD:; /// Test whether the currently considered function contributes to the; /// fit. See also; /// <a href=""#TMultiDimFit:description"">class description</a>",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:22,Testability,test,test,22,"// Now for the second test:",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:50,Testability,test,test,50,"// If the user hasn't supplied a max angle do the test as,",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx:41,Testability,test,test,41,"// If the user has provided a max angle, test if the calculated; // angle is less then the max angle.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiDimFit.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiDimFit.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:4480,Availability,avail,available,4480,"y1[size];; double py2[size];; double py3[size];. for ( int i = 0; i < size ; ++i ) {; px[i] = i;; py1[i] = size - i;; py2[i] = size - 0.5 * i;; py3[i] = size - 0.6 * i;; }. auto gr1 = new TGraph( size, px, py1 );; gr1->SetName(""gr1"");; gr1->SetTitle(""graph 1"");; gr1->SetMarkerStyle(21);; gr1->SetDrawOption(""AP"");; gr1->SetLineColor(2);; gr1->SetLineWidth(4);; gr1->SetFillStyle(0);. auto gr2 = new TGraph( size, px, py2 );; gr2->SetName(""gr2"");; gr2->SetTitle(""graph 2"");; gr2->SetMarkerStyle(22);; gr2->SetMarkerColor(2);; gr2->SetDrawOption(""P"");; gr2->SetLineColor(3);; gr2->SetLineWidth(4);; gr2->SetFillStyle(0);. auto gr3 = new TGraph( size, px, py3 );; gr3->SetName(""gr3"");; gr3->SetTitle(""graph 3"");; gr3->SetMarkerStyle(23);; gr3->SetLineColor(4);; gr3->SetLineWidth(4);; gr3->SetFillStyle(0);. mg->Add( gr1 );; mg->Add( gr2 );. gr3->Draw(""ALP"");; mg->Draw(""LP"");; c3->BuildLegend();; }; End_Macro. \anchor MG01e; #### Automatic coloring. Automatic coloring according to the current palette is available as shown in the; following example:. Begin_Macro(source); ../../../tutorials/graphs/multigraphpalettecolor.C; End_Macro. \anchor MG01f; #### Reverse axis. \since **ROOT version 6.19/02**. When a TMultiGraph is drawn, the X-axis is drawn with increasing values from left to; right and the Y-axis from bottom to top. The two options RX and RY allow to change; this order. The option RX allows to draw the X-axis with increasing values from; right to left and the RY option allows to draw the Y-axis with increasing values; from top to bottom. The following example illustrate how to use these options. Begin_Macro(source); {; auto *c = new TCanvas();; c->Divide(2,1);. auto *g1 = new TGraphErrors();; g1->SetPoint(0,-4,-3);; g1->SetPoint(1,1,1);; g1->SetPoint(2,2,1);; g1->SetPoint(3,3,4);; g1->SetPoint(4,5,5);; g1->SetPointError(0,1.,2.);; g1->SetPointError(1,2,1);; g1->SetPointError(2,2,3);; g1->SetPointError(3,3,2);; g1->SetPointError(4,4,5);; g1->SetMarkerStyle(21);. auto *g2 = n",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:3136,Deployability,Update,Update,3136," example:. Begin_Macro(source); {; auto c0 = new TCanvas(""c1"",""multigraph L3"",200,10,700,500);. auto mg = new TMultiGraph();. auto gr1 = new TGraph(); gr1->SetLineColor(kBlue);; auto gr2 = new TGraph(); gr2->SetLineColor(kRed);; auto gr3 = new TGraph(); gr3->SetLineColor(kGreen);; auto gr4 = new TGraph(); gr4->SetLineColor(kOrange);. Double_t dx = 6.28/1000;; Double_t x = -3.14;. for (int i=0; i<=1000; i++) {; x = x+dx;; gr1->SetPoint(i,x,2.*TMath::Sin(x));; gr2->SetPoint(i,x,TMath::Cos(x));; gr3->SetPoint(i,x,TMath::Cos(x*x));; gr4->SetPoint(i,x,TMath::Cos(x*x*x));; }. mg->Add(gr4); gr4->SetTitle(""Cos(x*x*x)""); gr4->SetLineWidth(3);; mg->Add(gr3); gr3->SetTitle(""Cos(x*x)"") ; gr3->SetLineWidth(3);; mg->Add(gr2); gr2->SetTitle(""Cos(x)"") ; gr2->SetLineWidth(3);; mg->Add(gr1); gr1->SetTitle(""2*Sin(x)"") ; gr1->SetLineWidth(3);. mg->SetTitle(""Multi-graph Title; X-axis Title; Y-axis Title"");. mg->Draw(""a fb l3d"");. mg->GetHistogram()->GetXaxis()->SetRangeUser(0.,2.5);; gPad->Modified();; gPad->Update();; }; End_Macro. \anchor MG01d; #### Legend drawing. The method TPad::BuildLegend is able to extract the graphs inside a; multigraph. The following example demonstrate this. Begin_Macro(source); {; auto c3 = new TCanvas(""c3"",""c3"",600, 400);. auto mg = new TMultiGraph(""mg"",""mg"");. const Int_t size = 10;. double px[size];; double py1[size];; double py2[size];; double py3[size];. for ( int i = 0; i < size ; ++i ) {; px[i] = i;; py1[i] = size - i;; py2[i] = size - 0.5 * i;; py3[i] = size - 0.6 * i;; }. auto gr1 = new TGraph( size, px, py1 );; gr1->SetName(""gr1"");; gr1->SetTitle(""graph 1"");; gr1->SetMarkerStyle(21);; gr1->SetDrawOption(""AP"");; gr1->SetLineColor(2);; gr1->SetLineWidth(4);; gr1->SetFillStyle(0);. auto gr2 = new TGraph( size, px, py2 );; gr2->SetName(""gr2"");; gr2->SetTitle(""graph 2"");; gr2->SetMarkerStyle(22);; gr2->SetMarkerColor(2);; gr2->SetDrawOption(""P"");; gr2->SetLineColor(3);; gr2->SetLineWidth(4);; gr2->SetFillStyle(0);. auto gr3 = new TGraph( size, px, py3 ",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:1144,Performance,perform,performed,1144,"collection of TGraph (or derived) objects. - [Introduction](\ref MG00); - [MultiGraphs' drawing](\ref MG01); - [Setting drawing options](\ref MG01a); - [Titles setting](\ref MG01b); - [The option \""3D\""](\ref MG01c); - [Legend drawing](\ref MG01d); - [Automatic coloring](\ref MG01e); - [Reverse axis](\ref MG01f); - [MultiGraphs' fitting](\ref MG02); - [Fit box position](\ref MG02a); - [Axis' limits setting](\ref MG03). \anchor MG00; ### Introduction. A TMultiGraph allows to manipulate a set of graphs as a single entity. In particular,; when drawn, the X and Y axis ranges are automatically computed such as all the graphs; will be visible. `TMultiGraph::Add` should be used to add a new graph to the list. The TMultiGraph owns the objects in the list. The number of graphs in a multigraph can be retrieve with:; ~~~ {.cpp}; mg->GetListOfGraphs()->GetEntries();; ~~~. \anchor MG01; ### MultiGraphs' Drawing. The drawing options are the same as for TGraph.; Like for TGraph, the painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. Example:; ~~~ {.cpp}; TGraph *gr1 = new TGraph(...; TGraphErrors *gr2 = new TGraphErrors(...; TMultiGraph *mg = new TMultiGraph();; mg->Add(gr1,""lp"");; mg->Add(gr2,""cp"");; mg->Draw(""a"");; ~~~. \anchor MG01a; #### Setting drawing options. The drawing option for each TGraph may be specified as an optional; second argument of the `Add` function. If a draw option is specified, it will be used to draw the graph,; otherwise the graph will be drawn with the option specified in; `TMultiGraph::Draw`. \anchor MG01b; #### Titles setting. The global title and the axis titles can be modified the following way:. ~~~ {.cpp}; [...]; auto mg = new TMultiGraph;; mg->SetTitle(""title;xaxis title; yaxis title"");; mg->Add(g1);; mg->Add(g2);; mg->Draw(""apl"");; ~~~. \anchor MG01c; #### The option ""3D"". A special option `3D` allows to draw the graphs in a 3D space. See the; following example:. Begin",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:10,Testability,log,logic,10,"//special logic to support the case where the same object is; //added multiple times in fFunctions.; //This case happens when the same object is added with different; //drawing modes",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:142,Integrability,interface,interface,142,"////////////////////////////////////////////////////////////////////////////////; /// Fit this graph with function with name fname.; ///; /// interface to TF1::Fit(TF1 *f1...",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:507,Availability,error,errors,507,"////////////////////////////////////////////////////////////////////////////////; /// Fit this multigraph with function f1.; ///; /// In this function all graphs of the multigraph are fitted simultaneously; ///; /// f1 is an already predefined function created by TF1.; /// Predefined functions such as gaus, expo and poln are automatically; /// created by ROOT.; ///; /// The list of fit options is given in parameter `option`which may takes the; /// following values:; ///; /// - ""W"" Ignore all the point errors; /// - ""U"" Use a User specified fitting algorithm (via SetFCN); /// - ""Q"" Quiet mode (minimum printing); /// - ""V"" Verbose mode (default is between Q and V); /// - ""B"" Use this option when you want to fix one or more parameters; /// and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; /// - ""R"" Use the Range specified in the function range; /// - ""N"" Do not store the graphics function, do not draw; /// - ""0"" Do not plot the result of the fit. By default the fitted function; /// is drawn unless the option""N"" above is specified.; /// - ""+"" Add this new fitted function to the list of fitted functions; /// (by default, any previous function is deleted); /// - ""C"" In case of linear fitting, not calculate the chisquare (saves time); /// - ""F"" If fitting a polN, switch to minuit fitter; /// - ""ROB"" In case of linear fitting, compute the LTS regression; /// coefficients (robust(resistant) regression), using; /// the default fraction of good points; /// - ""ROB=0.x"" - compute the LTS regression coefficients, using; /// 0.x as a fraction of good points; ///; /// When the fit is drawn (by default), the parameter goption may be used; /// to specify a list of graphics options. See TGraph::Paint for a complete; /// list of these options.; ///; /// In order to use the Range option, one must first create a function; /// with the expression to be fitted. For example, if your graph; /// has a defined range between -4 and 4 and you want to fit a gaussian; /// only in the",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:1402,Availability,robust,robust,1402,"edefined functions such as gaus, expo and poln are automatically; /// created by ROOT.; ///; /// The list of fit options is given in parameter `option`which may takes the; /// following values:; ///; /// - ""W"" Ignore all the point errors; /// - ""U"" Use a User specified fitting algorithm (via SetFCN); /// - ""Q"" Quiet mode (minimum printing); /// - ""V"" Verbose mode (default is between Q and V); /// - ""B"" Use this option when you want to fix one or more parameters; /// and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; /// - ""R"" Use the Range specified in the function range; /// - ""N"" Do not store the graphics function, do not draw; /// - ""0"" Do not plot the result of the fit. By default the fitted function; /// is drawn unless the option""N"" above is specified.; /// - ""+"" Add this new fitted function to the list of fitted functions; /// (by default, any previous function is deleted); /// - ""C"" In case of linear fitting, not calculate the chisquare (saves time); /// - ""F"" If fitting a polN, switch to minuit fitter; /// - ""ROB"" In case of linear fitting, compute the LTS regression; /// coefficients (robust(resistant) regression), using; /// the default fraction of good points; /// - ""ROB=0.x"" - compute the LTS regression coefficients, using; /// 0.x as a fraction of good points; ///; /// When the fit is drawn (by default), the parameter goption may be used; /// to specify a list of graphics options. See TGraph::Paint for a complete; /// list of these options.; ///; /// In order to use the Range option, one must first create a function; /// with the expression to be fitted. For example, if your graph; /// has a defined range between -4 and 4 and you want to fit a gaussian; /// only in the interval 1 to 3, you can do:; /// ~~~ {.cpp}; /// TF1 *f1 = new TF1(""f1"",""gaus"",1,3);; /// graph->Fit(""f1"",""R"");; /// ~~~; ///; /// ### Who is calling this function ?; ///; /// Note that this function is called when calling TGraphErrors::Fit; /// or TGraphAsymmErrors::Fit o",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:2337,Availability,error,errors,2337,"se of linear fitting, not calculate the chisquare (saves time); /// - ""F"" If fitting a polN, switch to minuit fitter; /// - ""ROB"" In case of linear fitting, compute the LTS regression; /// coefficients (robust(resistant) regression), using; /// the default fraction of good points; /// - ""ROB=0.x"" - compute the LTS regression coefficients, using; /// 0.x as a fraction of good points; ///; /// When the fit is drawn (by default), the parameter goption may be used; /// to specify a list of graphics options. See TGraph::Paint for a complete; /// list of these options.; ///; /// In order to use the Range option, one must first create a function; /// with the expression to be fitted. For example, if your graph; /// has a defined range between -4 and 4 and you want to fit a gaussian; /// only in the interval 1 to 3, you can do:; /// ~~~ {.cpp}; /// TF1 *f1 = new TF1(""f1"",""gaus"",1,3);; /// graph->Fit(""f1"",""R"");; /// ~~~; ///; /// ### Who is calling this function ?; ///; /// Note that this function is called when calling TGraphErrors::Fit; /// or TGraphAsymmErrors::Fit ot TGraphBentErrors::Fit; /// see the discussion below on the errors calculation.; ///; /// ### Setting initial conditions; ///; /// Parameters must be initialized before invoking the Fit function.; /// The setting of the parameter initial values is automatic for the; /// predefined functions : poln, expo, gaus, landau. One can however disable; /// this automatic computation by specifying the option ""B"".; /// You can specify boundary limits for some or all parameters via; /// ~~~ {.cpp}; /// f1->SetParLimits(p_number, parmin, parmax);; /// ~~~; /// if `parmin>=parmax`, the parameter is fixed; /// Note that you are not forced to fix the limits for all parameters.; /// For example, if you fit a function with 6 parameters, you can do:; /// ~~~ {.cpp}; /// func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; /// func->SetParLimits(4,-10,-4);; /// func->SetParLimits(5, 1,1);; /// ~~~; /// With this setup, parameters 0->3 c",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:4943,Availability,error,error,4943," specify option ""U"" and; /// call the following function:; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); /// ~~~; /// where MyFittingFunction is of type:; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// ### Access to the fit result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit and it converts; /// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; /// the TFitResult and behaves as a smart pointer to it. For example one can do:; /// ~~~ {.cpp}; /// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; /// from the fitted function.; ///; /// ### Associated functions; ///; /// One or more object (typically a TF1*) can be added to the list; /// of functions (fFunctions) associated to each graph.; /// When TGraph::Fit is invoked, the fitted function is added to this list.; /// Given a graph gr, one can retrieve an associated function; /// with:; /// ~~~ {.cpp}; /// TF1 *myfunc = gr->GetFunction(""myfunc"");; /// ~~~; ///; /// If the graph is made persistent, the list of; /// associated functions is also persistent. Given a pointer (see above); /// to an associated function myfunc, one can retrieve the function/fit; /// parameters with calls such as:; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetPa",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:5136,Availability,error,error,5136," specify option ""U"" and; /// call the following function:; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); /// ~~~; /// where MyFittingFunction is of type:; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// ### Access to the fit result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit and it converts; /// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; /// the TFitResult and behaves as a smart pointer to it. For example one can do:; /// ~~~ {.cpp}; /// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; /// from the fitted function.; ///; /// ### Associated functions; ///; /// One or more object (typically a TF1*) can be added to the list; /// of functions (fFunctions) associated to each graph.; /// When TGraph::Fit is invoked, the fitted function is added to this list.; /// Given a graph gr, one can retrieve an associated function; /// with:; /// ~~~ {.cpp}; /// TF1 *myfunc = gr->GetFunction(""myfunc"");; /// ~~~; ///; /// If the graph is made persistent, the list of; /// associated functions is also persistent. Given a pointer (see above); /// to an associated function myfunc, one can retrieve the function/fit; /// parameters with calls such as:; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetPa",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:6036,Availability,error,error,6036,"trieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; /// from the fitted function.; ///; /// ### Associated functions; ///; /// One or more object (typically a TF1*) can be added to the list; /// of functions (fFunctions) associated to each graph.; /// When TGraph::Fit is invoked, the fitted function is added to this list.; /// Given a graph gr, one can retrieve an associated function; /// with:; /// ~~~ {.cpp}; /// TF1 *myfunc = gr->GetFunction(""myfunc"");; /// ~~~; ///; /// If the graph is made persistent, the list of; /// associated functions is also persistent. Given a pointer (see above); /// to an associated function myfunc, one can retrieve the function/fit; /// parameters with calls such as:; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ### Fit Statistics; ///; /// You can change the statistics box to display the fit parameters with; /// the TStyle::SetOptFit(mode) method. This mode has four digits.; /// mode = pcev (default = 0111); ///; /// - v = 1; print name/values of parameters; /// - e = 1; print errors (if e=1, v must be 1); /// - c = 1; print Chisquare/Number of degrees of freedom; /// - p = 1; print Probability; ///; /// For example: `gStyle->SetOptFit(1011);`; /// prints the fit probability, parameter names/values, and errors.; /// You can change the position of the statistics box with these lines; /// (where g is a pointer to the TGraph):; ///; /// ~~~ {.cpp}; /// Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); /// Root > st->SetX1NDC(newx1); //new x start position; /// Root > st->SetX2NDC(newx2); //new x end position; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:6351,Availability,error,errors,6351,"trieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; /// from the fitted function.; ///; /// ### Associated functions; ///; /// One or more object (typically a TF1*) can be added to the list; /// of functions (fFunctions) associated to each graph.; /// When TGraph::Fit is invoked, the fitted function is added to this list.; /// Given a graph gr, one can retrieve an associated function; /// with:; /// ~~~ {.cpp}; /// TF1 *myfunc = gr->GetFunction(""myfunc"");; /// ~~~; ///; /// If the graph is made persistent, the list of; /// associated functions is also persistent. Given a pointer (see above); /// to an associated function myfunc, one can retrieve the function/fit; /// parameters with calls such as:; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ### Fit Statistics; ///; /// You can change the statistics box to display the fit parameters with; /// the TStyle::SetOptFit(mode) method. This mode has four digits.; /// mode = pcev (default = 0111); ///; /// - v = 1; print name/values of parameters; /// - e = 1; print errors (if e=1, v must be 1); /// - c = 1; print Chisquare/Number of degrees of freedom; /// - p = 1; print Probability; ///; /// For example: `gStyle->SetOptFit(1011);`; /// prints the fit probability, parameter names/values, and errors.; /// You can change the position of the statistics box with these lines; /// (where g is a pointer to the TGraph):; ///; /// ~~~ {.cpp}; /// Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); /// Root > st->SetX1NDC(newx1); //new x start position; /// Root > st->SetX2NDC(newx2); //new x end position; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:6582,Availability,error,errors,6582,"trieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; /// from the fitted function.; ///; /// ### Associated functions; ///; /// One or more object (typically a TF1*) can be added to the list; /// of functions (fFunctions) associated to each graph.; /// When TGraph::Fit is invoked, the fitted function is added to this list.; /// Given a graph gr, one can retrieve an associated function; /// with:; /// ~~~ {.cpp}; /// TF1 *myfunc = gr->GetFunction(""myfunc"");; /// ~~~; ///; /// If the graph is made persistent, the list of; /// associated functions is also persistent. Given a pointer (see above); /// to an associated function myfunc, one can retrieve the function/fit; /// parameters with calls such as:; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; /// Double_t err0 = myfunc->GetParError(0); //error on first parameter; /// ~~~; ///; /// ### Fit Statistics; ///; /// You can change the statistics box to display the fit parameters with; /// the TStyle::SetOptFit(mode) method. This mode has four digits.; /// mode = pcev (default = 0111); ///; /// - v = 1; print name/values of parameters; /// - e = 1; print errors (if e=1, v must be 1); /// - c = 1; print Chisquare/Number of degrees of freedom; /// - p = 1; print Probability; ///; /// For example: `gStyle->SetOptFit(1011);`; /// prints the fit probability, parameter names/values, and errors.; /// You can change the position of the statistics box with these lines; /// (where g is a pointer to the TGraph):; ///; /// ~~~ {.cpp}; /// Root > TPaveStats *st = (TPaveStats*)g->GetListOfFunctions()->FindObject(""stats""); /// Root > st->SetX1NDC(newx1); //new x start position; /// Root > st->SetX2NDC(newx2); //new x end position; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:4280,Security,Access,Access,4280,"8; /// Parameter 5 is fixed to 100.; ///; /// ### Fit range; ///; /// The fit range can be specified in two ways:; ///; /// - specify rxmax > rxmin (default is rxmin=rxmax=0); /// - specify the option ""R"". In this case, the function will be taken; /// instead of the full graph range.; ///; /// ### Changing the fitting function; ///; /// By default a chi2 fitting function is used for fitting the TGraphs's.; /// The function is implemented in `FitUtil::EvaluateChi2`.; /// In case of TGraphErrors an effective chi2 is used; /// (see TGraphErrors fit in TGraph::Fit) and is implemented in; /// `FitUtil::EvaluateChi2Effective`; /// To specify a User defined fitting function, specify option ""U"" and; /// call the following function:; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); /// ~~~; /// where MyFittingFunction is of type:; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// ### Access to the fit result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit and it converts; /// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; /// the TFitResult and behaves as a smart pointer to it. For example one can do:; /// ~~~ {.cpp}; /// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; /// from the fitted function.; ///; /// ### Associated functions; ///; //",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:4781,Security,access,access,4781," specify option ""U"" and; /// call the following function:; /// ~~~ {.cpp}; /// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); /// ~~~; /// where MyFittingFunction is of type:; /// ~~~ {.cpp}; /// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; /// ~~~; ///; /// ### Access to the fit result; ///; /// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; /// By default the TFitResultPtr contains only the status of the fit and it converts; /// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; /// the TFitResult and behaves as a smart pointer to it. For example one can do:; /// ~~~ {.cpp}; /// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; /// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; /// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; /// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; /// r->Print(""V""); // print full information of fit including covariance matrix; /// r->Write(); // store the result in a file; /// ~~~; ///; /// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; /// from the fitted function.; ///; /// ### Associated functions; ///; /// One or more object (typically a TF1*) can be added to the list; /// of functions (fFunctions) associated to each graph.; /// When TGraph::Fit is invoked, the fitted function is added to this list.; /// Given a graph gr, one can retrieve an associated function; /// with:; /// ~~~ {.cpp}; /// TF1 *myfunc = gr->GetFunction(""myfunc"");; /// ~~~; ///; /// If the graph is made persistent, the list of; /// associated functions is also persistent. Given a pointer (see above); /// to an associated function myfunc, one can retrieve the function/fit; /// parameters with calls such as:; /// ~~~ {.cpp}; /// Double_t chi2 = myfunc->GetChisquare();; /// Double_t par0 = myfunc->GetPa",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:7,Modifiability,plugin,plugin,7,"// use plugin manager to create instance of TFitEditor",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:336,Integrability,rout,routine,336,"////////////////////////////////////////////////////////////////////////////////; /// Least squares lpolynomial fitting without weights.; ///; /// - m number of parameters; /// - a array of parameters; /// - first 1st point number to fit (default =0); /// - last last point number to fit (default=fNpoints-1); ///; /// based on CERNLIB routine LSQ: Translated to C++ by Rene Brun",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:303,Deployability,update,updated,303,"////////////////////////////////////////////////////////////////////////////////; /// Returns a pointer to the histogram used to draw the axis.; /// Takes into account following cases.; ///; /// 1. if `fHistogram` exists it is returned; /// 2. if `fHistogram` doesn't exists and `gPad` exists `gPad` is updated. That; /// may trigger the creation of `fHistogram`. If `fHistogram` still does not; /// exit but `hframe` does (if user called `TPad::DrawFrame`) the pointer to; /// `hframe` histogram is returned; /// 3. after the two previous steps, if `fHistogram` still doesn't exist, then; /// it is created.",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:7,Usability,ux,uxmin,7,"//else uxmin = 0;",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx:7,Usability,ux,uxmax,7,"//else uxmax = 0;",MatchSource.CODE_COMMENT,hist/hist/src/TMultiGraph.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TMultiGraph.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPolyMarker.cxx:2,Modifiability,extend,extend,2,"//extend this polymarker to hold npoints",MatchSource.CODE_COMMENT,hist/hist/src/TPolyMarker.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPolyMarker.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPolyMarker.cxx:184,Modifiability,extend,extended,184,"////////////////////////////////////////////////////////////////////////////////; /// Set point number n.; /// if n is greater than the current size, the arrays are automatically; /// extended",MatchSource.CODE_COMMENT,hist/hist/src/TPolyMarker.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPolyMarker.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPolyMarker.cxx:6,Energy Efficiency,allocate,allocate,6,"// re-allocate the object",MatchSource.CODE_COMMENT,hist/hist/src/TPolyMarker.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPolyMarker.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:5355,Availability,error,error,5355,"t of; coordinate vectors, which hopefully provide easier feature; identification and dimensionality reduction. Let's define the covariance matrix:; \f[; \mathsf{C} = \left\langle\mathbf{y}\mathbf{y}^T\right\rangle; \quad\mbox{where}\quad; \mathbf{y} = \mathbf{x} - \left\langle\mathbf{x}\right\rangle\,,; \f]; and the brackets indicate mean value over the sample of \f$M\f$; prototypes. This matrix \f$\mathsf{C}\f$ is real, positive definite, symmetric, and will; have all its eigenvalues greater then zero. It will now be show that; among the family of all the complete orthonormal bases of the pattern; space, the base formed by the eigenvectors of the covariance matrix; and belonging to the largest eigenvalues, corresponds to the most; significant features of the description of the original prototypes. let the prototypes be expanded on into a set of \f$N\f$ basis vectors; \f$\mathbf{e}_n, n=0,\ldots,N,N+1, \ldots, P-1\f$; \f[; \mathbf{y}_i = \sum^N_{i=0} a_{i_n} \mathbf{e}_n,; \quad; i = 1, \ldots, M,; \quad; N < P-1; \f]; The `best' feature coordinates \f$\mathbf{e}_n\f$, spanning a *feature; space*, will be obtained by minimizing the error due to this; truncated expansion, i.e.,; \f[; \min\left(E_N\right) =; \min\left[\left\langle\left(\mathbf{y}_i - \sum^N_{i=0} a_{i_n} \mathbf{e}_n\right)^2\right\rangle\right]; \f]; with the conditions:; \f[; \mathbf{e}_k\bullet\mathbf{e}_j = \delta_{jk} =; \left\{\begin{array}{rcl}; 1 & \mbox{for} & k = j\\; 0 & \mbox{for} & k \neq j; \end{array}\right.; \f]; Multiplying (3) by \f$\mathbf{e}^T_n\f$ using (5),; we get; \f[; a_{i_n} = \mathbf{y}_i^T\bullet\mathbf{e}_n\,,; \f]; so the error becomes; \f{eqnarray*}{; E_N &=&; \left\langle\left[\sum_{n=N+1}^{P-1} a_{i_n}\mathbf{e}_n\right]^2\right\rangle\nonumber\\; &=&; \left\langle\left[\sum_{n=N+1}^{P-1} \mathbf{y}_i^T\bullet\mathbf{e}_n\mathbf{e}_n\right]^2\right\rangle\nonumber\\; &=&; \left\langle\sum_{n=N+1}^{P-1} \mathbf{e}_n^T\mathbf{y}_i\mathbf{y}_i^T\mathbf{e}_n\right\rangle\no",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:5849,Availability,error,error,5849,"ors; \f$\mathbf{e}_n, n=0,\ldots,N,N+1, \ldots, P-1\f$; \f[; \mathbf{y}_i = \sum^N_{i=0} a_{i_n} \mathbf{e}_n,; \quad; i = 1, \ldots, M,; \quad; N < P-1; \f]; The `best' feature coordinates \f$\mathbf{e}_n\f$, spanning a *feature; space*, will be obtained by minimizing the error due to this; truncated expansion, i.e.,; \f[; \min\left(E_N\right) =; \min\left[\left\langle\left(\mathbf{y}_i - \sum^N_{i=0} a_{i_n} \mathbf{e}_n\right)^2\right\rangle\right]; \f]; with the conditions:; \f[; \mathbf{e}_k\bullet\mathbf{e}_j = \delta_{jk} =; \left\{\begin{array}{rcl}; 1 & \mbox{for} & k = j\\; 0 & \mbox{for} & k \neq j; \end{array}\right.; \f]; Multiplying (3) by \f$\mathbf{e}^T_n\f$ using (5),; we get; \f[; a_{i_n} = \mathbf{y}_i^T\bullet\mathbf{e}_n\,,; \f]; so the error becomes; \f{eqnarray*}{; E_N &=&; \left\langle\left[\sum_{n=N+1}^{P-1} a_{i_n}\mathbf{e}_n\right]^2\right\rangle\nonumber\\; &=&; \left\langle\left[\sum_{n=N+1}^{P-1} \mathbf{y}_i^T\bullet\mathbf{e}_n\mathbf{e}_n\right]^2\right\rangle\nonumber\\; &=&; \left\langle\sum_{n=N+1}^{P-1} \mathbf{e}_n^T\mathbf{y}_i\mathbf{y}_i^T\mathbf{e}_n\right\rangle\nonumber\\; &=&; \sum_{n=N+1}^{P-1} \mathbf{e}_n^T\mathsf{C}\mathbf{e}_n; \f}; The minimization of the sum in (7) is obtained when each; term \f$\mathbf{e}_n^\mathsf{C}\mathbf{e}_n\f$ is minimum, since \f$\mathsf{C}\f$ is; positive definite. By the method of Lagrange multipliers, and the; condition (5), we get; \f[; E_N = \sum^{P-1}_{n=N+1} \left(\mathbf{e}_n^T\mathsf{C}\mathbf{e}_n -; l_n\mathbf{e}_n^T\bullet\mathbf{e}_n + l_n\right); \f]; The minimum condition \f$\frac{dE_N}{d\mathbf{e}^T_n} = 0\f$ leads to the; equation; \f[; \mathsf{C}\mathbf{e}_n = l_n\mathbf{e}_n\,,; \f]; which shows that \f$\mathbf{e}_n\f$ is an eigenvector of the covariance; matrix \f$\mathsf{C}\f$ with eigenvalue \f$l_n\f$. The estimated minimum error is; then given by; \f[; E_N \sim \sum^{P-1}_{n=N+1} \mathbf{e}_n^T\bullet l_n\mathbf{e}_n; = \sum^{P-1}_{n=N+1} l_n\,,; \f]; where \f$l_n,\,",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:6935,Availability,error,error,6935,"f{e}_n\right]^2\right\rangle\nonumber\\; &=&; \left\langle\sum_{n=N+1}^{P-1} \mathbf{e}_n^T\mathbf{y}_i\mathbf{y}_i^T\mathbf{e}_n\right\rangle\nonumber\\; &=&; \sum_{n=N+1}^{P-1} \mathbf{e}_n^T\mathsf{C}\mathbf{e}_n; \f}; The minimization of the sum in (7) is obtained when each; term \f$\mathbf{e}_n^\mathsf{C}\mathbf{e}_n\f$ is minimum, since \f$\mathsf{C}\f$ is; positive definite. By the method of Lagrange multipliers, and the; condition (5), we get; \f[; E_N = \sum^{P-1}_{n=N+1} \left(\mathbf{e}_n^T\mathsf{C}\mathbf{e}_n -; l_n\mathbf{e}_n^T\bullet\mathbf{e}_n + l_n\right); \f]; The minimum condition \f$\frac{dE_N}{d\mathbf{e}^T_n} = 0\f$ leads to the; equation; \f[; \mathsf{C}\mathbf{e}_n = l_n\mathbf{e}_n\,,; \f]; which shows that \f$\mathbf{e}_n\f$ is an eigenvector of the covariance; matrix \f$\mathsf{C}\f$ with eigenvalue \f$l_n\f$. The estimated minimum error is; then given by; \f[; E_N \sim \sum^{P-1}_{n=N+1} \mathbf{e}_n^T\bullet l_n\mathbf{e}_n; = \sum^{P-1}_{n=N+1} l_n\,,; \f]; where \f$l_n,\,n=N+1,\ldots,P\f$ \f$l_n,\,n=N+1,\ldots,P-1\f$ are the eigenvalues associated with the; omitted eigenvectors in the expansion (3). Thus, by choosing; the \f$N\f$ largest eigenvalues, and their associated eigenvectors, the; error \f$E_N\f$ is minimized. The transformation matrix to go from the pattern space to the feature; space consists of the ordered eigenvectors \f$\mathbf{e}_1,\ldots,\mathbf{e}_P\f$; \f$\mathbf{e}_0,\ldots,\mathbf{e}_{P-1}\f$ for its columns; \f[; \mathsf{T} = \left[; \begin{array}{cccc}; \mathbf{e}_0 &; \mathbf{e}_1 &; \vdots &; \mathbf{e}_{P-1}; \end{array}\right]; = \left[; \begin{array}{cccc}; \mathbf{e}_{0_0} & \mathbf{e}_{1_0} & \cdots & \mathbf{e}_{{P-1}_0}\\; \mathbf{e}_{0_1} & \mathbf{e}_{1_1} & \cdots & \mathbf{e}_{{P-1}_1}\\; \vdots & \vdots & \ddots & \vdots \\; \mathbf{e}_{0_{P-1}} & \mathbf{e}_{1_{P-1}} & \cdots & \mathbf{e}_{{P-1}_{P-1}}\\; \end{array}\right]; \f]; This is an orthogonal transformation, or rotation, of the pattern; s",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:7304,Availability,error,error,7304,"ight\rangle\nonumber\\; &=&; \sum_{n=N+1}^{P-1} \mathbf{e}_n^T\mathsf{C}\mathbf{e}_n; \f}; The minimization of the sum in (7) is obtained when each; term \f$\mathbf{e}_n^\mathsf{C}\mathbf{e}_n\f$ is minimum, since \f$\mathsf{C}\f$ is; positive definite. By the method of Lagrange multipliers, and the; condition (5), we get; \f[; E_N = \sum^{P-1}_{n=N+1} \left(\mathbf{e}_n^T\mathsf{C}\mathbf{e}_n -; l_n\mathbf{e}_n^T\bullet\mathbf{e}_n + l_n\right); \f]; The minimum condition \f$\frac{dE_N}{d\mathbf{e}^T_n} = 0\f$ leads to the; equation; \f[; \mathsf{C}\mathbf{e}_n = l_n\mathbf{e}_n\,,; \f]; which shows that \f$\mathbf{e}_n\f$ is an eigenvector of the covariance; matrix \f$\mathsf{C}\f$ with eigenvalue \f$l_n\f$. The estimated minimum error is; then given by; \f[; E_N \sim \sum^{P-1}_{n=N+1} \mathbf{e}_n^T\bullet l_n\mathbf{e}_n; = \sum^{P-1}_{n=N+1} l_n\,,; \f]; where \f$l_n,\,n=N+1,\ldots,P\f$ \f$l_n,\,n=N+1,\ldots,P-1\f$ are the eigenvalues associated with the; omitted eigenvectors in the expansion (3). Thus, by choosing; the \f$N\f$ largest eigenvalues, and their associated eigenvectors, the; error \f$E_N\f$ is minimized. The transformation matrix to go from the pattern space to the feature; space consists of the ordered eigenvectors \f$\mathbf{e}_1,\ldots,\mathbf{e}_P\f$; \f$\mathbf{e}_0,\ldots,\mathbf{e}_{P-1}\f$ for its columns; \f[; \mathsf{T} = \left[; \begin{array}{cccc}; \mathbf{e}_0 &; \mathbf{e}_1 &; \vdots &; \mathbf{e}_{P-1}; \end{array}\right]; = \left[; \begin{array}{cccc}; \mathbf{e}_{0_0} & \mathbf{e}_{1_0} & \cdots & \mathbf{e}_{{P-1}_0}\\; \mathbf{e}_{0_1} & \mathbf{e}_{1_1} & \cdots & \mathbf{e}_{{P-1}_1}\\; \vdots & \vdots & \ddots & \vdots \\; \mathbf{e}_{0_{P-1}} & \mathbf{e}_{1_{P-1}} & \cdots & \mathbf{e}_{{P-1}_{P-1}}\\; \end{array}\right]; \f]; This is an orthogonal transformation, or rotation, of the pattern; space and feature selection results in ignoring certain coordinates; in the transformed space. Christian Holm August 2000, CERN; */",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:812,Energy Efficiency,power,powerful,812,"// @(#)root/hist:$Id$; // Author: Christian Holm Christensen 1/8/2000; /*************************************************************************; * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TPrincipal; \ingroup Hist; Principal Components Analysis (PCA). The current implementation is based on the LINTRA package from CERNLIB; by R. Brun, H. Hansroul, and J. Kubler.; The class has been implemented by Christian Holm Christensen in August 2000. ## Introduction. In many applications of various fields of research, the treatment of; large amounts of data requires powerful techniques capable of rapid; data reduction and analysis. Usually, the quantities most; conveniently measured by the experimentalist, are not necessarily the; most significant for classification and analysis of the data. It is; then useful to have a way of selecting an optimal set of variables; necessary for the recognition process and reducing the dimensionality; of the problem, resulting in an easier classification procedure. This paper describes the implementation of one such method of; feature selection, namely the principal components analysis. This; multidimensional technique is well known in the field of pattern; recognition and and its use in Particle Physics has been documented; elsewhere (cf. H. Wind, <I>Function Parameterization</I>, CERN; 72-21). ## Overview; Suppose we have prototypes which are trajectories of particles,; passing through a spectrometer. If one measures the passage of the; particle at say 8 fixed planes, the trajectory is described by an; 8-component vector:; \f[; \mathbf{x} = \left(x_0, x_1, \ldots, x_7\right); \f]; in 8-dimensional pattern space. One proceeds by generating a representative tracks sample and; building up the covaria",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:1106,Modifiability,variab,variables,1106," * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /** \class TPrincipal; \ingroup Hist; Principal Components Analysis (PCA). The current implementation is based on the LINTRA package from CERNLIB; by R. Brun, H. Hansroul, and J. Kubler.; The class has been implemented by Christian Holm Christensen in August 2000. ## Introduction. In many applications of various fields of research, the treatment of; large amounts of data requires powerful techniques capable of rapid; data reduction and analysis. Usually, the quantities most; conveniently measured by the experimentalist, are not necessarily the; most significant for classification and analysis of the data. It is; then useful to have a way of selecting an optimal set of variables; necessary for the recognition process and reducing the dimensionality; of the problem, resulting in an easier classification procedure. This paper describes the implementation of one such method of; feature selection, namely the principal components analysis. This; multidimensional technique is well known in the field of pattern; recognition and and its use in Particle Physics has been documented; elsewhere (cf. H. Wind, <I>Function Parameterization</I>, CERN; 72-21). ## Overview; Suppose we have prototypes which are trajectories of particles,; passing through a spectrometer. If one measures the passage of the; particle at say 8 fixed planes, the trajectory is described by an; 8-component vector:; \f[; \mathbf{x} = \left(x_0, x_1, \ldots, x_7\right); \f]; in 8-dimensional pattern space. One proceeds by generating a representative tracks sample and; building up the covariance matrix \f$\mathsf{C}\f$. Its eigenvectors and; eigenvalues are computed by standard methods, and thus a new basis is; obtained for the origina",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:1554,Modifiability,Parameteriz,Parameterization,1554,"from CERNLIB; by R. Brun, H. Hansroul, and J. Kubler.; The class has been implemented by Christian Holm Christensen in August 2000. ## Introduction. In many applications of various fields of research, the treatment of; large amounts of data requires powerful techniques capable of rapid; data reduction and analysis. Usually, the quantities most; conveniently measured by the experimentalist, are not necessarily the; most significant for classification and analysis of the data. It is; then useful to have a way of selecting an optimal set of variables; necessary for the recognition process and reducing the dimensionality; of the problem, resulting in an easier classification procedure. This paper describes the implementation of one such method of; feature selection, namely the principal components analysis. This; multidimensional technique is well known in the field of pattern; recognition and and its use in Particle Physics has been documented; elsewhere (cf. H. Wind, <I>Function Parameterization</I>, CERN; 72-21). ## Overview; Suppose we have prototypes which are trajectories of particles,; passing through a spectrometer. If one measures the passage of the; particle at say 8 fixed planes, the trajectory is described by an; 8-component vector:; \f[; \mathbf{x} = \left(x_0, x_1, \ldots, x_7\right); \f]; in 8-dimensional pattern space. One proceeds by generating a representative tracks sample and; building up the covariance matrix \f$\mathsf{C}\f$. Its eigenvectors and; eigenvalues are computed by standard methods, and thus a new basis is; obtained for the original 8-dimensional space the expansion of the; prototypes,; \f[; \mathbf{x}_m = \sum^7_{i=0} a_{m_i} \mathbf{e}_i; \quad; \mbox{where}; \quad; a_{m_i} = \mathbf{x}^T\bullet\mathbf{e}_i; \f]; allows the study of the behavior of the coefficients \f$a_{m_i}\f$ for all; the tracks of the sample. The eigenvectors which are insignificant for; the trajectory description in the expansion will have their; corresponding coef",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:2835,Modifiability,variab,variables,2835,"ional pattern space. One proceeds by generating a representative tracks sample and; building up the covariance matrix \f$\mathsf{C}\f$. Its eigenvectors and; eigenvalues are computed by standard methods, and thus a new basis is; obtained for the original 8-dimensional space the expansion of the; prototypes,; \f[; \mathbf{x}_m = \sum^7_{i=0} a_{m_i} \mathbf{e}_i; \quad; \mbox{where}; \quad; a_{m_i} = \mathbf{x}^T\bullet\mathbf{e}_i; \f]; allows the study of the behavior of the coefficients \f$a_{m_i}\f$ for all; the tracks of the sample. The eigenvectors which are insignificant for; the trajectory description in the expansion will have their; corresponding coefficients \f$a_{m_i}\f$ close to zero for all the; prototypes. On one hand, a reduction of the dimensionality is then obtained by; omitting these least significant vectors in the subsequent analysis. On the other hand, in the analysis of real data, these least; significant variables(?) can be used for the pattern; recognition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components \f$a_{m_i}\f$, thus providing; to the user all the means of understanding their data. ## Principal Components Method; Let's consider a sample of \f$M\f$ prototypes each being characterized by; \f$P\f$ variables \f$x_0, x_1, \ldots, x_{P-1}\f$. Each prototype is a point, or a; column vector, in a \f$P\f$-dimensional *Pattern space*.; \f[; \mathbf{x} = \left[\begin{array}{c}; x_0\\x_1\\\vdots\\x_{P-1}\end{array}\right]\,,; \f]; where each \f$x_n\f$ represents the particular value associated with the; \f$n\f$-dimension. Those \f$P\f$ variables are the quantities accessible to the; experimentalist, but are no",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:3483,Modifiability,variab,variables,3483,"vectors which are insignificant for; the trajectory description in the expansion will have their; corresponding coefficients \f$a_{m_i}\f$ close to zero for all the; prototypes. On one hand, a reduction of the dimensionality is then obtained by; omitting these least significant vectors in the subsequent analysis. On the other hand, in the analysis of real data, these least; significant variables(?) can be used for the pattern; recognition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components \f$a_{m_i}\f$, thus providing; to the user all the means of understanding their data. ## Principal Components Method; Let's consider a sample of \f$M\f$ prototypes each being characterized by; \f$P\f$ variables \f$x_0, x_1, \ldots, x_{P-1}\f$. Each prototype is a point, or a; column vector, in a \f$P\f$-dimensional *Pattern space*.; \f[; \mathbf{x} = \left[\begin{array}{c}; x_0\\x_1\\\vdots\\x_{P-1}\end{array}\right]\,,; \f]; where each \f$x_n\f$ represents the particular value associated with the; \f$n\f$-dimension. Those \f$P\f$ variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The *Principal Components Method* consists of applying a; *linear* transformation to the original variables. This; transformation is described by an orthogonal matrix and is equivalent; to a rotation of the original pattern space into a new set of; coordinate vectors, which hopefully provide easier feature; identification and dimensionality reduction. Let's define the covariance matrix:; \f[; \mathsf{C} = \left\langle\mathbf{y}\mathbf{y}^T\right\rangle; \quad\mbox{where}\quad; \m",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:3819,Modifiability,variab,variables,3819,"nition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components \f$a_{m_i}\f$, thus providing; to the user all the means of understanding their data. ## Principal Components Method; Let's consider a sample of \f$M\f$ prototypes each being characterized by; \f$P\f$ variables \f$x_0, x_1, \ldots, x_{P-1}\f$. Each prototype is a point, or a; column vector, in a \f$P\f$-dimensional *Pattern space*.; \f[; \mathbf{x} = \left[\begin{array}{c}; x_0\\x_1\\\vdots\\x_{P-1}\end{array}\right]\,,; \f]; where each \f$x_n\f$ represents the particular value associated with the; \f$n\f$-dimension. Those \f$P\f$ variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The *Principal Components Method* consists of applying a; *linear* transformation to the original variables. This; transformation is described by an orthogonal matrix and is equivalent; to a rotation of the original pattern space into a new set of; coordinate vectors, which hopefully provide easier feature; identification and dimensionality reduction. Let's define the covariance matrix:; \f[; \mathsf{C} = \left\langle\mathbf{y}\mathbf{y}^T\right\rangle; \quad\mbox{where}\quad; \mathbf{y} = \mathbf{x} - \left\langle\mathbf{x}\right\rangle\,,; \f]; and the brackets indicate mean value over the sample of \f$M\f$; prototypes. This matrix \f$\mathsf{C}\f$ is real, positive definite, symmetric, and will; have all its eigenvalues greater then zero. It will now be show that; among the family of all the complete orthonormal bases of the pattern; space, the base formed by the eigenvectors of the covariance matrix; and",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:4060,Modifiability,variab,variables,4060,"combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components \f$a_{m_i}\f$, thus providing; to the user all the means of understanding their data. ## Principal Components Method; Let's consider a sample of \f$M\f$ prototypes each being characterized by; \f$P\f$ variables \f$x_0, x_1, \ldots, x_{P-1}\f$. Each prototype is a point, or a; column vector, in a \f$P\f$-dimensional *Pattern space*.; \f[; \mathbf{x} = \left[\begin{array}{c}; x_0\\x_1\\\vdots\\x_{P-1}\end{array}\right]\,,; \f]; where each \f$x_n\f$ represents the particular value associated with the; \f$n\f$-dimension. Those \f$P\f$ variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The *Principal Components Method* consists of applying a; *linear* transformation to the original variables. This; transformation is described by an orthogonal matrix and is equivalent; to a rotation of the original pattern space into a new set of; coordinate vectors, which hopefully provide easier feature; identification and dimensionality reduction. Let's define the covariance matrix:; \f[; \mathsf{C} = \left\langle\mathbf{y}\mathbf{y}^T\right\rangle; \quad\mbox{where}\quad; \mathbf{y} = \mathbf{x} - \left\langle\mathbf{x}\right\rangle\,,; \f]; and the brackets indicate mean value over the sample of \f$M\f$; prototypes. This matrix \f$\mathsf{C}\f$ is real, positive definite, symmetric, and will; have all its eigenvalues greater then zero. It will now be show that; among the family of all the complete orthonormal bases of the pattern; space, the base formed by the eigenvectors of the covariance matrix; and belonging to the largest eigenvalues, corresponds to the most; significant features of the description of the original prototypes. l",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:3056,Performance,perform,performs,3056,"ard methods, and thus a new basis is; obtained for the original 8-dimensional space the expansion of the; prototypes,; \f[; \mathbf{x}_m = \sum^7_{i=0} a_{m_i} \mathbf{e}_i; \quad; \mbox{where}; \quad; a_{m_i} = \mathbf{x}^T\bullet\mathbf{e}_i; \f]; allows the study of the behavior of the coefficients \f$a_{m_i}\f$ for all; the tracks of the sample. The eigenvectors which are insignificant for; the trajectory description in the expansion will have their; corresponding coefficients \f$a_{m_i}\f$ close to zero for all the; prototypes. On one hand, a reduction of the dimensionality is then obtained by; omitting these least significant vectors in the subsequent analysis. On the other hand, in the analysis of real data, these least; significant variables(?) can be used for the pattern; recognition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components \f$a_{m_i}\f$, thus providing; to the user all the means of understanding their data. ## Principal Components Method; Let's consider a sample of \f$M\f$ prototypes each being characterized by; \f$P\f$ variables \f$x_0, x_1, \ldots, x_{P-1}\f$. Each prototype is a point, or a; column vector, in a \f$P\f$-dimensional *Pattern space*.; \f[; \mathbf{x} = \left[\begin{array}{c}; x_0\\x_1\\\vdots\\x_{P-1}\end{array}\right]\,,; \f]; where each \f$x_n\f$ represents the particular value associated with the; \f$n\f$-dimension. Those \f$P\f$ variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The *Principal Components Method* consists of applying a; *linear* transformation to the original variables. This; transfor",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:3848,Security,access,accessible,3848,"nition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components \f$a_{m_i}\f$, thus providing; to the user all the means of understanding their data. ## Principal Components Method; Let's consider a sample of \f$M\f$ prototypes each being characterized by; \f$P\f$ variables \f$x_0, x_1, \ldots, x_{P-1}\f$. Each prototype is a point, or a; column vector, in a \f$P\f$-dimensional *Pattern space*.; \f[; \mathbf{x} = \left[\begin{array}{c}; x_0\\x_1\\\vdots\\x_{P-1}\end{array}\right]\,,; \f]; where each \f$x_n\f$ represents the particular value associated with the; \f$n\f$-dimension. Those \f$P\f$ variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The *Principal Components Method* consists of applying a; *linear* transformation to the original variables. This; transformation is described by an orthogonal matrix and is equivalent; to a rotation of the original pattern space into a new set of; coordinate vectors, which hopefully provide easier feature; identification and dimensionality reduction. Let's define the covariance matrix:; \f[; \mathsf{C} = \left\langle\mathbf{y}\mathbf{y}^T\right\rangle; \quad\mbox{where}\quad; \mathbf{y} = \mathbf{x} - \left\langle\mathbf{x}\right\rangle\,,; \f]; and the brackets indicate mean value over the sample of \f$M\f$; prototypes. This matrix \f$\mathsf{C}\f$ is real, positive definite, symmetric, and will; have all its eigenvalues greater then zero. It will now be show that; among the family of all the complete orthonormal bases of the pattern; space, the base formed by the eigenvectors of the covariance matrix; and",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:121,Modifiability,variab,variables,121,"////////////////////////////////////////////////////////////////////////////////; /// Constructor. Argument is number of variables in the sample of data; /// Options are:; /// - N Normalize the covariance matrix (default); /// - D Store input data (default); ///; /// The created object is named ""principal"" by default.",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:866,Availability,error,errors,866,"////////////////////////////////////////////////////////////////////////////////; /// Add a data point and update the covariance matrix. The input; /// array must be <TT>fNumberOfVariables</TT> long.; ///; ///; /// The Covariance matrix and mean values of the input data is calculated; /// on the fly by the following equations:; ///; /// \f[; /// \left<x_i\right>^{(0)} = x_{i0}; /// \f]; ///; ///; /// \f[; /// \left<x_i\right>^{(n)} = \left<x_i\right>^{(n-1)}; /// + \frac1n \left(x_{in} - \left<x_i\right>^{(n-1)}\right); /// \f]; ///; /// \f[; /// C_{ij}^{(0)} = 0; /// \f]; ///; ///; ///; /// \f[; /// C_{ij}^{(n)} = C_{ij}^{(n-1)}; /// + \frac1{n-1}\left[\left(x_{in} - \left<x_i\right>^{(n)}\right); /// \left(x_{jn} - \left<x_j\right>^{(n)}\right)\right]; /// - \frac1n C_{ij}^{(n-1)}; /// \f]; ///; /// since this is a really fast method, with no rounding errors (please; /// refer to CERN 72-21 pp. 54-106).; ///; ///; /// The data is stored internally in a <TT>TVectorD</TT>, in the following; /// way:; ///; /// \f[; /// \mathbf{x} = \left[\left(x_{0_0},\ldots,x_{{P-1}_0}\right),\ldots,; /// \left(x_{0_i},\ldots,x_{{P-1}_i}\right), \ldots\right]; /// \f]; ///; /// With \f$P\f$ as defined in the class description.",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:107,Deployability,update,update,107,"////////////////////////////////////////////////////////////////////////////////; /// Add a data point and update the covariance matrix. The input; /// array must be <TT>fNumberOfVariables</TT> long.; ///; ///; /// The Covariance matrix and mean values of the input data is calculated; /// on the fly by the following equations:; ///; /// \f[; /// \left<x_i\right>^{(0)} = x_{i0}; /// \f]; ///; ///; /// \f[; /// \left<x_i\right>^{(n)} = \left<x_i\right>^{(n-1)}; /// + \frac1n \left(x_{in} - \left<x_i\right>^{(n-1)}\right); /// \f]; ///; /// \f[; /// C_{ij}^{(0)} = 0; /// \f]; ///; ///; ///; /// \f[; /// C_{ij}^{(n)} = C_{ij}^{(n-1)}; /// + \frac1{n-1}\left[\left(x_{in} - \left<x_i\right>^{(n)}\right); /// \left(x_{jn} - \left<x_j\right>^{(n)}\right)\right]; /// - \frac1n C_{ij}^{(n-1)}; /// \f]; ///; /// since this is a really fast method, with no rounding errors (please; /// refer to CERN 72-21 pp. 54-106).; ///; ///; /// The data is stored internally in a <TT>TVectorD</TT>, in the following; /// way:; ///; /// \f[; /// \mathbf{x} = \left[\left(x_{0_0},\ldots,x_{{P-1}_0}\right),\ldots,; /// \left(x_{0_i},\ldots,x_{{P-1}_i}\right), \ldots\right]; /// \f]; ///; /// With \f$P\f$ as defined in the class description.",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:48,Security,access,access,48,"// use directly vector array for faster element access",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear the data in Object. Notice, that's not possible to change; /// the dimension of the original data.",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:516,Modifiability,variab,variables,516,"////////////////////////////////////////////////////////////////////////////////; /// Generates the file `<filename>`, with `.C` appended if it does; /// argument doesn't end in .cxx or .C.; ///; /// The file contains the implementation of two functions; /// ~~~ {.cpp}; /// void X2P(Double_t *x, Double *p); /// void P2X(Double_t *p, Double *x, Int_t nTest); /// ~~~; /// which does the same as `TPrincipal::X2P` and `TPrincipal::P2X`; /// respectively. Please refer to these methods.; ///; /// Further, the static variables:; /// ~~~ {.cpp}; /// Int_t gNVariables; /// Double_t gEigenValues[]; /// Double_t gEigenVectors[]; /// Double_t gMeanValues[]; /// Double_t gSigmaValues[]; /// ~~~; /// are initialized. The only ROOT header file needed is Rtypes.h; ///; /// See TPrincipal::MakeRealCode for a list of options",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:734,Modifiability,variab,variable,734,"////////////////////////////////////////////////////////////////////////////////; /// Make histograms of the result of the analysis.; /// The option string say which histograms to create; /// - X Histogram original data; /// - P Histogram principal components corresponding to; /// original data; /// - D Histogram the difference between the original data; /// and the projection of principal unto a lower; /// dimensional subspace (2D histograms); /// - E Histogram the eigenvalues; /// - S Histogram the square of the residues; /// (see `TPrincipal::SumOfSquareResiduals`); /// The histograms will be named `<name>_<type><number>`, where `<name>`; /// is the first argument, `<type>` is one of X,P,D,E,S, and `<number>`; /// is the variable.",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:3,Deployability,update,update,3,"// update the original data histogram",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:86,Performance,Perform,Perform,86,"////////////////////////////////////////////////////////////////////////////////; /// Perform the principal components analysis.; /// This is done in several stages in the TMatrix::EigenVectors method:; /// - Transform the covariance matrix into a tridiagonal matrix.; /// - Find the eigenvalues and vectors of the tridiagonal matrix.",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:195,Modifiability,variab,variables,195,"//; // Now for the data; //; // We make the Eigenvector matrix, Eigenvalue vector, Sigma vector,; // and Mean value vector static, since all are needed in both; // functions. Also ,the number of variables are stored in a static; // variable.",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:232,Modifiability,variab,variable,232,"//; // Now for the data; //; // We make the Eigenvector matrix, Eigenvalue vector, Sigma vector,; // and Mean value vector static, since all are needed in both; // functions. Also ,the number of variables are stored in a static; // variable.",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:309,Energy Efficiency,allocate,allocated,309,"////////////////////////////////////////////////////////////////////////////////; /// Calculate x as a function of nTest of the most significant; /// principal components p, and return it in x.; /// It's the users responsibility to make sure that both x and p are; /// of the right size (i.e., memory must be allocated for x).",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:86,Testability,Test,Test,86,"////////////////////////////////////////////////////////////////////////////////; /// Test the PCA, bye calculating the sum square of residuals; /// (see method SumOfSquareResiduals), and display the histogram",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:299,Energy Efficiency,allocate,allocated,299,"////////////////////////////////////////////////////////////////////////////////; /// Calculate the principal components from the original data vector; /// x, and return it in p.; ///; /// It's the users responsibility to make sure that both x and p are; /// of the right size (i.e., memory must be allocated for p).",MatchSource.CODE_COMMENT,hist/hist/src/TPrincipal.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:130,Availability,error,error,130,"/** \class TProfile; \ingroup Histograms; Profile Histogram.; Profile histograms are used to display the mean; value of Y and its error for each bin in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; Profile histograms are in many cases an; elegant replacement of two-dimensional histograms. The inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter plot, but if Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the avera",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:169,Availability,error,error,169,"/** \class TProfile; \ingroup Histograms; Profile Histogram.; Profile histograms are used to display the mean; value of Y and its error for each bin in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; Profile histograms are in many cases an; elegant replacement of two-dimensional histograms. The inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter plot, but if Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the avera",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:203,Availability,error,error,203,"/** \class TProfile; \ingroup Histograms; Profile Histogram.; Profile histograms are used to display the mean; value of Y and its error for each bin in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; Profile histograms are in many cases an; elegant replacement of two-dimensional histograms. The inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter plot, but if Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the avera",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1184,Availability,error,error,1184,"n in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; Profile histograms are in many cases an; elegant replacement of two-dimensional histograms. The inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter plot, but if Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the average of the s(j) for all bins if; the static function TProfile::Approximate() has been called.; This simple/crude approximation was suggested in orde",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1281,Availability,error,errors,1281,"n in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; Profile histograms are in many cases an; elegant replacement of two-dimensional histograms. The inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter plot, but if Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the average of the s(j) for all bins if; the static function TProfile::Approximate() has been called.; This simple/crude approximation was suggested in orde",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1451,Availability,Error,Error,1451,"al; histogram or scatter plot, but if Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the average of the s(j) for all bins if; the static function TProfile::Approximate() has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for more on error options. ### Creating and drawing a profile histogram; ~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof = new TPro",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1768,Availability,Error,Error,1768,"small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the average of the s(j) for all bins if; the static function TProfile::Approximate() has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for more on error options. ### Creating and drawing a profile histogram; ~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile histogra",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1964,Availability,error,error,1964,"l letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the average of the s(j) for all bins if; the static function TProfile::Approximate() has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for more on error options. ### Creating and drawing a profile histogram; ~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile histograms",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:2299,Availability,error,error,2299,"l letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the average of the s(j) for all bins if; the static function TProfile::Approximate() has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for more on error options. ### Creating and drawing a profile histogram; ~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile histograms",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:794,Integrability,rout,routines,794,"/** \class TProfile; \ingroup Histograms; Profile Histogram.; Profile histograms are used to display the mean; value of Y and its error for each bin in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; Profile histograms are in many cases an; elegant replacement of two-dimensional histograms. The inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter plot, but if Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the avera",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1295,Integrability,depend,depending,1295,"n in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ).; Profile histograms are in many cases an; elegant replacement of two-dimensional histograms. The inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter plot, but if Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the average of the s(j) for all bins if; the static function TProfile::Approximate() has been called.; This simple/crude approximation was suggested in orde",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:2100,Usability,simpl,simple,2100,"l letters) of the elements for bin j.; \f[; \begin{align}; H(j) &= \sum w \cdot Y \\; E(j) &= \sum w \cdot Y^2 \\; W(j) &= \sum w & &\text{if weights different from 1, the number of bin effective entries is used} \\; h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; \end{align}; \f]; The bin content is always the mean of the Y values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(j) &= h(j) \\; \text{GetBinError}(j) &=; \begin{cases}; e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]; In the special case where s(j) is zero (eg, case of 1 entry only in one bin); the bin error e(j) is computed from the average of the s(j) for all bins if; the static function TProfile::Approximate() has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOptions for more on error options. ### Creating and drawing a profile histogram; ~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }; ~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile histograms",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:828,Availability,error,errors,828,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first five parameters are similar to TH1D::TH1D.; /// All values of y are accepted at filling time.; /// To fill a profile histogram, one must use TProfile::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable y is between fYmin and fYmax.; /// If a minimum or maximum value is set for the Y scale before filling,; /// then all values below ymin or above ymax will be discarded.; /// Setting the minimum or maximum value for the Y scale before filling; /// has the same effect as calling the special TProfile constructor below; /// where ymin and ymax are specified.; ///; /// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; /// (spread option), or e(j) if `CHOPT`='' (error on mean).; ///; /// See TProfile::BuildOptions() for explanation of parameters; ///; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:915,Availability,error,error,915,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first five parameters are similar to TH1D::TH1D.; /// All values of y are accepted at filling time.; /// To fill a profile histogram, one must use TProfile::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable y is between fYmin and fYmax.; /// If a minimum or maximum value is set for the Y scale before filling,; /// then all values below ymin or above ymax will be discarded.; /// Setting the minimum or maximum value for the Y scale before filling; /// has the same effect as calling the special TProfile constructor below; /// where ymin and ymax are specified.; ///; /// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; /// (spread option), or e(j) if `CHOPT`='' (error on mean).; ///; /// See TProfile::BuildOptions() for explanation of parameters; ///; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:407,Modifiability,variab,variable,407,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first five parameters are similar to TH1D::TH1D.; /// All values of y are accepted at filling time.; /// To fill a profile histogram, one must use TProfile::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable y is between fYmin and fYmax.; /// If a minimum or maximum value is set for the Y scale before filling,; /// then all values below ymin or above ymax will be discarded.; /// Setting the minimum or maximum value for the Y scale before filling; /// has the same effect as calling the special TProfile constructor below; /// where ymin and ymax are specified.; ///; /// H(j) is printed as the channel contents. The errors displayed are s(j) if `option`='S'; /// (spread option), or e(j) if `CHOPT`='' (error on mean).; ///; /// See TProfile::BuildOptions() for explanation of parameters; ///; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:209,Availability,error,errors,209,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Profile histograms with variable bin size.; ///; /// See TProfile::BuildOptions() for more explanations on errors; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:126,Modifiability,variab,variable,126,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Profile histograms with variable bin size.; ///; /// See TProfile::BuildOptions() for more explanations on errors; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:207,Availability,error,errors,207,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Profile histograms with variable bin size.; ///; /// See TProfile::BuildOptions for more explanations on errors; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:126,Modifiability,variab,variable,126,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Profile histograms with variable bin size.; ///; /// See TProfile::BuildOptions for more explanations on errors; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:202,Availability,error,errors,202,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Profile histograms with variable bin size.; /// See TProfile::BuildOptions for more explanations on errors; ///; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:126,Modifiability,variab,variable,126,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Profile histograms with variable bin size.; /// See TProfile::BuildOptions for more explanations on errors; ///; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:454,Availability,error,errors,454,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Profile histograms with range in y.; ///; /// The first five parameters are similar to TH1D::TH1D.; /// Only the values of Y between ylow and yup will be considered at filling time.; /// ylow and yup will also be the maximum and minimum values; /// on the y scale when drawing the profile.; ///; /// See TProfile::BuildOptions for more explanations on errors; ///; /// see also comments in the TH1 base class constructors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:402,Availability,error,error,402,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this cas",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:520,Availability,error,errors,520,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this cas",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:544,Availability,error,error,544,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this cas",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:747,Availability,error,errors,747,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this cas",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:771,Availability,error,error,771,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this cas",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:823,Availability,Error,Errors,823,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this cas",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:879,Availability,Error,Errors,879,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this cas",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:913,Availability,error,error,913,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this cas",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1047,Availability,error,error,1047,"///////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1106,Availability,error,error,1106,"///////; /// Set Profile histogram structure and options.; ///; /// \param[in] ymin minimum value allowed for y; /// \param[in] ymax maximum value allowed for y; /// if (ymin = ymax = 0) there are no limits on the allowed y values (ymin = -inf, ymax = +inf); /// \param[in] option this is the option for the computation of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1385,Availability,error,error,1385,"of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); ///; /// If a bin has N data points all with the same value Y (especially; /// possible when dealing with integers), the spread in Y for that bin; /// is zero, and the uncertainty assigned is also zero, and the bin is; /// ignored in making subsequent fits.; /// To avoid this problem one can use an approximati",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1416,Availability,Error,Errors,1416,"of the y error of the profile ( TProfile::GetBinError ); /// possible values for the options are:; /// - ' ' (Default) the bin errors are the standard error on the mean of Y = S(Y)/SQRT(N); /// where S(Y) is the standard deviation (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); ///; /// If a bin has N data points all with the same value Y (especially; /// possible when dealing with integers), the spread in Y for that bin; /// is zero, and the uncertainty assigned is also zero, and the bin is; /// ignored in making subsequent fits.; /// To avoid this problem one can use an approximati",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1553,Availability,error,errors,1553,"tion (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); ///; /// If a bin has N data points all with the same value Y (especially; /// possible when dealing with integers), the spread in Y for that bin; /// is zero, and the uncertainty assigned is also zero, and the bin is; /// ignored in making subsequent fits.; /// To avoid this problem one can use an approximation for the standard deviation S(Y),; /// by using the average of all the S(Y) of the other Profile bins. To use this approximation; /// one must call before TProfile::Approximate; /// This approximation applies only for the de",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1672,Availability,error,error,1672,"tion (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); ///; /// If a bin has N data points all with the same value Y (especially; /// possible when dealing with integers), the spread in Y for that bin; /// is zero, and the uncertainty assigned is also zero, and the bin is; /// ignored in making subsequent fits.; /// To avoid this problem one can use an approximation for the standard deviation S(Y),; /// by using the average of all the S(Y) of the other Profile bins. To use this approximation; /// one must call before TProfile::Approximate; /// This approximation applies only for the de",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1782,Availability,error,error,1782,"tion (RMS) of the Y data in the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); ///; /// If a bin has N data points all with the same value Y (especially; /// possible when dealing with integers), the spread in Y for that bin; /// is zero, and the uncertainty assigned is also zero, and the bin is; /// ignored in making subsequent fits.; /// To avoid this problem one can use an approximation for the standard deviation S(Y),; /// by using the average of all the S(Y) of the other Profile bins. To use this approximation; /// one must call before TProfile::Approximate; /// This approximation applies only for the de",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:2349,Safety,avoid,avoid,2349," the bin; /// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); /// (i.e the errors are the standard error on the bin content of the profile); /// - 's' Errors are the standard deviation of Y, S(Y); /// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); /// The only difference is only when the standard deviation in Y is zero.; /// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; /// 1./SQRT(12*N).; /// This approximation assumes that the Y values are integer (e.g. ADC counts); /// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; /// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); /// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; /// W is obtained as from TProfile::GetBinEntries(ibin); /// This errors corresponds to the standard deviation of weighted mean where each; /// measurement Y is uncorrelated and has an error sigma, which is expressed in the; /// weight used to fill the Profile: w = 1/sigma^2; /// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); ///; /// In the case of Profile filled weights and with TProfile::Sumw2() called,; /// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; /// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); ///; /// If a bin has N data points all with the same value Y (especially; /// possible when dealing with integers), the spread in Y for that bin; /// is zero, and the uncertainty assigned is also zero, and the bin is; /// ignored in making subsequent fits.; /// To avoid this problem one can use an approximation for the standard deviation S(Y),; /// by using the average of all the S(Y) of the other Profile bins. To use this approximation; /// one must call before TProfile::Approximate; /// This approximation applies only for the default and the 's' options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this + c1*f1",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this + c1*h1",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:220,Availability,error,error,220,"////////////////////////////////////////////////////////////////////////////////; /// Static function to set the fgApproximate flag.; ///; ///When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; ///; /// - the number of bins in the profile is less than 1002; /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:251,Availability,error,error,251,"////////////////////////////////////////////////////////////////////////////////; /// Static function to set the fgApproximate flag.; ///; ///When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; ///; /// - the number of bins in the profile is less than 1002; /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:443,Availability,error,error,443,"////////////////////////////////////////////////////////////////////////////////; /// Static function to set the fgApproximate flag.; ///; ///When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; ///; /// - the number of bins in the profile is less than 1002; /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)`.; ///; /// This function is not implemented for the TProfile",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:88,Availability,error,error,88,"// maintaining the correct sum of weights square is not supported when dividing; // bin error resulting from division of profile needs to be checked",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:30,Availability,ERROR,ERRORS,30,"//THE ALGORITHM COMPUTING THE ERRORS IS WRONG. HELP REQUIRED",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:88,Availability,error,error,88,"// maintaining the correct sum of weights square is not supported when dividing; // bin error resulting from division of profile needs to be checked",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:97,Availability,error,error,97,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:146,Availability,error,errors,146,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:198,Availability,error,errors,198,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:295,Availability,error,errors,295,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:456,Availability,error,errors,456,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:669,Availability,error,errors,669,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:699,Availability,error,errors,699,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1005,Availability,error,error,1005,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:224,Modifiability,evolve,evolved,224,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile histogram; ///; /// Computing errors: A moving field; ///; /// The computation of errors for a TProfile has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.00, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; /// eprim2 very small and the bin errors set to the average bin errors, following; /// recommendations from a group of users.; /// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; /// should be applied only to low statistic bins.; /// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; /// to take two times the average error on all bins for these low; /// statistics bins giving a very small value for eprim2.; /// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; /// when a TProfile is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile with a large number of; /// bins (eg 100000).; /// - in version 3.05/06, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; ///; /// Ideas for improvements of this algorithm are welcome. No suggestions; /// received since our call for advice to roottalk in Jul 2002.; /// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:119,Availability,error,errors,119,"////////////////////////////////////////////////////////////////////////////////; /// Return option to compute profile errors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:462,Usability,simpl,simply,462,"////////////////////////////////////////////////////////////////////////////////; /// fill the array stats from the contents of this profile.; ///; /// The array stats must be correctly dimensioned in the calling program.; ///; /// - stats[0] = sumw; /// - stats[1] = sumw2; /// - stats[2] = sumwx; /// - stats[3] = sumwx2; /// - stats[4] = sumwy; /// - stats[5] = sumwy2; ///; /// If no axis-subrange is specified (via TAxis::SetRange), the array stats; /// is simply a copy of the statistics quantities computed at filling time.; /// If a sub-range is specified, the function recomputes these quantities; /// from the bin contents in the current axis range.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Energy Efficiency,Reduce,Reduce,86,"////////////////////////////////////////////////////////////////////////////////; /// Reduce the number of bins for this axis to the number of bins having a label.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:436,Availability,down,down,436,"////////////////////////////////////////////////////////////////////////////////; /// Set option(s) to draw axis with labels.; ///; /// option might have the following values:; ///; /// - ""a"" sort by alphabetic order; /// - "">"" sort by decreasing values; /// - ""<"" sort by increasing values; /// - ""h"" draw labels horizontal; /// - ""v"" draw labels vertical; /// - ""u"" draw labels up (end of label right adjusted); /// - ""d"" draw labels down (start of label left adjusted)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:276,Availability,error,errors,276,"////////////////////////////////////////////////////////////////////////////////; ///Merge all histograms in the collection in this histogram.; ///; /// This function computes the min/max for the x axis,; /// compute a new number of bins, if necessary,; /// add bin contents, errors and statistics.; /// If overflows are present and limits are different the function will fail.; /// The function returns the total number of entries in the result histogram; /// if the merge is successful, -1 otherwise.; ///; /// IMPORTANT remark. The axis x may have different number; /// of bins and different limits, BUT the largest bin width must be; /// a multiple of the smallest bin width and the upper limit must also; /// be a multiple of the bin width.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c1*f1; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:232,Availability,error,errors,232,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile into a 1-D histogram along X; ///; /// The projection is always of the type TH1D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// otherwise (default) it will be equal to GetBinContent(bin); /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH1D using the 2-nd value as a weight.; /// This makes sense only for profile filled with weights =1. If not, the error of the; /// projected histogram obtained with this option will not be correct.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:311,Availability,error,errors,311,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile into a 1-D histogram along X; ///; /// The projection is always of the type TH1D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// otherwise (default) it will be equal to GetBinContent(bin); /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH1D using the 2-nd value as a weight.; /// This makes sense only for profile filled with weights =1. If not, the error of the; /// projected histogram obtained with this option will not be correct.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:447,Availability,error,errors,447,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile into a 1-D histogram along X; ///; /// The projection is always of the type TH1D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// otherwise (default) it will be equal to GetBinContent(bin); /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH1D using the 2-nd value as a weight.; /// This makes sense only for profile filled with weights =1. If not, the error of the; /// projected histogram obtained with this option will not be correct.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:776,Availability,error,errors,776,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile into a 1-D histogram along X; ///; /// The projection is always of the type TH1D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// otherwise (default) it will be equal to GetBinContent(bin); /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH1D using the 2-nd value as a weight.; /// This makes sense only for profile filled with weights =1. If not, the error of the; /// projected histogram obtained with this option will not be correct.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1178,Availability,error,error,1178,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile into a 1-D histogram along X; ///; /// The projection is always of the type TH1D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// otherwise (default) it will be equal to GetBinContent(bin); /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH1D using the 2-nd value as a weight.; /// This makes sense only for profile filled with weights =1. If not, the error of the; /// projected histogram obtained with this option will not be correct.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:458,Usability,simpl,simply,458,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile into a 1-D histogram along X; ///; /// The projection is always of the type TH1D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// otherwise (default) it will be equal to GetBinContent(bin); /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH1D using the 2-nd value as a weight.; /// This makes sense only for profile filled with weights =1. If not, the error of the; /// projected histogram obtained with this option will not be correct.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:35,Availability,error,errors,35,"// if option E projected histogram errors are same as profile",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:27,Availability,error,error,27,"// in case of option W bin error is deduced from bin sum of z**2 values of profile; // this is correct only if the profile is filled with weights =1",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:79,Availability,error,error,79,"// in case of bin entries and profile is weighted, we need to set also the bin error",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:421,Availability,error,errors,421,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this profile grouping ngroup bins together.; ///; /// ## case 1 xbins=0; /// if newname is not blank a new temporary profile hnew is created.; /// else the current profile is modified (default); /// The parameter ngroup indicates how many bins of this have to me merged; /// into one bin of hnew; /// If the original profile has errors stored (via Sumw2), the resulting; /// profile has new errors correctly calculated.; ///; /// examples: if hp is an existing TProfile histogram with 100 bins; ///; /// ~~~ {.cpp}; /// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; /// hp->Rebin(5); //merges five bins in one in hp; /// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; /// //merging 5 bins of hp in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned profile is changed; /// to the upper edge of the bin=newbins*ngroup and the corresponding; /// bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// ## case 2 xbins!=0; /// a new profile is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created profile; /// The array xbins must contain ngroup+1 elements that represent the low-edge; /// of the bins.; /// The data of the old bins are added to the new bin which contains the bin center; /// of the old bins. It is possible that information from the old binning are attached; /// to the under-/overflow bins of the new binning.; ///; /// examples: if hp is an existing TProfile with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:483,Availability,error,errors,483,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this profile grouping ngroup bins together.; ///; /// ## case 1 xbins=0; /// if newname is not blank a new temporary profile hnew is created.; /// else the current profile is modified (default); /// The parameter ngroup indicates how many bins of this have to me merged; /// into one bin of hnew; /// If the original profile has errors stored (via Sumw2), the resulting; /// profile has new errors correctly calculated.; ///; /// examples: if hp is an existing TProfile histogram with 100 bins; ///; /// ~~~ {.cpp}; /// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; /// hp->Rebin(5); //merges five bins in one in hp; /// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; /// //merging 5 bins of hp in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned profile is changed; /// to the upper edge of the bin=newbins*ngroup and the corresponding; /// bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// ## case 2 xbins!=0; /// a new profile is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created profile; /// The array xbins must contain ngroup+1 elements that represent the low-edge; /// of the bins.; /// The data of the old bins are added to the new bin which contains the bin center; /// of the old bins. It is possible that information from the old binning are attached; /// to the under-/overflow bins of the new binning.; ///; /// examples: if hp is an existing TProfile with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1295,Modifiability,variab,variable,1295,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this profile grouping ngroup bins together.; ///; /// ## case 1 xbins=0; /// if newname is not blank a new temporary profile hnew is created.; /// else the current profile is modified (default); /// The parameter ngroup indicates how many bins of this have to me merged; /// into one bin of hnew; /// If the original profile has errors stored (via Sumw2), the resulting; /// profile has new errors correctly calculated.; ///; /// examples: if hp is an existing TProfile histogram with 100 bins; ///; /// ~~~ {.cpp}; /// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; /// hp->Rebin(5); //merges five bins in one in hp; /// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; /// //merging 5 bins of hp in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned profile is changed; /// to the upper edge of the bin=newbins*ngroup and the corresponding; /// bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// ## case 2 xbins!=0; /// a new profile is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created profile; /// The array xbins must contain ngroup+1 elements that represent the low-edge; /// of the bins.; /// The data of the old bins are added to the new bin which contains the bin center; /// of the old bins. It is possible that information from the old binning are attached; /// to the under-/overflow bins of the new binning.; ///; /// examples: if hp is an existing TProfile with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:1888,Modifiability,variab,variable,1888,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this profile grouping ngroup bins together.; ///; /// ## case 1 xbins=0; /// if newname is not blank a new temporary profile hnew is created.; /// else the current profile is modified (default); /// The parameter ngroup indicates how many bins of this have to me merged; /// into one bin of hnew; /// If the original profile has errors stored (via Sumw2), the resulting; /// profile has new errors correctly calculated.; ///; /// examples: if hp is an existing TProfile histogram with 100 bins; ///; /// ~~~ {.cpp}; /// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; /// hp->Rebin(5); //merges five bins in one in hp; /// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; /// //merging 5 bins of hp in one bin; /// ~~~; ///; /// NOTE: If ngroup is not an exact divider of the number of bins,; /// the top limit of the rebinned profile is changed; /// to the upper edge of the bin=newbins*ngroup and the corresponding; /// bins are added to the overflow bin.; /// Statistics will be recomputed from the new bin contents.; ///; /// ## case 2 xbins!=0; /// a new profile is created (you should specify newname).; /// The parameter ngroup is the number of variable size bins in the created profile; /// The array xbins must contain ngroup+1 elements that represent the low-edge; /// of the bins.; /// The data of the old bins are added to the new bin which contains the bin center; /// of the old bins. It is possible that information from the old binning are attached; /// to the under-/overflow bins of the new binning.; ///; /// examples: if hp is an existing TProfile with 100 bins; ///; /// ~~~ {.cpp}; /// Double_t xbins[25] = {...} array of low-edges (xbins[25] is the upper edge of last bin; /// hp->Rebin(24,""hpnew"",xbins); //creates a new variable bin size profile hpnew; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:44,Modifiability,variab,variable,44,"// in the case of xbins given (rebinning in variable bins) ngroup is the new number of bins.; // and number of grouped bins is not constant.; // when looping for setting the contents for the new histogram we; // need to loop on all bins of original histogram. Set then ngroup=nbins",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:20,Modifiability,variab,variable,20,"// for rebinning of variable bins in a constant group",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:21,Modifiability,variab,variable,21,"// when rebinning in variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:459,Availability,error,errors,459,"////////////////////////////////////////////////////////////////////////////////; /// Profile histogram is resized along x axis such that x is in the axis range.; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The axis must be extendable before invoking this function.; ///; /// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:415,Modifiability,extend,extended,415,"////////////////////////////////////////////////////////////////////////////////; /// Profile histogram is resized along x axis such that x is in the axis range.; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The axis must be extendable before invoking this function.; ///; /// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:504,Modifiability,extend,extendable,504,"////////////////////////////////////////////////////////////////////////////////; /// Profile histogram is resized along x axis such that x is in the axis range.; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The axis must be extendable before invoking this function.; ///; /// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:63,Modifiability,variab,variable,63,"//Note the following restrictions in the code generated:; // - variable bin size not implemented; // - SetErrorOption not implemented",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:109,Safety,safe,safer,109,"//histogram pointer has by default the histogram name.; //however, in case histogram has no directory, it is safer to add a incremental suffix",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:12,Availability,error,errors,12,"// save bin errors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:116,Availability,error,errors,116,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:161,Availability,error,errors,161,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:235,Availability,error,errors,235,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:259,Availability,error,error,259,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:332,Availability,error,error,332,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:523,Availability,error,errors,523,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:734,Availability,Error,Errors,734,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:774,Availability,error,errors,774,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:905,Availability,error,error,905,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:939,Availability,Error,Errors,939,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile errors.; ///; /// The computation of the bin errors is based on the parameter option:; ///; /// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'s' The bin errors are the standard deviations of the Y bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Y is 0 and the number of bin entries is > 0; /// -'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Y is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements y +/- dy,; /// and the profile is filled with values y and weights w = 1/dy**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:114,Availability,error,error,114,"/** \class TProfile2D; \ingroup Histograms; Profile2D histograms are used to display the mean; value of Z and its error for each cell in X,Y.; Profile2D histograms are in many cases an; elegant replacement of three-dimensional histograms : the inter-relation of three; measured quantities X, Y and Z can always be visualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; \f[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \f]; The bin content is always the mean of the Z values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggeste",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1122,Availability,error,errors,1122,"ams are used to display the mean; value of Z and its error for each cell in X,Y.; Profile2D histograms are in many cases an; elegant replacement of three-dimensional histograms : the inter-relation of three; measured quantities X, Y and Z can always be visualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; \f[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \f]; The bin content is always the mean of the Z values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1300,Availability,Error,Error,1300,"sualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; \f[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \f]; The bin content is always the mean of the Z values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. ### Creating and drawing a 2D profile; ~~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1621,Availability,Error,Error,1621,"ter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; \f[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \f]; The bin content is always the mean of the Z values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. ### Creating and drawing a 2D profile; ~~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }; ~~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile2D histograms.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1821,Availability,error,error,1821,"ter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; \f[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \f]; The bin content is always the mean of the Z values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. ### Creating and drawing a 2D profile; ~~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }; ~~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile2D histograms.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:769,Integrability,rout,routines,769,"/** \class TProfile2D; \ingroup Histograms; Profile2D histograms are used to display the mean; value of Z and its error for each cell in X,Y.; Profile2D histograms are in many cases an; elegant replacement of three-dimensional histograms : the inter-relation of three; measured quantities X, Y and Z can always be visualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; \f[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \f]; The bin content is always the mean of the Z values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggeste",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1136,Integrability,depend,depending,1136,"ams are used to display the mean; value of Z and its error for each cell in X,Y.; Profile2D histograms are in many cases an; elegant replacement of three-dimensional histograms : the inter-relation of three; measured quantities X, Y and Z can always be visualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; \f[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \f]; The bin content is always the mean of the Z values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1962,Usability,simpl,simple,1962,"ter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell i, j.; \f[; \begin{align}; H(i,j) &= \sum w \cdot Z \\; E(i,j) &= \sum w \cdot Z^2 \\; W(i,j) &= \sum w \\; h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; \end{align}; \f]; The bin content is always the mean of the Z values, but errors change depending on options:; \f[; \begin{align}; \text{GetBinContent}(i,j) &= h(i,j) \\; \text{GetBinError}(i,j) &=; \begin{cases}; e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; \end{cases}; \end{align}; \f]. In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); the bin error e(I,J) is computed from the average of the s(I,J) for all cells; if the static function TProfile2D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. ### Creating and drawing a 2D profile; ~~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }; ~~~~; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile2D histograms.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:834,Availability,error,errors,834,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first eight parameters are similar to TH2D::TH2D.; /// All values of z are accepted at filling time.; /// To fill a profile2D histogram, one must use TProfile2D::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable z is between fZmin and fZmax.; /// If a minimum or maximum value is set for the Z scale before filling,; /// then all values below zmin or above zmax will be discarded.; /// Setting the minimum or maximum value for the Z scale before filling; /// has the same effect as calling the special TProfile2D constructor below; /// where zmin and zmax are specified.; ///; /// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; /// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; ///; /// See TProfile2D::BuildOptions for explanation of parameters; ///; /// see other constructors below with all possible combinations of; /// fix and variable bin size like in TH2D.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:920,Availability,error,error,920,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first eight parameters are similar to TH2D::TH2D.; /// All values of z are accepted at filling time.; /// To fill a profile2D histogram, one must use TProfile2D::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable z is between fZmin and fZmax.; /// If a minimum or maximum value is set for the Z scale before filling,; /// then all values below zmin or above zmax will be discarded.; /// Setting the minimum or maximum value for the Z scale before filling; /// has the same effect as calling the special TProfile2D constructor below; /// where zmin and zmax are specified.; ///; /// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; /// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; ///; /// See TProfile2D::BuildOptions for explanation of parameters; ///; /// see other constructors below with all possible combinations of; /// fix and variable bin size like in TH2D.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:412,Modifiability,variab,variable,412,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first eight parameters are similar to TH2D::TH2D.; /// All values of z are accepted at filling time.; /// To fill a profile2D histogram, one must use TProfile2D::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable z is between fZmin and fZmax.; /// If a minimum or maximum value is set for the Z scale before filling,; /// then all values below zmin or above zmax will be discarded.; /// Setting the minimum or maximum value for the Z scale before filling; /// has the same effect as calling the special TProfile2D constructor below; /// where zmin and zmax are specified.; ///; /// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; /// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; ///; /// See TProfile2D::BuildOptions for explanation of parameters; ///; /// see other constructors below with all possible combinations of; /// fix and variable bin size like in TH2D.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1091,Modifiability,variab,variable,1091,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first eight parameters are similar to TH2D::TH2D.; /// All values of z are accepted at filling time.; /// To fill a profile2D histogram, one must use TProfile2D::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable z is between fZmin and fZmax.; /// If a minimum or maximum value is set for the Z scale before filling,; /// then all values below zmin or above zmax will be discarded.; /// Setting the minimum or maximum value for the Z scale before filling; /// has the same effect as calling the special TProfile2D constructor below; /// where zmin and zmax are specified.; ///; /// H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; /// (spread option), or e(I,J) if CHOPT=' ' (error on mean).; ///; /// See TProfile2D::BuildOptions for explanation of parameters; ///; /// see other constructors below with all possible combinations of; /// fix and variable bin size like in TH2D.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:112,Modifiability,variab,variable,112,"////////////////////////////////////////////////////////////////////////////////; /// Create a 2-D Profile with variable bins in X and fix bins in Y.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:130,Modifiability,variab,variable,130,"////////////////////////////////////////////////////////////////////////////////; /// Create a 2-D Profile with fix bins in X and variable bins in Y.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:112,Modifiability,variab,variable,112,"////////////////////////////////////////////////////////////////////////////////; /// Create a 2-D Profile with variable bins in X and variable bins in Y.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:135,Modifiability,variab,variable,135,"////////////////////////////////////////////////////////////////////////////////; /// Create a 2-D Profile with variable bins in X and variable bins in Y.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:463,Availability,error,errors,463,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Profile2D histograms with range in z.; ///; /// The first eight parameters are similar to TH2D::TH2D.; /// Only the values of Z between ZMIN and ZMAX will be considered at filling time.; /// zmin and zmax will also be the maximum and minimum values; /// on the z scale when drawing the profile2D.; ///; /// See TProfile2D::BuildOptions for more explanations on errors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:385,Availability,error,error,385,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile2D histogram structure and options.; ///; /// - zmin: minimum value allowed for z; /// - zmax: maximum value allowed for z; /// if (zmin = zmax = 0) there are no limits on the allowed z values (zmin = -inf, zmax = +inf); ///; /// - option: this is the option for the computation of the t error of the profile ( TProfile2D::GetBinError ); /// possible values for the options are documented in TProfile2D::SetErrorOption; ///; /// See TProfile::BuildOptions for a detailed description",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*f1` .",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1` .",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:219,Availability,error,error,219,"////////////////////////////////////////////////////////////////////////////////; /// Static function, set the fgApproximate flag.; ///; /// When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; /// - the number of bins in the profile2D is less than 10404 (eg 100x100); /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile2D::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:250,Availability,error,error,250,"////////////////////////////////////////////////////////////////////////////////; /// Static function, set the fgApproximate flag.; ///; /// When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; /// - the number of bins in the profile2D is less than 10404 (eg 100x100); /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile2D::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:453,Availability,error,error,453,"////////////////////////////////////////////////////////////////////////////////; /// Static function, set the fgApproximate flag.; ///; /// When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; /// - the number of bins in the profile2D is less than 10404 (eg 100x100); /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile2D::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)` .; /// This function is not implemented",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:88,Availability,error,error,88,"// maintaining the correct sum of weights square is not supported when dividing; // bin error resulting from division of profile needs to be checked",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:97,Availability,error,error,97,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile2D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile2D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile2D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile2D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:153,Availability,error,errors,153,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile2D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile2D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile2D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile2D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:205,Availability,error,errors,205,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile2D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile2D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile2D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile2D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:304,Availability,error,errors,304,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile2D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile2D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile2D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile2D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:460,Availability,error,errors,460,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile2D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile2D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile2D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile2D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:233,Modifiability,evolve,evolved,233,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile2D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile2D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile2D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile2D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:121,Availability,error,errors,121,"////////////////////////////////////////////////////////////////////////////////; /// Return option to compute profile2D errors.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:531,Usability,simpl,simply,531,"////////////////////////////////////////////////////////////////////////////////; /// Fill the array stats from the contents of this profile.; /// The array stats must be correctly dimensioned in the calling program.; ///; /// - stats[0] = sumw; /// - stats[1] = sumw2; /// - stats[2] = sumwx; /// - stats[3] = sumwx2; /// - stats[4] = sumwy; /// - stats[5] = sumwy2; /// - stats[6] = sumwxy; /// - stats[7] = sumwz; /// - stats[8] = sumwz2; ///; /// If no axis-subrange is specified (via TAxis::SetRange), the array stats; /// is simply a copy of the statistics quantities computed at filling time.; /// If a sub-range is specified, the function recomputes these quantities; /// from the bin contents in the current axis range.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Energy Efficiency,Reduce,Reduce,86,"////////////////////////////////////////////////////////////////////////////////; /// Reduce the number of bins for this axis to the number of bins having a label.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:436,Availability,down,down,436,"////////////////////////////////////////////////////////////////////////////////; /// Set option(s) to draw axis with labels.; ///; /// option might have the following values:; ///; /// - ""a"" sort by alphabetic order; /// - "">"" sort by decreasing values; /// - ""<"" sort by increasing values; /// - ""h"" draw labels horizontal; /// - ""v"" draw labels vertical; /// - ""u"" draw labels up (end of label right adjusted); /// - ""d"" draw labels down (start of label left adjusted)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:270,Availability,error,errors,270,"////////////////////////////////////////////////////////////////////////////////; /// Merge all histograms in the collection in this histogram.; /// This function computes the min/max for the axes,; /// compute a new number of bins, if necessary,; /// add bin contents, errors and statistics.; /// If overflows are present and limits are different the function will fail.; /// The function returns the total number of entries in the result histogram; /// if the merge is successful, -1 otherwise.; ///; /// IMPORTANT remark. The 2 axis x and y may have different number; /// of bins and different limits, BUT the largest bin width must be; /// a multiple of the smallest bin width and the upper limit must also; /// be a multiple of the bin width.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c1*f1",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:237,Availability,error,errors,237,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile2D into a 2-D histogram along X,Y.; ///; /// The projection is always of the type TH2D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] )",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:316,Availability,error,errors,316,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile2D into a 2-D histogram along X,Y.; ///; /// The projection is always of the type TH2D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] )",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:452,Availability,error,errors,452,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile2D into a 2-D histogram along X,Y.; ///; /// The projection is always of the type TH2D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] )",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:717,Availability,error,errors,717,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile2D into a 2-D histogram along X,Y.; ///; /// The projection is always of the type TH2D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] )",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1204,Availability,error,error,1204,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile2D into a 2-D histogram along X,Y.; ///; /// The projection is always of the type TH2D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] )",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:1405,Availability,error,error,1405,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile2D into a 2-D histogram along X,Y.; ///; /// The projection is always of the type TH2D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] )",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:463,Usability,simpl,simply,463,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile2D into a 2-D histogram along X,Y.; ///; /// The projection is always of the type TH2D.; ///; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] )",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:35,Availability,error,errors,35,"// if option E projected histogram errors are same as profile",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:27,Availability,error,error,27,"// in case of option W bin error is deduced from bin sum of z**2 values of profile; // this is correct only if the profile is unweighted",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:79,Availability,error,error,79,"// in case of bin entries and profile is weighted, we need to set also the bin error",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:688,Availability,error,error,688,"////////////////////////////////////////////////////////////////////////////////; /// Project a 2-D histogram into a profile histogram along X.; ///; /// The projection is made from the channels along the Y axis; /// ranging from firstybin to lastybin included.; /// The result is a 1D profile which contains the combination of all the considered bins along Y; /// By default, bins 1 to ny are included; /// When all bins are included, the number of entries in the projection; /// is set to the number of entries of the 2-D histogram, otherwise; /// the number of entries is incremented by 1 for all non empty cells.; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:687,Availability,error,error,687,"////////////////////////////////////////////////////////////////////////////////; /// Project a 2-D histogram into a profile histogram along X; ///; /// The projection is made from the channels along the X axis; /// ranging from firstybin to lastybin included.; /// The result is a 1D profile which contains the combination of all the considered bins along X; /// By default, bins 1 to ny are included; /// When all bins are included, the number of entries in the projection; /// is set to the number of entries of the 2-D histogram, otherwise; /// the number of entries is incremented by 1 for all non empty cells.; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:11,Modifiability,variab,variable,11,"// case of variable bins",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:47,Availability,error,errors,47,"// sum of weight squares are stored to compute errors in h1N histogram",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:462,Availability,error,errors,462,"////////////////////////////////////////////////////////////////////////////////; /// Profile histogram is resized along axis such that x is in the axis range.; ///; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The axis must be extendable before invoking this function.; ///; /// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:418,Modifiability,extend,extended,418,"////////////////////////////////////////////////////////////////////////////////; /// Profile histogram is resized along axis such that x is in the axis range.; ///; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The axis must be extendable before invoking this function.; ///; /// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:507,Modifiability,extend,extendable,507,"////////////////////////////////////////////////////////////////////////////////; /// Profile histogram is resized along axis such that x is in the axis range.; ///; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the extended histogram.; /// Takes into account errors (Sumw2) if any.; /// The axis must be extendable before invoking this function.; ///; /// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:453,Availability,error,errors,453,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; ///; /// if newname is not blank a new profile hnew is created.; /// else the current histogram is modified (default); /// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; /// have to be merged into one bin of hnew; /// If the original profile has errors stored (via Sumw2), the resulting; /// profile has new errors correctly calculated.; ///; /// examples: if hpxpy is an existing TProfile2D profile with 40 x 40 bins; /// ~~~ {.cpp}; /// hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one; /// // Carefull: previous contents of hpxpy are lost; /// hpxpy->Rebin2D(3,5); // merges 3 bins along the xaxis and 5 bins along the yaxis in one; /// // Carefull: previous contents of hpxpy are lost; /// hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; /// TProfile2D *hnew = hpxpy->RebinY(5,""hnew""); // creates a new profile hnew; /// // merging 5 bins of hpxpy along the yaxis in one bin; /// ~~~; ///; /// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; /// along the xaxis/yaxis the top limit(s) of the rebinned profile; /// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; /// ybin=newybins*nygroup and the remaining bins are added to; /// the overflow bin.; /// Statistics will be recomputed from the new bin contents.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:515,Availability,error,errors,515,"////////////////////////////////////////////////////////////////////////////////; /// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; ///; /// if newname is not blank a new profile hnew is created.; /// else the current histogram is modified (default); /// The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; /// have to be merged into one bin of hnew; /// If the original profile has errors stored (via Sumw2), the resulting; /// profile has new errors correctly calculated.; ///; /// examples: if hpxpy is an existing TProfile2D profile with 40 x 40 bins; /// ~~~ {.cpp}; /// hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one; /// // Carefull: previous contents of hpxpy are lost; /// hpxpy->Rebin2D(3,5); // merges 3 bins along the xaxis and 5 bins along the yaxis in one; /// // Carefull: previous contents of hpxpy are lost; /// hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; /// TProfile2D *hnew = hpxpy->RebinY(5,""hnew""); // creates a new profile hnew; /// // merging 5 bins of hpxpy along the yaxis in one bin; /// ~~~; ///; /// NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; /// along the xaxis/yaxis the top limit(s) of the rebinned profile; /// is changed to the upper edge of the xbin=newxbins*nxgroup resp.; /// ybin=newybins*nygroup and the remaining bins are added to; /// the overflow bin.; /// Statistics will be recomputed from the new bin contents.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:217,Modifiability,variab,variable,217,"////////////////////////////////////////////////////////////////////////////////; /// Save primitive as a C++ statement(s) on output stream out.; ///; /// Note the following restrictions in the code generated:; /// - variable bin size not implemented; /// - SetErrorOption not implemented",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:12,Availability,error,errors,12,"// save bin errors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:123,Modifiability,variab,variable,123,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x and y axis parameters for variable bin sizes.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:163,Availability,error,errors,163,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:233,Availability,error,errors,233,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:257,Availability,error,error,257,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:330,Availability,error,error,330,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:522,Availability,error,errors,522,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:734,Availability,Error,Errors,734,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:774,Availability,error,errors,774,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:905,Availability,error,error,905,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:940,Availability,Error,Errors,940,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile2D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the Z bin values; /// Note that if TProfile::Approximate() is called, an approximation is used when; /// the spread in Z is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in Z is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements z +/- dz,; /// and the profile is filled with values y and weights z = 1/dz**2; ///; /// See TProfile::BuildOptions for a detailed explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update average.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:93,Availability,error,error,93,"////////////////////////////////////////////////////////////////////////////////; /// Update error.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:86,Deployability,Update,Update,86,"////////////////////////////////////////////////////////////////////////////////; /// Update error.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear statistics.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:16,Deployability,Update,Update,16,"// ------------ Update global (per histo) statistics",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:16,Deployability,Update,Update,16,"// ------------ Update local (per bin) statistics",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:16,Deployability,Update,Update,16,"// ------------ Update global (per histo) statistics",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:16,Deployability,Update,Update,16,"// ------------ Update local (per bin) statistics",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:101,Availability,error,error,101,"////////////////////////////////////////////////////////////////////////////////; /// Set content to error.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:94,Availability,error,error,94,"////////////////////////////////////////////////////////////////////////////////; /// Get bin error.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:531,Usability,simpl,simply,531,"////////////////////////////////////////////////////////////////////////////////; /// Fill the array stats from the contents of this profile.; /// The array stats must be correctly dimensioned in the calling program.; ///; /// - stats[0] = sumw; /// - stats[1] = sumw2; /// - stats[2] = sumwx; /// - stats[3] = sumwx2; /// - stats[4] = sumwy; /// - stats[5] = sumwy2; /// - stats[6] = sumwxy; /// - stats[7] = sumwz; /// - stats[8] = sumwz2; ///; /// If no axis-subrange is specified (via TAxis::SetRange), the array stats; /// is simply a copy of the statistics quantities computed at filling time.; /// If a sub-range is specified, the function recomputes these quantities; /// from the bin contents in the current axis range.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:3,Usability,Clear,Clears,3,"// Clears bin contents",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx:90,Availability,error,error,90,"////////////////////////////////////////////////////////////////////////////////; /// Set error option.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile2Poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2Poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:719,Integrability,rout,routines,719,"/** \class TProfile3D; \ingroup Histograms; Profile3D histograms are used to display the mean; value of T and its RMS for each cell in X,Y,Z.; Profile3D histograms are in many cases an; The inter-relation of three measured quantities X, Y, Z and T can always; be visualized by a four-dimensional histogram or scatter-plot;; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If T is an unknown (but single-valued); approximate function of X,Y,Z this function is displayed by a profile3D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; if the static function TProfile3D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile3D histogram; ~~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }; ~~~~; NOTE: A TProfile3D is drawn as it was a simple TH3; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile3D histograms.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:1185,Usability,simpl,simple,1185,"/** \class TProfile3D; \ingroup Histograms; Profile3D histograms are used to display the mean; value of T and its RMS for each cell in X,Y,Z.; Profile3D histograms are in many cases an; The inter-relation of three measured quantities X, Y, Z and T can always; be visualized by a four-dimensional histogram or scatter-plot;; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If T is an unknown (but single-valued); approximate function of X,Y,Z this function is displayed by a profile3D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; if the static function TProfile3D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile3D histogram; ~~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }; ~~~~; NOTE: A TProfile3D is drawn as it was a simple TH3; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile3D histograms.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:1803,Usability,simpl,simple,1803,"/** \class TProfile3D; \ingroup Histograms; Profile3D histograms are used to display the mean; value of T and its RMS for each cell in X,Y,Z.; Profile3D histograms are in many cases an; The inter-relation of three measured quantities X, Y, Z and T can always; be visualized by a four-dimensional histogram or scatter-plot;; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If T is an unknown (but single-valued); approximate function of X,Y,Z this function is displayed by a profile3D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells,; if the static function TProfile3D::Approximate has been called.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile3D histogram; ~~~~{.cpp}; {; auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; auto hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }; ~~~~; NOTE: A TProfile3D is drawn as it was a simple TH3; */; ////////////////////////////////////////////////////////////////////////////////; /// Default constructor for Profile3D histograms.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:837,Availability,error,errors,837,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first eleven parameters are similar to TH3D::TH3D.; /// All values of t are accepted at filling time.; /// To fill a profile3D histogram, one must use TProfile3D::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable t is between fTmin and fTmax.; /// If a minimum or maximum value is set for the T scale before filling,; /// then all values below tmin or above tmax will be discarded.; /// Setting the minimum or maximum value for the T scale before filling; /// has the same effect as calling the special TProfile3D constructor below; /// where tmin and tmax are specified.; ///; /// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; /// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; ///; /// See TProfile3D::BuildOptions for explanation of parameters; ///; /// see other constructors below with all possible combinations of; /// fix and variable bin size like in TH3D.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:927,Availability,error,error,927,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first eleven parameters are similar to TH3D::TH3D.; /// All values of t are accepted at filling time.; /// To fill a profile3D histogram, one must use TProfile3D::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable t is between fTmin and fTmax.; /// If a minimum or maximum value is set for the T scale before filling,; /// then all values below tmin or above tmax will be discarded.; /// Setting the minimum or maximum value for the T scale before filling; /// has the same effect as calling the special TProfile3D constructor below; /// where tmin and tmax are specified.; ///; /// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; /// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; ///; /// See TProfile3D::BuildOptions for explanation of parameters; ///; /// see other constructors below with all possible combinations of; /// fix and variable bin size like in TH3D.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:413,Modifiability,variab,variable,413,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first eleven parameters are similar to TH3D::TH3D.; /// All values of t are accepted at filling time.; /// To fill a profile3D histogram, one must use TProfile3D::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable t is between fTmin and fTmax.; /// If a minimum or maximum value is set for the T scale before filling,; /// then all values below tmin or above tmax will be discarded.; /// Setting the minimum or maximum value for the T scale before filling; /// has the same effect as calling the special TProfile3D constructor below; /// where tmin and tmax are specified.; ///; /// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; /// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; ///; /// See TProfile3D::BuildOptions for explanation of parameters; ///; /// see other constructors below with all possible combinations of; /// fix and variable bin size like in TH3D.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:1098,Modifiability,variab,variable,1098,"////////////////////////////////////////////////////////////////////////////////; /// Normal Constructor for Profile histograms.; ///; /// The first eleven parameters are similar to TH3D::TH3D.; /// All values of t are accepted at filling time.; /// To fill a profile3D histogram, one must use TProfile3D::Fill function.; ///; /// Note that when filling the profile histogram the function Fill; /// checks if the variable t is between fTmin and fTmax.; /// If a minimum or maximum value is set for the T scale before filling,; /// then all values below tmin or above tmax will be discarded.; /// Setting the minimum or maximum value for the T scale before filling; /// has the same effect as calling the special TProfile3D constructor below; /// where tmin and tmax are specified.; ///; /// H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; /// (spread option), or e(I,J,K) if CHOPT=' ' (error on mean).; ///; /// See TProfile3D::BuildOptions for explanation of parameters; ///; /// see other constructors below with all possible combinations of; /// fix and variable bin size like in TH3D.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:112,Modifiability,variab,variable,112,"////////////////////////////////////////////////////////////////////////////////; /// Create a 3-D Profile with variable bins in X , Y and Z.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:385,Availability,error,error,385,"////////////////////////////////////////////////////////////////////////////////; /// Set Profile3D histogram structure and options.; ///; /// - tmin: minimum value allowed for t; /// - tmax: maximum value allowed for t; /// if (tmin = tmax = 0) there are no limits on the allowed t values (tmin = -inf, tmax = +inf); ///; /// - option: this is the option for the computation of the t error of the profile ( TProfile3D::GetBinError ); /// possible values for the options are documented in TProfile3D::SetErrorOption; ///; /// see also TProfile::BuildOptions for a detailed description",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*f1` .",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1` .",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:202,Availability,error,error,202,"////////////////////////////////////////////////////////////////////////////////; /// Set the fgApproximate flag.; ///; /// When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; ///; /// - the number of bins in the profile3D is less than 10404 (eg 100x100x100); /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile3D::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:233,Availability,error,error,233,"////////////////////////////////////////////////////////////////////////////////; /// Set the fgApproximate flag.; ///; /// When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; ///; /// - the number of bins in the profile3D is less than 10404 (eg 100x100x100); /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile3D::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:445,Availability,error,error,445,"////////////////////////////////////////////////////////////////////////////////; /// Set the fgApproximate flag.; ///; /// When the flag is true, the function GetBinError; /// will approximate the bin error with the average profile error on all bins; /// in the following situation only; ///; /// - the number of bins in the profile3D is less than 10404 (eg 100x100x100); /// - the bin number of entries is small ( <5); /// - the estimated bin error is extremely small compared to the bin content; /// (see TProfile3D::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)` .; ///; /// This function is not implemented",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:88,Availability,error,error,88,"// maintaining the correct sum of weights square is not supported when dividing; // bin error resulting from division of profile needs to be checked",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:97,Availability,error,error,97,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile3D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile3D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile3D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile3D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:153,Availability,error,errors,153,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile3D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile3D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile3D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile3D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:205,Availability,error,errors,205,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile3D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile3D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile3D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile3D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:304,Availability,error,errors,304,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile3D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile3D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile3D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile3D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:465,Availability,error,errors,465,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile3D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile3D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile3D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile3D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:233,Modifiability,evolve,evolved,233,"////////////////////////////////////////////////////////////////////////////////; /// Return bin error of a Profile3D histogram.; ///; /// ### Computing errors: A moving field; ///; /// The computation of errors for a TProfile3D has evolved with the versions; /// of ROOT. The difficulty is in computing errors for bins with low statistics.; ///; /// - prior to version 3.10, we had no special treatment of low statistic bins.; /// As a result, these bins had huge errors. The reason is that the; /// expression eprim2 is very close to 0 (rounding problems) or 0.; /// - The algorithm is modified/protected for the case; /// when a TProfile3D is projected (ProjectionX). The previous algorithm; /// generated a N^2 problem when projecting a TProfile3D with a large number of; /// bins (eg 100000).; /// - in version 3.10/02, a new static function TProfile::Approximate; /// is introduced to enable or disable (default) the approximation.; /// (see also comments in TProfile::GetBinError)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:121,Availability,error,errors,121,"////////////////////////////////////////////////////////////////////////////////; /// Return option to compute profile2D errors.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:635,Usability,simpl,simply,635,"////////////////////////////////////////////////////////////////////////////////; /// fill the array stats from the contents of this profile.; ///; /// The array stats must be correctly dimensioned in the calling program.; ///; /// - stats[0] = sumw; /// - stats[1] = sumw2; /// - stats[2] = sumwx; /// - stats[3] = sumwx2; /// - stats[4] = sumwy; /// - stats[5] = sumwy2; /// - stats[6] = sumwxy; /// - stats[7] = sumwz; /// - stats[8] = sumwz2; /// - stats[9] = sumwxz; /// - stats[10]= sumwyz; /// - stats[11]= sumwt; /// - stats[12]= sumwt2; ///; /// If no axis-subrange is specified (via TAxis::SetRange), the array stats; /// is simply a copy of the statistics quantities computed at filling time.; /// If a sub-range is specified, the function recomputes these quantities; /// from the bin contents in the current axis range.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:86,Energy Efficiency,Reduce,Reduce,86,"////////////////////////////////////////////////////////////////////////////////; /// Reduce the number of bins for this axis to the number of bins having a label.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:436,Availability,down,down,436,"////////////////////////////////////////////////////////////////////////////////; /// Set option(s) to draw axis with labels.; ///; /// option might have the following values:; ///; /// - ""a"" sort by alphabetic order; /// - "">"" sort by decreasing values; /// - ""<"" sort by increasing values; /// - ""h"" draw labels horizontal; /// - ""v"" draw labels vertical; /// - ""u"" draw labels up (end of label right adjusted); /// - ""d"" draw labels down (start of label left adjusted)",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:275,Availability,error,errors,275,"////////////////////////////////////////////////////////////////////////////////; /// Merge all histograms in the collection in this histogram.; ///; /// This function computes the min/max for the axes,; /// compute a new number of bins, if necessary,; /// add bin contents, errors and statistics.; /// If overflows are present and limits are different the function will fail.; /// The function returns the total number of entries in the result histogram; /// if the merge is successful, -1 otherwise.; ///; /// IMPORTANT remark. The 2 axis x and y may have different number; /// of bins and different limits, BUT the largest bin width must be; /// a multiple of the smallest bin width and the upper limit must also; /// be a multiple of the bin width.",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:86,Performance,Perform,Performs,86,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this*c1*f1` .",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:240,Availability,error,errors,240,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:494,Availability,error,errors,494,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:554,Availability,error,errors,554,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:633,Availability,error,errors,633,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:769,Availability,error,errors,769,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:1034,Availability,error,errors,1034,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:1521,Availability,error,error,1521,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:1722,Availability,error,error,1722,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:780,Usability,simpl,simply,780,"////////////////////////////////////////////////////////////////////////////////; /// Project this profile3D into a 3-D histogram along X,Y,Z.; ///; /// The projection is always of the type TH3D.; ///; /// - if option ""E"" is specified, the errors are computed. (default); /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""E"" is specified the errors of the projected histogram are computed and set; /// to be equal to the errors of the profile.; /// Option ""E"" is defined as the default one in the header file.; /// - if option """" is specified the histogram errors are simply the sqrt of its content; /// - if option ""B"" is specified, the content of bin of the returned histogram; /// will be equal to the GetBinEntries(bin) of the profile,; /// - if option ""C=E"" the bin contents of the projection are set to the; /// bin errors of the profile; /// - if option ""W"" is specified the bin content of the projected histogram is set to the; /// product of the bin content of the profile and the entries.; /// With this option the returned histogram will be equivalent to the one obtained by; /// filling directly a TH2D using the 3-rd value as a weight.; /// This option makes sense only for profile filled with all weights =1.; /// When the profile is weighted (filled with weights different than 1) the; /// bin error of the projected histogram (obtained using this option ""W"") cannot be; /// correctly computed from the information stored in the profile. In that case the; /// obtained histogram contains as bin error square the weighted sum of the square of the; /// profiled observable (TProfile2D::fSumw2[bin] ); ///; /// Note that the axis range is not considered when doing the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:35,Availability,error,errors,35,"// if option E projected histogram errors are same as profile",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:27,Availability,error,error,27,"// in case of option W bin error is deduced from bin sum of z**2 values of profile; // this is correct only if the profile is unweighted",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:79,Availability,error,error,79,"// in case of bin entries and profile is weighted, we need to set also the bin error",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:1057,Availability,error,error,1057,"////////////////////////////////////////////////////////////////////////////////; /// Project a 3-D profile into a 2D-profile histogram depending on the option parameter.; ///; /// option may contain a combination of the characters x,y,z:; ///; /// - option = ""xy"" return the x versus y projection into a TProfile2D histogram; /// - option = ""yx"" return the y versus x projection into a TProfile2D histogram; /// - option = ""xz"" return the x versus z projection into a TProfile2D histogram; /// - option = ""zx"" return the z versus x projection into a TProfile2D histogram; /// - option = ""yz"" return the y versus z projection into a TProfile2D histogram; /// - option = ""zy"" return the z versus y projection into a TProfile2D histogram; ///; /// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal along X; ///; /// The resulting profile contains the combination of all the considered bins along X; /// By default, all bins are included considering also underflow/overflows; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; ///; /// To select a bin range along an axis, use TAxis::SetRange, eg; /// `h3.GetYaxis()->SetRange(23,56);`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:136,Integrability,depend,depending,136,"////////////////////////////////////////////////////////////////////////////////; /// Project a 3-D profile into a 2D-profile histogram depending on the option parameter.; ///; /// option may contain a combination of the characters x,y,z:; ///; /// - option = ""xy"" return the x versus y projection into a TProfile2D histogram; /// - option = ""yx"" return the y versus x projection into a TProfile2D histogram; /// - option = ""xz"" return the x versus z projection into a TProfile2D histogram; /// - option = ""zx"" return the z versus x projection into a TProfile2D histogram; /// - option = ""yz"" return the y versus z projection into a TProfile2D histogram; /// - option = ""zy"" return the z versus y projection into a TProfile2D histogram; ///; /// NB: the notation ""a vs b"" means ""a"" vertical and ""b"" horizontal along X; ///; /// The resulting profile contains the combination of all the considered bins along X; /// By default, all bins are included considering also underflow/overflows; ///; /// The option can also be used to specify the projected profile error type.; /// Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; ///; /// To select a bin range along an axis, use TAxis::SetRange, eg; /// `h3.GetYaxis()->SetRange(23,56);`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:24,Modifiability,variab,variable,24,"// assume all axis have variable bins or have fixed bins",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:73,Availability,error,error,73,"// note that h3dW is always a weighted histogram - so we need to compute error in the projection",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:47,Availability,error,errors,47,"// sum of weight squares are stored to compute errors in h1N histogram",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:457,Availability,error,errors,457,"////////////////////////////////////////////////////////////////////////////////; /// Profile histogram is resized along axis such that x is in the axis range.; /// The new axis limits are recomputed by doubling iteratively; /// the current axis range until the specified value x is within the limits.; /// The algorithm makes a copy of the histogram, then loops on all bins; /// of the old histogram to fill the rebinned histogram.; /// Takes into account errors (Sumw2) if any.; /// The axis must be rebinnable before invoking this function.; /// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:217,Modifiability,variab,variable,217,"////////////////////////////////////////////////////////////////////////////////; /// Save primitive as a C++ statement(s) on output stream out.; ///; /// Note the following restrictions in the code generated:; /// - variable bin size not implemented; /// - SetErrorOption not implemented",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:12,Availability,error,errors,12,"// save bin errors",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:127,Modifiability,variab,variable,127,"////////////////////////////////////////////////////////////////////////////////; /// Redefine x, y and z axis parameters with variable bin sizes",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:118,Availability,error,errors,118,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:163,Availability,error,errors,163,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:233,Availability,error,errors,233,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:257,Availability,error,error,257,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:330,Availability,error,error,330,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:524,Availability,error,errors,524,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:738,Availability,Error,Errors,738,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:778,Availability,error,errors,778,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:909,Availability,error,error,909,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:944,Availability,Error,Errors,944,"////////////////////////////////////////////////////////////////////////////////; /// Set option to compute profile3D errors.; ///; /// The computation of the bin errors is based on the parameter option:; /// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; /// i.e. the standard error of the bin contents.; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 's' The bin errors are the standard deviations of the T bin values; /// Note that if TProfile3D::Approximate() is called, an approximation is used when; /// the spread in T is 0 and the number of bin entries is > 0; /// - 'i' Errors are as in default case (standard errors of the bin contents); /// The only difference is for the case when the spread in T is zero.; /// In this case for N > 0 the error is 1./SQRT(12.*N); /// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; /// W is the sum in the bin of the weights of the profile.; /// This option is for combining measurements t +/- dt,; /// and the profile is filled with values t and weights w = 1/dt**2; ///; /// See TProfile::BuildOptions for explanation of all options",MatchSource.CODE_COMMENT,hist/hist/src/TProfile3D.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:3,Performance,Perform,Performs,3,"// Performs the operation: this = c1*h1 + c2*h2",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:180,Availability,error,errors,180,"//Merge all histograms in the collection in this histogram.; //This function computes the min/max for the axes,; //compute a new number of bins, if necessary,; //add bin contents, errors and statistics.; //If overflows are present and limits are different the function will fail.; //The function returns the total number of entries in the result histogram; //if the merge is successful, -1 otherwise.; //; //IMPORTANT remark. The 2 axis x and y may have different number; //of bins and different limits, BUT the largest bin width must be; //a multiple of the smallest bin width and the upper limit must also; //be a multiple of the bin width.",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:152,Performance,perform,perform,152,"// In the case of histogram with different limits; // newX(Y)Axis will now have the new found limits; // but one needs first to clone this histogram to perform the merge; // The clone is not needed when all histograms have the same limits",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:25,Availability,error,errors,25,"//merge bin contents and errors",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:52,Modifiability,extend,extend,52,"// reset, otherwise setting the under/overflow will extend the axis",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:369,Availability,error,errors,369,"// Profile histogram is resized along axis such that x is in the axis range.; // The new axis limits are recomputed by doubling iteratively; // the current axis range until the specified value x is within the limits.; // The algorithm makes a copy of the histogram, then loops on all bins; // of the old histogram to fill the extended histogram.; // Takes into account errors (Sumw2) if any.; // The axis must be extendable before invoking this function.; // Ex: h->GetXaxis()->SetCanExtend(kTRUE)",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:326,Modifiability,extend,extended,326,"// Profile histogram is resized along axis such that x is in the axis range.; // The new axis limits are recomputed by doubling iteratively; // the current axis range until the specified value x is within the limits.; // The algorithm makes a copy of the histogram, then loops on all bins; // of the old histogram to fill the extended histogram.; // Takes into account errors (Sumw2) if any.; // The axis must be extendable before invoking this function.; // Ex: h->GetXaxis()->SetCanExtend(kTRUE)",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:413,Modifiability,extend,extendable,413,"// Profile histogram is resized along axis such that x is in the axis range.; // The new axis limits are recomputed by doubling iteratively; // the current axis range until the specified value x is within the limits.; // The algorithm makes a copy of the histogram, then loops on all bins; // of the old histogram to fill the extended histogram.; // Takes into account errors (Sumw2) if any.; // The axis must be extendable before invoking this function.; // Ex: h->GetXaxis()->SetCanExtend(kTRUE)",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:36,Availability,Error,Errors,36,"//reset only Integral, contents and Errors; // need to consider also underflow/overflow in the non-extending axes",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:99,Modifiability,extend,extending,99,"//reset only Integral, contents and Errors; // need to consider also underflow/overflow in the non-extending axes",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:3,Usability,clear,clear,3,"// clear array if existing or do nothing",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce the number of bins for this axis to the number of bins having a label.; // Works only for the given axis passed in the option; // The method will remove only the extra bins existing after the last ""labeled"" bin.; // Note that if there are ""un-labeled"" bins present between ""labeled"" bins they will not be removed",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:21,Availability,error,error,21,"// reset content and error; //now loop on all old bins and refill excluding underflow/overflow in; // the axis that has the bin doubled",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:15,Availability,error,error,15,"// compute bin error of profile histograms",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:54,Availability,error,error,54,"// in case content y is an integer (so each my has an error +/- 1/sqrt(12); // when the std(y) is zero",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h:62,Availability,error,error,62,"// default case : fErrorMode = kERRORMEAN; // return standard error on the mean of y; //if (neff == 0) std::cerr << ""NEFF = 0 for bin "" << bin << "" "" << eprim << "" "" << neff << "" "" << std::endl;",MatchSource.CODE_COMMENT,hist/hist/src/TProfileHelper.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfileHelper.h
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx:152,Modifiability,variab,variables,152,"////////////////////////////////////////////////////////////////////////////////; /** \class TScatter; \ingroup Graphs; A TScatter is able to draw four variables scatter plot on a single plot. The two first; variables are the x and y position of the markers, the third is mapped on the current; color map and the fourth on the marker size. The following example demonstrates how it works:. Begin_Macro(source); ../../../tutorials/graphs/scatter.C; End_Macro. ### TScatter's plotting options; TScatter can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |. */; ////////////////////////////////////////////////////////////////////////////////; /// TScatter default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TScatter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx:208,Modifiability,variab,variables,208,"////////////////////////////////////////////////////////////////////////////////; /** \class TScatter; \ingroup Graphs; A TScatter is able to draw four variables scatter plot on a single plot. The two first; variables are the x and y position of the markers, the third is mapped on the current; color map and the fourth on the marker size. The following example demonstrates how it works:. Begin_Macro(source); ../../../tutorials/graphs/scatter.C; End_Macro. ### TScatter's plotting options; TScatter can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |. */; ////////////////////////////////////////////////////////////////////////////////; /// TScatter default constructor.",MatchSource.CODE_COMMENT,hist/hist/src/TScatter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx:326,Deployability,release,released,326,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when a graph is clicked with the locator; ///; /// If Left button clicked on one of the line end points, this point; /// follows the cursor until button is released.; ///; /// if Middle button clicked, the line is moved parallel to itself; /// until the button is released.",MatchSource.CODE_COMMENT,hist/hist/src/TScatter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx:434,Deployability,release,released,434,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when a graph is clicked with the locator; ///; /// If Left button clicked on one of the line end points, this point; /// follows the cursor until button is released.; ///; /// if Middle button clicked, the line is moved parallel to itself; /// until the button is released.",MatchSource.CODE_COMMENT,hist/hist/src/TScatter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx:139,Safety,avoid,avoid,139,"// do not add the histogram to gDirectory; // use local TDirectory::TContect that will set temporarly gDirectory to a nullptr and; // will avoid that histogram is added in the global directory",MatchSource.CODE_COMMENT,hist/hist/src/TScatter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx:102,Availability,error,errors,102,"////////////////////////////////////////////////////////////////////////////////; /// Print graph and errors values.",MatchSource.CODE_COMMENT,hist/hist/src/TScatter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TScatter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:6,Testability,log,logx,6,"// if logx, we must bin in logx and not in x !!!; // otherwise if several decades, one gets crazy results",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:27,Testability,log,logx,27,"// if logx, we must bin in logx and not in x !!!; // otherwise if several decades, one gets crazy results",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:289,Modifiability,variab,variables,289,"////////////////////////////////////////////////////////////////////////////////; /// Test method for TSpline5; ///; /// ~~~ {.cpp}; /// n number of data points.; /// m 2*m-1 is order of spline.; /// m = 2 always for third spline.; /// nn,nm1,mm,; /// mm1,i,k,; /// j,jj temporary integer variables.; /// z,p temporary double precision variables.; /// x[n] the sequence of knots.; /// y[n] the prescribed function values at the knots.; /// a[200][4] two dimensional array whose columns are; /// the computed spline coefficients; /// diff[3] maximum values of differences of values and; /// derivatives to right and left of knots.; /// com[3] maximum values of coefficients.; /// ~~~; ///; /// test of TSpline3 with non equidistant knots and; /// equidistant knots follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:336,Modifiability,variab,variables,336,"////////////////////////////////////////////////////////////////////////////////; /// Test method for TSpline5; ///; /// ~~~ {.cpp}; /// n number of data points.; /// m 2*m-1 is order of spline.; /// m = 2 always for third spline.; /// nn,nm1,mm,; /// mm1,i,k,; /// j,jj temporary integer variables.; /// z,p temporary double precision variables.; /// x[n] the sequence of knots.; /// y[n] the prescribed function values at the knots.; /// a[200][4] two dimensional array whose columns are; /// the computed spline coefficients; /// diff[3] maximum values of differences of values and; /// derivatives to right and left of knots.; /// com[3] maximum values of coefficients.; /// ~~~; ///; /// test of TSpline3 with non equidistant knots and; /// equidistant knots follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:86,Testability,Test,Test,86,"////////////////////////////////////////////////////////////////////////////////; /// Test method for TSpline5; ///; /// ~~~ {.cpp}; /// n number of data points.; /// m 2*m-1 is order of spline.; /// m = 2 always for third spline.; /// nn,nm1,mm,; /// mm1,i,k,; /// j,jj temporary integer variables.; /// z,p temporary double precision variables.; /// x[n] the sequence of knots.; /// y[n] the prescribed function values at the knots.; /// a[200][4] two dimensional array whose columns are; /// the computed spline coefficients; /// diff[3] maximum values of differences of values and; /// derivatives to right and left of knots.; /// com[3] maximum values of coefficients.; /// ~~~; ///; /// test of TSpline3 with non equidistant knots and; /// equidistant knots follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:693,Testability,test,test,693,"////////////////////////////////////////////////////////////////////////////////; /// Test method for TSpline5; ///; /// ~~~ {.cpp}; /// n number of data points.; /// m 2*m-1 is order of spline.; /// m = 2 always for third spline.; /// nn,nm1,mm,; /// mm1,i,k,; /// j,jj temporary integer variables.; /// z,p temporary double precision variables.; /// x[n] the sequence of knots.; /// y[n] the prescribed function values at the knots.; /// a[200][4] two dimensional array whose columns are; /// the computed spline coefficients; /// diff[3] maximum values of differences of values and; /// derivatives to right and left of knots.; /// com[3] maximum values of coefficients.; /// ~~~; ///; /// test of TSpline3 with non equidistant knots and; /// equidistant knots follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:27,Availability,error,errors,27,"// Correction for rounding errors",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:30,Safety,sanity check,sanity check,30,"//; // This could be removed, sanity check",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:204,Usability,guid,guide,204,"////////////////////////////////////////////////////////////////////////////////; /// Build coefficients.; ///; /// ~~~ {.cpp}; /// subroutine cubspl ( tau, c, n, ibcbeg, ibcend ); /// from * a practical guide to splines * by c. de boor; /// ************************ input ***************************; /// n = number of data points. assumed to be .ge. 2.; /// (tau(i), c(1,i), i=1,...,n) = abscissae and ordinates of the; /// data points. tau is assumed to be strictly increasing.; /// ibcbeg, ibcend = boundary condition indicators, and; /// c(2,1), c(2,n) = boundary condition information. specifically,; /// ibcbeg = 0 means no boundary condition at tau(1) is given.; /// in this case, the not-a-knot condition is used, i.e. the; /// jump in the third derivative across tau(2) is forced to; /// zero, thus the first and the second cubic polynomial pieces; /// are made to coincide.); /// ibcbeg = 1 means that the slope at tau(1) is made to equal; /// c(2,1), supplied by input.; /// ibcbeg = 2 means that the second derivative at tau(1) is; /// made to equal c(2,1), supplied by input.; /// ibcend = 0, 1, or 2 has analogous meaning concerning the; /// boundary condition at tau(n), with the additional infor-; /// mation taken from c(2,n).; /// *********************** output **************************; /// c(j,i), j=1,...,4; i=1,...,l (= n-1) = the polynomial coefficients; /// of the cubic interpolating spline with interior knots (or; /// joints) tau(2), ..., tau(n-1). precisely, in the interval; /// (tau(i), tau(i+1)), the spline f is given by; /// f(x) = c(1,i)+h*(c(2,i)+h*(c(3,i)+h*c(4,i)/3.)/2.); /// where h = x - tau(i). the function program *ppvalu* may be; /// used to evaluate f or its derivatives from tau,c, l = n-1,; /// and k=4.; /// ~~~",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:26,Safety,sanity check,sanity check,26,"// This could be removed, sanity check",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:914,Deployability,continuous,continuous,914,"////////////////////////////////////////////////////////////////////////////////; /// Algorithm 600, collected algorithms from acm.; ///; /// algorithm appeared in acm-trans. math. software, vol.9, no. 2,; /// jun., 1983, p. 258-259.; ///; /// TSpline5 computes the coefficients of a quintic natural quintic spli; /// s(x) with knots x(i) interpolating there to given function values:; /// ~~~ {.cpp}; /// s(x(i)) = y(i) for i = 1,2, ..., n.; /// ~~~; /// in each interval (x(i),x(i+1)) the spline function s(xx) is a; /// polynomial of fifth degree:; /// ~~~ {.cpp}; /// s(xx) = ((((f(i)*p+e(i))*p+d(i))*p+c(i))*p+b(i))*p+y(i) (*); /// = ((((-f(i)*q+e(i+1))*q-d(i+1))*q+c(i+1))*q-b(i+1))*q+y(i+1); /// ~~~; /// where p = xx - x(i) and q = x(i+1) - xx.; /// (note the first subscript in the second expression.); /// the different polynomials are pieced together so that s(x) and; /// its derivatives up to s"""" are continuous.; ///; /// ### input:; ///; /// n number of data points, (at least three, i.e. n > 2); /// x(1:n) the strictly increasing or decreasing sequence of; /// knots. the spacing must be such that the fifth power; /// of x(i+1) - x(i) can be formed without overflow or; /// underflow of exponents.; /// y(1:n) the prescribed function values at the knots.; ///; /// ### output:; ///; /// b,c,d,e,f the computed spline coefficients as in (*).; /// (1:n) specifically; /// b(i) = s'(x(i)), c(i) = s""(x(i))/2, d(i) = s""'(x(i))/6,; /// e(i) = s""""(x(i))/24, f(i) = s""""'(x(i))/120.; /// f(n) is neither used nor altered. the five arrays; /// b,c,d,e,f must always be distinct.; ///; /// ### option:; ///; /// it is possible to specify values for the first and second; /// derivatives of the spline function at arbitrarily many knots.; /// this is done by relaxing the requirement that the sequence of; /// knots be strictly increasing or decreasing. specifically:; ///; /// ~~~ {.cpp}; /// if x(j) = x(j+1) then s(x(j)) = y(j) and s'(x(j)) = y(j+1),; /// if x(j) = x(j+1) = x(j+2) then in a",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:1125,Energy Efficiency,power,power,1125,"hm appeared in acm-trans. math. software, vol.9, no. 2,; /// jun., 1983, p. 258-259.; ///; /// TSpline5 computes the coefficients of a quintic natural quintic spli; /// s(x) with knots x(i) interpolating there to given function values:; /// ~~~ {.cpp}; /// s(x(i)) = y(i) for i = 1,2, ..., n.; /// ~~~; /// in each interval (x(i),x(i+1)) the spline function s(xx) is a; /// polynomial of fifth degree:; /// ~~~ {.cpp}; /// s(xx) = ((((f(i)*p+e(i))*p+d(i))*p+c(i))*p+b(i))*p+y(i) (*); /// = ((((-f(i)*q+e(i+1))*q-d(i+1))*q+c(i+1))*q-b(i+1))*q+y(i+1); /// ~~~; /// where p = xx - x(i) and q = x(i+1) - xx.; /// (note the first subscript in the second expression.); /// the different polynomials are pieced together so that s(x) and; /// its derivatives up to s"""" are continuous.; ///; /// ### input:; ///; /// n number of data points, (at least three, i.e. n > 2); /// x(1:n) the strictly increasing or decreasing sequence of; /// knots. the spacing must be such that the fifth power; /// of x(i+1) - x(i) can be formed without overflow or; /// underflow of exponents.; /// y(1:n) the prescribed function values at the knots.; ///; /// ### output:; ///; /// b,c,d,e,f the computed spline coefficients as in (*).; /// (1:n) specifically; /// b(i) = s'(x(i)), c(i) = s""(x(i))/2, d(i) = s""'(x(i))/6,; /// e(i) = s""""(x(i))/24, f(i) = s""""'(x(i))/120.; /// f(n) is neither used nor altered. the five arrays; /// b,c,d,e,f must always be distinct.; ///; /// ### option:; ///; /// it is possible to specify values for the first and second; /// derivatives of the spline function at arbitrarily many knots.; /// this is done by relaxing the requirement that the sequence of; /// knots be strictly increasing or decreasing. specifically:; ///; /// ~~~ {.cpp}; /// if x(j) = x(j+1) then s(x(j)) = y(j) and s'(x(j)) = y(j+1),; /// if x(j) = x(j+1) = x(j+2) then in addition s""(x(j)) = y(j+2).; /// ~~~; ///; /// note that s""""(x) is discontinuous at a double knot and, in; /// addition, s""'(x) is discontinuous at a ",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:3,Deployability,Integrat,Integrate,3,"// Integrate the third derivative of s(x)",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:3,Integrability,Integrat,Integrate,3,"// Integrate the third derivative of s(x)",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:291,Modifiability,variab,variables,291,"////////////////////////////////////////////////////////////////////////////////; /// Test method for TSpline5; ///; /// ~~~ {.cpp}; /// n number of data points.; /// m 2*m-1 is order of spline.; /// m = 3 always for quintic spline.; /// nn,nm1,mm,; /// mm1,i,k,; /// j,jj temporary integer variables.; /// z,p temporary double precision variables.; /// x[n] the sequence of knots.; /// y[n] the prescribed function values at the knots.; /// a[200][6] two dimensional array whose columns are; /// the computed spline coefficients; /// diff[5] maximum values of differences of values and; /// derivatives to right and left of knots.; /// com[5] maximum values of coefficients.; /// ~~~; ///; /// test of TSpline5 with non equidistant knots and; /// equidistant knots follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:338,Modifiability,variab,variables,338,"////////////////////////////////////////////////////////////////////////////////; /// Test method for TSpline5; ///; /// ~~~ {.cpp}; /// n number of data points.; /// m 2*m-1 is order of spline.; /// m = 3 always for quintic spline.; /// nn,nm1,mm,; /// mm1,i,k,; /// j,jj temporary integer variables.; /// z,p temporary double precision variables.; /// x[n] the sequence of knots.; /// y[n] the prescribed function values at the knots.; /// a[200][6] two dimensional array whose columns are; /// the computed spline coefficients; /// diff[5] maximum values of differences of values and; /// derivatives to right and left of knots.; /// com[5] maximum values of coefficients.; /// ~~~; ///; /// test of TSpline5 with non equidistant knots and; /// equidistant knots follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:86,Testability,Test,Test,86,"////////////////////////////////////////////////////////////////////////////////; /// Test method for TSpline5; ///; /// ~~~ {.cpp}; /// n number of data points.; /// m 2*m-1 is order of spline.; /// m = 3 always for quintic spline.; /// nn,nm1,mm,; /// mm1,i,k,; /// j,jj temporary integer variables.; /// z,p temporary double precision variables.; /// x[n] the sequence of knots.; /// y[n] the prescribed function values at the knots.; /// a[200][6] two dimensional array whose columns are; /// the computed spline coefficients; /// diff[5] maximum values of differences of values and; /// derivatives to right and left of knots.; /// com[5] maximum values of coefficients.; /// ~~~; ///; /// test of TSpline5 with non equidistant knots and; /// equidistant knots follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:695,Testability,test,test,695,"////////////////////////////////////////////////////////////////////////////////; /// Test method for TSpline5; ///; /// ~~~ {.cpp}; /// n number of data points.; /// m 2*m-1 is order of spline.; /// m = 3 always for quintic spline.; /// nn,nm1,mm,; /// mm1,i,k,; /// j,jj temporary integer variables.; /// z,p temporary double precision variables.; /// x[n] the sequence of knots.; /// y[n] the prescribed function values at the knots.; /// a[200][6] two dimensional array whose columns are; /// the computed spline coefficients; /// diff[5] maximum values of differences of values and; /// derivatives to right and left of knots.; /// com[5] maximum values of coefficients.; /// ~~~; ///; /// test of TSpline5 with non equidistant knots and; /// equidistant knots follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:3,Testability,Test,Test,3,"// Test of TSpline5 with non equidistant double knots follows",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:3,Testability,test,test,3,"// test of TSpline5 with non equidistant knots, one double knot,; // one triple knot, follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:3,Testability,Test,Test,3,"// Test of TSpline5 with non equidistant knots, two double knots,; // one triple knot,follows.",MatchSource.CODE_COMMENT,hist/hist/src/TSpline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:1966,Availability,error,errors,1966,"; * *; **********************************************************************************/; ////////////////////////////////////////////////////////////////////////////////; /** \class TSVDUnfold; \ingroup Hist; SVD Approach to Data Unfolding; <p>; Reference: <a href=""http://arXiv.org/abs/hep-ph/9509307"">Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]</a>; <p>; TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; <p>; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; <p>; Monte Carlo inputs:; <ul>; <li><tt>xini</tt>: true underlying spectrum (TH1D, n bins); <li><tt>bini</tt>: reconstructed spectrum (TH1D, n bins); <li><tt>Adet</tt>: response matrix (TH2D, nxn bins); </ul>; Consider the unfolding of a measured spectrum <tt>bdat</tt> with covariance matrix <tt>Bcov</tt> (if not passed explicitly, a diagonal covariance will be built given the errors of <tt>bdat</tt>). The corresponding spectrum in the Monte Carlo is given by <tt>bini</tt>, with the true underlying spectrum given by <tt>xini</tt>. The detector response is described by <tt>Adet</tt>, with <tt>Adet</tt> filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; <p>; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of <tt>xini</tt> and <tt>Adet</tt>.<br><br>; <p>; The unfolding can be performed by; \code{.cpp}; TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; \endcode; where <tt>kreg</tt> determines the regularisation of the unfolding. In general, overregular",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:2545,Performance,perform,performed,2545,"ted via a discrete minimum-curvature condition.; <p>; Monte Carlo inputs:; <ul>; <li><tt>xini</tt>: true underlying spectrum (TH1D, n bins); <li><tt>bini</tt>: reconstructed spectrum (TH1D, n bins); <li><tt>Adet</tt>: response matrix (TH2D, nxn bins); </ul>; Consider the unfolding of a measured spectrum <tt>bdat</tt> with covariance matrix <tt>Bcov</tt> (if not passed explicitly, a diagonal covariance will be built given the errors of <tt>bdat</tt>). The corresponding spectrum in the Monte Carlo is given by <tt>bini</tt>, with the true underlying spectrum given by <tt>xini</tt>. The detector response is described by <tt>Adet</tt>, with <tt>Adet</tt> filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; <p>; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of <tt>xini</tt> and <tt>Adet</tt>.<br><br>; <p>; The unfolding can be performed by; \code{.cpp}; TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; \endcode; where <tt>kreg</tt> determines the regularisation of the unfolding. In general, overregularisation (too small <tt>kreg</tt>) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large <tt>kreg</tt>) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in <a href=""http://arXiv.org/abs/hep-ph/9509307"">Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]</a> using the distribution of the <tt>|d_i|</tt> that can be obtained by <tt>tsvdunf->GetD()</tt> and/or using pseudo-experiments.; <p>; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the <tt>GetUnfoldCovMatrix</tt> method, which uses pseudo experiment",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:2127,Safety,detect,detector,2127,"folding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; <p>; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; <p>; Monte Carlo inputs:; <ul>; <li><tt>xini</tt>: true underlying spectrum (TH1D, n bins); <li><tt>bini</tt>: reconstructed spectrum (TH1D, n bins); <li><tt>Adet</tt>: response matrix (TH2D, nxn bins); </ul>; Consider the unfolding of a measured spectrum <tt>bdat</tt> with covariance matrix <tt>Bcov</tt> (if not passed explicitly, a diagonal covariance will be built given the errors of <tt>bdat</tt>). The corresponding spectrum in the Monte Carlo is given by <tt>bini</tt>, with the true underlying spectrum given by <tt>xini</tt>. The detector response is described by <tt>Adet</tt>, with <tt>Adet</tt> filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; <p>; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of <tt>xini</tt> and <tt>Adet</tt>.<br><br>; <p>; The unfolding can be performed by; \code{.cpp}; TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; \endcode; where <tt>kreg</tt> determines the regularisation of the unfolding. In general, overregularisation (too small <tt>kreg</tt>) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large <tt>kreg</tt>) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in <a href=""http://arXiv.org/abs/hep-ph/9509307"">Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]</a> using the distribution of the <tt>|d_i|</tt> that ca",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:3050,Usability,guid,guidelines,3050," given by <tt>bini</tt>, with the true underlying spectrum given by <tt>xini</tt>. The detector response is described by <tt>Adet</tt>, with <tt>Adet</tt> filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; <p>; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of <tt>xini</tt> and <tt>Adet</tt>.<br><br>; <p>; The unfolding can be performed by; \code{.cpp}; TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; \endcode; where <tt>kreg</tt> determines the regularisation of the unfolding. In general, overregularisation (too small <tt>kreg</tt>) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large <tt>kreg</tt>) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in <a href=""http://arXiv.org/abs/hep-ph/9509307"">Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]</a> using the distribution of the <tt>|d_i|</tt> that can be obtained by <tt>tsvdunf->GetD()</tt> and/or using pseudo-experiments.; <p>; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the <tt>GetUnfoldCovMatrix</tt> method, which uses pseudo experiments for the propagation. In addition, <tt>GetAdetCovMatrix</tt> allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to <tt>Bcov</tt> is also computed as described in <a href=""http://arXiv.org/abs/hep-ph/9509307"">Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]</a> and can be obtained from <tt>tsvdunf->GetXtau()</tt> and its (regularisation independent) inverse from <tt>tsvdunf->GetXinv()</tt>. The dist",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:166,Safety,detect,detector,166,"////////////////////////////////////////////////////////////////////////////////; /// Alternative constructor; /// User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:141,Testability,test,test,141,"////////////////////////////////////////////////////////////////////////////////; /// Alternative constructor; /// User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:196,Safety,detect,detector,196,"////////////////////////////////////////////////////////////////////////////////; /// Default constructor; /// Initialisation of TSVDUnfold; /// User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:171,Testability,test,test,171,"////////////////////////////////////////////////////////////////////////////////; /// Default constructor; /// Initialisation of TSVDUnfold; /// User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:86,Performance,Perform,Perform,86,"////////////////////////////////////////////////////////////////////////////////; /// Perform the unfolding with regularisation parameter kreg",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:10,Modifiability,variab,variable,10,"// Return variable; // Damping factors",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:112,Availability,error,error,112,"////////////////////////////////////////////////////////////////////////////////; /// Determine for given input error matrix covariance matrix of unfolded; /// spectrum from toy simulation given the passed covariance matrix on measured spectrum; /// ""cov"" - covariance matrix on the measured spectrum, to be propagated; /// ""ntoys"" - number of pseudo experiments used for the propagation; /// ""seed"" - seed for pseudo experiments; /// Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area.",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:36,Modifiability,variab,variables,36,"// create a vector of unit Gaussian variables",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:36,Modifiability,variab,variables,36,"// Create a vector of unit Gaussian variables",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:23,Safety,detect,detector,23,"//Now the toys for the detector response matrix",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:104,Availability,error,errors,104,"////////////////////////////////////////////////////////////////////////////////; /// Fill 1D histogram errors into vector",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:18,Safety,avoid,avoid,18,"// Add epsilon to avoid singularities",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:8,Energy Efficiency,reduce,reduced,8,"// init reduced matrix",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:93,Integrability,rout,routine,93,"////////////////////////////////////////////////////////////////////////////////; /// Helper routine to compute chi-squared between distributions using the computed inverse of the covariance matrix for the unfolded spectrum as given in paper.",MatchSource.CODE_COMMENT,hist/hist/src/TSVDUnfold.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:105,Availability,Error,Error,105,"////////////////////////////////////////////////////////////////////////////////; /// static: Return the Error Definition",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:101,Performance,cache,cache,101,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the cache array; /// npoints is the number of points to be stored (or already stored) in the cache; /// psize is the number of elements per point; ///; /// if (npoints*psize > fCacheSize) the existing cache is deleted; /// and a new array is created.; /// The function returns a pointer to the cache",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:190,Performance,cache,cache,190,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the cache array; /// npoints is the number of points to be stored (or already stored) in the cache; /// psize is the number of elements per point; ///; /// if (npoints*psize > fCacheSize) the existing cache is deleted; /// and a new array is created.; /// The function returns a pointer to the cache",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:298,Performance,cache,cache,298,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the cache array; /// npoints is the number of points to be stored (or already stored) in the cache; /// psize is the number of elements per point; ///; /// if (npoints*psize > fCacheSize) the existing cache is deleted; /// and a new array is created.; /// The function returns a pointer to the cache",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:391,Performance,cache,cache,391,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the cache array; /// npoints is the number of points to be stored (or already stored) in the cache; /// psize is the number of elements per point; ///; /// if (npoints*psize > fCacheSize) the existing cache is deleted; /// and a new array is created.; /// The function returns a pointer to the cache",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:102,Availability,Error,Error,102,"////////////////////////////////////////////////////////////////////////////////; /// static: Set the Error Definition (default=1); /// For Minuit this is the value passed with the ""SET ERR"" command; /// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html)",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:102,Availability,toler,tolerance,102,"////////////////////////////////////////////////////////////////////////////////; /// static: Set the tolerance used in the minimization algorithm; /// For example for MIGRAD this is tolerance value passed as second argument; /// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html )",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:183,Availability,toler,tolerance,183,"////////////////////////////////////////////////////////////////////////////////; /// static: Set the tolerance used in the minimization algorithm; /// For example for MIGRAD this is tolerance value passed as second argument; /// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html )",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualFitter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualGraphPainter.cxx:64,Integrability,interface,interface,64,"/** \class TVirtualGraphPainter; \ingroup Histpainter; Abstract interface to a histogram painter; */; ////////////////////////////////////////////////////////////////////////////////; /// Static function returning a pointer to the current graph painter.; /// If the graph painter does not exist a default painter (singleton) is created.",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualGraphPainter.cxx:59,Modifiability,Plugin,PluginManager,59,"// if no painter set yet, create a default painter via the PluginManager",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualHistPainter.cxx:63,Integrability,interface,interface,63,"/** \class TVirtualHistPainter; \ingroup Histpainter; Abstract interface to a histogram painter; */; ////////////////////////////////////////////////////////////////////////////////; /// Static function returning a pointer to the current histogram painter.; /// The painter will paint the specified obj. If the histogram painter; /// does not exist a default painter is created.",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualHistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualHistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualHistPainter.cxx:59,Modifiability,Plugin,PluginManager,59,"// if no painter set yet, create a default painter via the PluginManager",MatchSource.CODE_COMMENT,hist/hist/src/TVirtualHistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualHistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx:20,Testability,test,test,20,"// time saving self-test",MatchSource.CODE_COMMENT,hist/hist/src/WrappedTF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx:144,Safety,avoid,avoid,144,"// evaluate the derivative of the function with respect to the parameters; //IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; // BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; // so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters",MatchSource.CODE_COMMENT,hist/hist/src/WrappedTF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx:45,Integrability,depend,dependency,45,"// case of polynomial function (no parameter dependency)",MatchSource.CODE_COMMENT,hist/hist/src/WrappedTF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx:26,Integrability,depend,depend,26,"// derivatives should not depend on parameters since func is linear",MatchSource.CODE_COMMENT,hist/hist/src/WrappedTF1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/tdirectoryfile_destructor_segfault.cxx:589,Performance,load,loading,589,"// Test against https://github.com/root-project/root/issues/13691; // At destruction time TDirectoryFile called the destructor of; // TDirectory, thus:; // - inadvertently triggered initialization of gROOT; // - called TDirectory::RecursiveRemove which didn't check for the validity; // of the `fList` data member, which had already been deleted in the; // TDirectoryFile destructor; //; // NOTE: In order for the segfault to actually be triggered, this test needs; // to link against some library that is not in the list of globally ignored; // PCMs (gIgnoredPCMNames in TCling.cxx). The loading of a PCM is what; // actually triggers the call to TDirectory::RecursiveRemove in the end.",MatchSource.CODE_COMMENT,hist/hist/test/tdirectoryfile_destructor_segfault.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/tdirectoryfile_destructor_segfault.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/tdirectoryfile_destructor_segfault.cxx:3,Testability,Test,Test,3,"// Test against https://github.com/root-project/root/issues/13691; // At destruction time TDirectoryFile called the destructor of; // TDirectory, thus:; // - inadvertently triggered initialization of gROOT; // - called TDirectory::RecursiveRemove which didn't check for the validity; // of the `fList` data member, which had already been deleted in the; // TDirectoryFile destructor; //; // NOTE: In order for the segfault to actually be triggered, this test needs; // to link against some library that is not in the list of globally ignored; // PCMs (gIgnoredPCMNames in TCling.cxx). The loading of a PCM is what; // actually triggers the call to TDirectory::RecursiveRemove in the end.",MatchSource.CODE_COMMENT,hist/hist/test/tdirectoryfile_destructor_segfault.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/tdirectoryfile_destructor_segfault.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/tdirectoryfile_destructor_segfault.cxx:454,Testability,test,test,454,"// Test against https://github.com/root-project/root/issues/13691; // At destruction time TDirectoryFile called the destructor of; // TDirectory, thus:; // - inadvertently triggered initialization of gROOT; // - called TDirectory::RecursiveRemove which didn't check for the validity; // of the `fList` data member, which had already been deleted in the; // TDirectoryFile destructor; //; // NOTE: In order for the segfault to actually be triggered, this test needs; // to link against some library that is not in the list of globally ignored; // PCMs (gIgnoredPCMNames in TCling.cxx). The loading of a PCM is what; // actually triggers the call to TDirectory::RecursiveRemove in the end.",MatchSource.CODE_COMMENT,hist/hist/test/tdirectoryfile_destructor_segfault.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/tdirectoryfile_destructor_segfault.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_MapCppName.cxx:3,Testability,Test,Test,3,"// Test the C++ validity of saved objects' names",MatchSource.CODE_COMMENT,hist/hist/test/test_MapCppName.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_MapCppName.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_Project3D_name.cxx:3,Testability,test,test,3,"// test TH3::Project3D name",MatchSource.CODE_COMMENT,hist/hist/test/test_Project3D_name.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_Project3D_name.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_projections.cxx:3,Testability,Test,Test,3,"// Test projection from 2D hist for labels/nbins",MatchSource.CODE_COMMENT,hist/hist/test/test_projections.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_projections.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_projections.cxx:3,Testability,Test,Test,3,"// Test projection from 3D hist for labels/nbins",MatchSource.CODE_COMMENT,hist/hist/test/test_projections.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_projections.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_projections.cxx:3,Testability,Test,Test,3,"// Test projection from Profile2D hist for labels/nbins",MatchSource.CODE_COMMENT,hist/hist/test/test_projections.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_projections.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_spline.cxx:3,Usability,simpl,simple,3,"// simple quadratic polynomial",MatchSource.CODE_COMMENT,hist/hist/test/test_spline.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_spline.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx:3,Testability,test,test,3,"// test the various option : case no mode (average) and shortes (no central); // cannot be done with TGraphAsymmErrors. ROOT-10324 is missing mode central; // that is now fixed",MatchSource.CODE_COMMENT,hist/hist/test/test_TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx:53,Testability,test,test,53,"// adding central is actually useless here but so we test this",MatchSource.CODE_COMMENT,hist/hist/test/test_TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx:3,Testability,test,test,3,"// test the 95% confidence intervals; // taken from: http://www.measuringusability.com/wald.htm; //; // format: (k,n) -> lower bound, upper bound; // (0,0) -> 0, 1; // (3,7) -> 0.062, 0.795; // (0,8) -> 0, 0; // (3,12) -> 0.005, 0.495; // (2,14) -> 0, 0.326; // (5,18) -> 0.071, 0.485; // (15,30) -> 0.321, 0.679; // (10,10) -> 1, 1",MatchSource.CODE_COMMENT,hist/hist/test/test_TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx:3,Testability,test,test,3,"// test the 95% confidence intervals; // taken from: http://www.measuringusability.com/wald.htm; //; // format: (k,n) -> lower bound, upper bound; // (0,0) -> 0, 1; // (3,7) -> 0.158, 0.750; // (0,8) -> 0, 0.324; // (3,12) -> 0.089, 0.532; // (2,14) -> 0.040, 0.399; // (5,18) -> 0.125, 0.509; // (15,30) -> 0.332, 0.669; // (10,10) -> 0.722, 1.000",MatchSource.CODE_COMMENT,hist/hist/test/test_TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx:3,Testability,test,test,3,"// test the 95% confidence intervals; // taken from: http://people.na.infn.it/~lista/cgi/binomial/binomial.pl; //; // format: (k,n) -> lower bound, upper bound; // (0,0) -> 0, 1; // (3,7) -> 0.129, 0.775; // (0,8) -> 0, 0.321; // (3,12) -> 0.072, 0.548; // (2,14) -> 0.026, 0.418; // (5,18) -> 0.106, 0.531; // (15,30) -> 0.324, 0.676; // (10,10) -> 0.733, 1.000",MatchSource.CODE_COMMENT,hist/hist/test/test_TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx:3,Testability,test,test,3,"// test the 95% confidence intervals; // taken from: http://people.na.infn.it/~lista/cgi/binomial/binomial.pl; //; // format: (k,n) -> lower bound, upper bound; // (0,0) -> 0, 1; // (3,7) -> 0.099, 0.816; // (0,8) -> 0, 0.369; // (3,12) -> 0.055, 0.572; // (2,14) -> 0.018, 0.428; // (5,18) -> 0.097, 0.535; // (15,30) -> 0.313, 0.687; // (10,10) -> 0.692, 1.000",MatchSource.CODE_COMMENT,hist/hist/test/test_TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx:3,Testability,test,test,3,"// test the 95% confidence intervals; // taken from:; // ""Interval Estimation for a Binomial Proportion"" Brown, Cai, DasGupta; // Table 5; //; // format: (k,n) -> lower bound, upper bound; // (0,0) -> 0.002, 0.998; // (3,7) -> 0.139, 0.766; // (0,8) -> 0, 0.262; // (3,12) -> 0.076, 0.529; // (2,14) -> 0.031, 0.385; // (5,18) -> 0.115, 0.506; // (15,30) -> 0.328, 0.672; // (10,10) -> 0.783, 1.000; //; // alpha = k + 0.5; // beta = n - k + 0.5",MatchSource.CODE_COMMENT,hist/hist/test/test_TEfficiency.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TEfficiency.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,Test,Test,3,"// Test that the NSUM names are copied correctly",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,Test,Test,3,"// Test that the NSUM is normalized as we'd expect",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,Test,Test,3,"// Test that we can change the range of TF1NormSum and TF1Convolution",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:108,Availability,error,errors,108,"// making our convolution much more accurate; // Numeric integration of this function suffers from roundoff errors, so the default 1.E-12 accuracy won't be reached.; // By reducing the tolerance, we get rid of a GSL warning, which was picked up by the log checkers.",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:185,Availability,toler,tolerance,185,"// making our convolution much more accurate; // Numeric integration of this function suffers from roundoff errors, so the default 1.E-12 accuracy won't be reached.; // By reducing the tolerance, we get rid of a GSL warning, which was picked up by the log checkers.",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:57,Deployability,integrat,integration,57,"// making our convolution much more accurate; // Numeric integration of this function suffers from roundoff errors, so the default 1.E-12 accuracy won't be reached.; // By reducing the tolerance, we get rid of a GSL warning, which was picked up by the log checkers.",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:57,Integrability,integrat,integration,57,"// making our convolution much more accurate; // Numeric integration of this function suffers from roundoff errors, so the default 1.E-12 accuracy won't be reached.; // By reducing the tolerance, we get rid of a GSL warning, which was picked up by the log checkers.",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:252,Testability,log,log,252,"// making our convolution much more accurate; // Numeric integration of this function suffers from roundoff errors, so the default 1.E-12 accuracy won't be reached.; // By reducing the tolerance, we get rid of a GSL warning, which was picked up by the log checkers.",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,Test,Test,3,"// Test that we can copy and clone TF1 objects based on NSUM and CONV",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:17,Testability,test,test,17,"// Make copy and test",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:18,Testability,test,test,18,"// Make clone and test",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,Test,Test,3,"// Test that the voigt can be expressed as a convolution of a gaussian and lorentzian; // Check that the values match to within 1%",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,test,test,3,"// test at position of saved bins",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,test,test,3,"// test linear approximation",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,test,test,3,"// test outside range",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:7,Testability,test,test,7,"// now test saved at middle of bins",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,test,test,3,"// test at position of saved bins",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,test,test,3,"// test linear approximation",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx:3,Testability,test,test,3,"// test outside range",MatchSource.CODE_COMMENT,hist/hist/test/test_tf1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TF123_Moments.cxx:3,Testability,Test,Test,3,"// Test the moments for a TF2 function - a bi-variate gaussian with correlation",MatchSource.CODE_COMMENT,hist/hist/test/test_TF123_Moments.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TF123_Moments.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx:3,Testability,test,test,3,"// test exact position",MatchSource.CODE_COMMENT,hist/hist/test/test_tf2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx:3,Testability,test,test,3,"// test approximation",MatchSource.CODE_COMMENT,hist/hist/test/test_tf2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx:3,Testability,test,test,3,"// test boundaries",MatchSource.CODE_COMMENT,hist/hist/test/test_tf2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx:3,Testability,test,test,3,"// test exact position",MatchSource.CODE_COMMENT,hist/hist/test/test_tf2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx:3,Testability,test,test,3,"// test approximation",MatchSource.CODE_COMMENT,hist/hist/test/test_tf2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx:3,Testability,test,test,3,"// test boundaries",MatchSource.CODE_COMMENT,hist/hist/test/test_tf2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx:3,Testability,test,test,3,"// test exact position",MatchSource.CODE_COMMENT,hist/hist/test/test_tf3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx:3,Testability,test,test,3,"// test approximation",MatchSource.CODE_COMMENT,hist/hist/test/test_tf3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx:3,Testability,test,test,3,"// test boundaries",MatchSource.CODE_COMMENT,hist/hist/test/test_tf3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx:3,Testability,test,test,3,"// test exact position",MatchSource.CODE_COMMENT,hist/hist/test/test_tf3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx:3,Testability,test,test,3,"// test approximation",MatchSource.CODE_COMMENT,hist/hist/test/test_tf3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx:3,Testability,test,test,3,"// test boundaries",MatchSource.CODE_COMMENT,hist/hist/test/test_tf3.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tf3.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TFormula.cxx:3,Testability,Test,Test,3,"// Test that autoloading works (ROOT-9840)",MatchSource.CODE_COMMENT,hist/hist/test/test_TFormula.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TFormula.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx:22,Availability,error,errors,22,"// Check if the graph errors are sorted based on the sorted values",MatchSource.CODE_COMMENT,hist/hist/test/test_TGraph_sorting.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx:22,Availability,error,errors,22,"// Check if the graph errors are sorted based on the sorted values",MatchSource.CODE_COMMENT,hist/hist/test/test_TGraph_sorting.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx:22,Availability,error,errors,22,"// Check if the graph errors are sorted based on the sorted values",MatchSource.CODE_COMMENT,hist/hist/test/test_TGraph_sorting.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx:22,Availability,error,errors,22,"// Check if the graph errors are sorted based on the sorted values",MatchSource.CODE_COMMENT,hist/hist/test/test_TGraph_sorting.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TGraph_sorting.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1.cxx:3,Usability,Simpl,Simple,3,"// Simple cross-check that TH1::SmoothArray() is not doing anything if input; // array is already smooth.",MatchSource.CODE_COMMENT,hist/hist/test/test_TH1.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_FindFirstBinAbove.cxx:3,Testability,test,test,3,"// test TH1::FindFirstBinAbove abd TH1::FindLastBinAbove",MatchSource.CODE_COMMENT,hist/hist/test/test_TH1_FindFirstBinAbove.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_FindFirstBinAbove.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_SaveAs.cxx:24,Availability,error,errors,24,"// Bin contents and bin errors",MatchSource.CODE_COMMENT,hist/hist/test/test_TH1_SaveAs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_SaveAs.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_SaveAs.cxx:4,Testability,Test,Tests,4,"/// Tests for TH1::SaveAs; /// In this test we export a TH1 to 4 files of types csv, tsv, txt and C,; /// and then read those files checking whether the contents are as expected; /// In the csv file, we include the header line",MatchSource.CODE_COMMENT,hist/hist/test/test_TH1_SaveAs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_SaveAs.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_SaveAs.cxx:39,Testability,test,test,39,"/// Tests for TH1::SaveAs; /// In this test we export a TH1 to 4 files of types csv, tsv, txt and C,; /// and then read those files checking whether the contents are as expected; /// In the csv file, we include the header line",MatchSource.CODE_COMMENT,hist/hist/test/test_TH1_SaveAs.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH1_SaveAs.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_Add.cxx:3,Testability,test,test,3,"// test TH2Poly adding two histograms",MatchSource.CODE_COMMENT,hist/hist/test/test_TH2Poly_Add.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_Add.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx:43,Availability,error,error,43,"// test TH2Poly setting and retrieving bin error ",MatchSource.CODE_COMMENT,hist/hist/test/test_TH2Poly_BinError.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx:3,Testability,test,test,3,"// test TH2Poly setting and retrieving bin error ",MatchSource.CODE_COMMENT,hist/hist/test/test_TH2Poly_BinError.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx:42,Availability,error,error,42,"// setting a new content does not set bin error",MatchSource.CODE_COMMENT,hist/hist/test/test_TH2Poly_BinError.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx:19,Availability,error,error,19,"// set content and error",MatchSource.CODE_COMMENT,hist/hist/test/test_TH2Poly_BinError.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx:3,Testability,test,test,3,"// test copying",MatchSource.CODE_COMMENT,hist/hist/test/test_TH2Poly_BinError.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx:3,Testability,test,test,3,"// test statistics",MatchSource.CODE_COMMENT,hist/hist/test/test_TH2Poly_BinError.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_BinError.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_GetNumberOfBins.cxx:3,Testability,test,test,3,"// test TH2Poly GetNumberOfBins",MatchSource.CODE_COMMENT,hist/hist/test/test_TH2Poly_GetNumberOfBins.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TH2Poly_GetNumberOfBins.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:3,Testability,test,test,3,"// test iterating histogram bins and using the new THistRange and; // THBinIterator classes",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:10,Modifiability,variab,variables,10,"// global variables",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:3,Testability,test,test,3,"// test classes",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:42,Testability,test,test,42,"//GOOD: this is called after running same test suite and not at; // end of main program.",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:7,Testability,test,test,7,"// TH1 test classes -",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:3,Testability,test,test,3,"// test 60% of histogram",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:3,Testability,test,test,3,"// test 60% of histogram",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:20,Testability,test,test,20,"// createTH3();; // test 60% of histogram; // test 60% of histogram",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:46,Testability,test,test,46,"// createTH3();; // test 60% of histogram; // test 60% of histogram",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:3,Testability,test,test,3,"// test with full range",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:3,Testability,test,test,3,"// test with restricted range",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:8,Testability,test,tests,8,"// TH2D tests",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:6,Testability,test,tests,6,"// 2D tests with restricted range",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:8,Testability,test,tests,8,"// TH3D tests",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:6,Testability,test,tests,6,"// 3D tests with restricted range",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx:42,Testability,test,testing,42,"// Disables elapsed time by default.; //::testing::GTEST_FLAG(print_time) = false;; // Parse command line arguments",MatchSource.CODE_COMMENT,hist/hist/test/test_THBinIterator.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THBinIterator.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx:14,Availability,error,errors,14,"// stack with errors",MatchSource.CODE_COMMENT,hist/hist/test/test_THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx:16,Availability,error,errors,16,"// nostack with errors",MatchSource.CODE_COMMENT,hist/hist/test/test_THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx:15,Availability,error,error,15,"// significant error at maximum bin",MatchSource.CODE_COMMENT,hist/hist/test/test_THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx:14,Availability,error,errors,14,"// stack with errors",MatchSource.CODE_COMMENT,hist/hist/test/test_THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx:16,Availability,error,errors,16,"// nostack with errors",MatchSource.CODE_COMMENT,hist/hist/test/test_THStack.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_THStack.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:79,Availability,error,error,79,"// should use half of data for histogram since; // we do not count statistical error from TKDE?; //for (int i = 0; i < 0.5*n; ++i); // h1->Fill(data2[i]);",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:13,Testability,test,test,13,"// make chi2 test; //double pvalChi2 = h1->Chi2Test(h2,""WW P"");; // note Chisquare called SetParameters and delete histogram returned from the function",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:19,Availability,error,error,19,"// set correct bin error",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:14,Testability,test,test,14,"// compute KS test",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:24,Testability,test,tests,24,"/// Hstogram comparison tests; /// In this test we compare the TKDE with an histogram; /// filled with the same type of data. A GoF test (chi2 and KS) is applied to; /// check for compatibility",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:43,Testability,test,test,43,"/// Hstogram comparison tests; /// In this test we compare the TKDE with an histogram; /// filled with the same type of data. A GoF test (chi2 and KS) is applied to; /// check for compatibility",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:132,Testability,test,test,132,"/// Hstogram comparison tests; /// In this test we compare the TKDE with an histogram; /// filled with the same type of data. A GoF test (chi2 and KS) is applied to; /// check for compatibility",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:3,Energy Efficiency,reduce,reduce,3,"// reduce n here since unbinned adaptive is slow",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:32,Energy Efficiency,adapt,adaptive,32,"// reduce n here since unbinned adaptive is slow",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:32,Modifiability,adapt,adaptive,32,"// reduce n here since unbinned adaptive is slow",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:3,Testability,test,test,3,"// test also default constructors + usage of setters functions",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:8,Testability,test,test,8,"// this test will fail miserably if sigma2 is large since; // binning does not use events outside range; // data.InRange=false is not doing since the bin data will; // consider only data in the range !!!",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:19,Energy Efficiency,adapt,adaptive,19,"// with binned not adaptive it is good for high statistics",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:19,Modifiability,adapt,adaptive,19,"// with binned not adaptive it is good for high statistics",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:22,Testability,test,test,22,"// for mirror case KS test is not so good but Chi2 is better; // test both p-values",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:65,Testability,test,test,65,"// for mirror case KS test is not so good but Chi2 is better; // test both p-values",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:14,Energy Efficiency,adapt,adaptive,14,"// when using adaptive mirror a much; // smaller bandwidth is used. Not sure this is correct; // seee line TKDE.cxx:770",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:14,Modifiability,adapt,adaptive,14,"// when using adaptive mirror a much; // smaller bandwidth is used. Not sure this is correct; // seee line TKDE.cxx:770",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:7,Testability,test,tests,7,"/// IO tests; /// In this test we compare the value before writing and after reading of the TKDE",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx:26,Testability,test,test,26,"/// IO tests; /// In this test we compare the value before writing and after reading of the TKDE",MatchSource.CODE_COMMENT,hist/hist/test/test_tkde.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tkde.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TMultiGraph_GetHistogram.cxx:3,Testability,test,test,3,"// test TMultiGraph::GetHistogram in log scale",MatchSource.CODE_COMMENT,hist/hist/test/test_TMultiGraph_GetHistogram.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TMultiGraph_GetHistogram.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TMultiGraph_GetHistogram.cxx:37,Testability,log,log,37,"// test TMultiGraph::GetHistogram in log scale",MatchSource.CODE_COMMENT,hist/hist/test/test_TMultiGraph_GetHistogram.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_TMultiGraph_GetHistogram.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:3,Testability,test,test,3,"// test overflow",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:3,Testability,test,test,3,"// test overflow",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:97,Availability,error,error,97,"// ASSERT_DOUBLE_EQ does not succeed on macOS, that's why we use ASSERT_NEAR; // with a relative error in this test. A relative error of 1.E-12 should be; // large enough to take into account some numerical differences. It is,; // however, unexpected that the test fails since the code to compute the bin; // error of the TProfile2Poly and the TProfile2D do the same operations.",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:128,Availability,error,error,128,"// ASSERT_DOUBLE_EQ does not succeed on macOS, that's why we use ASSERT_NEAR; // with a relative error in this test. A relative error of 1.E-12 should be; // large enough to take into account some numerical differences. It is,; // however, unexpected that the test fails since the code to compute the bin; // error of the TProfile2Poly and the TProfile2D do the same operations.",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:309,Availability,error,error,309,"// ASSERT_DOUBLE_EQ does not succeed on macOS, that's why we use ASSERT_NEAR; // with a relative error in this test. A relative error of 1.E-12 should be; // large enough to take into account some numerical differences. It is,; // however, unexpected that the test fails since the code to compute the bin; // error of the TProfile2Poly and the TProfile2D do the same operations.",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:111,Testability,test,test,111,"// ASSERT_DOUBLE_EQ does not succeed on macOS, that's why we use ASSERT_NEAR; // with a relative error in this test. A relative error of 1.E-12 should be; // large enough to take into account some numerical differences. It is,; // however, unexpected that the test fails since the code to compute the bin; // error of the TProfile2Poly and the TProfile2D do the same operations.",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:260,Testability,test,test,260,"// ASSERT_DOUBLE_EQ does not succeed on macOS, that's why we use ASSERT_NEAR; // with a relative error in this test. A relative error of 1.E-12 should be; // large enough to take into account some numerical differences. It is,; // however, unexpected that the test fails since the code to compute the bin; // error of the TProfile2Poly and the TProfile2D do the same operations.",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:3,Testability,test,test,3,"// test overflow",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx:16,Testability,TEST,TEST,16,"// ------------ TEST CALLS ------------",MatchSource.CODE_COMMENT,hist/hist/test/test_tprofile2poly.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/test_tprofile2poly.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaGradientTests.cxx:75,Testability,test,tests,75,"/// \file TFormulaGradientTests.cxx; ///; /// \brief The file contain unit tests which test the clad-based gradient; /// computations.; ///; /// \author Vassil Vassilev <vvasilev@cern.ch>; ///; /// \date Oct, 2018; ///; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/hist/test/TFormulaGradientTests.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaGradientTests.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaGradientTests.cxx:87,Testability,test,test,87,"/// \file TFormulaGradientTests.cxx; ///; /// \brief The file contain unit tests which test the clad-based gradient; /// computations.; ///; /// \author Vassil Vassilev <vvasilev@cern.ch>; ///; /// \date Oct, 2018; ///; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/hist/test/TFormulaGradientTests.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaGradientTests.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaGradientTests.cxx:40,Modifiability,inherit,inheritently,40,"// auto h = new TF1(""f1"", ""landau""); -- inheritently does not work. See DIFLAN; //crystalball, breitwigner, cheb3, bigaus,; //auto h = new TF1(""f1"", """");",MatchSource.CODE_COMMENT,hist/hist/test/TFormulaGradientTests.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaGradientTests.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaHessianTests.cxx:74,Testability,test,tests,74,"/// \file TFormulaHessianTests.cxx; ///; /// \brief The file contain unit tests which test the clad-based hessian; /// computations.; ///; /// \author Baidyanath Kundu <kundubaidya99@gmail.com>; ///; /// \date Aug, 2021; ///; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/hist/test/TFormulaHessianTests.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaHessianTests.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaHessianTests.cxx:86,Testability,test,test,86,"/// \file TFormulaHessianTests.cxx; ///; /// \brief The file contain unit tests which test the clad-based hessian; /// computations.; ///; /// \author Baidyanath Kundu <kundubaidya99@gmail.com>; ///; /// \date Aug, 2021; ///; /*************************************************************************; * Copyright (C) 1995-2018, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/hist/test/TFormulaHessianTests.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/test/TFormulaHessianTests.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistDisplayItem.hxx:239,Usability,Feedback,Feedback,239,"/// \file ROOT/RHistDisplayItem.hxx; /// \ingroup HistDrawV7; /// \author Sergey Linev <s.linev@gsi.de>; /// \date 2020-06-25; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistDisplayItem.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistDisplayItem.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistDrawable.hxx:234,Usability,Feedback,Feedback,234,"/// \file ROOT/RHistDrawable.hxx; /// \ingroup HistDrawV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-07-09; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistDrawable.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistDrawable.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistDrawable.hxx:6,Performance,optimiz,optimize,6,"///<! optimize drawing",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistDrawable.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistDrawable.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx:136,Safety,avoid,avoid,136,"/** \class ROOT::Experimental::RDisplayHistStat; \ingroup GrafROOT7; \brief Object send to client for display of RHistStat, required to avoid sending histogram to the client; \author Sergey Linev <s.linev@gsi.de>; \date 2020-04-17; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx:340,Usability,Feedback,Feedback,340,"/** \class ROOT::Experimental::RDisplayHistStat; \ingroup GrafROOT7; \brief Object send to client for display of RHistStat, required to avoid sending histogram to the client; \author Sergey Linev <s.linev@gsi.de>; \date 2020-04-17; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx:18,Availability,mask,mask,18,"///< initial show mask",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx:349,Usability,Feedback,Feedback,349,"/** \class ROOT::Experimental::RHistStatBoxBase; \ingroup GrafROOT7; \brief Base class for histogram statistic box, provides graphics attributes and virtual method for fill statistic; \author Sergey Linev <s.linev@gsi.de>; \date 2020-04-01; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx:5,Availability,mask,mask,5,"///< mask used to create lines",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx:3,Availability,mask,mask,3,"// mask of items to show",MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx:287,Usability,Feedback,Feedback,287,/** \class ROOT::Experimental::RHistStatBox; \ingroup GrafROOT7; \brief Template class for statistic box for RHist class; \author Sergey Linev <s.linev@gsi.de>; \date 2020-04-01; \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; */,MatchSource.CODE_COMMENT,hist/histdrawv7/inc/ROOT/RHistStatBox.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistStatBox.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDisplayItem.cxx:234,Usability,Feedback,Feedback,234,"/// \file RHistDisplayItem.cxx; /// \ingroup HistDrawV7; /// \author Sergey Linev <s.linev@gsi.de>; /// \date 2020-06-25; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histdrawv7/src/RHistDisplayItem.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDisplayItem.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx:229,Usability,Feedback,Feedback,229,"/// \file RHistDrawable.cxx; /// \ingroup HistDrawV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-09-11; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histdrawv7/src/RHistDrawable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx:165,Modifiability,config,configured,165,"// with minmax approach 2*n bins replaced by 2 bins with min and max value inside the range; // this let display histogram showing dynamic values range properly; // configured when more than 3 bins should be merged",MatchSource.CODE_COMMENT,hist/histdrawv7/src/RHistDrawable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx:11,Usability,simpl,simple,11,"// provide simple rebin with average values; // TODO: provide methods in histogram classes",MatchSource.CODE_COMMENT,hist/histdrawv7/src/RHistDrawable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx:11,Usability,simpl,simple,11,"// provide simple rebin with average values; // TODO: provide methods in histogram classes",MatchSource.CODE_COMMENT,hist/histdrawv7/src/RHistDrawable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx:11,Usability,simpl,simple,11,"// provide simple rebin with average values; // TODO: provide methods in histogram classes",MatchSource.CODE_COMMENT,hist/histdrawv7/src/RHistDrawable.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/src/RHistDrawable.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/draw.cxx:3,Testability,Test,Test,3,"// Test drawing of histograms.",MatchSource.CODE_COMMENT,hist/histdrawv7/test/draw.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/draw.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/io.cxx:3,Testability,Test,Test,3,"// Test storing of 1D histogram",MatchSource.CODE_COMMENT,hist/histdrawv7/test/io.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/io.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/io.cxx:3,Testability,Test,Test,3,"// Test storing of 2D histogram",MatchSource.CODE_COMMENT,hist/histdrawv7/test/io.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/io.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/io.cxx:3,Testability,Test,Test,3,"// Test storing RCanvas with two RHistDrawable, referencing same histo",MatchSource.CODE_COMMENT,hist/histdrawv7/test/io.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/test/io.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h:22,Availability,Error,Errors,22,"///< <b>""En""</b> Draw Errors with current marker type and size (0 <= n <=6).",MatchSource.CODE_COMMENT,hist/histpainter/inc/Hoption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h:18,Usability,simpl,simple,18,"///< <b>""L""</b> A simple polyline through every point is drawn.",MatchSource.CODE_COMMENT,hist/histpainter/inc/Hoption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h:5,Testability,log,log,5,"///< log scale in X. Also set by histogram option",MatchSource.CODE_COMMENT,hist/histpainter/inc/Hoption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h:5,Testability,log,log,5,"///< log scale in Y. Also set by histogram option",MatchSource.CODE_COMMENT,hist/histpainter/inc/Hoption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h:5,Testability,log,log,5,"///< log scale in Z. Also set by histogram option; ///@}",MatchSource.CODE_COMMENT,hist/histpainter/inc/Hoption.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hoption.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hparam.h:5,Deployability,Integrat,Integrated,5,"///< Integrated sum of contents",MatchSource.CODE_COMMENT,hist/histpainter/inc/Hparam.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hparam.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hparam.h:5,Integrability,Integrat,Integrated,5,"///< Integrated sum of contents",MatchSource.CODE_COMMENT,hist/histpainter/inc/Hparam.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/inc/Hparam.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraph2DPainter.cxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate space to store the segments. They cannot be more than the; // number of triangles.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraph2DPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraph2DPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraph2DPainter.cxx:109,Availability,error,error,109,"////////////////////////////////////////////////////////////////////////////////; /// Paints the 2D graph as error bars",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraph2DPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraph2DPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:322,Availability,error,error,322,"////////////////////////////////////////////////////////////////////////////////; /*! \class TGraphPainter; \ingroup Histpainter; \brief The graph painter class. Implements all graphs' drawing's options. - [Introduction](\ref GrP0); - [Graphs' plotting options](\ref GrP1); - [Exclusion graphs](\ref GrP2); - [Graphs with error bars](\ref GrP3); - [TGraphErrors](\ref GrP3a); - [TGraphAsymmErrors](\ref GrP3b); - [TGraphBentErrors](\ref GrP3c); - [TGraphMultiErrors](\ref GrP3d); - [TGraphPolar options](\ref GrP4); - [Colors automatically picked in palette](\ref GrP5); - [Reverse graphs' axis](\ref GrP6); - [Graphs in logarithmic scale](\ref GrP7); - [Highlight mode for graph](\ref GrP8). \anchor GrP0; ### Introduction. Graphs are drawn via the painter `TGraphPainter` class. This class; implements techniques needed to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|--------------------------------------",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:5280,Availability,error,error,5280,"sin(x[i]+0.2)-6;; }; auto gr = new TGraph(n,x,y);; gr->SetFillColor(38);; gr->SetTitle("" "");; c47->cd(1); gr->Draw(""AB"");; c47->cd(2); gr->Draw(""AB1"");; }; End_Macro. \anchor GrP2; ### Exclusion graphs. When a graph is painted with the option `C` or `L` it is; possible to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute value of the graph line; width (set by `SetLineWidth()`) is greater than 99. In that; case the line width number is interpreted as:. 100*ff+ll = ffll. - The two digits number `ll` represent the normal line width; - The two digits number `ff` represent the filled area width.; - The sign of ""ffll"" allows to flip the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on to",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:5310,Availability,avail,available,5310,"sin(x[i]+0.2)-6;; }; auto gr = new TGraph(n,x,y);; gr->SetFillColor(38);; gr->SetTitle("" "");; c47->cd(1); gr->Draw(""AB"");; c47->cd(2); gr->Draw(""AB1"");; }; End_Macro. \anchor GrP2; ### Exclusion graphs. When a graph is painted with the option `C` or `L` it is; possible to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute value of the graph line; width (set by `SetLineWidth()`) is greater than 99. In that; case the line width number is interpreted as:. 100*ff+ll = ffll. - The two digits number `ll` represent the normal line width; - The two digits number `ff` represent the filled area width.; - The sign of ""ffll"" allows to flip the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on to",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:5342,Availability,error,error,5342,"sin(x[i]+0.2)-6;; }; auto gr = new TGraph(n,x,y);; gr->SetFillColor(38);; gr->SetTitle("" "");; c47->cd(1); gr->Draw(""AB"");; c47->cd(2); gr->Draw(""AB1"");; }; End_Macro. \anchor GrP2; ### Exclusion graphs. When a graph is painted with the option `C` or `L` it is; possible to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute value of the graph line; width (set by `SetLineWidth()`) is greater than 99. In that; case the line width number is interpreted as:. 100*ff+ll = ffll. - The two digits number `ll` represent the normal line width; - The two digits number `ff` represent the filled area width.; - The sign of ""ffll"" allows to flip the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on to",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:5474,Availability,error,error,5474,");; c47->cd(2); gr->Draw(""AB1"");; }; End_Macro. \anchor GrP2; ### Exclusion graphs. When a graph is painted with the option `C` or `L` it is; possible to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute value of the graph line; width (set by `SetLineWidth()`) is greater than 99. In that; case the line width number is interpreted as:. 100*ff+ll = ffll. - The two digits number `ll` represent the normal line width; - The two digits number `ff` represent the filled area width.; - The sign of ""ffll"" allows to flip the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws add",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:5666,Availability,error,error,5666,"`L` it is; possible to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute value of the graph line; width (set by `SetLineWidth()`) is greater than 99. In that; case the line width number is interpreted as:. 100*ff+ll = ffll. - The two digits number `ll` represent the normal line width; - The two digits number `ff` represent the filled area width.; - The sign of ""ffll"" allows to flip the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:5768,Availability,error,error,5768,"e graph line; width (set by `SetLineWidth()`) is greater than 99. In that; case the line width number is interpreted as:. 100*ff+ll = ffll. - The two digits number `ll` represent the normal line width; - The two digits number `ff` represent the filled area width.; - The sign of ""ffll"" allows to flip the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' d",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:5894,Availability,error,error,5894," 100*ff+ll = ffll. - The two digits number `ll` represent the normal line width; - The two digits number `ff` represent the filled area width.; - The sign of ""ffll"" allows to flip the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles a",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:5985,Availability,error,error,5985,"` represent the filled area width.; - The sign of ""ffll"" allows to flip the filled area from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A s",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6033,Availability,error,errors,6033,"rea from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; |",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6059,Availability,error,errors,6059,"rea from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; |",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6088,Availability,error,errors,6088,"rea from one side of the line to the other. The current fill area attributes are used to draw the hatched zone. Begin_Macro(source); ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; |",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6212,Availability,error,error,6212," ../../../tutorials/graphs/exclusiongraph.C; End_Macro. \anchor GrP3; ### Graphs with error bars; Three classes are available to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when b",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6320,Availability,error,errors,6320,"to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6373,Availability,error,errors,6373,"to handle graphs with error bars:; `TGraphErrors`, `TGraphAsymmErrors` and `TGraphBentErrors`.; The following drawing options are specific to graphs with error bars:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""Z"" | Do not draw small horizontal and vertical lines the end of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6692,Availability,error,error,6692," of the error bars. Without ""Z"", the default is to draw these. |; | "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are s",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6737,Availability,error,error,6737,". The size of the arrow is set to 2/3 of the marker size. |; | \""\|\>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6852,Availability,Error,Error,6852,"d arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1,",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:6953,Availability,error,error,6953," arrow is set to 2/3 of the marker size. |; | ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1,",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7047,Availability,error,error,7047,"aph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7070,Availability,Error,Error,7070,"no errors, and so this option has no effect.) |; | \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; E",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7303,Availability,error,error,7303,"ng to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0}",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7340,Availability,error,error,7340,"f a graph with statistical+systematic errors. |; | ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7435,Availability,error,error,7435,"tion \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7599,Availability,error,error,7599,"same picture. |; | ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; End_Macro. The option ""3"" shows the errors as a band. Begin_Macro(sou",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7615,Availability,error,errors,7615,"the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; End_Macro. The option ""3"" shows the errors as a band. Begin_Macro(source); {; auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7687,Availability,error,errors,7687,"the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; End_Macro. The option ""3"" shows the errors as a band. Begin_Macro(source); {; auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:7738,Availability,error,errors,7738,"the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; | ""2"" | Error rectangles are drawn. |; | ""3"" | A filled area is drawn through the end points of the vertical error bars. |; | ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; End_Macro. The option ""3"" shows the errors as a band. Begin_Macro(source); {; auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:8054,Availability,error,errors,8054,"the vertical error bars. |; | ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; End_Macro. The option ""3"" shows the errors as a band. Begin_Macro(source); {; auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a band"");; ge->SetFillColor(4);; ge->SetFillStyle(3010);; ge->Draw(""a3"");; }; End_Macro. The option ""4"" is similar to the option ""3"" except that the band; is smoothed. As the f",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:8121,Availability,error,error,8121,"e contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |. `gStyle->SetErrorX(dx)` controls the size of the error along x.; `dx = 0` removes the error along x. `gStyle->SetEndErrorSize(np)` controls the size of the lines; at the end of the error bars (when option 1 is used).; By default `np=1`. (np represents the number of pixels). \anchor GrP3a; #### TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; End_Macro. The option ""3"" shows the errors as a band. Begin_Macro(source); {; auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a band"");; ge->SetFillColor(4);; ge->SetFillStyle(3010);; ge->Draw(""a3"");; }; End_Macro. The option ""4"" is similar to the option ""3"" except that the band; is smoothed. As the following picture shows, this option should be; used carefully because the smoothing algorithm m",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:8553,Availability,error,errors,8553," TGraphErrors. A `TGraphErrors` is a `TGraph` with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Begin_Macro(source); {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; End_Macro. The option ""3"" shows the errors as a band. Begin_Macro(source); {; auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a band"");; ge->SetFillColor(4);; ge->SetFillStyle(3010);; ge->Draw(""a3"");; }; End_Macro. The option ""4"" is similar to the option ""3"" except that the band; is smoothed. As the following picture shows, this option should be; used carefully because the smoothing algorithm may show some (huge); ""bouncing"" effects. In some cases it looks nicer than option ""3""; (because it is smooth) but it can be misleading. Begin_Macro(source); {; auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:8848,Availability,Error,Errors,8848," 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; End_Macro. The option ""0"" shows the error bars for data points outside range. Begin_Macro(source); {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; End_Macro. The option ""3"" shows the errors as a band. Begin_Macro(source); {; auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a band"");; ge->SetFillColor(4);; ge->SetFillStyle(3010);; ge->Draw(""a3"");; }; End_Macro. The option ""4"" is similar to the option ""3"" except that the band; is smoothed. As the following picture shows, this option should be; used carefully because the smoothing algorithm may show some (huge); ""bouncing"" effects. In some cases it looks nicer than option ""3""; (because it is smooth) but it can be misleading. Begin_Macro(source); {; auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a smooth band"");; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; }; End_Macro. The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:9542,Availability,Error,Errors,9542,"as a band. Begin_Macro(source); {; auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a band"");; ge->SetFillColor(4);; ge->SetFillStyle(3010);; ge->Draw(""a3"");; }; End_Macro. The option ""4"" is similar to the option ""3"" except that the band; is smoothed. As the following picture shows, this option should be; used carefully because the smoothing algorithm may show some (huge); ""bouncing"" effects. In some cases it looks nicer than option ""3""; (because it is smooth) but it can be misleading. Begin_Macro(source); {; auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a smooth band"");; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; }; End_Macro. The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow de",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:9735,Availability,error,errors,9735,"e ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a band"");; ge->SetFillColor(4);; ge->SetFillStyle(3010);; ge->Draw(""a3"");; }; End_Macro. The option ""4"" is similar to the option ""3"" except that the band; is smoothed. As the following picture shows, this option should be; used carefully because the smoothing algorithm may show some (huge); ""bouncing"" effects. In some cases it looks nicer than option ""3""; (because it is smooth) but it can be misleading. Begin_Macro(source); {; auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a smooth band"");; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; }; End_Macro. The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:9777,Availability,error,errors,9777,"e ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a band"");; ge->SetFillColor(4);; ge->SetFillStyle(3010);; ge->Draw(""a3"");; }; End_Macro. The option ""4"" is similar to the option ""3"" except that the band; is smoothed. As the following picture shows, this option should be; used carefully because the smoothing algorithm may show some (huge); ""bouncing"" effects. In some cases it looks nicer than option ""3""; (because it is smooth) but it can be misleading. Begin_Macro(source); {; auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a smooth band"");; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; }; End_Macro. The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:9997,Availability,error,errors,9997,"cept that the band; is smoothed. As the following picture shows, this option should be; used carefully because the smoothing algorithm may show some (huge); ""bouncing"" effects. In some cases it looks nicer than option ""3""; (because it is smooth) but it can be misleading. Begin_Macro(source); {; auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a smooth band"");; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; }; End_Macro. The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:10187,Availability,error,errors,10187,"s it looks nicer than option ""3""; (because it is smooth) but it can be misleading. Begin_Macro(source); {; auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a smooth band"");; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; }; End_Macro. The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:10416,Availability,error,errors,10416,"le ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""Errors as a smooth band"");; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; }; End_Macro. The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:10574,Availability,error,errors,10574,"ooth band"");; ge->SetFillColor(6);; ge->SetFillStyle(3005);; ge->Draw(""a4"");; }; End_Macro. The following example shows how the option ""[]"" can be used to superimpose; systematic errors on top of a graph with statistical errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5}",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:10743,Availability,error,errors,10743," errors. Begin_Macro(source); {; auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; c43->DrawFrame(0., -0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetTitle(""Not symmetric errors"");; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; }; End_Macro. \anchor G",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:10900,Availability,error,errors,10900,"0.5, 6., 2);. double x[5] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetTitle(""Not symmetric errors"");; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; }; End_Macro. \anchor GrP3c; #### TGraphBentErrors; A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; An extra parameter allow",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:11103,Availability,error,errors,11103,"71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetTitle(""Not symmetric errors"");; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; }; End_Macro. \anchor GrP3c; #### TGraphBentErrors; A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; An extra parameter allows to bend the error bars to better see them; when several graphs are drawn on the same plot. Begin_Macro(source); {; auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:11171,Availability,error,errors,11171,"71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetTitle(""Not symmetric errors"");; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; }; End_Macro. \anchor GrP3c; #### TGraphBentErrors; A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; An extra parameter allows to bend the error bars to better see them; when several graphs are drawn on the same plot. Begin_Macro(source); {; auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:11223,Availability,error,errors,11223,"71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph1_sys = new TGraphErrors(5, x, py1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetTitle(""Not symmetric errors"");; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; }; End_Macro. \anchor GrP3c; #### TGraphBentErrors; A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; An extra parameter allows to bend the error bars to better see them; when several graphs are drawn on the same plot. Begin_Macro(source); {; auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:11659,Availability,error,errors,11659,"(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; auto graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. auto graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetTitle(""Not symmetric errors"");; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; }; End_Macro. \anchor GrP3c; #### TGraphBentErrors; A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; An extra parameter allows to bend the error bars to better see them; when several graphs are drawn on the same plot. Begin_Macro(source); {; auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGra",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:11897,Availability,error,error,11897,"ph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; }; End_Macro. \anchor GrP3b; #### TGraphAsymmErrors; A `TGraphAsymmErrors` is like a `TGraphErrors` but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Begin_Macro(source); {; auto c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; auto gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetTitle(""Not symmetric errors"");; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; }; End_Macro. \anchor GrP3c; #### TGraphBentErrors; A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; An extra parameter allows to bend the error bars to better see them; when several graphs are drawn on the same plot. Begin_Macro(source); {; auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basica",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:12751,Availability,error,errors,12751,"->Draw(""p"");; }; End_Macro. \anchor GrP3c; #### TGraphBentErrors; A `TGraphBentErrors` is like a `TGraphAsymmErrors`.; An extra parameter allows to bend the error bars to better see them; when several graphs are drawn on the same plot. Begin_Macro(source); {; auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; It has the possibility to define more than one type / dimension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmE",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13031,Availability,Error,Errors,13031," auto c45 = new TCanvas(""c45"",""c45"",200,10,600,400);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; It has the possibility to define more than one type / dimension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one o",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13100,Availability,error,errors,13100,"uble_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; It has the possibility to define more than one type / dimension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13180,Availability,error,error,13180,"4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; It has the possibility to define more than one type / dimension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13321,Availability,error,error,13321,"6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; It has the possibility to define more than one type / dimension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use in",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13429,Availability,Error,Errors,13429,"yh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; It has the possibility to define more than one type / dimension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions inste",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13559,Availability,error,error,13559,",.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; It has the possibility to define more than one type / dimension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific on",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13610,Availability,error,errors,13610,",.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro. \anchor GrP3d; #### TGraphMultiErrors; A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; It has the possibility to define more than one type / dimension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific on",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13947,Availability,error,errors,13947,"mension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific ones add the draw option ""S"" to the first block. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14017,Availability,error,errors,14017,"mension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific ones add the draw option ""S"" to the first block. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14079,Availability,Error,Errors,14079,"mension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific ones add the draw option ""S"" to the first block. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14202,Availability,error,errors,14202,"mension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific ones add the draw option ""S"" to the first block. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14252,Availability,Error,Errors,14252,"mension of y-Errors.; This is useful if you want to plot statistic and systematic errors at once. To be able to define different drawing options for the multiple error dimensions; the option string can consist of multiple blocks separated by semicolons.; The painting method assigns these blocks to the error dimensions. The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific ones add the draw option ""S"" to the first block. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14365,Availability,error,error,14365," The first block; is always used for the general draw options and options concerning the x-Errors.; In case there are less than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific ones add the draw option ""S"" to the first block. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, 0.6, 0.4, 0.8};. TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", 5, ax, ay, aexl, aexh, aeylstat, aeyhstat);; gme->AddYError(5, aeylsys, aeyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14486,Availability,error,error,14486,"ss than NErrorDimensions + 1 blocks in the option string; the first block is also used for the first error dimension which is reserved for; statistical errors. The remaining blocks are assigned to the remaining dimensions. In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:. | Option | Block | Description |; |----------|----------------|-------------------------------------------------------------------|; | ""X0"" | First one only | Do not draw errors for points with x = 0 |; | ""Y0"" | First one only | Do not draw errors for points with y = 0 |; | ""s=%f"" | Any | Scales the x-Errors with %f similar to `gStyle->SetErrorX(dx)` but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) |; | ""S"" | First one only | Use individual TAttFill and TAttLine attributes for the different error dimensions instead of the global ones. |. Per default the Fill and Line Styles of the Graph are being used for all error; dimensions. To use the specific ones add the draw option ""S"" to the first block. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double aexh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, 0.6, 0.4, 0.8};. TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", 5, ax, ay, aexl, aexh, aeylstat, aeyhstat);; gme->AddYError(5, aeylsys, aeyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);. gme->Draw(""a p s ; ; 5 s=0.5"");; }; End_Macro. \anchor GrP4; ### TGraphPolar options",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:15770,Availability,error,error,15770,"exh[] = {0.3, 0.3, 0.3, 0.3, 0.3};; double* aeylstat = new double[5] {1, 0.5, 1, 0.5, 1};; double* aeyhstat = new double[5] {0.5, 1, 0.5, 1, 0.5};; double* aeylsys = new double[5] {0.5, 0.4, 0.8, 0.3, 1.2};; double* aeyhsys = new double[5] {0.6, 0.7, 0.6, 0.4, 0.8};. TGraphMultiErrors* gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", 5, ax, ay, aexl, aexh, aeylstat, aeyhstat);; gme->AddYError(5, aeylsys, aeyhsys);; gme->SetMarkerStyle(20);; gme->SetLineColor(kRed);; gme->GetAttLine(0)->SetLineColor(kRed);; gme->GetAttLine(1)->SetLineColor(kBlue);; gme->GetAttFill(1)->SetFillStyle(0);. gme->Draw(""a p s ; ; 5 s=0.5"");; }; End_Macro. \anchor GrP4; ### TGraphPolar options. The drawing options for the polar graphs are the following:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""O"" | Polar labels are drawn orthogonally to the polargram radius. |; | ""P"" | Polymarker are drawn at each point position. |; | ""E"" | Draw error bars. |; | ""F"" | Draw fill area (closed polygon). |; | ""A"" | Force axis redrawing even if a polargram already exists. |; | ""N"" | Disable the display of the polar labels. |. Begin_Macro(source); {; auto c46 = new TCanvas(""c46"",""c46"",500,500);; auto grP1 = new TGraphPolar();; grP1->SetTitle(""TGraphPolar example"");. grP1->SetPoint(0, (1*TMath::Pi())/4., 0.05);; grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(1.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(4);; grP1->Draw(""ALP"");. // Update, otherwise GetPolargram returns 0; c46->Update();; grP1->GetPolargram()->SetToRadian();; }; End_Macro. \anchor GrP5; ### Colors automatically picked in palette. \since **ROOT ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:1665,Deployability,update,updated,1665," GrP6); - [Graphs in logarithmic scale](\ref GrP7); - [Highlight mode for graph](\ref GrP8). \anchor GrP0; ### Introduction. Graphs are drawn via the painter `TGraphPainter` class. This class; implements techniques needed to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |; | ""I"" | Combine with option 'A' it draws invisible axis |; | ""L"" | A simple polyline is drawn |; | ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; | ""C"" | A smooth Curve is drawn |; | ""*"" | A Star is plotted at each point |; | ""P"" | The current marker is plotted at each point |; | ""B"" | A Bar chart is drawn |; | ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. |; | ""X+"" | The X-axis is drawn on the top side o",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:1683,Deployability,update,updated,1683,"r GrP0; ### Introduction. Graphs are drawn via the painter `TGraphPainter` class. This class; implements techniques needed to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |; | ""I"" | Combine with option 'A' it draws invisible axis |; | ""L"" | A simple polyline is drawn |; | ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; | ""C"" | A smooth Curve is drawn |; | ""*"" | A Star is plotted at each point |; | ""P"" | The current marker is plotted at each point |; | ""B"" | A Bar chart is drawn |; | ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. |; | ""X+"" | The X-axis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""PFC"" | Palette Fil",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:1823,Deployability,Update,Update,1823,"ded to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |; | ""I"" | Combine with option 'A' it draws invisible axis |; | ""L"" | A simple polyline is drawn |; | ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; | ""C"" | A smooth Curve is drawn |; | ""*"" | A Star is plotted at each point |; | ""P"" | The current marker is plotted at each point |; | ""B"" | A Bar chart is drawn |; | ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. |; | ""X+"" | The X-axis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""PFC"" | Palette Fill Color: graph's fill color is taken in the current palette. |; | ""PLC"" | Palette Line Color: graph's line color is ta",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:3684,Deployability,Update,Update,3684,"| ""PLC"" | Palette Line Color: graph's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: graph's marker color is taken in the current palette. |; | ""RX"" | Reverse the X axis. |; | ""RY"" | Reverse the Y axis. |. Drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") with markers (option ""P"") and; with axes (option ""A""). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",200,10,600,400);. c1->SetFillColor(42);; c1->SetGrid();. const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; auto gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerSize(1.5);; gr->SetMarkerStyle(21);; gr->SetTitle(""Option ACP example"");; gr->GetXaxis()->SetTitle(""X title"");; gr->GetYaxis()->SetTitle(""Y title"");; gr->Draw(""ACP"");. // TCanvas::Update() draws the frame, after which one can change it; c1->Update();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; c1->Modified();; }; End_Macro. The following macro shows the option ""B"" usage. It can be combined with the; option ""1"". The bar width is equal to:. bar_width = 0.5*delta*gStyle->GetBarWidth();. Where `delta` is equal to the X maximal value minus the X minimal value divided by the; number of points in the graph. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; c47->Divide(1,2);; const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2)-6;; }; auto gr = new TGraph(n,x,y);; gr->SetFillColor(38);; gr->SetTitle("" "");; c47->cd(1); gr->Draw(""AB"");; c47->cd(2); gr->Draw(""AB1"");; }; End_Macro. \anchor GrP2; ### Exclusion graphs. When a graph is painted with the option `C` or `L` it is; possible to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute value of the graph line; w",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:3745,Deployability,Update,Update,3745,"| ""PLC"" | Palette Line Color: graph's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: graph's marker color is taken in the current palette. |; | ""RX"" | Reverse the X axis. |; | ""RY"" | Reverse the Y axis. |. Drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") with markers (option ""P"") and; with axes (option ""A""). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",200,10,600,400);. c1->SetFillColor(42);; c1->SetGrid();. const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; auto gr = new TGraph(n,x,y);; gr->SetLineColor(2);; gr->SetLineWidth(4);; gr->SetMarkerColor(4);; gr->SetMarkerSize(1.5);; gr->SetMarkerStyle(21);; gr->SetTitle(""Option ACP example"");; gr->GetXaxis()->SetTitle(""X title"");; gr->GetYaxis()->SetTitle(""Y title"");; gr->Draw(""ACP"");. // TCanvas::Update() draws the frame, after which one can change it; c1->Update();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; c1->Modified();; }; End_Macro. The following macro shows the option ""B"" usage. It can be combined with the; option ""1"". The bar width is equal to:. bar_width = 0.5*delta*gStyle->GetBarWidth();. Where `delta` is equal to the X maximal value minus the X minimal value divided by the; number of points in the graph. Begin_Macro(source); {; auto c47 = new TCanvas(""c47"",""c47"",200,10,600,400);; c47->Divide(1,2);; const Int_t n = 20;; Double_t x[n], y[n];; for (Int_t i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2)-6;; }; auto gr = new TGraph(n,x,y);; gr->SetFillColor(38);; gr->SetTitle("" "");; c47->cd(1); gr->Draw(""AB"");; c47->cd(2); gr->Draw(""AB1"");; }; End_Macro. \anchor GrP2; ### Exclusion graphs. When a graph is painted with the option `C` or `L` it is; possible to draw a filled area on one side of the line. This is useful to show; exclusion zones. This drawing mode is activated when the absolute value of the graph line; w",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:16585,Deployability,Update,Update,16585,"Polar labels are drawn orthogonally to the polargram radius. |; | ""P"" | Polymarker are drawn at each point position. |; | ""E"" | Draw error bars. |; | ""F"" | Draw fill area (closed polygon). |; | ""A"" | Force axis redrawing even if a polargram already exists. |; | ""N"" | Disable the display of the polar labels. |. Begin_Macro(source); {; auto c46 = new TCanvas(""c46"",""c46"",500,500);; auto grP1 = new TGraphPolar();; grP1->SetTitle(""TGraphPolar example"");. grP1->SetPoint(0, (1*TMath::Pi())/4., 0.05);; grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(1.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(4);; grP1->Draw(""ALP"");. // Update, otherwise GetPolargram returns 0; c46->Update();; grP1->GetPolargram()->SetToRadian();; }; End_Macro. \anchor GrP5; ### Colors automatically picked in palette. \since **ROOT version 6.09/01**. When several graphs are painted in the same canvas or when a multi-graph is drawn,; it might be useful to have an easy and automatic way to choose; their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; When one of these options is given to `TGraph::Draw` the graph get its color; from the current color palette defined by `gStyle->SetPalette(...)`. The color; is determined according to the number of objects having palette coloring in; the current pad. Begin_Macro(source); ../../../tutorials/graphs/graphpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/graphs/multigraphpalettecolor.C; End_Macro. \anchor GrP6; ### Reverse graphs' axis. \since",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:16632,Deployability,Update,Update,16632,"Polar labels are drawn orthogonally to the polargram radius. |; | ""P"" | Polymarker are drawn at each point position. |; | ""E"" | Draw error bars. |; | ""F"" | Draw fill area (closed polygon). |; | ""A"" | Force axis redrawing even if a polargram already exists. |; | ""N"" | Disable the display of the polar labels. |. Begin_Macro(source); {; auto c46 = new TCanvas(""c46"",""c46"",500,500);; auto grP1 = new TGraphPolar();; grP1->SetTitle(""TGraphPolar example"");. grP1->SetPoint(0, (1*TMath::Pi())/4., 0.05);; grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(1.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(4);; grP1->Draw(""ALP"");. // Update, otherwise GetPolargram returns 0; c46->Update();; grP1->GetPolargram()->SetToRadian();; }; End_Macro. \anchor GrP5; ### Colors automatically picked in palette. \since **ROOT version 6.09/01**. When several graphs are painted in the same canvas or when a multi-graph is drawn,; it might be useful to have an easy and automatic way to choose; their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; When one of these options is given to `TGraph::Draw` the graph get its color; from the current color palette defined by `gStyle->SetPalette(...)`. The color; is determined according to the number of objects having palette coloring in; the current pad. Begin_Macro(source); ../../../tutorials/graphs/graphpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/graphs/multigraphpalettecolor.C; End_Macro. \anchor GrP6; ### Reverse graphs' axis. \since",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:621,Testability,log,logarithmic,621,"////////////////////////////////////////////////////////////////////////////////; /*! \class TGraphPainter; \ingroup Histpainter; \brief The graph painter class. Implements all graphs' drawing's options. - [Introduction](\ref GrP0); - [Graphs' plotting options](\ref GrP1); - [Exclusion graphs](\ref GrP2); - [Graphs with error bars](\ref GrP3); - [TGraphErrors](\ref GrP3a); - [TGraphAsymmErrors](\ref GrP3b); - [TGraphBentErrors](\ref GrP3c); - [TGraphMultiErrors](\ref GrP3d); - [TGraphPolar options](\ref GrP4); - [Colors automatically picked in palette](\ref GrP5); - [Reverse graphs' axis](\ref GrP6); - [Graphs in logarithmic scale](\ref GrP7); - [Highlight mode for graph](\ref GrP8). \anchor GrP0; ### Introduction. Graphs are drawn via the painter `TGraphPainter` class. This class; implements techniques needed to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|--------------------------------------",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:18650,Testability,log,logarithmic,18650,"T version 6.09/03**. When a TGraph is drawn, the X-axis is drawn with increasing values from left to; right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; change this order. The option `RX` allows to draw the X-axis with increasing values; from right to left and the `RY` option allows to draw the Y-axis with increasing; values from top to bottom. The following example illustrate how to use these options. Begin_Macro(source); {; auto c = new TCanvas();; c->Divide(2,1);; auto g = new TGraphErrors();; g->SetTitle(""Simple Graph"");. g->SetPoint(0,-4,-3);; g->SetPoint(1,1,1);; g->SetPoint(2,2,1);; g->SetPoint(3,3,4);; g->SetPoint(4,5,5);. g->SetPointError(0,1.,2.);; g->SetPointError(1,2,1);; g->SetPointError(2,2,3);; g->SetPointError(3,3,2);; g->SetPointError(4,4,5);. g->GetXaxis()->SetNdivisions(520);. g->SetMarkerStyle(21);; c->cd(1); gPad->SetGrid(1,1);; g->Draw(""APL"");. c->cd(2); gPad->SetGrid(1,1);; g->Draw(""A RX RY PL"");; }; End_Macro. \anchor GrP7; ### Graphs in logarithmic scale. Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); the points building the graph are converted into logarithmic scale. But **only** the; points not the lines connecting them which stay linear. This can be clearly seen; on the following example:. Begin_Macro(source); {; // A graph with 3 points; Double_t xmin = 750.;; Double_t xmax = 1000;; auto g = new TGraph(3);; g->SetPoint(0,xmin,0.1);; g->SetPoint(1,845,0.06504);; g->SetPoint(2,xmax,0.008);. // The same graph with n points; Int_t n = 10000;; Double_t dx = (xmax-xmin)/n;; Double_t x = xmin;; auto g2 = new TGraph();; for (Int_t i=0; i<n; i++) {; g2->SetPoint(i, x, g->Eval(x));; x = x + dx;; }. auto cv = new TCanvas(""cv"",""cv"",800,600);; cv->SetLogy();; cv->SetGridx();; cv->SetGridy();; g->Draw(""AL*"");. g2->SetMarkerColor(kRed);; g2->SetMarkerStyle(1);; g2->Draw(""P"");; }. End_Macro. \anchor GrP8; #### ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:18709,Testability,log,logarithmic,18709,"rawn with increasing values from left to; right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; change this order. The option `RX` allows to draw the X-axis with increasing values; from right to left and the `RY` option allows to draw the Y-axis with increasing; values from top to bottom. The following example illustrate how to use these options. Begin_Macro(source); {; auto c = new TCanvas();; c->Divide(2,1);; auto g = new TGraphErrors();; g->SetTitle(""Simple Graph"");. g->SetPoint(0,-4,-3);; g->SetPoint(1,1,1);; g->SetPoint(2,2,1);; g->SetPoint(3,3,4);; g->SetPoint(4,5,5);. g->SetPointError(0,1.,2.);; g->SetPointError(1,2,1);; g->SetPointError(2,2,3);; g->SetPointError(3,3,2);; g->SetPointError(4,4,5);. g->GetXaxis()->SetNdivisions(520);. g->SetMarkerStyle(21);; c->cd(1); gPad->SetGrid(1,1);; g->Draw(""APL"");. c->cd(2); gPad->SetGrid(1,1);; g->Draw(""A RX RY PL"");; }; End_Macro. \anchor GrP7; ### Graphs in logarithmic scale. Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); the points building the graph are converted into logarithmic scale. But **only** the; points not the lines connecting them which stay linear. This can be clearly seen; on the following example:. Begin_Macro(source); {; // A graph with 3 points; Double_t xmin = 750.;; Double_t xmax = 1000;; auto g = new TGraph(3);; g->SetPoint(0,xmin,0.1);; g->SetPoint(1,845,0.06504);; g->SetPoint(2,xmax,0.008);. // The same graph with n points; Int_t n = 10000;; Double_t dx = (xmax-xmin)/n;; Double_t x = xmin;; auto g2 = new TGraph();; for (Int_t i=0; i<n; i++) {; g2->SetPoint(i, x, g->Eval(x));; x = x + dx;; }. auto cv = new TCanvas(""cv"",""cv"",800,600);; cv->SetLogy();; cv->SetGridx();; cv->SetGridy();; g->Draw(""AL*"");. g2->SetMarkerColor(kRed);; g2->SetMarkerStyle(1);; g2->Draw(""P"");; }. End_Macro. \anchor GrP8; #### Highlight mode for graph. \since **ROOT version 6.15/01**. \",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:18764,Testability,log,logarithmic,18764,"ow to; change this order. The option `RX` allows to draw the X-axis with increasing values; from right to left and the `RY` option allows to draw the Y-axis with increasing; values from top to bottom. The following example illustrate how to use these options. Begin_Macro(source); {; auto c = new TCanvas();; c->Divide(2,1);; auto g = new TGraphErrors();; g->SetTitle(""Simple Graph"");. g->SetPoint(0,-4,-3);; g->SetPoint(1,1,1);; g->SetPoint(2,2,1);; g->SetPoint(3,3,4);; g->SetPoint(4,5,5);. g->SetPointError(0,1.,2.);; g->SetPointError(1,2,1);; g->SetPointError(2,2,3);; g->SetPointError(3,3,2);; g->SetPointError(4,4,5);. g->GetXaxis()->SetNdivisions(520);. g->SetMarkerStyle(21);; c->cd(1); gPad->SetGrid(1,1);; g->Draw(""APL"");. c->cd(2); gPad->SetGrid(1,1);; g->Draw(""A RX RY PL"");; }; End_Macro. \anchor GrP7; ### Graphs in logarithmic scale. Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); the points building the graph are converted into logarithmic scale. But **only** the; points not the lines connecting them which stay linear. This can be clearly seen; on the following example:. Begin_Macro(source); {; // A graph with 3 points; Double_t xmin = 750.;; Double_t xmax = 1000;; auto g = new TGraph(3);; g->SetPoint(0,xmin,0.1);; g->SetPoint(1,845,0.06504);; g->SetPoint(2,xmax,0.008);. // The same graph with n points; Int_t n = 10000;; Double_t dx = (xmax-xmin)/n;; Double_t x = xmin;; auto g2 = new TGraph();; for (Int_t i=0; i<n; i++) {; g2->SetPoint(i, x, g->Eval(x));; x = x + dx;; }. auto cv = new TCanvas(""cv"",""cv"",800,600);; cv->SetLogy();; cv->SetGridx();; cv->SetGridy();; g->Draw(""AL*"");. g2->SetMarkerColor(kRed);; g2->SetMarkerStyle(1);; g2->Draw(""P"");; }. End_Macro. \anchor GrP8; #### Highlight mode for graph. \since **ROOT version 6.15/01**. \image html hlGraph1.gif ""Highlight mode"". Highlight mode is implemented for `TGraph` (and for `TH1`) class. When; h",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:18881,Testability,log,logarithmic,18881,"ow to; change this order. The option `RX` allows to draw the X-axis with increasing values; from right to left and the `RY` option allows to draw the Y-axis with increasing; values from top to bottom. The following example illustrate how to use these options. Begin_Macro(source); {; auto c = new TCanvas();; c->Divide(2,1);; auto g = new TGraphErrors();; g->SetTitle(""Simple Graph"");. g->SetPoint(0,-4,-3);; g->SetPoint(1,1,1);; g->SetPoint(2,2,1);; g->SetPoint(3,3,4);; g->SetPoint(4,5,5);. g->SetPointError(0,1.,2.);; g->SetPointError(1,2,1);; g->SetPointError(2,2,3);; g->SetPointError(3,3,2);; g->SetPointError(4,4,5);. g->GetXaxis()->SetNdivisions(520);. g->SetMarkerStyle(21);; c->cd(1); gPad->SetGrid(1,1);; g->Draw(""APL"");. c->cd(2); gPad->SetGrid(1,1);; g->Draw(""A RX RY PL"");; }; End_Macro. \anchor GrP7; ### Graphs in logarithmic scale. Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); the points building the graph are converted into logarithmic scale. But **only** the; points not the lines connecting them which stay linear. This can be clearly seen; on the following example:. Begin_Macro(source); {; // A graph with 3 points; Double_t xmin = 750.;; Double_t xmax = 1000;; auto g = new TGraph(3);; g->SetPoint(0,xmin,0.1);; g->SetPoint(1,845,0.06504);; g->SetPoint(2,xmax,0.008);. // The same graph with n points; Int_t n = 10000;; Double_t dx = (xmax-xmin)/n;; Double_t x = xmin;; auto g2 = new TGraph();; for (Int_t i=0; i<n; i++) {; g2->SetPoint(i, x, g->Eval(x));; x = x + dx;; }. auto cv = new TCanvas(""cv"",""cv"",800,600);; cv->SetLogy();; cv->SetGridx();; cv->SetGridy();; g->Draw(""AL*"");. g2->SetMarkerColor(kRed);; g2->SetMarkerStyle(1);; g2->Draw(""P"");; }. End_Macro. \anchor GrP8; #### Highlight mode for graph. \since **ROOT version 6.15/01**. \image html hlGraph1.gif ""Highlight mode"". Highlight mode is implemented for `TGraph` (and for `TH1`) class. When; h",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:1125,Usability,simpl,simple,1125,"painter; \brief The graph painter class. Implements all graphs' drawing's options. - [Introduction](\ref GrP0); - [Graphs' plotting options](\ref GrP1); - [Exclusion graphs](\ref GrP2); - [Graphs with error bars](\ref GrP3); - [TGraphErrors](\ref GrP3a); - [TGraphAsymmErrors](\ref GrP3b); - [TGraphBentErrors](\ref GrP3c); - [TGraphMultiErrors](\ref GrP3d); - [TGraphPolar options](\ref GrP4); - [Colors automatically picked in palette](\ref GrP5); - [Reverse graphs' axis](\ref GrP6); - [Graphs in logarithmic scale](\ref GrP7); - [Highlight mode for graph](\ref GrP8). \anchor GrP0; ### Introduction. Graphs are drawn via the painter `TGraphPainter` class. This class; implements techniques needed to display the various kind of; graphs i.e.: `TGraph`, `TGraphErrors`, `TGraphBentErrors` and `TGraphAsymmErrors`. To draw a graph `graph` it's enough to do:. graph->Draw(""AL"");. The option `AL` in the `Draw()` method means:. 1. The axis should be drawn (option `A`),; 2. The graph should be drawn as a simple line (option `L`). By default a graph is drawn in the current pad in the current coordinate system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |; | ""I"" | Combine with option 'A' ",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:2159,Usability,simpl,simple,2159," system.; To define a suitable coordinate system and draw the axis the option; `A` must be specified. `TGraphPainter` offers many options to paint the various kind of graphs. It is separated from the graph classes so that one can have graphs without the; graphics overhead, for example in a batch program. When a displayed graph is modified, there is no need to call `Draw()` again; the; image will be refreshed the next time the pad will be updated. A pad is updated; after one of these three actions:. 1. a carriage return on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. \anchor GrP1; ### Graphs' plotting options; Graphs can be drawn with the following options:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""A"" | Produce a new plot with Axis around the graph |; | ""I"" | Combine with option 'A' it draws invisible axis |; | ""L"" | A simple polyline is drawn |; | ""F"" | A fill area is drawn ('CF' draw a smoothed fill area) |; | ""C"" | A smooth Curve is drawn |; | ""*"" | A Star is plotted at each point |; | ""P"" | The current marker is plotted at each point |; | ""B"" | A Bar chart is drawn |; | ""1"" | When a graph is drawn as a bar chart, this option makes the bars start from the bottom of the pad. By default they start at 0. |; | ""X+"" | The X-axis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""PFC"" | Palette Fill Color: graph's fill color is taken in the current palette. |; | ""PLC"" | Palette Line Color: graph's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: graph's marker color is taken in the current palette. |; | ""RX"" | Reverse the X axis. |; | ""RY"" | Reverse the Y axis. |. Drawing options can be combined. In the following example the graph; is drawn as a smooth curve (option ""C"") with markers (option ""P"") and; with axes (option ""A""). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",20",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:16951,Usability,simpl,simplest,16951,"= new TCanvas(""c46"",""c46"",500,500);; auto grP1 = new TGraphPolar();; grP1->SetTitle(""TGraphPolar example"");. grP1->SetPoint(0, (1*TMath::Pi())/4., 0.05);; grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);. grP1->SetMarkerStyle(20);; grP1->SetMarkerSize(1.);; grP1->SetMarkerColor(4);; grP1->SetLineColor(4);; grP1->Draw(""ALP"");. // Update, otherwise GetPolargram returns 0; c46->Update();; grP1->GetPolargram()->SetToRadian();; }; End_Macro. \anchor GrP5; ### Colors automatically picked in palette. \since **ROOT version 6.09/01**. When several graphs are painted in the same canvas or when a multi-graph is drawn,; it might be useful to have an easy and automatic way to choose; their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; When one of these options is given to `TGraph::Draw` the graph get its color; from the current color palette defined by `gStyle->SetPalette(...)`. The color; is determined according to the number of objects having palette coloring in; the current pad. Begin_Macro(source); ../../../tutorials/graphs/graphpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/graphs/multigraphpalettecolor.C; End_Macro. \anchor GrP6; ### Reverse graphs' axis. \since **ROOT version 6.09/03**. When a TGraph is drawn, the X-axis is drawn with increasing values from left to; right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; change this order. The option `RX` allows to draw the X-axis with increasing values; from right to left and the `RY` option allows to draw the Y-axis with i",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:18189,Usability,Simpl,Simple,18189,"and `PMC` (Palette Marker Color).; When one of these options is given to `TGraph::Draw` the graph get its color; from the current color palette defined by `gStyle->SetPalette(...)`. The color; is determined according to the number of objects having palette coloring in; the current pad. Begin_Macro(source); ../../../tutorials/graphs/graphpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/graphs/multigraphpalettecolor.C; End_Macro. \anchor GrP6; ### Reverse graphs' axis. \since **ROOT version 6.09/03**. When a TGraph is drawn, the X-axis is drawn with increasing values from left to; right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; change this order. The option `RX` allows to draw the X-axis with increasing values; from right to left and the `RY` option allows to draw the Y-axis with increasing; values from top to bottom. The following example illustrate how to use these options. Begin_Macro(source); {; auto c = new TCanvas();; c->Divide(2,1);; auto g = new TGraphErrors();; g->SetTitle(""Simple Graph"");. g->SetPoint(0,-4,-3);; g->SetPoint(1,1,1);; g->SetPoint(2,2,1);; g->SetPoint(3,3,4);; g->SetPoint(4,5,5);. g->SetPointError(0,1.,2.);; g->SetPointError(1,2,1);; g->SetPointError(2,2,3);; g->SetPointError(3,3,2);; g->SetPointError(4,4,5);. g->GetXaxis()->SetNdivisions(520);. g->SetMarkerStyle(21);; c->cd(1); gPad->SetGrid(1,1);; g->Draw(""APL"");. c->cd(2); gPad->SetGrid(1,1);; g->Draw(""A RX RY PL"");; }; End_Macro. \anchor GrP7; ### Graphs in logarithmic scale. Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); the points building the graph are converted into logarithmic scale. But **only** the; points not the lines connecting them which stay linear. This can be clearly seen; on the following example:. Begin_Macro(source); {; // A graph with 3 points; Double_t xmin = 750.;; Double_t xmax = 1000;; auto g = new TGraph",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:18986,Usability,clear,clearly,18986,"s from top to bottom. The following example illustrate how to use these options. Begin_Macro(source); {; auto c = new TCanvas();; c->Divide(2,1);; auto g = new TGraphErrors();; g->SetTitle(""Simple Graph"");. g->SetPoint(0,-4,-3);; g->SetPoint(1,1,1);; g->SetPoint(2,2,1);; g->SetPoint(3,3,4);; g->SetPoint(4,5,5);. g->SetPointError(0,1.,2.);; g->SetPointError(1,2,1);; g->SetPointError(2,2,3);; g->SetPointError(3,3,2);; g->SetPointError(4,4,5);. g->GetXaxis()->SetNdivisions(520);. g->SetMarkerStyle(21);; c->cd(1); gPad->SetGrid(1,1);; g->Draw(""APL"");. c->cd(2); gPad->SetGrid(1,1);; g->Draw(""A RX RY PL"");; }; End_Macro. \anchor GrP7; ### Graphs in logarithmic scale. Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); the points building the graph are converted into logarithmic scale. But **only** the; points not the lines connecting them which stay linear. This can be clearly seen; on the following example:. Begin_Macro(source); {; // A graph with 3 points; Double_t xmin = 750.;; Double_t xmax = 1000;; auto g = new TGraph(3);; g->SetPoint(0,xmin,0.1);; g->SetPoint(1,845,0.06504);; g->SetPoint(2,xmax,0.008);. // The same graph with n points; Int_t n = 10000;; Double_t dx = (xmax-xmin)/n;; Double_t x = xmin;; auto g2 = new TGraph();; for (Int_t i=0; i<n; i++) {; g2->SetPoint(i, x, g->Eval(x));; x = x + dx;; }. auto cv = new TCanvas(""cv"",""cv"",800,600);; cv->SetLogy();; cv->SetGridx();; cv->SetGridy();; g->Draw(""AL*"");. g2->SetMarkerColor(kRed);; g2->SetMarkerStyle(1);; g2->Draw(""P"");; }. End_Macro. \anchor GrP8; #### Highlight mode for graph. \since **ROOT version 6.15/01**. \image html hlGraph1.gif ""Highlight mode"". Highlight mode is implemented for `TGraph` (and for `TH1`) class. When; highlight mode is on, mouse movement over the point will be represented; graphically. Point will be highlighted as ""point circle"" (presented by; marker object). Moreover, any highli",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:111,Modifiability,variab,variables,111,"////////////////////////////////////////////////////////////////////////////////; /// Compute the logarithm of variables `gxwork` and `gywork`; /// according to the value of Options and put the results; /// in the variables `gxworkl` and `gyworkl`.; ///; /// npoints : Number of points in gxwork and in gywork.; ///; /// - opt = 1 ComputeLogs is called from PaintGrapHist; /// - opt = 0 ComputeLogs is called from PaintGraph",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:214,Modifiability,variab,variables,214,"////////////////////////////////////////////////////////////////////////////////; /// Compute the logarithm of variables `gxwork` and `gywork`; /// according to the value of Options and put the results; /// in the variables `gxworkl` and `gyworkl`.; ///; /// npoints : Number of points in gxwork and in gywork.; ///; /// - opt = 1 ComputeLogs is called from PaintGrapHist; /// - opt = 0 ComputeLogs is called from PaintGraph",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:98,Testability,log,logarithm,98,"////////////////////////////////////////////////////////////////////////////////; /// Compute the logarithm of variables `gxwork` and `gywork`; /// according to the value of Options and put the results; /// in the variables `gxworkl` and `gyworkl`.; ///; /// npoints : Number of points in gxwork and in gywork.; ///; /// - opt = 1 ComputeLogs is called from PaintGrapHist; /// - opt = 0 ComputeLogs is called from PaintGraph",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:340,Deployability,release,released,340,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when a graph is clicked with the locator.; ///; /// If the left mouse button is clicked on one of the line end points, this point; /// follows the cursor until button is released.; ///; /// If the middle mouse button clicked, the line is moved parallel to itself; /// until the button is released.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:458,Deployability,release,released,458,"////////////////////////////////////////////////////////////////////////////////; /// Execute action corresponding to one event.; ///; /// This member function is called when a graph is clicked with the locator.; ///; /// If the left mouse button is clicked on one of the line end points, this point; /// follows the cursor until button is released.; ///; /// If the middle mouse button clicked, the line is moved parallel to itself; /// until the button is released.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:109,Integrability,rout,routines,109,"// Range() could change the size of the pad pixmap and therefore should; // be called before the other paint routines",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:9,Deployability,update,update,9,"//do not update if big zoom and points moved",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:8,Deployability,Update,Update,8,"//gPad->Update();",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:109,Integrability,rout,routines,109,"// Range() could change the size of the pad pixmap and therefore should; // be called before the other paint routines",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:9,Deployability,update,update,9,"//do not update if big zoom and points moved",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:3,Testability,test,testing,3,"// testing specific possibility (after zoom, draw with ""same"", log, etc.)",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:63,Testability,log,log,63,"// testing specific possibility (after zoom, draw with ""same"", log, etc.)",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:972,Usability,simpl,simple,972,"////////////////////////////////////////////////////////////////////////////////; /// This is a service method used by `THistPainter`; /// to paint 1D histograms. It is not used to paint TGraph.; ///; /// Input parameters:; ///; /// - npoints : Number of points in X or in Y.; /// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; /// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; /// - chopt : Option.; ///; /// The aspect of the histogram is done according to the value of the chopt.; ///; /// | Option | Description |; /// |--------|-----------------------------------------------------------------|; /// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must give, N values for Y, one for each channel or 2 values for X (x[0]=XMIN and x[1]=XMAX) |; /// |""L"" | A simple polyline between every points is drawn.|; /// |""H"" | An Histogram with equidistant bins is drawn as a polyline.|; /// |""F"" | An histogram with equidistant bins is drawn as a fill area. Contour is not drawn unless chopt='H' is also selected..|; /// |""N"" | Non equidistant bins (default is equidistant). If N is the number of channels array X and Y must be dimensioned as follow: If option R is not selected (default) then the user must give (N+1) values for X (limits of channels) or N values for Y, one for each channel. Otherwise the user must give (N+1) values for Y (limits of channels). or N values for X, one for each channel |; /// |""F1"" | Idem as 'F' except that fill area base line is the minimum of the pad instead of Y=0.|; /// |""F2"" | Draw a Fill area polyline connecting the center of bins|; /// |""C"" | A smooth Curve is drawn.|; /// |""*"" | A Star is plotted at the center of each bin.|; /// |""P"" | Idem with the current marker.|; /// |""P0"" | Idem with the current marker. Empty bins also drawn.|; /// |""B"" | A",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,Safety,risk,risky,21,"// coverity [Calling risky function]",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,Safety,risk,risky,21,"// coverity [Calling risky function]",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,Safety,risk,risky,21,"// coverity [Calling risky function]",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,Safety,risk,risky,21,"// coverity [Calling risky function]",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,Safety,risk,risky,21,"// coverity [Calling risky function]",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,Safety,risk,risky,21,"// coverity [Calling risky function]",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:15,Testability,log,log,15,"//y already in log scale",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:15,Testability,log,log,15,"//transform to log ?",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:29,Usability,simpl,simple,29,"// Draw the histogram with a simple line",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:29,Usability,simpl,simple,29,"// Draw the histogram with a simple marker",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:48,Testability,log,log,48,"// special flags in case of ""reverse plot"" and ""log scale""",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:28,Availability,error,error,28,"// Define the offset of the error bars due to the symbol size",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:29,Availability,error,error,29,"// special flags to turn off error bar drawing in case the marker cover it",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:12,Availability,error,error,12,"// draw the error rectangles",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:28,Availability,error,error,28,"// Define the offset of the error bars due to the symbol size",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:12,Availability,error,error,12,"// draw the error rectangles",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:48,Testability,log,log,48,"// special flags in case of ""reverse plot"" and ""log scale""",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:28,Availability,error,error,28,"// define the offset of the error bars due to the symbol size",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:29,Availability,error,error,29,"// special flags to turn off error bar drawing in case the marker cover it",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:12,Availability,error,error,12,"// draw the error rectangles",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:48,Testability,log,log,48,"// special flags in case of ""reverse plot"" and ""log scale""",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:28,Availability,error,error,28,"// define the offset of the error bars due to the symbol size",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:29,Availability,error,error,29,"// special flags to turn off error bar drawing in case the marker cover it",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:12,Availability,error,error,12,"// draw the error rectangles",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:13,Availability,error,errors,13,"// Check for errors if available",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:23,Availability,avail,available,23,"// Check for errors if available",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:12,Availability,error,error,12,"// Draw the error bars.; // Y errors are lines, but X errors are pieces of circles.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:30,Availability,error,errors,30,"// Draw the error bars.; // Y errors are lines, but X errors are pieces of circles.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:54,Availability,error,errors,54,"// Draw the error bars.; // Y errors are lines, but X errors are pieces of circles.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:24,Availability,error,errors,24,"// Reverse X asymmetric errors",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:24,Availability,error,errors,24,"// Reverse Y asymmetric errors",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:116,Availability,error,errors,116,"////////////////////////////////////////////////////////////////////////////////; /// Paint a simple graph, without errors bars.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:94,Usability,simpl,simple,94,"////////////////////////////////////////////////////////////////////////////////; /// Paint a simple graph, without errors bars.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,Safety,avoid,avoid,21,"// add an epsilon to avoid exact vertical lines.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:351,Deployability,continuous,continuous,351,"////////////////////////////////////////////////////////////////////////////////; /// Smooth a curve given by N points.; ///; /// The original code is from an underlaying routine for Draw based on the; /// CERN GD3 routine TVIPTE:; ///; /// Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ///; /// This method draws a smooth tangentially continuous curve through; /// the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; /// The curve is approximated by a polygonal arc of short vectors.; /// The data points can represent open curves, P(1) != P(N) or closed; /// curves P(2) == P(N). If a tangential discontinuity at P(I) is; /// required, then set P(I)=P(I+1). Loops are also allowed.; ///; /// Reference Marlow and Powell, Harwell report No.R.7092.1972; /// MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; ///; /// - npoints : Number of data points.; /// - x : Abscissa; /// - y : Ordinate",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:171,Integrability,rout,routine,171,"////////////////////////////////////////////////////////////////////////////////; /// Smooth a curve given by N points.; ///; /// The original code is from an underlaying routine for Draw based on the; /// CERN GD3 routine TVIPTE:; ///; /// Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ///; /// This method draws a smooth tangentially continuous curve through; /// the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; /// The curve is approximated by a polygonal arc of short vectors.; /// The data points can represent open curves, P(1) != P(N) or closed; /// curves P(2) == P(N). If a tangential discontinuity at P(I) is; /// required, then set P(I)=P(I+1). Loops are also allowed.; ///; /// Reference Marlow and Powell, Harwell report No.R.7092.1972; /// MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; ///; /// - npoints : Number of data points.; /// - x : Abscissa; /// - y : Ordinate",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:215,Integrability,rout,routine,215,"////////////////////////////////////////////////////////////////////////////////; /// Smooth a curve given by N points.; ///; /// The original code is from an underlaying routine for Draw based on the; /// CERN GD3 routine TVIPTE:; ///; /// Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ///; /// This method draws a smooth tangentially continuous curve through; /// the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)).; /// The curve is approximated by a polygonal arc of short vectors.; /// The data points can represent open curves, P(1) != P(N) or closed; /// curves P(2) == P(N). If a tangential discontinuity at P(I) is; /// required, then set P(I)=P(I+1). Loops are also allowed.; ///; /// Reference Marlow and Powell, Harwell report No.R.7092.1972; /// MCCONALOGUE, Computer Journal VOL.13, NO4, NOV1970P p392 6; ///; /// - npoints : Number of data points.; /// - x : Abscissa; /// - y : Ordinate",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:88,Integrability,rout,routine,88,"// delta is the accuracy required in constructing the curve.; // If it is zero then the routine calculates a value otherwise; // it uses this value. (default is 0.0)",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:181,Deployability,continuous,continuous,181,"// Convert coordinates back to original system; // Separate the set of data points into arcs P(k-1),P(k).; // Calculate the direction cosines. first consider whether; // there is a continuous tangent at the endpoints.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14,Usability,clear,clear,14,"// Prepare to clear out remaining short vectors before returning",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:14,Usability,clear,clear,14,"// Prepare to clear out remaining short vectors before returning",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:3,Testability,Test,Test,3,"// Test whether P(k) is a cusp.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:3,Testability,Test,Test,3,"// Test D(tj,THETA). A is set to (Y(tj+s)-Y(tj))/s.b is; // set to (X(tj+s)-X(tj))/s.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:3,Deployability,Update,Update,3,"// Update tj,xt and yt.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:471,Safety,avoid,avoid,471,"////////////////////////////////////////////////////////////////////////////////; /// Static function to set `fgMaxPointsPerLine` for graph painting. When graphs; /// are painted with lines, they are split into chunks of length `fgMaxPointsPerLine`.; /// This allows to paint line with an ""infinite"" number of points. In some case; /// this ""chunks painting"" technic may create artefacts at the chunk's boundaries.; /// For instance when zooming deeply in a PDF file. To avoid this effect it might; /// be necessary to increase the chunks' size using this function:; /// `TGraphPainter::SetMaxPointsPerLine(20000)`.",MatchSource.CODE_COMMENT,hist/histpainter/src/TGraphPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:975,Availability,error,error,975," - [Introduction](\ref HP00); - [Histograms' plotting options](\ref HP01); - [Options supported for 1D and 2D histograms](\ref HP01a); - [Options supported for 1D histograms](\ref HP01b); - [Options supported for 2D histograms](\ref HP01c); - [Options supported for 3D histograms](\ref HP01d); - [Options supported for histograms' stacks (THStack)](\ref HP01e); - [Setting the Style](\ref HP02); - [Setting line, fill, marker, and text attributes](\ref HP03); - [Setting Tick marks on the histogram axis](\ref HP04); - [Giving titles to the X, Y and Z axis](\ref HP05); - [The option ""SAME""](\ref HP060); - [Limitations](\ref HP060a); - [Colors automatically picked in palette](\ref HP061); - [Superimposing two histograms with different scales in the same pad](\ref HP06); - [Statistics Display](\ref HP07); - [Fit Statistics](\ref HP08); - [The error bars options](\ref HP09); - [The bar chart option](\ref HP100); - [The ""BAR"" and ""HBAR"" options](\ref HP10); - [The SCATter plot option (legacy draw option)](\ref HP11); - [The ARRow option](\ref HP12); - [The BOX option](\ref HP13); - [The COLor option (default for 2D and 3D histograms)](\ref HP14); - [The CANDLE and VIOLIN options](\ref HP140); - [The CANDLE option](\ref HP140a); - [The VIOLIN option](\ref HP140b); - [The TEXT and TEXTnn Option](\ref HP15); - [The CONTour options](\ref HP16); - [The LIST option](\ref HP16a); - [The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options](\ref HP16b); - [The LEGO options](\ref HP17); - [The ""SURFace"" options](\ref HP18); - [Cylindrical, Polar, Spherical and PseudoRapidity/Phi options](\ref HP19); - [Base line for bar-charts and lego plots](\ref HP20); - [TH2Poly Drawing](\ref HP20a); - [The SPEC option](\ref HP21); - [Option ""Z"" : Adding the color palette on the right side of the pad](\ref HP22); - [Setting the color palette](\ref HP23); - [Drawing a sub-rang",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:5645,Availability,error,error,5645,"ogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". \anchor HP01a; #### Options supported for 1D and 2D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Draw error bars. |; | ""AXIS"" | Draw only axis. |; | ""AXIG"" | Draw only grid (if the grid is requested). |; | \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; | ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; | ""SAME"" | Superimpose on previous picture in the same pad. |; | ""SAMES"" | Same as ""SAME"" and draw the statistics box|; | ""PFC"" | Palette Fill Color: histogram",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:5769,Availability,error,error,5769,"ogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". \anchor HP01a; #### Options supported for 1D and 2D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Draw error bars. |; | ""AXIS"" | Draw only axis. |; | ""AXIG"" | Draw only grid (if the grid is requested). |; | \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; | ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; | ""SAME"" | Superimpose on previous picture in the same pad. |; | ""SAMES"" | Same as ""SAME"" and draw the statistics box|; | ""PFC"" | Palette Fill Color: histogram",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6071,Availability,error,error,6071,"om the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". \anchor HP01a; #### Options supported for 1D and 2D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Draw error bars. |; | ""AXIS"" | Draw only axis. |; | ""AXIG"" | Draw only grid (if the grid is requested). |; | \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; | ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; | ""SAME"" | Superimpose on previous picture in the same pad. |; | ""SAMES"" | Same as ""SAME"" and draw the statistics box|; | ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; | ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; | ""LEGO"" | Draw a lego plot with hidden ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6222,Availability,error,errors,6222,"nchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". \anchor HP01a; #### Options supported for 1D and 2D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Draw error bars. |; | ""AXIS"" | Draw only axis. |; | ""AXIG"" | Draw only grid (if the grid is requested). |; | \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; | ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; | ""SAME"" | Superimpose on previous picture in the same pad. |; | ""SAMES"" | Same as ""SAME"" and draw the statistics box|; | ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; | ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; | ""LEGO"" | Draw a lego plot with hidden line removal. |; | ""LEGO1"" | Draw a lego plot with hidden surface removal. |; | ""LEGO2"" | Draw a lego plot using colors to show the cell contents When the option ""0"" is used with any LEGO option, the empty",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6262,Availability,error,error,6262,"nchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". \anchor HP01a; #### Options supported for 1D and 2D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Draw error bars. |; | ""AXIS"" | Draw only axis. |; | ""AXIG"" | Draw only grid (if the grid is requested). |; | \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; | ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; | ""SAME"" | Superimpose on previous picture in the same pad. |; | ""SAMES"" | Same as ""SAME"" and draw the statistics box|; | ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; | ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; | ""LEGO"" | Draw a lego plot with hidden line removal. |; | ""LEGO1"" | Draw a lego plot with hidden surface removal. |; | ""LEGO2"" | Draw a lego plot using colors to show the cell contents When the option ""0"" is used with any LEGO option, the empty",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6298,Availability,error,errors,6298,"commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". \anchor HP01a; #### Options supported for 1D and 2D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Draw error bars. |; | ""AXIS"" | Draw only axis. |; | ""AXIG"" | Draw only grid (if the grid is requested). |; | \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; | ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; | ""SAME"" | Superimpose on previous picture in the same pad. |; | ""SAMES"" | Same as ""SAME"" and draw the statistics box|; | ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; | ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; | ""LEGO"" | Draw a lego plot with hidden line removal. |; | ""LEGO1"" | Draw a lego plot with hidden surface removal. |; | ""LEGO2"" | Draw a lego plot using colors to show the cell contents When the option ""0"" is used with any LEGO option, the empty bins are not drawn.|; | ""LEGO3"" | Draw a lego plot with hidden surface removal, like LEGO1 but the border",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:8545,Availability,error,error,8545,"Style->SetPaintTextFormat`).|; | ""TEXTnn"" | Draw bin contents as text at angle nn (0 < nn <= 90). |; | ""X+"" | The X-axis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |. \anchor HP01b; #### Options supported for 1D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default. |; | ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; | ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; | ""B"" | Bar chart option.|; | ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; | ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; | ""C"" | Draw a smooth Curve through the histogram bins.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E1"" | Draw error bars with perpendicular lines at the edges.|; | ""E2"" | Draw error bars with rectangles.|; | ""E3"" | Draw a fill area through the end points of the vertical error bars.|; | ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; | ""L"" | Draw a line through the bin contents.|; | ""P"" | Draw current marker at each bin except empty bins.|; | ""P*"" | Draw a star marker at each bin except empty bins.|; | ""P0"" | Draw current marker at each bin including empty bins.|; | ""PIE"" | Draw histogram as a Pie Chart.|; | ""*H"" | Draw histogram with a * at each bin.|; | ""LF2"" | Draw histogram like with option ""L"" but with a fi",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:8634,Availability,error,error,8634,"xis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |. \anchor HP01b; #### Options supported for 1D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default. |; | ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; | ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; | ""B"" | Bar chart option.|; | ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; | ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; | ""C"" | Draw a smooth Curve through the histogram bins.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E1"" | Draw error bars with perpendicular lines at the edges.|; | ""E2"" | Draw error bars with rectangles.|; | ""E3"" | Draw a fill area through the end points of the vertical error bars.|; | ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; | ""L"" | Draw a line through the bin contents.|; | ""P"" | Draw current marker at each bin except empty bins.|; | ""P*"" | Draw a star marker at each bin except empty bins.|; | ""P0"" | Draw current marker at each bin including empty bins.|; | ""PIE"" | Draw histogram as a Pie Chart.|; | ""*H"" | Draw histogram with a * at each bin.|; | ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histo",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:8670,Availability,error,error,8670,"xis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |. \anchor HP01b; #### Options supported for 1D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default. |; | ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; | ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; | ""B"" | Bar chart option.|; | ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; | ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; | ""C"" | Draw a smooth Curve through the histogram bins.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E1"" | Draw error bars with perpendicular lines at the edges.|; | ""E2"" | Draw error bars with rectangles.|; | ""E3"" | Draw a fill area through the end points of the vertical error bars.|; | ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; | ""L"" | Draw a line through the bin contents.|; | ""P"" | Draw current marker at each bin except empty bins.|; | ""P*"" | Draw a star marker at each bin except empty bins.|; | ""P0"" | Draw current marker at each bin including empty bins.|; | ""PIE"" | Draw histogram as a Pie Chart.|; | ""*H"" | Draw histogram with a * at each bin.|; | ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histo",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:8736,Availability,error,error,8736,"ight side of the plot. |; | ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |. \anchor HP01b; #### Options supported for 1D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default. |; | ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; | ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; | ""B"" | Bar chart option.|; | ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; | ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; | ""C"" | Draw a smooth Curve through the histogram bins.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E1"" | Draw error bars with perpendicular lines at the edges.|; | ""E2"" | Draw error bars with rectangles.|; | ""E3"" | Draw a fill area through the end points of the vertical error bars.|; | ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; | ""L"" | Draw a line through the bin contents.|; | ""P"" | Draw current marker at each bin except empty bins.|; | ""P*"" | Draw a star marker at each bin except empty bins.|; | ""P0"" | Draw current marker at each bin including empty bins.|; | ""PIE"" | Draw histogram as a Pie Chart.|; | ""*H"" | Draw histogram with a * at each bin.|; | ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour.|. \anchor HP01c; #### Options supported for 2D histograms. | Option",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:8831,Availability,error,error,8831,"e Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |. \anchor HP01b; #### Options supported for 1D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default. |; | ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; | ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; | ""B"" | Bar chart option.|; | ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; | ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; | ""C"" | Draw a smooth Curve through the histogram bins.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E1"" | Draw error bars with perpendicular lines at the edges.|; | ""E2"" | Draw error bars with rectangles.|; | ""E3"" | Draw a fill area through the end points of the vertical error bars.|; | ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; | ""L"" | Draw a line through the bin contents.|; | ""P"" | Draw current marker at each bin except empty bins.|; | ""P*"" | Draw a star marker at each bin except empty bins.|; | ""P0"" | Draw current marker at each bin including empty bins.|; | ""PIE"" | Draw histogram as a Pie Chart.|; | ""*H"" | Draw histogram with a * at each bin.|; | ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour.|. \anchor HP01c; #### Options supported for 2D histograms. | Option | Description |; |--------------|----------------------------",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:8912,Availability,error,error,8912,"# Options supported for 1D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default. |; | ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; | ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; | ""B"" | Bar chart option.|; | ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; | ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; | ""C"" | Draw a smooth Curve through the histogram bins.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E1"" | Draw error bars with perpendicular lines at the edges.|; | ""E2"" | Draw error bars with rectangles.|; | ""E3"" | Draw a fill area through the end points of the vertical error bars.|; | ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; | ""L"" | Draw a line through the bin contents.|; | ""P"" | Draw current marker at each bin except empty bins.|; | ""P*"" | Draw a star marker at each bin except empty bins.|; | ""P0"" | Draw current marker at each bin including empty bins.|; | ""PIE"" | Draw histogram as a Pie Chart.|; | ""*H"" | Draw histogram with a * at each bin.|; | ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour.|. \anchor HP01c; #### Options supported for 2D histograms. | Option | Description |; |--------------|------------------------------------------------------------------|; | "" "" | Default (color plot).|; | ""ARR""",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:9101,Availability,error,error,9101," be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; | ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; | ""B"" | Bar chart option.|; | ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; | ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; | ""C"" | Draw a smooth Curve through the histogram bins.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E1"" | Draw error bars with perpendicular lines at the edges.|; | ""E2"" | Draw error bars with rectangles.|; | ""E3"" | Draw a fill area through the end points of the vertical error bars.|; | ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; | ""L"" | Draw a line through the bin contents.|; | ""P"" | Draw current marker at each bin except empty bins.|; | ""P*"" | Draw a star marker at each bin except empty bins.|; | ""P0"" | Draw current marker at each bin including empty bins.|; | ""PIE"" | Draw histogram as a Pie Chart.|; | ""*H"" | Draw histogram with a * at each bin.|; | ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour.|. \anchor HP01c; #### Options supported for 2D histograms. | Option | Description |; |--------------|------------------------------------------------------------------|; | "" "" | Default (color plot).|; | ""ARR"" | Arrow mode. Shows gradient between adjacent cells.|; | ""BOX"" | A box is drawn for each cell with surface proportional to the content's absolute value. A negative content is marked with a X. |; | ""BOX1"" | A but",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:18008,Availability,avail,available,18008,"e drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (`tx = ty = 0`). `TPad::SetTicks(tx,ty)` allows to set these options.; See also The `TAxis` functions to set specific axis attributes. In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. \anchor HP05; ### Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any `TLatex` string.; The titles are part of the persistent histogram. \anchor HP060; ### The option ""SAME"". By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option `SAME` should be use. The histogram drawn with the option; `SAME` uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care. \anchor HP060a; #### Limitations. - It does not work when combined with the `LEGO` and `SURF` options unless the; histogram plotted with the option `SAME` has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots [histograms' stacks](\ref HP26) should be used. \anchor HP061; ### Colors automatically picked in palette. \since **ROOT version 6.09/01**. When several histograms are painted in the same canvas thanks to the option ""SAME""; or via a `THStack` it might be useful to have an easy and automatic way to choose; their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; When one of ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:21149,Availability,error,error,21149," h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; float rightmax = 1.1*hint1->GetMaximum();; float scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; }; End_Macro. \anchor HP07; ### Statistics Display. The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The `mode` has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; standard deviation printed; r = 2; standard deviation and standard deviation error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and standard deviation. <b>WARNING 1:</b> never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because `0001111` will be taken as an octal number!. <b>WARNING 2:</b> for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. <b>NOTE</b> that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all comb",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:21218,Availability,error,error,21218," h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; float rightmax = 1.1*hint1->GetMaximum();; float scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; }; End_Macro. \anchor HP07; ### Statistics Display. The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The `mode` has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; standard deviation printed; r = 2; standard deviation and standard deviation error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and standard deviation. <b>WARNING 1:</b> never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because `0001111` will be taken as an octal number!. <b>WARNING 2:</b> for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. <b>NOTE</b> that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all comb",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:21476,Availability,error,error,21476," h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; float rightmax = 1.1*hint1->GetMaximum();; float scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; }; End_Macro. \anchor HP07; ### Statistics Display. The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The `mode` has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; standard deviation printed; r = 2; standard deviation and standard deviation error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and standard deviation. <b>WARNING 1:</b> never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because `0001111` will be taken as an octal number!. <b>WARNING 2:</b> for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. <b>NOTE</b> that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all comb",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:21539,Availability,error,error,21539," h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; float rightmax = 1.1*hint1->GetMaximum();; float scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; }; End_Macro. \anchor HP07; ### Statistics Display. The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The `mode` has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; standard deviation printed; r = 2; standard deviation and standard deviation error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and standard deviation. <b>WARNING 1:</b> never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because `0001111` will be taken as an octal number!. <b>WARNING 2:</b> for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. <b>NOTE</b> that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all comb",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:22531,Availability,error,error,22531,"es, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and standard deviation. <b>WARNING 1:</b> never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because `0001111` will be taken as an octal number!. <b>WARNING 2:</b> for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. <b>NOTE</b> that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number. The parameter mode can be any combination of the letters `kKsSiIourRmMen`. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : standard deviation printed; R : standard deviation and standard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:22594,Availability,error,error,22594,"es, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and standard deviation. <b>WARNING 1:</b> never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because `0001111` will be taken as an octal number!. <b>WARNING 2:</b> for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. <b>NOTE</b> that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number. The parameter mode can be any combination of the letters `kKsSiIourRmMen`. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : standard deviation printed; R : standard deviation and standard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:22834,Availability,error,error,22834,"es, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and standard deviation. <b>WARNING 1:</b> never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because `0001111` will be taken as an octal number!. <b>WARNING 2:</b> for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. <b>NOTE</b> that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number. The parameter mode can be any combination of the letters `kKsSiIourRmMen`. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : standard deviation printed; R : standard deviation and standard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:22893,Availability,error,error,22893,"es, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and standard deviation. <b>WARNING 1:</b> never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because `0001111` will be taken as an octal number!. <b>WARNING 2:</b> for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. <b>NOTE</b> that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number. The parameter mode can be any combination of the letters `kKsSiIourRmMen`. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : standard deviation printed; R : standard deviation and standard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:25351,Availability,error,errors,25351,"h` being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; `TPaveStats` one should do:. st->SetOptStat(mode);. Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; (see above). One can delete the statistics box for a histogram `TH1* h` with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; `$ROOTSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`). \anchor HP08; ### Fit Statistics. The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; `= pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars cli",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:25507,Availability,error,errors,25507,"sition; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; `TPaveStats` one should do:. st->SetOptStat(mode);. Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; (see above). One can delete the statistics box for a histogram `TH1* h` with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; `$ROOTSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`). \anchor HP08; ### Fit Statistics. The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; `= pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with on",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:25753,Availability,error,error,25753,"ove). One can delete the statistics box for a histogram `TH1* h` with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; `$ROOTSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`). \anchor HP08; ### Fit Statistics. The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; `= pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<1000",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:25913,Availability,error,error,25913," (""Mean"", ""Std Dev"", ...) can be changed from; `$ROOTSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`). \anchor HP08; ### Fit Statistics. The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; `= pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" an",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:25990,Availability,error,error,25990,"TSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`). \anchor HP08; ### Fit Statistics. The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; `= pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26013,Availability,Error,Error,26013,"string `Hist.Stats.`). \anchor HP08; ### Fit Statistics. The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; `= pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26114,Availability,error,error,26114,"ype of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; `= pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some art",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26208,Availability,error,error,26208,"lected via the parameter mode. The parameter mode can be; `= pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26236,Availability,error,error,26236,"pcev` (default `= 0111`). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; a",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26325,Availability,error,error,26325,"print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn wit",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26522,Availability,error,error,26522,"1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Dr",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26694,Availability,error,error,26694,"tyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; auto he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; }; End_Macro. 2D histograms can be drawn with error bars as shown is the follow",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26933,Availability,error,error,26933,""" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; auto he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; }; End_Macro. 2D histograms can be drawn with error bars as shown is the following example:. Begin_Macro(source); {; auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26984,Availability,error,error,26984,""" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; auto he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; }; End_Macro. 2D histograms can be drawn with error bars as shown is the following example:. Begin_Macro(source); {; auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:27010,Availability,error,error,27010,"rror rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; auto he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; }; End_Macro. 2D histograms can be drawn with error bars as shown is the following example:. Begin_Macro(source); {; auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; }; End_Macro. \anchor HP100; ##",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:27675,Availability,error,error,27675,"n drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; auto he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; }; End_Macro. 2D histograms can be drawn with error bars as shown is the following example:. Begin_Macro(source); {; auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; }; End_Macro. \anchor HP100; ### The bar chart option. The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with `TH1::SetBarWidth()`,; and the bar offset within the bin, with `TH1::SetBarOffset()`.; These two settings are useful to draw several histograms on the; same plot as shown in the following example:. Begin_Macro(source); {; int i;; const Int_t nx = 8;; string os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; float d_35_1[nx] = {1.01, -3.02, -0.65, 0.37, 0.34, -1.42, -1.02, -2.10};. auto cb = new TCanvas(""cb"",""cb"",600,400);; cb->SetGrid();. gStyle->SetHistMin",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:29997,Availability,error,errors,29997," h2b = new TH1F(""h2b"",""h2b"",nx,0,nx);; h2b->SetFillColor(38);; h2b->SetBarWidth(0.4);; h2b->SetBarOffset(0.5);; h2b->SetStats(0);; for (i=1;i<=nx;i++) h2b->SetBinContent(i, d_35_1[i-1]);. h2b->Draw(""b same"");; }; End_Macro. \anchor HP10; ### The ""BAR"" and ""HBAR"" options. When the option `bar` or `hbar` is specified, a bar chart is drawn. A vertical; bar-chart is drawn with the options `bar`, `bar0`, `bar1`, `bar2`, `bar3`, `bar4`.; An horizontal bar-chart is drawn with the options `hbar`, `hbar0`, `hbar1`,; `hbar2`, `hbar3`, `hbar4` (hbars.C). - The bar is filled with the histogram fill color.; - The left side of the bar is drawn with a light fill color.; - The right side of the bar is drawn with a dark fill color.; - The percentage of the bar drawn with either the light or dark color is:; - 0% for option ""(h)bar"" or ""(h)bar0""; - 10% for option ""(h)bar1""; - 20% for option ""(h)bar2""; - 30% for option ""(h)bar3""; - 40% for option ""(h)bar4"". When an histogram has errors the option [""HIST""](\ref OPTHIST) together with the `(h)bar` option. Begin_Macro(source); ../../../tutorials/hist/hbars.C; End_Macro. To control the bar width (default is the bin width) `TH1::SetBarWidth()`; should be used. To control the bar offset (default is 0) `TH1::SetBarOffset()` should; be used. These two parameters are useful when several histograms are plotted using; the option `SAME`. They allow to plot the histograms next to each other. \anchor HP11; ### The SCATter plot option (legacy draw option). \attention; Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 3D histograms. The new default option is `COL` (heat-map). For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; `kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; If option is of the form `scat=ff`, (eg `scat=1.8`,; `scat=1e-3`), then `ff` is used as a scale factor to compute the; number of ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:40932,Availability,avail,available,40932,"""Example of col plots with option SAME"",200,10,700,500);; auto h1 = new TH2F(""h1"",""h1"",40,-3,3,40,-3,3);; auto h2 = new TH2F(""h2"",""h2"",40,-3,3,40,-3,3);; auto h3 = new TH2F(""h3"",""h3"",40,-3,3,40,-3,3);; auto h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; End_Macro. The option `COL` can be combined with the option `POL`:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the C",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:43577,Availability,error,errors,43577," will initiate the drawing of; the corresponding plots. Followed by the keyword the user can select a plot direction (X or V for; vertical projections, or Y or H for horizontal projections) and/or predefined definitions; (1-6 for candles, 1-2 for violins). The order doesn't matter. Default is X and 1. Instead of using the predefined representations, the candle and violin parameters can be; changed individually. In that case the option have the following form:. CANDLEX(<option-string>); CANDLEY(<option-string>); VIOLINX(<option-string>); VIOLINY(<option-string>). All zeros at the beginning of `option-string` can be omitted. `option-string` consists eight values, defined as follow:. ""CANDLEX(zhpawMmb)"". Where:. - `b = 0`; no box drawn; - `b = 1`; the box is drawn. As the candle-plot is also called a box-plot it; makes sense in the very most cases to always draw the box; - `b = 2`; draw a filled box with border. - `m = 0`; no median drawn; - `m = 1`; median is drawn as a line; - `m = 2`; median is drawn with errors (notches); - `m = 3`; median is drawn as a circle. - `M = 0`; no mean drawn; - `M = 1`; mean is drawn as a dashed line; - `M = 3`; mean is drawn as a circle. - `w = 0`; no whisker drawn; - `w = 1`; whisker is drawn to end of distribution.; - `w = 2`; whisker is drawn to max 1.5*iqr. - `a = 0`; no anchor drawn; - `a = 1`; the anchors are drawn. - `p = 0`; no points drawn; - `p = 1`; only outliers are drawn; - `p = 2`; all datapoints are drawn; - `p = 3`: all datapoints are drawn scattered. - `h = 0`; no histogram is drawn; - `h = 1`; histogram at the left or bottom side is drawn; - `h = 2`; histogram at the right or top side is drawn; - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn. - `z = 0`; no zero indicator line is drawn; - `z = 1`; zero indicator line is drawn. As one can see all individual options for both candle and violin plots can be accessed by this; mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:46641,Availability,avail,available,46641,"ted as one candle. Begin_Macro(source); ../../../tutorials/hist/candleplotwhiskers.C; End_Macro. The candle reduces the information coming from a whole distribution into few values.; Independently from the number of entries or the significance of the underlying distribution; a candle will always look like a candle. So candle plots should be used carefully in; particular with unknown distributions. The definition of a candle is based on; __unbinned data__. Here, candles are created from binned data. Because of this, the; deviation is connected to the bin width used. The calculation of the quantiles; normally done on unbinned data also. Because data are binned, this will; only work the best possible way within the resolution of one bin. Because of all these facts one should take care that:. - there are enough points per candle; - the bin width is small enough (more bins will increase the maximum; available resolution of the quantiles although there will be some; bins with no entries); - never make a candle-plot if the underlying distribution is double-distributed; - only create candles of distributions that are more-or-less gaussian (the; MPV should be not too far away from the mean). #### What a candle is made of. \since **ROOT version 6.07/05**. ##### The box; The box displays the position of the inter-quantile-range of the underlying; distribution. The box contains 25% of the distribution below the median; and 25% of the distribution above the median. If the underlying distribution is large; enough and gaussian shaped the end-points of the box represent \f$ 0.6745\times\sigma \f$; (Where \f$ \sigma \f$ is the standard deviation of the gaussian). The width and; the position of the box can be modified by SetBarWidth() and SetBarOffset().; The +-25% quantiles are calculated by the GetQuantiles() methods. \since **ROOT version 6.11/01**. Using the static function TCandle::SetBoxRange(double) the box definition will be; overwritten. E.g. using a box range of 0.68 will r",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:51134,Availability,avail,available,51134,"ented as the size of the notch; (where iqr is the size of the box and N is the number of entries of the whole; distribution). Candle plots like these are usually called ""notched candle plots"". In case the significance of the median is greater that the size of the box, the; box will have an unnatural shape. Usually it means the chart has not enough data,; or that representing this uncertainty is not useful. ##### The Mean; The mean can be drawn as a dashed line or as a circle or not drawn at all.; The mean is the arithmetic average of the values in the distribution.; It is calculated using GetMean(). Because histograms are; binned data, the mean value can differ from a calculation on the raw-data.; If the distribution is large enough and gaussian shaped the mean will be; exactly the median. ##### The Whiskers; The whiskers represent the part of the distribution not covered by the box.; The upper 25% and the lower 25% of the distribution are located within the whiskers.; Two representations are available. - A simple one (using w=1) defining the lower whisker from the lowest data value; to the bottom of the box, and the upper whisker from the top of the box to the; highest data value. In this representation the whisker-lines are dashed.; - A more complex one having a further restriction. The whiskers are still connected; to the box but their length cannot exceed \f$ 1.5\times iqr \f$. So it might; be that the outermost part of the underlying distribution will not be covered; by the whiskers. Usually these missing parts will be represented by the outliers; (see points). Of course the upper and the lower whisker may differ in length.; In this representation the whiskers are drawn as solid lines. \since **ROOT version 6.11/01**. Using the static function TCandle::SetWhiskerRange(double) the whisker definition w=1; will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of; the lower whisker to the upper whisker in order to cover 95% of the d",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:61276,Availability,error,errors,61276," of a certain value:. Begin_Macro(source); ../../../tutorials/hist/candledecay.C; End_Macro. \anchor HP15; ### The TEXT and TEXTnn Option. For each bin the content is printed. The text attributes are:. - text font = current TStyle font (`gStyle->SetTextFont()`).; - text size = 0.02*padheight*markersize (if `h` is the histogram drawn; with the option `TEXT` the marker size can be changed with; `h->SetMarkerSize(markersize)`).; - text color = marker color. By default the format `g` is used. This format can be redefined; by calling `gStyle->SetPaintTextFormat()`. It is also possible to use `TEXTnn` in order to draw the text with; the angle `nn` (`0 < nn <= 90`). For 2D histograms the text is plotted in the center of each non empty cells.; It is possible to plot empty cells by calling `gStyle->SetHistMinimumZero()`; or providing MIN0 draw option. For 1D histogram the text is plotted at a y; position equal to the bin content. For 2D histograms when the option ""E"" (errors) is combined with the option; text (""TEXTE""), the error for each bin is also printed. Begin_Macro(source); {; auto c01 = new TCanvas(""c01"",""c01"",700,400);; c01->Divide(2,1);; auto htext1 = new TH1F(""htext1"",""Option TEXT on 1D histograms "",10,-4,4);; auto htext2 = new TH2F(""htext2"",""Option TEXT on 2D histograms "",10,-4,4,10,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; htext1->Fill(px,0.1);; htext2->Fill(px,5*py,0.1);; }; gStyle->SetPaintTextFormat(""4.1f m"");; htext2->SetMarkerSize(1.8);; c01->cd(1);; htext2->Draw(""TEXT45"");; c01->cd(2);; htext1->Draw();; htext1->Draw(""HIST TEXT0 SAME"");; }; End_Macro. \since **ROOT version 6.07/07:**. In case several histograms are drawn on top ot each other (using option `SAME`),; the text can be shifted using `SetBarOffset()`. It specifies an offset for the; text position in each cell, in percentage of the bin width. Begin_Macro(source); {; auto c03 = new TCanvas(""c03"",""c03"",700,400);; gStyle->SetOptStat(0);; auto htext3 = new T",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:61333,Availability,error,error,61333," of a certain value:. Begin_Macro(source); ../../../tutorials/hist/candledecay.C; End_Macro. \anchor HP15; ### The TEXT and TEXTnn Option. For each bin the content is printed. The text attributes are:. - text font = current TStyle font (`gStyle->SetTextFont()`).; - text size = 0.02*padheight*markersize (if `h` is the histogram drawn; with the option `TEXT` the marker size can be changed with; `h->SetMarkerSize(markersize)`).; - text color = marker color. By default the format `g` is used. This format can be redefined; by calling `gStyle->SetPaintTextFormat()`. It is also possible to use `TEXTnn` in order to draw the text with; the angle `nn` (`0 < nn <= 90`). For 2D histograms the text is plotted in the center of each non empty cells.; It is possible to plot empty cells by calling `gStyle->SetHistMinimumZero()`; or providing MIN0 draw option. For 1D histogram the text is plotted at a y; position equal to the bin content. For 2D histograms when the option ""E"" (errors) is combined with the option; text (""TEXTE""), the error for each bin is also printed. Begin_Macro(source); {; auto c01 = new TCanvas(""c01"",""c01"",700,400);; c01->Divide(2,1);; auto htext1 = new TH1F(""htext1"",""Option TEXT on 1D histograms "",10,-4,4);; auto htext2 = new TH2F(""htext2"",""Option TEXT on 2D histograms "",10,-4,4,10,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; htext1->Fill(px,0.1);; htext2->Fill(px,5*py,0.1);; }; gStyle->SetPaintTextFormat(""4.1f m"");; htext2->SetMarkerSize(1.8);; c01->cd(1);; htext2->Draw(""TEXT45"");; c01->cd(2);; htext1->Draw();; htext1->Draw(""HIST TEXT0 SAME"");; }; End_Macro. \since **ROOT version 6.07/07:**. In case several histograms are drawn on top ot each other (using option `SAME`),; the text can be shifted using `SetBarOffset()`. It specifies an offset for the; text position in each cell, in percentage of the bin width. Begin_Macro(source); {; auto c03 = new TCanvas(""c03"",""c03"",700,400);; gStyle->SetOptStat(0);; auto htext3 = new T",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:88899,Availability,avail,available,88899,"en from the Z axis of the object. For example, to; set the labels size on the palette axis do:. hist->GetZaxis()->SetLabelSize(). <b>WARNING:</b> The palette axis is always drawn vertically. \anchor HP23; ### Setting the color palette. To change the color palette `TStyle::SetPalette` should be used, eg:. gStyle->SetPalette(ncolors,colors);. For example the option `COL` draws a 2D histogram with cells; represented by a box filled with a color index which is a function; of the cell content.; If the cell content is N, the color index used will be the color number; in `colors[N]`, etc. If the maximum cell content is greater than; `ncolors`, all cell contents are scaled to `ncolors`. If ` ncolors <= 0`, a default palette (see below) of 50 colors is; defined. This palette is recommended for pads, labels ... `if ncolors == 1 && colors == 0`, then a Pretty Palette with a; Spectrum Violet->Red is created with 50 colors. That's the default rain bow; palette. Other pre-defined palettes with 255 colors are available when `colors == 0`.; The following value of `ncolors` give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors. The default palette defines:. - index 0 to 9 : shades of grey; - index 10 to 19 : shades of brown; - index 20 to 29 : shades of blue; - index 30 to 39 : shades of red; - index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item `colors` in the `VIEW` menu of the canvas tool bar.; The red, green, and blue components of a ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:96680,Availability,error,errors,96680,"urrent pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad. The following example shows various types of stacks (hstack.C). Begin_Macro(source); ../../../tutorials/hist/hstack.C; End_Macro. The option `nostackb` allows to draw the histograms next to each; other as bar charts:. Begin_Macro(source); {; auto cst0 = new TCanvas(""cst0"",""cst0"",600,400);; auto hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");. auto h1 = new TH1F(""h1"",""h1"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);. auto h2 = new TH1F(""h2"",""h2"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);. auto h3 = new TH1F(""h3"",""h3"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);. hs->Draw(""nostackb"");; hs->GetXaxis()->SetNdivisions(-10);; cst0->SetGridx();; }; End_Macro. If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option `HIST` should be used. Begin_Macro(source); {; auto cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. auto hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. auto hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");; }; End_Macro. \anchor HP27; ### Drawing of 3D implicit functions. 3D implicit functions (`TF3`) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Begin_Macro(source); {; auto c2 = new TCanvas(""c2""",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:96735,Availability,error,error,96735,"urrent pad/canvas is; subdivided into a number of pads equal to the number of histograms and each; histogram is paint into a separate pad. The following example shows various types of stacks (hstack.C). Begin_Macro(source); ../../../tutorials/hist/hstack.C; End_Macro. The option `nostackb` allows to draw the histograms next to each; other as bar charts:. Begin_Macro(source); {; auto cst0 = new TCanvas(""cst0"",""cst0"",600,400);; auto hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");. auto h1 = new TH1F(""h1"",""h1"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);. auto h2 = new TH1F(""h2"",""h2"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);. auto h3 = new TH1F(""h3"",""h3"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);. hs->Draw(""nostackb"");; hs->GetXaxis()->SetNdivisions(-10);; cst0->SetGridx();; }; End_Macro. If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option `HIST` should be used. Begin_Macro(source); {; auto cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. auto hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. auto hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");; }; End_Macro. \anchor HP27; ### Drawing of 3D implicit functions. 3D implicit functions (`TF3`) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Begin_Macro(source); {; auto c2 = new TCanvas(""c2""",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:96771,Availability,error,errors,96771," each; histogram is paint into a separate pad. The following example shows various types of stacks (hstack.C). Begin_Macro(source); ../../../tutorials/hist/hstack.C; End_Macro. The option `nostackb` allows to draw the histograms next to each; other as bar charts:. Begin_Macro(source); {; auto cst0 = new TCanvas(""cst0"",""cst0"",600,400);; auto hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");. auto h1 = new TH1F(""h1"",""h1"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);. auto h2 = new TH1F(""h2"",""h2"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);. auto h3 = new TH1F(""h3"",""h3"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);. hs->Draw(""nostackb"");; hs->GetXaxis()->SetNdivisions(-10);; cst0->SetGridx();; }; End_Macro. If at least one of the histograms in the stack has errors, the whole stack is; visualized by default with error bars. To visualize it without errors the; option `HIST` should be used. Begin_Macro(source); {; auto cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);. auto hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);. auto hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");; }; End_Macro. \anchor HP27; ### Drawing of 3D implicit functions. 3D implicit functions (`TF3`) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Begin_Macro(source); {; auto c2 = new TCanvas(""c2"",""c2"",600,400);; auto f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClipp",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:4470,Deployability,update,updated,4470,"t is enough to do:. h->Draw();. `h` can be of any kind: 1D, 2D or 3D. To choose how the histogram will; be drawn, the `Draw()` method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. `THistPainter` offers many options to paint 1D, 2D and 3D histograms. When the `Draw()` method of a histogram is called for the first time; (`TH1::Draw`), it creates a `THistPainter` object and saves a; pointer to this ""painter"" as a data member of the histogram. The; `THistPainter` class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram having its own; painter (rather than a central singleton painter painting all histograms), allows; two histograms to be drawn in two threads without overwriting the painter's; values. When a displayed histogram is filled again, there is no need to call the; `Draw()` method again; the image will be refreshed the next time the; pad will be updated. A pad is updated after one of these three actions:. 1. a carriage control on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. By default a call to `TH1::Draw()` clears the pad of all objects; before drawing the new image of the histogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case se",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:4488,Deployability,update,updated,4488,"awn, the `Draw()` method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. `THistPainter` offers many options to paint 1D, 2D and 3D histograms. When the `Draw()` method of a histogram is called for the first time; (`TH1::Draw`), it creates a `THistPainter` object and saves a; pointer to this ""painter"" as a data member of the histogram. The; `THistPainter` class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram having its own; painter (rather than a central singleton painter painting all histograms), allows; two histograms to be drawn in two threads without overwriting the painter's; values. When a displayed histogram is filled again, there is no need to call the; `Draw()` method again; the image will be refreshed the next time the; pad will be updated. A pad is updated after one of these three actions:. 1. a carriage control on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. By default a call to `TH1::Draw()` clears the pad of all objects; before drawing the new image of the histogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; usi",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:4628,Deployability,Update,Update,4628,"h to do:. h->Draw(""lego"");. `THistPainter` offers many options to paint 1D, 2D and 3D histograms. When the `Draw()` method of a histogram is called for the first time; (`TH1::Draw`), it creates a `THistPainter` object and saves a; pointer to this ""painter"" as a data member of the histogram. The; `THistPainter` class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram having its own; painter (rather than a central singleton painter painting all histograms), allows; two histograms to be drawn in two threads without overwriting the painter's; values. When a displayed histogram is filled again, there is no need to call the; `Draw()` method again; the image will be refreshed the next time the; pad will be updated. A pad is updated after one of these three actions:. 1. a carriage control on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. By default a call to `TH1::Draw()` clears the pad of all objects; before drawing the new image of the histogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:20169,Deployability,Update,Update,20169,"istogram get its color; from the current color palette defined by `gStyle->SetPalette(...)`. The color; is determined according to the number of objects having palette coloring in; the current pad. Begin_Macro(source); ../../../tutorials/hist/histpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/hist/thstackpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/hist/thstack2palettecolor.C; End_Macro. \anchor HP06; ### Superimposing two histograms with different scales in the same pad. The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutorial `transpad.C` for a variant; of this example. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; // create/fill draw h1; gStyle->SetOptStat(kFALSE);; auto h1 = new TH1F(""h1"",""Superimposing two histograms with different scales"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) h1->Fill(gRandom->Gaus(0,1));; h1->Draw();; c1->Update();. // create hint1 filled with the bins integral of h1; auto hint1 = new TH1F(""hint1"",""h1 bins integral"",100,-3,3);; float sum = 0.f;; for (i=1;i<=100;i++) {; sum += h1->GetBinContent(i);; hint1->SetBinContent(i,sum);; }. // scale hint1 to the pad coordinates; float rightmax = 1.1*hint1->GetMaximum();; float scale = gPad->GetUymax()/rightmax;; hint1->SetLineColor(kRed);; hint1->Scale(scale);; hint1->Draw(""same"");. // draw an axis on the right side; auto axis = new TGaxis(gPad->GetUxmax(),gPad->GetUymin(),; gPad->GetUxmax(), gPad->GetUymax(),0,rightmax,510,""+L"");; axis->SetLineColor(kRed);; axis->SetTextColor(kRed);; axis->Draw();; }; End_Macro. \anchor HP07; ### Statistics Display. The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The `mode` has up to nine digits that can be set",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:23424,Deployability,update,updated,23424,"single number. The parameter mode can be any combination of the letters `kKsSiIourRmMen`. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : standard deviation printed; R : standard deviation and standard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer. When a histogram is drawn with the option `SAME`, the statistics box; is not drawn. To force the statistics box drawing with the option; `SAME`, the option `SAMES` must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (`h` being the pointer to the histogram):. Root > TPaveSt",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:23819,Deployability,Update,Update,23819,"ndard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer. When a histogram is drawn with the option `SAME`, the statistics box; is not drawn. To force the statistics box drawing with the option; `SAME`, the option `SAMES` must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (`h` being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; `TPaveStats` one should do:. st->SetOptStat(mode);. Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; (see above). One can delete the statistics box for a histogram `TH1* h` wi",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:23902,Deployability,Update,Update,23902," of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer. When a histogram is drawn with the option `SAME`, the statistics box; is not drawn. To force the statistics box drawing with the option; `SAME`, the option `SAMES` must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (`h` being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; `TPaveStats` one should do:. st->SetOptStat(mode);. Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; (see above). One can delete the statistics box for a histogram `TH1* h` with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean""",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:23983,Deployability,Update,Update,23983,"ame of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer. When a histogram is drawn with the option `SAME`, the statistics box; is not drawn. To force the statistics box drawing with the option; `SAME`, the option `SAMES` must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (`h` being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; `TPaveStats` one should do:. st->SetOptStat(mode);. Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; (see above). One can delete the statistics box for a histogram `TH1* h` with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; `$ROOTSYS/etc/system.rootrc` or `.rootrc` (lo",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:52889,Deployability,configurat,configuration,52889,"skerRange(double) the whisker definition w=1; will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of; the lower whisker to the upper whisker in order to cover 95% of the distribution inside; that candle. The static function will affect all candle-charts in the running program.; Default is 1. If the distribution is large enough and gaussian shaped, the maximum length of; the whisker will be located at \f$ \pm 2.698 \sigma \f$ (when using the; 1.5*iqr-definition (w=2), where \f$ \sigma \f$ is the standard deviation; (see picture above). In that case 99.3% of the total distribution will be covered; by the box and the whiskers, whereas 0.7% are represented by the outliers. ##### The Anchors; The anchors have no special meaning in terms of statistical calculation. They mark; the end of the whiskers and they have the width of the box. Both representation; with and without anchors are common. ##### The Points; Depending on the configuration the points can have different meanings:; - If p=1 the points represent the outliers. If they are shown, it means; some parts of the underlying distribution are not covered by the whiskers.; This can only occur when the whiskers are set to option w=2. Here the whiskers; can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; whiskers will be drawn as outliers. The outliers will be represented by crosses.; - If p=2 all points in the distribution will be painted as crosses. This is; useful for small datasets only (up to 10 or 20 points per candle).; The outliers are shown along the candle. Because the underlying distribution; is binned, is frequently occurs that a bin contains more than one value.; Because of this the points will be randomly scattered within their bin along; the candle axis. If the bin content for a bin is exactly 1 (usually; this happens for the outliers) if will be drawn in the middle of the bin along; the candle axis. As the maximum number of points per candle i",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:60230,Deployability,Update,Update,60230,"tion. There are two predefined violin-plot representations:; - ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution,; zero indicator line); - ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers. A solid fill style is recommended for this plot (as opposed to a hollow or; hashed style). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; auto hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1"", ""gaus"", +0,0 +4.0);; double x,y;; for (Int_t iBin=1; iBin<hviolin->GetNbinsX(); ++iBin) {; double xc = hviolin->GetXaxis()->GetBinCenter(iBin);; f1.SetParameters(1, 2.0+TMath::Sin(1.0+xc), 0.2+0.1*(xc-xmin)/xmax);; for(Int_t i=0; i<10000; ++i){; x = xc;; y = f1.GetRandom();; hviolin->Fill(x, y);; }; }; hviolin->SetFillColor(kGray);; hviolin->SetMarkerStyle(20);; hviolin->SetMarkerSize(0.5);; hviolin->Draw(""VIOLIN"");; c1->Update();; }; End_Macro. The next example illustrates a time development of a certain value:. Begin_Macro(source); ../../../tutorials/hist/candledecay.C; End_Macro. \anchor HP15; ### The TEXT and TEXTnn Option. For each bin the content is printed. The text attributes are:. - text font = current TStyle font (`gStyle->SetTextFont()`).; - text size = 0.02*padheight*markersize (if `h` is the histogram drawn; with the option `TEXT` the marker size can be changed with; `h->SetMarkerSize(markersize)`).; - text color = marker color. By default the format `g` is used. This format can be redefined; by calling `gStyle->SetPaintTextFormat()`. It is also possible to use `TEXTnn` in order to draw the text with; the angle `nn` (`0 < nn <= 90`). For 2D histograms the text is plotted in the center of each non empty cells.; It is possible to plot empty cells by calling `gStyle->SetHistMinimumZero()`; or providing MIN0 draw option. For 1D histogram the text is plotted at a y; position equal to the b",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:67552,Deployability,Update,Update,67552,"; }; End_Macro. The following example shows a 2D histogram plotted with the option; `CONT4`. The option `CONT4` draws a contour plot using surface; colors to distinguish contours (`SURF` option at theta = 0). Combined; with the option `CONT` (or `CONT0`), the option `Z`; allows to display the color palette defined by `gStyle->SetPalette()`. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; hcont4->Draw(""CONT4Z"");; }; End_Macro. The default number of contour levels is 20 equidistant levels and can be changed; with `TH1::SetContour()` or `TStyle::SetNumberContours()`. \anchor HP16a; #### The LIST option. When option `LIST` is specified together with option; `CONT`, the points used to draw the contours are saved in; `TGraph` objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in `TGraph` objects once the pad is painted.; Therefore to use this functionality in a macro, `gPad->Update()`; should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where `i` is a contour number, and list contains a list of; `TGraph` objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example (ContourList.C) shows how to use this functionality. Begin_Macro(source); ../../../tutorials/hist/ContourList.C; End_Macro. \anchor HP16b; #### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options. The following optio",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:67686,Deployability,Update,Update,67686,"e; colors to distinguish contours (`SURF` option at theta = 0). Combined; with the option `CONT` (or `CONT0`), the option `Z`; allows to display the color palette defined by `gStyle->SetPalette()`. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; hcont4->Draw(""CONT4Z"");; }; End_Macro. The default number of contour levels is 20 equidistant levels and can be changed; with `TH1::SetContour()` or `TStyle::SetNumberContours()`. \anchor HP16a; #### The LIST option. When option `LIST` is specified together with option; `CONT`, the points used to draw the contours are saved in; `TGraph` objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in `TGraph` objects once the pad is painted.; Therefore to use this functionality in a macro, `gPad->Update()`; should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where `i` is a contour number, and list contains a list of; `TGraph` objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example (ContourList.C) shows how to use this functionality. Begin_Macro(source); ../../../tutorials/hist/ContourList.C; End_Macro. \anchor HP16b; #### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options. The following options select the `CONT4` option and are useful for; sky maps or exposure maps (earth.C). | Option | Description |; |--------------|-----------------",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:107904,Deployability,Update,Update,107904," - when selected object (histogram as a whole) is different from previous; then emit `Picked()` signal; - when selected (highlighted) bin from histogram is different from previous; then emit `Highlighted()` signal. Any user function (or functions) has to be defined; `UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)`.; In example (see below) has name `PrintInfo()`. All parameters of user; function are taken from. void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y). - `pad` is pointer to pad with highlighted histogram; - `obj` is pointer to highlighted histogram; - `x` is highlighted x bin for 1D histogram; - `y` is highlighted y bin for 2D histogram (for 1D histogram not in use). Example how to create a connection from any `TCanvas` object to a user; `UserFunction()` slot (see also `TQObject::Connect()` for additional info). TQObject::Connect(""TCanvas"", ""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"",; 0, 0, ""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");. or use non-static ""simplified"" function; `TCanvas::HighlightConnect(const char *slot)`. c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");. NOTE the signal and slot string must have a form; ""(TVirtualPad*,TObject*,Int_t,Int_t)"". root [0] .x $ROOTSYS/tutorials/hsimple.C; root [1] hpx->SetHighlight(kTRUE); root [2] .x hlprint.C. file `hlprint.C`; ~~~ {.cpp}; void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); {; auto h = (TH1F *)obj;; if (!h->IsHighlight()) // after highlight disabled; h->SetTitle(""highlight disable"");; else; h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; h->GetBinCenter(x), h->GetBinContent(x)));; pad->Update();; }. void hlprint(); {; if (!gPad) return;; gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; }; ~~~. \image html hlsimple.gif ""Highlight mode and simple user function"". For more complex demo please see for example `$ROOTSYS/tutorials/tree/temperature.C` file. */",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:45841,Energy Efficiency,reduce,reduces,45841,"y affect violin charts of course. \anchor HP140a; #### The CANDLE option. <a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; way to describe graphically a data distribution (D) with only five numbers:. 1. The minimum value of the distribution D (bottom or left whisker).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 5. The maximum value of the distribution D (top or right whisker). In this implementation a TH2 is considered as a collection of TH1 along; X (option `CANDLE` or `CANDLEX`) or Y (option `CANDLEY`).; Each TH1 is represented as one candle. Begin_Macro(source); ../../../tutorials/hist/candleplotwhiskers.C; End_Macro. The candle reduces the information coming from a whole distribution into few values.; Independently from the number of entries or the significance of the underlying distribution; a candle will always look like a candle. So candle plots should be used carefully in; particular with unknown distributions. The definition of a candle is based on; __unbinned data__. Here, candles are created from binned data. Because of this, the; deviation is connected to the bin width used. The calculation of the quantiles; normally done on unbinned data also. Because data are binned, this will; only work the best possible way within the resolution of one bin. Because of all these facts one should take care that:. - there are enough points per candle; - the bin width is small enough (more bins will increase the maximum; available resolution of the quantiles although there will be some; bins with no entries); - never make a candle-plot if the underlying distribution is double-distributed; - only create candles of distributions that are more-or-less",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:89858,Energy Efficiency,green,green,89858," are available when `colors == 0`.; The following value of `ncolors` give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors. The default palette defines:. - index 0 to 9 : shades of grey; - index 10 to 19 : shades of brown; - index 20 to 29 : shades of blue; - index 30 to 39 : shades of red; - index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item `colors` in the `VIEW` menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; `TColor::SetRGB()`. \since **ROOT version 6.19/01**. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; For more details see `TPaletteAxis`. \anchor HP24; ### Drawing a sub-range of a 2D histogram; the [cutg] option. Using a `TCutG` object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between `[]` in the `Draw()` option.; For example (fit2a.C), with a `TCutG` named `cutg`, one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a `-` in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts (`,` means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Begin_Macro(source); ../../../tutorials/fit/fit2a.C; End_Macro. \anchor HP25",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:102324,Energy Efficiency,green,green,102324,"awn using iso-surfaces.|. \anchor HP29d; #### TF3 (implicit function). The supported option is:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GL"" | Draw a TF3.|. \anchor HP29e; #### Parametric surfaces. `$ROOTSYS/tutorials/gl/glparametric.C` shows how to create parametric; equations and visualize the surface. \anchor HP29f; #### Interaction with the plots. All the interactions are implemented via standard methods; `DistancetoPrimitive()` and `ExecuteEvent()`. That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed. \anchor HP29g; #### Selectable parts. Different parts of the plot can be selected:. - xoz, yoz, xoy back planes: When such a plane selected, it's highlighted in green; if the dynamic slicing by this plane is supported, and it's highlighted in red,; if the dynamic slicing is not supported.; - The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. \anchor HP29h; #### Rotation and zooming. - Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; - Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. \anchor HP29i; #### Panning. The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key. \anchor HP29j; #### Box cut. Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutti",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:103809,Energy Efficiency,green,green,103809,"selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; - Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. \anchor HP29i; #### Panning. The selected plot can be moved in a pad's area by pressing and; holding the left mouse button and the shift key. \anchor HP29j; #### Box cut. Surface, iso, box, TF3 and parametric painters support box cut by; pressing the 'c' or 'C' key when the mouse cursor is in a plot's; area. That will display a transparent box, cutting away part of the; surface (or boxes) in order to show internal part of plot. This box; can be moved inside the plot's area (the full size of the box is; equal to the plot's surrounding box) by selecting one of the box; cut axes and pressing the left mouse button to move it. \anchor HP29k; #### Plot specific interactions (dynamic slicing etc.). Currently, all gl-plots support some form of slicing. When back plane; is selected (and if it's highlighted in green) you can press and hold; left mouse button and shift key and move this back plane inside; plot's area, creating the slice. During this ""slicing"" plot becomes; semi-transparent. To remove all slices (and projected curves for; surfaces) double click with left mouse button in a plot's area. \anchor HP29l; #### Surface with option ""GLSURF"". The surface profile is displayed on the slicing plane.; The profile projection is drawn on the back plane; by pressing `'p'` or `'P'` key. \anchor HP29m; #### TF3. The contour plot is drawn on the slicing plane. For TF3 the color; scheme can be changed by pressing 's' or 'S'. \anchor HP29n; #### Box. The contour plot corresponding to slice plane position is drawn in real time. \anchor HP29o; #### Iso. Slicing is similar to ""GLBOX"" option. \anchor HP29p; #### Parametric plot. No slicing. Additional keys: 's' or 'S' to change color scheme -; about 20 color schemes supported ('s' for ""scheme""); 'l' or 'L' to; increase number of polygons ('l' for ""level"" of details), 'w' or 'W'; to sho",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41127,Integrability,depend,depends,41127,"o h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; End_Macro. The option `COL` can be combined with the option `POL`:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histog",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:52872,Integrability,Depend,Depending,52872,"skerRange(double) the whisker definition w=1; will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of; the lower whisker to the upper whisker in order to cover 95% of the distribution inside; that candle. The static function will affect all candle-charts in the running program.; Default is 1. If the distribution is large enough and gaussian shaped, the maximum length of; the whisker will be located at \f$ \pm 2.698 \sigma \f$ (when using the; 1.5*iqr-definition (w=2), where \f$ \sigma \f$ is the standard deviation; (see picture above). In that case 99.3% of the total distribution will be covered; by the box and the whiskers, whereas 0.7% are represented by the outliers. ##### The Anchors; The anchors have no special meaning in terms of statistical calculation. They mark; the end of the whiskers and they have the width of the box. Both representation; with and without anchors are common. ##### The Points; Depending on the configuration the points can have different meanings:; - If p=1 the points represent the outliers. If they are shown, it means; some parts of the underlying distribution are not covered by the whiskers.; This can only occur when the whiskers are set to option w=2. Here the whiskers; can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; whiskers will be drawn as outliers. The outliers will be represented by crosses.; - If p=2 all points in the distribution will be painted as crosses. This is; useful for small datasets only (up to 10 or 20 points per candle).; The outliers are shown along the candle. Because the underlying distribution; is binned, is frequently occurs that a bin contains more than one value.; Because of this the points will be randomly scattered within their bin along; the candle axis. If the bin content for a bin is exactly 1 (usually; this happens for the outliers) if will be drawn in the middle of the bin along; the candle axis. As the maximum number of points per candle i",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:86807,Integrability,interface,interface,86807,"01, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };. Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; auto p = new TH2Poly(""USA"",""USA Population"",lon1,lon2,lat1,lat2);. TFile::SetCacheFileDir(""."");; auto f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");. TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }. for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);. gStyle->SetOptStat(11);; p->Draw(""COLZ L"");; }; End_Macro. `TH2Poly` histograms can also be plotted using the GL interface using; the option ""GLLEGO"". \since **ROOT version 6.09/01**. In some cases it can be useful to not draw the empty bins. the option ""0""; combined with the option ""COL"" et COLZ allows to do that. Begin_Macro(source); {; auto chc = new TCanvas(""chc"",""chc"",600,400);. auto hc = new TH2Poly();; hc->Honeycomb(0,0,.1,25,25);; hc->SetName(""hc"");; hc->SetTitle(""Option COLZ 0"");; TRandom ran;; for (int i = 0; i<300; i++) hc->Fill(ran.Gaus(2.,1), ran.Gaus(2.,1));; hc->Draw(""colz 0"");; }; End_Macro. \anchor HP21; ### The SPEC option. This option allows to use the `TSpectrum2Painter` tools. See the full; documentation in `TSpectrum2Painter::PaintSpectrum`. \anchor HP22; ### Option ""Z"" : Adding the color palette on the right side of the pad. When this option is specified, a color palette with an axis indicating the value; of the corresponding color is drawn on the right side of the picture. In case,; not enough space is left, one can increase the size of the right margin by; callin",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:16508,Modifiability,inherit,inherit,16508,"n next to each other as bar charts.|; | ""PADS"" | The current pad/canvas is subdivided into a number of pads equal to the number of histograms in the stack and each histogram is paint into a separate pad.|; | ""PFC"" | Palette Fill Color: stack's fill color is taken in the current palette. |; | ""PLC"" | Palette Line Color: stack's line color is taken in the current palette. |; | ""PMC"" | Palette Marker Color: stack's marker color is taken in the current palette. |. \anchor HP02; ### Setting the Style. Histograms use the current style (`gStyle`). When one changes the current; style and would like to propagate the changes to the histogram,; `TH1::UseCurrentStyle` should be called. Call `UseCurrentStyle` on; each histogram is needed. To force all the histogram to use the current style use:. gROOT->ForceStyle();. All the histograms read after this call will use the current style. \anchor HP03; ### Setting line, fill, marker, and text attributes. The histogram classes inherit from the attribute classes:; `TAttLine`, `TAttFill` and `TAttMarker`.; See the description of these classes for the list of options. \anchor HP04; ### Setting Tick marks on the histogram axis. The `TPad::SetTicks` method specifies the type of tick marks on the axis.; If ` tx = gPad->GetTickx()` and `ty = gPad->GetTicky()` then:. tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (`tx = ty = 0`). `TPad::SetTicks(tx,ty)` allows to set these options.; See also The `TAxis` functions to set specific axis attributes. In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. \anchor HP05; ### Giving titles to the X, Y and Z axis. h->GetXaxis()->Se",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:52889,Modifiability,config,configuration,52889,"skerRange(double) the whisker definition w=1; will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of; the lower whisker to the upper whisker in order to cover 95% of the distribution inside; that candle. The static function will affect all candle-charts in the running program.; Default is 1. If the distribution is large enough and gaussian shaped, the maximum length of; the whisker will be located at \f$ \pm 2.698 \sigma \f$ (when using the; 1.5*iqr-definition (w=2), where \f$ \sigma \f$ is the standard deviation; (see picture above). In that case 99.3% of the total distribution will be covered; by the box and the whiskers, whereas 0.7% are represented by the outliers. ##### The Anchors; The anchors have no special meaning in terms of statistical calculation. They mark; the end of the whiskers and they have the width of the box. Both representation; with and without anchors are common. ##### The Points; Depending on the configuration the points can have different meanings:; - If p=1 the points represent the outliers. If they are shown, it means; some parts of the underlying distribution are not covered by the whiskers.; This can only occur when the whiskers are set to option w=2. Here the whiskers; can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; whiskers will be drawn as outliers. The outliers will be represented by crosses.; - If p=2 all points in the distribution will be painted as crosses. This is; useful for small datasets only (up to 10 or 20 points per candle).; The outliers are shown along the candle. Because the underlying distribution; is binned, is frequently occurs that a bin contains more than one value.; Because of this the points will be randomly scattered within their bin along; the candle axis. If the bin content for a bin is exactly 1 (usually; this happens for the outliers) if will be drawn in the middle of the bin along; the candle axis. As the maximum number of points per candle i",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:86559,Modifiability,Inherit,InheritsFrom,86559,"""rhode_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };. Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; auto p = new TH2Poly(""USA"",""USA Population"",lon1,lon2,lat1,lat2);. TFile::SetCacheFileDir(""."");; auto f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");. TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }. for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);. gStyle->SetOptStat(11);; p->Draw(""COLZ L"");; }; End_Macro. `TH2Poly` histograms can also be plotted using the GL interface using; the option ""GLLEGO"". \since **ROOT version 6.09/01**. In some cases it can be useful to not draw the empty bins. the option ""0""; combined with the option ""COL"" et COLZ allows to do that. Begin_Macro(source); {; auto chc = new TCanvas(""chc"",""chc"",600,400);. auto hc = new TH2Poly();; hc->Honeycomb(0,0,.1,25,25);; hc->SetName(""hc"");; hc->SetTitle(""Option COLZ 0"");; TRandom ran;; for (int i = 0; i<300; i++) hc->Fill(ran.Gaus(2.,1), ran.Gaus(2.,1));; hc->Draw(""colz 0"");; }; End_Macro. \anchor HP21; ### The SPEC option. This option allows to use the `TSpectrum2Painter` tools. See the full; documentation in `TSpectrum2Painter::PaintSpectrum`. \anchor HP22; ### Option ""Z"" : Adding the color palette o",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:10990,Performance,perform,performance,10990,"rtional to the content's absolute value. A negative content is marked with a X. |; | ""BOX1"" | A button is drawn for each cell with surface proportional to content's absolute value. A sunken button is drawn for negative values a raised one for positive.|; | ""COL"" | A box is drawn for each cell with a color scale varying with contents. All the none empty bins are painted. Empty bins are not painted unless some bins have a negative content because in that case the null bins might be not empty. `TProfile2D` histograms are handled differently because, for this type of 2D histograms, it is possible to know if an empty bin has been filled or not. So even if all the bins' contents are positive some empty bins might be painted. And vice versa, if some bins have a negative content some empty bins might be not painted (default).|; | ""COLZ"" | Same as ""COL"". In addition the color palette is also drawn.|; | ""COL2"" | Alternative rendering algorithm to ""COL"". Can significantly improve rendering performance for large, non-sparse 2-D histograms.|; | ""COLZ2"" | Same as ""COL2"". In addition the color palette is also drawn.|; | ""Z CJUST"" | In combination with colored options ""COL"",""CONT0"" etc: Justify labels in the color palette at color boundaries. For more details see `TPaletteAxis`|; | ""CANDLE"" | Draw a candle plot along X axis.|; | ""CANDLEX"" | Same as ""CANDLE"".|; | ""CANDLEY"" | Draw a candle plot along Y axis.|; | ""CANDLEXn"" | Draw a candle plot along X axis. Different candle-styles with n from 1 to 6.|; | ""CANDLEYn"" | Draw a candle plot along Y axis. Different candle-styles with n from 1 to 6.|; | ""VIOLIN"" | Draw a violin plot along X axis.|; | ""VIOLINX"" | Same as ""VIOLIN"".|; | ""VIOLINY"" | Draw a violin plot along Y axis.|; | ""VIOLINXn"" | Draw a violin plot along X axis. Different violin-styles with n being 1 or 2.|; | ""VIOLINYn"" | Draw a violin plot along Y axis. Different violin-styles with n being 1 or 2.|; | ""CONT"" | Draw a contour plot (same as CONT0).|; | ""CONT0"" | Draw a contou",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:31123,Performance,scalab,scalable,31123,"s/hist/hbars.C; End_Macro. To control the bar width (default is the bin width) `TH1::SetBarWidth()`; should be used. To control the bar offset (default is 0) `TH1::SetBarOffset()` should; be used. These two parameters are useful when several histograms are plotted using; the option `SAME`. They allow to plot the histograms next to each other. \anchor HP11; ### The SCATter plot option (legacy draw option). \attention; Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 3D histograms. The new default option is `COL` (heat-map). For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; `kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; If option is of the form `scat=ff`, (eg `scat=1.8`,; `scat=1e-3`), then `ff` is used as a scale factor to compute the; number of dots. `scat=1` is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the `TAttMarker` documentation). To change the marker size, a scalable marker; type should be used. For instance a circle (marker style 20). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; }; End_Macro. \anchor HP12; ### The ARRow option. Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; harr->SetLineColor(kRed);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:31200,Performance,scalab,scalable,31200,"idth()`; should be used. To control the bar offset (default is 0) `TH1::SetBarOffset()` should; be used. These two parameters are useful when several histograms are plotted using; the option `SAME`. They allow to plot the histograms next to each other. \anchor HP11; ### The SCATter plot option (legacy draw option). \attention; Use of option `SCAT` has been deprecated. It was the default drawing option for 2D and; 3D histograms. The new default option is `COL` (heat-map). For each cell (i,j) a number of points proportional to the cell content is; drawn. A maximum of `kNMAX` points per cell is drawn. If the maximum is above; `kNMAX` contents are normalized to `kNMAX` (`kNMAX=2000`).; If option is of the form `scat=ff`, (eg `scat=1.8`,; `scat=1e-3`), then `ff` is used as a scale factor to compute the; number of dots. `scat=1` is the default. By default the scatter plot is painted with a ""dot marker"" which not scalable; (see the `TAttMarker` documentation). To change the marker size, a scalable marker; type should be used. For instance a circle (marker style 20). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; }; End_Macro. \anchor HP12; ### The ARRow option. Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn; The orientation of the arrow follows the cell gradient. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; harr->SetLineColor(kRed);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; }; End_Macro. \since *",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41007,Performance,perform,performance,41007,"40,-3,3,40,-3,3);; auto h2 = new TH2F(""h2"",""h2"",40,-3,3,40,-3,3);; auto h3 = new TH2F(""h3"",""h3"",40,-3,3,40,-3,3);; auto h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; End_Macro. The option `COL` can be combined with the option `POL`:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41074,Performance,perform,performance,41074,"o h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; End_Macro. The option `COL` can be combined with the option `POL`:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histog",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41469,Performance,perform,performance,41469,"2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; End_Macro. The option `COL` can be combined with the option `POL`:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; graphics file format like PostScript or PDF (an empty image will be generated). It can; be saved only in bitmap files like PNG format for instance. \anchor HP140; ### The CANDLE and VIOLIN options. The mechanism behind Candle plots and Vi",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41648,Performance,perform,performance,41648,"ion COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; graphics file format like PostScript or PDF (an empty image will be generated). It can; be saved only in bitmap files like PNG format for instance. \anchor HP140; ### The CANDLE and VIOLIN options. The mechanism behind Candle plots and Violin plots is very similar. Because of this they are; implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing of; the corresponding plots. Followed by the keyword the user can select a plot direction (",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:41760,Performance,optimiz,optimized,41760,");; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }; End_Macro. \since **ROOT version 6.07/03:**. A second rendering technique is also available with the COL2 and COLZ2 options. These options provide potential performance improvements compared to the standard; COL option. The performance comparison of the COL2 to the COL option depends on; the histogram and the size of the rendering region in the current pad. In general,; a small (approx. less than 100 bins per axis), sparsely populated TH2 will render; faster with the COL option. However, for larger histograms (approx. more than 100 bins per axis); that are not sparse, the COL2 option will provide up to 20 times performance improvements.; For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude; faster with the COL2 option. The COL2 option will also scale its performance based on the size of the; pixmap the histogram image is being rendered into. It also is much better optimized for; sessions where the user is forwarding X11 windows through an `ssh` connection. For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL; and COLZ options. There is one major difference and that concerns the treatment of; bins with zero content. The COL2 and COLZ2 options color these bins the color of zero. COL2 option renders the histogram as a bitmap. Therefore it cannot be saved in vector; graphics file format like PostScript or PDF (an empty image will be generated). It can; be saved only in bitmap files like PNG format for instance. \anchor HP140; ### The CANDLE and VIOLIN options. The mechanism behind Candle plots and Violin plots is very similar. Because of this they are; implemented in the same class TCandle. The keywords CANDLE or VIOLIN will initiate the drawing of; the corresponding plots. Followed by the keyword the user can select a plot direction (X or V for; vertical projections, or Y or H for horizontal projections) and/or predefined definitions; (1-6 for candles, ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:53981,Performance,perform,performed,53981,"s:; - If p=1 the points represent the outliers. If they are shown, it means; some parts of the underlying distribution are not covered by the whiskers.; This can only occur when the whiskers are set to option w=2. Here the whiskers; can have a maximum length of \f$ 1.5 \times iqr \f$. So any points outside the; whiskers will be drawn as outliers. The outliers will be represented by crosses.; - If p=2 all points in the distribution will be painted as crosses. This is; useful for small datasets only (up to 10 or 20 points per candle).; The outliers are shown along the candle. Because the underlying distribution; is binned, is frequently occurs that a bin contains more than one value.; Because of this the points will be randomly scattered within their bin along; the candle axis. If the bin content for a bin is exactly 1 (usually; this happens for the outliers) if will be drawn in the middle of the bin along; the candle axis. As the maximum number of points per candle is limited by kNMax/2; on very large datasets scaling will be performed automatically. In that case one; would loose all outliers because they have usually a bin content of 1 (and a; bin content between 0 and 1 after the scaling). Because of this all bin contents; between 0 and 1 - after the scaling - will be forced to be 1.; - As the drawing of all values on large datasets can lead to big amounts of crosses,; one can show all values as a scatter plot instead by choosing p=3. The points will be; drawn as dots and will be scattered within the width of the candle. The color; of the points will be the color of the candle-chart. ##### Other Options; Is is possible to combine all options of candle and violin plots with each other. E.g. a box-plot; with a histogram. #### How to use the candle-plots drawing option. There are six predefined candle-plot representations:. - ""CANDLEX1"": Standard candle (whiskers cover the whole distribution); - ""CANDLEX2"": Standard candle with better whisker definition + outliers.; I",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:67707,Performance,perform,performed,67707,"e; colors to distinguish contours (`SURF` option at theta = 0). Combined; with the option `CONT` (or `CONT0`), the option `Z`; allows to display the color palette defined by `gStyle->SetPalette()`. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; hcont4->Draw(""CONT4Z"");; }; End_Macro. The default number of contour levels is 20 equidistant levels and can be changed; with `TH1::SetContour()` or `TStyle::SetNumberContours()`. \anchor HP16a; #### The LIST option. When option `LIST` is specified together with option; `CONT`, the points used to draw the contours are saved in; `TGraph` objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in `TGraph` objects once the pad is painted.; Therefore to use this functionality in a macro, `gPad->Update()`; should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where `i` is a contour number, and list contains a list of; `TGraph` objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example (ContourList.C) shows how to use this functionality. Begin_Macro(source); ../../../tutorials/hist/ContourList.C; End_Macro. \anchor HP16b; #### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options. The following options select the `CONT4` option and are useful for; sky maps or exposure maps (earth.C). | Option | Description |; |--------------|-----------------",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:86393,Performance,CACHE,CACHEREAD,86393,"ire"", ""new_jersey"",; ""new_mexico"", ""new_york"", ""north_carolina"", ""north_dakota"",; ""ohio"", ""oklahoma"", ""oregon"", ""pennsylvania"",; ""rhode_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };. Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; auto p = new TH2Poly(""USA"",""USA Population"",lon1,lon2,lat1,lat2);. TFile::SetCacheFileDir(""."");; auto f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");. TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }. for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);. gStyle->SetOptStat(11);; p->Draw(""COLZ L"");; }; End_Macro. `TH2Poly` histograms can also be plotted using the GL interface using; the option ""GLLEGO"". \since **ROOT version 6.09/01**. In some cases it can be useful to not draw the empty bins. the option ""0""; combined with the option ""COL"" et COLZ allows to do that. Begin_Macro(source); {; auto chc = new TCanvas(""chc"",""chc"",600,400);. auto hc = new TH2Poly();; hc->Honeycomb(0,0,.1,25,25);; hc->SetName(""hc"");; hc->SetTitle(""Option COLZ 0"");; TRandom ran;; for (int i = 0; i<300; i++) hc->Fill(ran.Gaus(2.,1), ran.Gaus(2.,1));; hc->Draw(""colz 0"");; }; End_Macro. \anchor HP21; ### The SPEC option. This option allows to use the `TSpectrum2Painter` to",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:102152,Performance,perform,performed,102152,"res are drawn instead of boxes.|. \anchor HP29c; #### TH3 as iso-surface(s). The supported option is:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLISO"" | TH3 is drawn using iso-surfaces.|. \anchor HP29d; #### TF3 (implicit function). The supported option is:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GL"" | Draw a TF3.|. \anchor HP29e; #### Parametric surfaces. `$ROOTSYS/tutorials/gl/glparametric.C` shows how to create parametric; equations and visualize the surface. \anchor HP29f; #### Interaction with the plots. All the interactions are implemented via standard methods; `DistancetoPrimitive()` and `ExecuteEvent()`. That's why all the; interactions with the OpenGL plots are possible only when the mouse cursor is; in the plot's area (the plot's area is the part of a the pad occupied by; gl-produced picture). If the mouse cursor is not above gl-picture, the standard; pad interaction is performed. \anchor HP29g; #### Selectable parts. Different parts of the plot can be selected:. - xoz, yoz, xoy back planes: When such a plane selected, it's highlighted in green; if the dynamic slicing by this plane is supported, and it's highlighted in red,; if the dynamic slicing is not supported.; - The plot itself:; On surfaces, the selected surface is outlined in red. (TF3 and; ISO are not outlined). On lego plots, the selected bin is; highlighted. The bin number and content are displayed in pad's; status bar. In box plots, the box or sphere is highlighted and; the bin info is displayed in pad's status bar. \anchor HP29h; #### Rotation and zooming. - Rotation:; When the plot is selected, it can be rotated by pressing and; holding the left mouse button and move the cursor.; - Zoom/Unzoom:; Mouse wheel or 'j', 'J', 'k', 'K' keys. \anchor HP29i; #### Panning. The selected plot can be moved in a pad's area by pressing and; holding the left mouse butto",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:8627,Safety,avoid,avoids,8627,"xis is drawn on the top side of the plot. |; | ""Y+"" | The Y-axis is drawn on the right side of the plot. |; | ""MIN0"" | Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). |. \anchor HP01b; #### Options supported for 1D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default. |; | ""AH"" | Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis.|; | ""]["" | When this option is selected the first and last vertical lines of the histogram are not drawn.|; | ""B"" | Bar chart option.|; | ""BAR"" | Like option ""B"", but bars can be drawn with a 3D effect.|; | ""HBAR"" | Like option ""BAR"", but bars are drawn horizontally.|; | ""C"" | Draw a smooth Curve through the histogram bins.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E1"" | Draw error bars with perpendicular lines at the edges.|; | ""E2"" | Draw error bars with rectangles.|; | ""E3"" | Draw a fill area through the end points of the vertical error bars.|; | ""E4"" | Draw a smoothed filled area through the end points of the error bars.|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; | ""L"" | Draw a line through the bin contents.|; | ""P"" | Draw current marker at each bin except empty bins.|; | ""P*"" | Draw a star marker at each bin except empty bins.|; | ""P0"" | Draw current marker at each bin including empty bins.|; | ""PIE"" | Draw histogram as a Pie Chart.|; | ""*H"" | Draw histogram with a * at each bin.|; | ""LF2"" | Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histo",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26318,Safety,avoid,avoids,26318,"print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. 1. When `v = 1` is specified, only the non-fixed parameters are shown.; 2. When `v = 2` all parameters are shown. Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; to `gStyle->SetOptFit(111)`. \anchor HP09; ### The error bars options. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""E"" | Default. Shows only the error bars, not a marker.|; | ""E1"" | Small lines are drawn at the end of the error bars.|; | ""E2"" | Error rectangles are drawn.|; | ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; | ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; | ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; | ""E5"" | Like E3 but ignore the bins with 0 contents.|; | ""E6"" | Like E4 but ignore the bins with 0 contents.|; | ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; End_Macro. The options ""E3"" and ""E4"" draw an error band through the end points of the; vertical error bars. With ""E4"" the error band is smoothed. Because of the; smoothing algorithm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn wit",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:98504,Safety,avoid,avoid,98504,"and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Begin_Macro(source); {; auto c2 = new TCanvas(""c2"",""c2"",600,400);; auto f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; }; End_Macro. \anchor HP28; ### Associated functions drawing. An associated function is created by `TH1::Fit`. More than on fitted; function can be associated with one histogram (see `TH1::Fit`). A `TF1` object `f1` can be added to the list of associated; functions of an histogram `h` without calling `TH1::Fit`; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option `HIST`; should be added to the list of the options used to paint the histogram. \anchor HP29; ### Drawing using OpenGL. The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with `GL` keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. \anchor HP29a; #### General information: plot types and supported options. The following types of plots are provided:. For lego plots the supported options are:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; | ""GLLEGO2""| Bins with color levels.|; | ""GLLEGO3""| Cylindrical bars.|. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y. For surface plots (`TF2` and `TH2`) the supp",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:23526,Security,access,accessed,23526,"and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : standard deviation printed; R : standard deviation and standard deviation error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a `TPaveStats` object is created and added; to the list of functions of the histogram. If a `TPaveStats` object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters. Once a histogram is painted, the statistics box can be accessed using; `h->FindObject(""stats"")`. In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after `h->Draw()` the histogram is automatically painted. But; in a script file the painting should be forced using `gPad->Update()`; in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer. When a histogram is drawn with the option `SAME`, the statistics box; is not drawn. To force the statistics box drawing with the option; `SAME`, the option `SAMES` must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (`h` being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2)",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:44471,Security,access,accessed,44471,"`; draw a filled box with border. - `m = 0`; no median drawn; - `m = 1`; median is drawn as a line; - `m = 2`; median is drawn with errors (notches); - `m = 3`; median is drawn as a circle. - `M = 0`; no mean drawn; - `M = 1`; mean is drawn as a dashed line; - `M = 3`; mean is drawn as a circle. - `w = 0`; no whisker drawn; - `w = 1`; whisker is drawn to end of distribution.; - `w = 2`; whisker is drawn to max 1.5*iqr. - `a = 0`; no anchor drawn; - `a = 1`; the anchors are drawn. - `p = 0`; no points drawn; - `p = 1`; only outliers are drawn; - `p = 2`; all datapoints are drawn; - `p = 3`: all datapoints are drawn scattered. - `h = 0`; no histogram is drawn; - `h = 1`; histogram at the left or bottom side is drawn; - `h = 2`; histogram at the right or top side is drawn; - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn. - `z = 0`; no zero indicator line is drawn; - `z = 1`; zero indicator line is drawn. As one can see all individual options for both candle and violin plots can be accessed by this; mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; vice versa, if you wish. Using a logarithmic x- or y-axis is possible for candle and violin charts. \since **ROOT version 6.11/01**. a logarithmic z-axis is possible, too but will only affect violin charts of course. \anchor HP140a; #### The CANDLE option. <a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; way to describe graphically a data distribution (D) with only five numbers:. 1. The minimum value of the distribution D (bottom or left whisker).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:58868,Security,hash,hashed,58868,"be; scaled with respect to each other, the maximum height can be influenced by SetBarWidth().; Deactivated, the height of the bin with the maximum content of each individual violin is; set to a constant value using SetBarWidth(). The static function will affect all violin-charts; in the running program. Default is true. Scaling between multiple violin-charts; (using ""same"" or THStack) is not supported, yet. ##### The zero indicator line; Typical for violin charts is a line in the background over the whole histogram indicating; the bins with zero entries. The zero indicator line can be activated with z=1. The line color; will always be the same as the fill-color of the histogram. ##### The Mean; The Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used. ##### Whiskers; The whiskers are illustrated by the same mechanism as used for candle plots. There is only one; difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then; the whiskers will be forced to be solid (usually hashed). ##### Points; The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses; better whisker definition (w=2) and outliers (p=1). ##### Other options; It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot; including a box-plot. #### How to use the violin-plots drawing option. There are two predefined violin-plot representations:; - ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution,; zero indicator line); - ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers. A solid fill style is recommended for this plot (as opposed to a hollow or; hashed style). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; auto hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1""",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:59540,Security,hash,hashed,59540,"he Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used. ##### Whiskers; The whiskers are illustrated by the same mechanism as used for candle plots. There is only one; difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then; the whiskers will be forced to be solid (usually hashed). ##### Points; The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses; better whisker definition (w=2) and outliers (p=1). ##### Other options; It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot; including a box-plot. #### How to use the violin-plots drawing option. There are two predefined violin-plot representations:; - ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution,; zero indicator line); - ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers. A solid fill style is recommended for this plot (as opposed to a hollow or; hashed style). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; auto hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1"", ""gaus"", +0,0 +4.0);; double x,y;; for (Int_t iBin=1; iBin<hviolin->GetNbinsX(); ++iBin) {; double xc = hviolin->GetXaxis()->GetBinCenter(iBin);; f1.SetParameters(1, 2.0+TMath::Sin(1.0+xc), 0.2+0.1*(xc-xmin)/xmax);; for(Int_t i=0; i<10000; ++i){; x = xc;; y = f1.GetRandom();; hviolin->Fill(x, y);; }; }; hviolin->SetFillColor(kGray);; hviolin->SetMarkerStyle(20);; hviolin->SetMarkerSize(0.5);; hviolin->Draw(""VIOLIN"");; c1->Update();; }; End_Macro. The next example illustrates a time development of a certain value:. Begin_Macro(source); ../../../tutorials/hist/candledecay.C; End_Macro. \anchor HP15; ### The TEXT and TEXTnn Option. For each bin the content is printed. The text attributes are:. - tex",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:67788,Security,access,accessible,67788," (or `CONT0`), the option `Z`; allows to display the color palette defined by `gStyle->SetPalette()`. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcont4 = new TH2F(""hcont4"",""Option CONT4Z example "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcont4->Fill(px-1,5*py);; hcont4->Fill(2+0.5*px,2*py-10.,0.1);; }; hcont4->Draw(""CONT4Z"");; }; End_Macro. The default number of contour levels is 20 equidistant levels and can be changed; with `TH1::SetContour()` or `TStyle::SetNumberContours()`. \anchor HP16a; #### The LIST option. When option `LIST` is specified together with option; `CONT`, the points used to draw the contours are saved in; `TGraph` objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in `TGraph` objects once the pad is painted.; Therefore to use this functionality in a macro, `gPad->Update()`; should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where `i` is a contour number, and list contains a list of; `TGraph` objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example (ContourList.C) shows how to use this functionality. Begin_Macro(source); ../../../tutorials/hist/ContourList.C; End_Macro. \anchor HP16b; #### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options. The following options select the `CONT4` option and are useful for; sky maps or exposure maps (earth.C). | Option | Description |; |--------------|---------------------------------------------------------------|; | ""AITOFF"" | Draw a contour via an AITOFF proje",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:68211,Security,access,access,68211," contour levels is 20 equidistant levels and can be changed; with `TH1::SetContour()` or `TStyle::SetNumberContours()`. \anchor HP16a; #### The LIST option. When option `LIST` is specified together with option; `CONT`, the points used to draw the contours are saved in; `TGraph` objects:. h->Draw(""CONT LIST"");; gPad->Update();. The contour are saved in `TGraph` objects once the pad is painted.; Therefore to use this functionality in a macro, `gPad->Update()`; should be performed after the histogram drawing. Once the list is; built, the contours are accessible in the following way:. TObjArray *contours = (TObjArray*)gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize();; TList *list = (TList*)contours->At(i);. Where `i` is a contour number, and list contains a list of; `TGraph` objects.; For one given contour, more than one disjoint polyline may be generated.; The number of TGraphs per contour is given by:. list->GetSize();. To access the first graph in the list one should do:. TGraph *gr1 = (TGraph*)list->First();. The following example (ContourList.C) shows how to use this functionality. Begin_Macro(source); ../../../tutorials/hist/ContourList.C; End_Macro. \anchor HP16b; #### The AITOFF, MERCATOR, SINUSOIDAL and PARABOLIC options. The following options select the `CONT4` option and are useful for; sky maps or exposure maps (earth.C). | Option | Description |; |--------------|---------------------------------------------------------------|; | ""AITOFF"" | Draw a contour via an AITOFF projection.|; | ""MERCATOR"" | Draw a contour via an Mercator projection.|; | ""SINUSOIDAL"" | Draw a contour via an Sinusoidal projection.|; | ""PARABOLIC"" | Draw a contour via an Parabolic projection.|. Begin_Macro(source); ../../../tutorials/graphics/earth.C; End_Macro. \anchor HP17; ### The LEGO options. In a lego plot the cell contents are drawn as 3-d boxes. The height of each box; is proportional to the cell content. The lego aspect is control with t",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:88968,Security,access,access,88968,"s size on the palette axis do:. hist->GetZaxis()->SetLabelSize(). <b>WARNING:</b> The palette axis is always drawn vertically. \anchor HP23; ### Setting the color palette. To change the color palette `TStyle::SetPalette` should be used, eg:. gStyle->SetPalette(ncolors,colors);. For example the option `COL` draws a 2D histogram with cells; represented by a box filled with a color index which is a function; of the cell content.; If the cell content is N, the color index used will be the color number; in `colors[N]`, etc. If the maximum cell content is greater than; `ncolors`, all cell contents are scaled to `ncolors`. If ` ncolors <= 0`, a default palette (see below) of 50 colors is; defined. This palette is recommended for pads, labels ... `if ncolors == 1 && colors == 0`, then a Pretty Palette with a; Spectrum Violet->Red is created with 50 colors. That's the default rain bow; palette. Other pre-defined palettes with 255 colors are available when `colors == 0`.; The following value of `ncolors` give access to:. if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors. The default palette defines:. - index 0 to 9 : shades of grey; - index 10 to 19 : shades of brown; - index 20 to 29 : shades of blue; - index 30 to 39 : shades of red; - index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item `colors` in the `VIEW` menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; `TColor::SetRGB()`. \since **ROO",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:44721,Testability,log,logarithmic,44721,"0`; no whisker drawn; - `w = 1`; whisker is drawn to end of distribution.; - `w = 2`; whisker is drawn to max 1.5*iqr. - `a = 0`; no anchor drawn; - `a = 1`; the anchors are drawn. - `p = 0`; no points drawn; - `p = 1`; only outliers are drawn; - `p = 2`; all datapoints are drawn; - `p = 3`: all datapoints are drawn scattered. - `h = 0`; no histogram is drawn; - `h = 1`; histogram at the left or bottom side is drawn; - `h = 2`; histogram at the right or top side is drawn; - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn. - `z = 0`; no zero indicator line is drawn; - `z = 1`; zero indicator line is drawn. As one can see all individual options for both candle and violin plots can be accessed by this; mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; vice versa, if you wish. Using a logarithmic x- or y-axis is possible for candle and violin charts. \since **ROOT version 6.11/01**. a logarithmic z-axis is possible, too but will only affect violin charts of course. \anchor HP140a; #### The CANDLE option. <a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; way to describe graphically a data distribution (D) with only five numbers:. 1. The minimum value of the distribution D (bottom or left whisker).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 5. The maximum value of the distribution D (top or right whisker). In this implementation a TH2 is considered as a collection of TH1 along; X (option `CANDLE` or `CANDLEX`) or Y (option `CANDLEY`).; Each TH1 is represented as one candle",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:44823,Testability,log,logarithmic,44823,"*iqr. - `a = 0`; no anchor drawn; - `a = 1`; the anchors are drawn. - `p = 0`; no points drawn; - `p = 1`; only outliers are drawn; - `p = 2`; all datapoints are drawn; - `p = 3`: all datapoints are drawn scattered. - `h = 0`; no histogram is drawn; - `h = 1`; histogram at the left or bottom side is drawn; - `h = 2`; histogram at the right or top side is drawn; - `h = 3`; histogram at left and right or top and bottom (violin-style) is drawn. - `z = 0`; no zero indicator line is drawn; - `z = 1`; zero indicator line is drawn. As one can see all individual options for both candle and violin plots can be accessed by this; mechanism. In deed the keywords CANDLE(<option-string>) and VIOLIN(<option-string>) have the same; meaning. So you can parametrise an option-string for a candle plot and use the keywords VIOLIN and; vice versa, if you wish. Using a logarithmic x- or y-axis is possible for candle and violin charts. \since **ROOT version 6.11/01**. a logarithmic z-axis is possible, too but will only affect violin charts of course. \anchor HP140a; #### The CANDLE option. <a href=""http://en.wikipedia.org/wiki/Box_plot"">A Candle plot</a> (also known as; a ""box plot"" or ""whisker plot"") was invented in 1977 by John Tukey. It is a convenient; way to describe graphically a data distribution (D) with only five numbers:. 1. The minimum value of the distribution D (bottom or left whisker).; 2. The lower quartile (Q1): 25% of the data points in D are less than Q1 (bottom of the box).; 3. The median (M): 50% of the data points in D are less than M.; 4. The upper quartile (Q3): 75% of the data points in D are less than Q3 (top of the box).; 5. The maximum value of the distribution D (top or right whisker). In this implementation a TH2 is considered as a collection of TH1 along; X (option `CANDLE` or `CANDLEX`) or Y (option `CANDLEY`).; Each TH1 is represented as one candle. Begin_Macro(source); ../../../tutorials/hist/candleplotwhiskers.C; End_Macro. The candle reduces the informati",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:90048,Testability,log,log,90048,"sed.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used. If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors. The default palette defines:. - index 0 to 9 : shades of grey; - index 10 to 19 : shades of brown; - index 20 to 29 : shades of blue; - index 30 to 39 : shades of red; - index 40 to 49 : basic colors. The color numbers specified in the palette can be viewed by selecting; the item `colors` in the `VIEW` menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; `TColor::SetRGB()`. \since **ROOT version 6.19/01**. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; For more details see `TPaletteAxis`. \anchor HP24; ### Drawing a sub-range of a 2D histogram; the [cutg] option. Using a `TCutG` object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between `[]` in the `Draw()` option.; For example (fit2a.C), with a `TCutG` named `cutg`, one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a `-` in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts (`,` means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Begin_Macro(source); ../../../tutorials/fit/fit2a.C; End_Macro. \anchor HP25; ### Drawing options for 3D histograms. | Option | Description |; |----------|------------------------------------------------------------",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:90765,Testability,log,logical,90765,"the palette can be viewed by selecting; the item `colors` in the `VIEW` menu of the canvas tool bar.; The red, green, and blue components of a color can be changed thanks to; `TColor::SetRGB()`. \since **ROOT version 6.19/01**. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; For more details see `TPaletteAxis`. \anchor HP24; ### Drawing a sub-range of a 2D histogram; the [cutg] option. Using a `TCutG` object, it is possible to draw a sub-range of a 2D; histogram. One must create a graphical cut (mouse or C++) and specify the name; of the cut between `[]` in the `Draw()` option.; For example (fit2a.C), with a `TCutG` named `cutg`, one can call:. myhist->Draw(""surf1 [cutg]"");. To invert the cut, it is enough to put a `-` in front of its name:. myhist->Draw(""surf1 [-cutg]"");. It is possible to apply several cuts (`,` means logical AND):. myhist->Draw(""surf1 [cutg1,cutg2]"");. Begin_Macro(source); ../../../tutorials/fit/fit2a.C; End_Macro. \anchor HP25; ### Drawing options for 3D histograms. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""SCAT"" | Draw a scatter plot (legacy draw option).|; | ""ISO"" | Draw a Gouraud shaded 3d iso surface through a 3d histogram. It paints one surface at the value computed as follow: `SumOfWeights/(NbinsX*NbinsY*NbinsZ)`|; | ""BOX"" | Draw a for each cell with volume proportional to the content's absolute value. An hidden line removal algorithm is used|; | ""BOX1"" | Same as BOX but an hidden surface removal algorithm is used|; | ""BOX2"" | Same as ""COL"". The boxes' colors are picked in the current palette according to the bins' contents (default)|; | ""BOX2Z"" | Same as ""BOX2"". In addition the color palette is also drawn.|; | ""BOX3"" | Same as BOX1, but the border lines of each lego-bar are not drawn.|. No",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:99429,Testability,log,logarithmic,99429,"ssociated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option `HIST`; should be added to the list of the options used to paint the histogram. \anchor HP29; ### Drawing using OpenGL. The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with `GL` keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. \anchor HP29a; #### General information: plot types and supported options. The following types of plots are provided:. For lego plots the supported options are:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; | ""GLLEGO2""| Bins with color levels.|; | ""GLLEGO3""| Cylindrical bars.|. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y. For surface plots (`TF2` and `TH2`) the supported options are:. | Option | Description |; |-----------|------------------------------------------------------------------|; | ""GLSURF"" | Draw a surface.|; | ""GLSURF1"" | Surface with color levels|; | ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; | ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; | ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis. Additional options to SURF and LEGO - Coordinate systems:. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default, cartesian coordinates system.|; | ""POL"" | Pol",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:99490,Testability,log,logarithmic,99490," drawn.; To avoid the painting of the associated functions the option `HIST`; should be added to the list of the options used to paint the histogram. \anchor HP29; ### Drawing using OpenGL. The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with `GL` keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. \anchor HP29a; #### General information: plot types and supported options. The following types of plots are provided:. For lego plots the supported options are:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; | ""GLLEGO2""| Bins with color levels.|; | ""GLLEGO3""| Cylindrical bars.|. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y. For surface plots (`TF2` and `TH2`) the supported options are:. | Option | Description |; |-----------|------------------------------------------------------------------|; | ""GLSURF"" | Draw a surface.|; | ""GLSURF1"" | Surface with color levels|; | ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; | ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; | ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis. Additional options to SURF and LEGO - Coordinate systems:. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default, cartesian coordinates system.|; | ""POL"" | Polar coordinates system.|; | ""CYL"" | Cylindrical coordinates system.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:100056,Testability,log,logarithmic,100056,"upported options. The following types of plots are provided:. For lego plots the supported options are:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; | ""GLLEGO2""| Bins with color levels.|; | ""GLLEGO3""| Cylindrical bars.|. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y. For surface plots (`TF2` and `TH2`) the supported options are:. | Option | Description |; |-----------|------------------------------------------------------------------|; | ""GLSURF"" | Draw a surface.|; | ""GLSURF1"" | Surface with color levels|; | ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; | ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; | ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis. Additional options to SURF and LEGO - Coordinate systems:. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default, cartesian coordinates system.|; | ""POL"" | Polar coordinates system.|; | ""CYL"" | Cylindrical coordinates system.|; | ""SPH"" | Spherical coordinates system.|. \anchor HP290; #### TH3 as color boxes. The supported option is:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLCOL"" | H3 is drawn using semi-transparent colored boxes. See `$ROOTSYS/tutorials/gl/glvox1.C`.|. \anchor HP29b; #### TH3 as boxes (spheres). The supported options are:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLBOX"" | TH3 as a set of boxes, size of box is prop",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:100140,Testability,log,logarithmic,100140,"are:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLLEGO"" | Draw a lego plot. It works also for `TH2Poly`.|; | ""GLLEGO2""| Bins with color levels.|; | ""GLLEGO3""| Cylindrical bars.|. Lego painter in cartesian supports logarithmic scales for X, Y, Z.; In polar only Z axis can be logarithmic, in cylindrical only Y. For surface plots (`TF2` and `TH2`) the supported options are:. | Option | Description |; |-----------|------------------------------------------------------------------|; | ""GLSURF"" | Draw a surface.|; | ""GLSURF1"" | Surface with color levels|; | ""GLSURF2"" | The same as ""GLSURF1"" but without polygon outlines.|; | ""GLSURF3"" | Color level projection on top of plot (works only in cartesian coordinate system).|; | ""GLSURF4"" | Same as ""GLSURF"" but without polygon outlines.|. The surface painting in cartesian coordinates supports logarithmic scales along; X, Y, Z axis. In polar coordinates only the Z axis can be logarithmic,; in cylindrical coordinates only the Y axis. Additional options to SURF and LEGO - Coordinate systems:. | Option | Description |; |----------|-------------------------------------------------------------------|; | "" "" | Default, cartesian coordinates system.|; | ""POL"" | Polar coordinates system.|; | ""CYL"" | Cylindrical coordinates system.|; | ""SPH"" | Spherical coordinates system.|. \anchor HP290; #### TH3 as color boxes. The supported option is:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLCOL"" | H3 is drawn using semi-transparent colored boxes. See `$ROOTSYS/tutorials/gl/glvox1.C`.|. \anchor HP29b; #### TH3 as boxes (spheres). The supported options are:. | Option | Description |; |----------|-------------------------------------------------------------------|; | ""GLBOX"" | TH3 as a set of boxes, size of box is proportional to bin content.|; | ""GLBOX1"" | The same as ""glbox"", but spheres are drawn instead of boxe",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:3161,Usability,usab,usable,3161," HP26); - [Drawing of 3D implicit functions](\ref HP27); - [Associated functions drawing](\ref HP28); - [Drawing using OpenGL](\ref HP29); - [General information: plot types and supported options](\ref HP29a); - [TH3 as color boxes](\ref HP290); - [TH3 as boxes (spheres)](\ref HP29b); - [TH3 as iso-surface(s)](\ref HP29c); - [TF3 (implicit function)](\ref HP29d); - [Parametric surfaces](\ref HP29e); - [Interaction with the plots](\ref HP29f); - [Selectable parts](\ref HP29g); - [Rotation and zooming](\ref HP29h); - [Panning](\ref HP29i); - [Box cut](\ref HP29j); - [Plot specific interactions (dynamic slicing etc.)](\ref HP29k); - [Surface with option ""GLSURF""](\ref HP29l); - [TF3](\ref HP29m); - [Box](\ref HP29n); - [Iso](\ref HP29o); - [Parametric plot](\ref HP29p); - [Highlight mode for histogram](\ref HP30); - [Highlight mode and user function](\ref HP30a). \anchor HP00; ## Introduction. Histograms are drawn via the `THistPainter` class. Each histogram has a; pointer to its own painter (to be usable in a multithreaded program). When the; canvas has to be redrawn, the `Paint` function of each objects in the; pad is called. In case of histograms, `TH1::Paint` invokes directly; `THistPainter::Paint`. To draw a histogram `h` it is enough to do:. h->Draw();. `h` can be of any kind: 1D, 2D or 3D. To choose how the histogram will; be drawn, the `Draw()` method can be invoked with an option. For instance; to draw a 2D histogram as a lego plot it is enough to do:. h->Draw(""lego"");. `THistPainter` offers many options to paint 1D, 2D and 3D histograms. When the `Draw()` method of a histogram is called for the first time; (`TH1::Draw`), it creates a `THistPainter` object and saves a; pointer to this ""painter"" as a data member of the histogram. The; `THistPainter` class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram having its own; pain",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:4672,Usability,clear,clears,4672,"nt 1D, 2D and 3D histograms. When the `Draw()` method of a histogram is called for the first time; (`TH1::Draw`), it creates a `THistPainter` object and saves a; pointer to this ""painter"" as a data member of the histogram. The; `THistPainter` class specializes in the drawing of histograms. It is; separated from the histogram so that one can have histograms without the; graphics overhead, for example in a batch program. Each histogram having its own; painter (rather than a central singleton painter painting all histograms), allows; two histograms to be drawn in two threads without overwriting the painter's; values. When a displayed histogram is filled again, there is no need to call the; `Draw()` method again; the image will be refreshed the next time the; pad will be updated. A pad is updated after one of these three actions:. 1. a carriage control on the ROOT command line,; 2. a click inside the pad,; 3. a call to `TPad::Update`. By default a call to `TH1::Draw()` clears the pad of all objects; before drawing the new image of the histogram. One can use the `SAME`; option to leave the previous display intact and superimpose the new histogram.; The same histogram can be drawn with different graphics options in different; pads. When a displayed histogram is deleted, its image is automatically removed; from the pad. To create a copy of the histogram when drawing it, one can use; `TH1::DrawClone()`. This will clone the histogram and allow to change; and delete the original one without affecting the clone. \anchor HP01; ### Histograms' plotting options. Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with `TH1::SetOption` and retrieve; using `TH1::GetOption`:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Chang",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:17817,Usability,clear,cleared,17817,">GetTickx()` and `ty = gPad->GetTicky()` then:. tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (`tx = ty = 0`). `TPad::SetTicks(tx,ty)` allows to set these options.; See also The `TAxis` functions to set specific axis attributes. In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. \anchor HP05; ### Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any `TLatex` string.; The titles are part of the persistent histogram. \anchor HP060; ### The option ""SAME"". By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option `SAME` should be use. The histogram drawn with the option; `SAME` uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care. \anchor HP060a; #### Limitations. - It does not work when combined with the `LEGO` and `SURF` options unless the; histogram plotted with the option `SAME` has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots [histograms' stacks](\ref HP26) should be used. \anchor HP061; ### Colors automatically picked in palette. \since **ROOT version 6.09/01**. When several histograms are painted in the same canvas thanks to the option ""SAME""; or via a `THStack` it might be useful to have an easy and automatic way to choose; their color. The simplest way is to pick colors in the current activ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:18748,Usability,simpl,simplest,18748,"istogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option `SAME` should be use. The histogram drawn with the option; `SAME` uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care. \anchor HP060a; #### Limitations. - It does not work when combined with the `LEGO` and `SURF` options unless the; histogram plotted with the option `SAME` has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots [histograms' stacks](\ref HP26) should be used. \anchor HP061; ### Colors automatically picked in palette. \since **ROOT version 6.09/01**. When several histograms are painted in the same canvas thanks to the option ""SAME""; or via a `THStack` it might be useful to have an easy and automatic way to choose; their color. The simplest way is to pick colors in the current active color; palette. Palette coloring for histogram is activated thanks to the options `PFC`; (Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; When one of these options is given to `TH1::Draw` the histogram get its color; from the current color palette defined by `gStyle->SetPalette(...)`. The color; is determined according to the number of objects having palette coloring in; the current pad. Begin_Macro(source); ../../../tutorials/hist/histpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/hist/thstackpalettecolor.C; End_Macro. Begin_Macro(source); ../../../tutorials/hist/thstack2palettecolor.C; End_Macro. \anchor HP06; ### Superimposing two histograms with different scales in the same pad. The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new v",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:28068,Usability,simpl,simple,28068,"thm used some artefacts may appear at the end of the band; like in the following example. In such cases ""E3"" should be used instead; of ""E4"". Begin_Macro(source); {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; auto he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; }; End_Macro. 2D histograms can be drawn with error bars as shown is the following example:. Begin_Macro(source); {; auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; }; End_Macro. \anchor HP100; ### The bar chart option. The option ""B"" allows to draw simple vertical bar charts.; The bar width is controlled with `TH1::SetBarWidth()`,; and the bar offset within the bin, with `TH1::SetBarOffset()`.; These two settings are useful to draw several histograms on the; same plot as shown in the following example:. Begin_Macro(source); {; int i;; const Int_t nx = 8;; string os_X[nx] = {""8"",""32"",""128"",""512"",""2048"",""8192"",""32768"",""131072""};; float d_35_0[nx] = {0.75, -3.30, -0.92, 0.10, 0.08, -1.69, -1.29, -2.37};; float d_35_1[nx] = {1.01, -3.02, -0.65, 0.37, 0.34, -1.42, -1.02, -2.10};. auto cb = new TCanvas(""cb"",""cb"",600,400);; cb->SetGrid();. gStyle->SetHistMinimumZero();. auto h1b = new TH1F(""h1b"",""Option B example"",nx,0,nx);; h1b->SetFillColor(4);; h1b->SetBarWidth(0.4);; h1b->SetBarOffset(0.1);; h1b->SetStats(0);; h1b->SetMinimum(-5);; h1b->SetMaximum(5);. for (i=1; i<=nx; i++) {; h1b->SetBinContent(i, d_35_0[i-1]);; h1b->GetXaxis()->SetBinLabel(i,os_X[i-1].c_str());; }. h1b->Draw(""b"");. auto h2b = new TH1F(""h2b"",""h2b"",nx,0,nx);; h2b-",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:51149,Usability,simpl,simple,51149,"; distribution). Candle plots like these are usually called ""notched candle plots"". In case the significance of the median is greater that the size of the box, the; box will have an unnatural shape. Usually it means the chart has not enough data,; or that representing this uncertainty is not useful. ##### The Mean; The mean can be drawn as a dashed line or as a circle or not drawn at all.; The mean is the arithmetic average of the values in the distribution.; It is calculated using GetMean(). Because histograms are; binned data, the mean value can differ from a calculation on the raw-data.; If the distribution is large enough and gaussian shaped the mean will be; exactly the median. ##### The Whiskers; The whiskers represent the part of the distribution not covered by the box.; The upper 25% and the lower 25% of the distribution are located within the whiskers.; Two representations are available. - A simple one (using w=1) defining the lower whisker from the lowest data value; to the bottom of the box, and the upper whisker from the top of the box to the; highest data value. In this representation the whisker-lines are dashed.; - A more complex one having a further restriction. The whiskers are still connected; to the box but their length cannot exceed \f$ 1.5\times iqr \f$. So it might; be that the outermost part of the underlying distribution will not be covered; by the whiskers. Usually these missing parts will be represented by the outliers; (see points). Of course the upper and the lower whisker may differ in length.; In this representation the whiskers are drawn as solid lines. \since **ROOT version 6.11/01**. Using the static function TCandle::SetWhiskerRange(double) the whisker definition w=1; will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of; the lower whisker to the upper whisker in order to cover 95% of the distribution inside; that candle. The static function will affect all candle-charts in the running program.; D",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:58746,Usability,simpl,simple,58746,"be; scaled with respect to each other, the maximum height can be influenced by SetBarWidth().; Deactivated, the height of the bin with the maximum content of each individual violin is; set to a constant value using SetBarWidth(). The static function will affect all violin-charts; in the running program. Default is true. Scaling between multiple violin-charts; (using ""same"" or THStack) is not supported, yet. ##### The zero indicator line; Typical for violin charts is a line in the background over the whole histogram indicating; the bins with zero entries. The zero indicator line can be activated with z=1. The line color; will always be the same as the fill-color of the histogram. ##### The Mean; The Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used. ##### Whiskers; The whiskers are illustrated by the same mechanism as used for candle plots. There is only one; difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then; the whiskers will be forced to be solid (usually hashed). ##### Points; The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses; better whisker definition (w=2) and outliers (p=1). ##### Other options; It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot; including a box-plot. #### How to use the violin-plots drawing option. There are two predefined violin-plot representations:; - ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution,; zero indicator line); - ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers. A solid fill style is recommended for this plot (as opposed to a hollow or; hashed style). Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; Int_t nx(6), ny(40);; double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; auto hviolin = new TH2F(""hviolin"", ""Option VIOLIN example"", nx, xmin, xmax, ny, ymin, ymax);; TF1 f1(""f1""",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:83767,Usability,simpl,simple,83767,"----------------------------------------------------------------|; | ""SCAT"" | Draw a scatter plot (legacy draw option).|; | ""COL"" | Draw a color plot. All the bins are painted even the empty bins (default).|; | ""COLZ"" | Same as ""COL"". In addition the color palette is also drawn.|; | ""0"" | When used with any COL options, the empty bins are not drawn.|; | ""TEXT"" | Draw bin contents as text (format set via `gStyle->SetPaintTextFormat`).|; | ""TEXTN"" | Draw bin names as text.|; | ""TEXTnn"" | Draw bin contents as text at angle nn (0 < nn <= 90).|; | ""L"" | Draw the bins boundaries as lines. The lines attributes are the TGraphs ones.|; | ""P"" | Draw the bins boundaries as markers. The markers attributes are the TGraphs ones.|; | ""F"" | Draw the bins boundaries as filled polygons. The filled polygons attributes are the TGraphs ones.|. `TH2Poly` can be drawn as a color plot (option COL). `TH2Poly` bins can have any; shapes. The bins are defined as graphs. The following macro is a very simple; example showing how to book a TH2Poly and draw it. Begin_Macro(source); {; auto ch2p1 = new TCanvas(""ch2p1"",""ch2p1"",600,400);; auto h2p = new TH2Poly();; h2p->SetName(""h2poly_name"");; h2p->SetTitle(""h2poly_title"");; double px1[] = {0, 5, 6};; double py1[] = {0, 0, 5};; double px2[] = {0, -1, -1, 0};; double py2[] = {0, 0, -1, 3};; double px3[] = {4, 3, 0, 1, 2.4};; double py3[] = {4, 3.7, 1, 3.7, 2.5};; h2p->AddBin(3, px1, py1);; h2p->AddBin(4, px2, py2);; h2p->AddBin(5, px3, py3);; h2p->Fill(0.1, 0.01, 3);; h2p->Fill(-0.5, -0.5, 7);; h2p->Fill(-0.7, -0.5, 1);; h2p->Fill(1, 3, 1.5);; double fx[] = {0.1, -0.5, -0.7, 1};; double fy[] = {0.01, -0.5, -0.5, 3};; double fw[] = {3, 1, 1, 1.5};; h2p->FillN(4, fx, fy, fw);; h2p->Draw(""col"");; }; End_Macro. Rectangular bins are a frequent case. The special version of; the `AddBin` method allows to define them more easily like; shown in the following example (th2polyBoxes.C). Begin_Macro(source); ../../../tutorials/hist/th2polyBoxes.C; End_Macro. One `",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:98176,Usability,simpl,simply,98176,"2->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");; }; End_Macro. \anchor HP27; ### Drawing of 3D implicit functions. 3D implicit functions (`TF3`) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the; ""Front Box"" and ""Back Box"" around the plot. Begin_Macro(source); {; auto c2 = new TCanvas(""c2"",""c2"",600,400);; auto f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; }; End_Macro. \anchor HP28; ### Associated functions drawing. An associated function is created by `TH1::Fit`. More than on fitted; function can be associated with one histogram (see `TH1::Fit`). A `TF1` object `f1` can be added to the list of associated; functions of an histogram `h` without calling `TH1::Fit`; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option `HIST`; should be added to the list of the options used to paint the histogram. \anchor HP29; ### Drawing using OpenGL. The class `TGLHistPainter` allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with `GL` keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. \anchor HP29a; #### General information: plot types and supported options. The following types of plots are provided:. For lego plots ",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:107244,Usability,simpl,simplified,107244," - when selected object (histogram as a whole) is different from previous; then emit `Picked()` signal; - when selected (highlighted) bin from histogram is different from previous; then emit `Highlighted()` signal. Any user function (or functions) has to be defined; `UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)`.; In example (see below) has name `PrintInfo()`. All parameters of user; function are taken from. void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y). - `pad` is pointer to pad with highlighted histogram; - `obj` is pointer to highlighted histogram; - `x` is highlighted x bin for 1D histogram; - `y` is highlighted y bin for 2D histogram (for 1D histogram not in use). Example how to create a connection from any `TCanvas` object to a user; `UserFunction()` slot (see also `TQObject::Connect()` for additional info). TQObject::Connect(""TCanvas"", ""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"",; 0, 0, ""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");. or use non-static ""simplified"" function; `TCanvas::HighlightConnect(const char *slot)`. c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");. NOTE the signal and slot string must have a form; ""(TVirtualPad*,TObject*,Int_t,Int_t)"". root [0] .x $ROOTSYS/tutorials/hsimple.C; root [1] hpx->SetHighlight(kTRUE); root [2] .x hlprint.C. file `hlprint.C`; ~~~ {.cpp}; void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); {; auto h = (TH1F *)obj;; if (!h->IsHighlight()) // after highlight disabled; h->SetTitle(""highlight disable"");; else; h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; h->GetBinCenter(x), h->GetBinContent(x)));; pad->Update();; }. void hlprint(); {; if (!gPad) return;; gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; }; ~~~. \image html hlsimple.gif ""Highlight mode and simple user function"". For more complex demo please see for example `$ROOTSYS/tutorials/tree/temperature.C` file. */",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:108096,Usability,simpl,simple,108096," - when selected object (histogram as a whole) is different from previous; then emit `Picked()` signal; - when selected (highlighted) bin from histogram is different from previous; then emit `Highlighted()` signal. Any user function (or functions) has to be defined; `UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)`.; In example (see below) has name `PrintInfo()`. All parameters of user; function are taken from. void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y). - `pad` is pointer to pad with highlighted histogram; - `obj` is pointer to highlighted histogram; - `x` is highlighted x bin for 1D histogram; - `y` is highlighted y bin for 2D histogram (for 1D histogram not in use). Example how to create a connection from any `TCanvas` object to a user; `UserFunction()` slot (see also `TQObject::Connect()` for additional info). TQObject::Connect(""TCanvas"", ""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"",; 0, 0, ""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");. or use non-static ""simplified"" function; `TCanvas::HighlightConnect(const char *slot)`. c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");. NOTE the signal and slot string must have a form; ""(TVirtualPad*,TObject*,Int_t,Int_t)"". root [0] .x $ROOTSYS/tutorials/hsimple.C; root [1] hpx->SetHighlight(kTRUE); root [2] .x hlprint.C. file `hlprint.C`; ~~~ {.cpp}; void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); {; auto h = (TH1F *)obj;; if (!h->IsHighlight()) // after highlight disabled; h->SetTitle(""highlight disable"");; else; h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; h->GetBinCenter(x), h->GetBinContent(x)));; pad->Update();; }. void hlprint(); {; if (!gPad) return;; gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; }; ~~~. \image html hlsimple.gif ""Highlight mode and simple user function"". For more complex demo please see for example `$ROOTSYS/tutorials/tree/temperature.C` file. */",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:320,Usability,simpl,simple,320,"////////////////////////////////////////////////////////////////////////////////; /// Compute the distance from the point px,py to a line.; ///; /// Compute the closest distance of approach from point px,py to elements of; /// an histogram. The distance is computed in pixels units.; ///; /// Algorithm: Currently, this simple model computes the distance from the mouse; /// to the histogram contour only.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:64,Integrability,rout,routine,64,"// might resize pad pixmap so should be called before any paint routine",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:13,Deployability,release,released,13,"// button is released",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:3,Testability,test,testing,3,"// testing specific possibility (after zoom, draw with ""same"", log, etc.)",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:63,Testability,log,log,63,"// testing specific possibility (after zoom, draw with ""same"", log, etc.)",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:95,Integrability,rout,routine,95,"////////////////////////////////////////////////////////////////////////////////; /// [Control routine to paint any kind of histograms](\ref HP00)",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:26,Testability,test,test,26,"// Draw the grid only; // test for options BAR or HBAR",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:28,Availability,error,error,28,"// do not draw histogram if error bars required",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:12,Availability,error,error,12,"// test for error bars or option E",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:3,Testability,test,test,3,"// test for error bars or option E",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:3,Testability,test,test,3,"// test for associated function",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:628,Testability,log,log,628,"////////////////////////////////////////////////////////////////////////////////; /// Returns the rendering regions for an axis to use in the COL2 option; ///; /// The algorithm analyses the size of the axis compared to the size of; /// the rendering region. It figures out the boundaries to use for each color; /// of the rendering region. Only one axis is computed here.; ///; /// This allows for a single computation of the boundaries before iterating; /// through all of the bins.; ///; /// \param pAxis the axis to consider; /// \param nPixels the number of pixels to render axis into; /// \param isLog whether the axis is log scale",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:24,Availability,error,error,24,"// this should cause an error if we have",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:3,Testability,log,logarithmic,3,"// logarithmic plot. we find the pixel for the bin; // pixel = eta * log10(V) - alpha; // where eta = nPixels/(log10(Vmax)-log10(Vmin)); // and alpha = nPixels*log10(Vmin)/(log10(Vmax)-log10(Vmin)); // and V is axis value",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:19,Usability,simpl,simply,19,"// linear plot. we simply need to find the appropriate bin; // for the",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:19,Usability,simpl,simply,19,"// linear plot. we simply need to find the appropriate bin; // for the",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:2,Testability,test,tested,2,"//tested in ExecuteEvent",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:106,Availability,error,error,106,"////////////////////////////////////////////////////////////////////////////////; /// [Draw 1D histograms error bars.](\ref HP09)",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:29,Availability,error,error,29,"// compute the offset of the error bars due to the symbol size",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:47,Availability,error,error,47,"// compute size of the lines at the end of the error bars",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6,Availability,error,errormarker,6,"// if errormarker = 0 or symbolsize = 0. no symbol is drawn",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:114,Availability,error,error,114,"// get the data; // xp = X position of the current point; // yp = Y position of the current point; // ex1 = Low X error; // ex2 = Up X error; // ey1 = Low Y error; // ey2 = Up Y error; // (xi,yi) = Error bars coordinates; // apply offset on errors for bar histograms",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:135,Availability,error,error,135,"// get the data; // xp = X position of the current point; // yp = Y position of the current point; // ex1 = Low X error; // ex2 = Up X error; // ey1 = Low Y error; // ey2 = Up Y error; // (xi,yi) = Error bars coordinates; // apply offset on errors for bar histograms",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:157,Availability,error,error,157,"// get the data; // xp = X position of the current point; // yp = Y position of the current point; // ex1 = Low X error; // ex2 = Up X error; // ey1 = Low Y error; // ey2 = Up Y error; // (xi,yi) = Error bars coordinates; // apply offset on errors for bar histograms",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:178,Availability,error,error,178,"// get the data; // xp = X position of the current point; // yp = Y position of the current point; // ex1 = Low X error; // ex2 = Up X error; // ey1 = Low Y error; // ey2 = Up Y error; // (xi,yi) = Error bars coordinates; // apply offset on errors for bar histograms",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:198,Availability,Error,Error,198,"// get the data; // xp = X position of the current point; // yp = Y position of the current point; // ex1 = Low X error; // ex2 = Up X error; // ey1 = Low Y error; // ey2 = Up Y error; // (xi,yi) = Error bars coordinates; // apply offset on errors for bar histograms",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:241,Availability,error,errors,241,"// get the data; // xp = X position of the current point; // yp = Y position of the current point; // ex1 = Low X error; // ex2 = Up X error; // ey1 = Low Y error; // ey2 = Up Y error; // (xi,yi) = Error bars coordinates; // apply offset on errors for bar histograms",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:12,Testability,LOG,LOG,12,"// take the LOG if necessary",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:11,Availability,error,error,11,"// test if error bars are not outside the limits; // otherwise they are truncated",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:3,Testability,test,test,3,"// test if error bars are not outside the limits; // otherwise they are truncated",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:97,Availability,error,error,97,"// test if the marker is on the frame limits. If ""Yes"", the; // marker will not be drawn and the error bars will be readjusted.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:3,Testability,test,test,3,"// test if the marker is on the frame limits. If ""Yes"", the; // marker will not be drawn and the error bars will be readjusted.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:12,Availability,error,error,12,"// draw the error rectangles",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:12,Availability,error,error,12,"// draw the error bars",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:31,Availability,error,error,31,"// draw line at the end of the error bars",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:105,Availability,error,errors,105,"////////////////////////////////////////////////////////////////////////////////; /// Draw 2D histograms errors.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:13,Availability,Error,Errors,13,"// Paint the Errors",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:106,Usability,clear,clear,106,"////////////////////////////////////////////////////////////////////////////////; /// Calculate range and clear pad (canvas).",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:71,Integrability,depend,depends,71,"//The next statement is always executed on non-iOS platform,; //on iOS depends on pad mode.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:71,Integrability,depend,depends,71,"//The next statement is ALWAYS executed on non-iOS platform, on iOS it depends on pad's mode; //and picked object.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:95,Integrability,rout,routine,95,"////////////////////////////////////////////////////////////////////////////////; /// [Control routine to draw 1D histograms](\ref HP01b)",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:10,Testability,LOG,LOGX,10,"// Option LOGX",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:135,Integrability,rout,routines,135,"////////////////////////////////////////////////////////////////////////////////; /// Compute histogram parameters used by the drawing routines.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6,Testability,log,log,6,"// if log scale in X, replace xmin,max by the log",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:46,Testability,log,log,46,"// if log scale in X, replace xmin,max by the log",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:22,Testability,log,log,22,"// empty histogram in log scale",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:7,Testability,log,log,7,"// For log scales, histogram coordinates are LOG10(ymin) and; // LOG10(ymax). Final adjustment (if not option ""Same""; // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; // Maximum and Minimum are not defined.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:159,Testability,log,logarithmic,159,"// For log scales, histogram coordinates are LOG10(ymin) and; // LOG10(ymax). Final adjustment (if not option ""Same""; // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; // Maximum and Minimum are not defined.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:135,Integrability,rout,routines,135,"////////////////////////////////////////////////////////////////////////////////; /// Compute histogram parameters used by the drawing routines for a rotated pad.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6,Testability,log,log,6,"// if log scale in Y, replace ymin,max by the log",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:46,Testability,log,log,46,"// if log scale in Y, replace ymin,max by the log",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:7,Testability,log,log,7,"// For log scales, histogram coordinates are LOG10(ymin) and; // LOG10(ymax). Final adjustment (if not option ""Same""; // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; // Maximum and Minimum are not defined.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:159,Testability,log,logarithmic,159,"// For log scales, histogram coordinates are LOG10(ymin) and; // LOG10(ymax). Final adjustment (if not option ""Same""; // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; // Maximum and Minimum are not defined.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:3,Deployability,update,update,3,"// update raster screen",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:2,Safety,avoid,avoid,2,"//avoid drawing with black",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:10,Testability,LOG,LOG,10,"// Option LOG is required ?",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:32,Modifiability,variab,variable,32,"// Set Axis attributes.; // The variable SCALE rescales the VSIZ; // in order to have the same label size for all angles.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:79,Safety,avoid,avoid,79,"// use an independent instance of a random generator; // instead of gRandom to avoid conflicts and; // to get same random numbers when drawing the same histogram",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:260,Integrability,depend,dependency,260,"////////////////////////////////////////////////////////////////////////////////; /// Static function to paint special objects like vectors and matrices.; /// This function is called via `gROOT->ProcessLine` to paint these objects; /// without having a direct dependency of the graphics or histogramming; /// system.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:50,Integrability,depend,depends,50,"//ALWAYS executed on non-iOS platform.; //On iOS, depends on mode.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:79,Safety,avoid,avoid,79,"// use an independent instance of a random generator; // instead of gRandom to avoid conflicts and; // to get same random numbers when drawing the same histogram",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:94,Integrability,message,message,94,"////////////////////////////////////////////////////////////////////////////////; /// Process message `mess`.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:546,Energy Efficiency,Green,Greenland,546,"////////////////////////////////////////////////////////////////////////////////; /// Static function; ///; /// Probably the most famous of the various map projections, the Mercator projection; /// takes its name from Mercator who presented it in 1569. It is a cylindrical, conformal projection; /// with no distortion along the equator.; /// The Mercator projection has been used extensively for world maps in which the distortion towards; /// the polar regions grows rather large, thus incorrectly giving the impression that, for example,; /// Greenland is larger than South America. In reality, the latter is about eight times the size of; /// Greenland. Also, the Former Soviet Union looks much bigger than Africa or South America. One may wonder; /// whether this illusion has had any influence on U.S. foreign policy.' (Source: GMT); /// code from Ernst-Jan Buis",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:647,Energy Efficiency,Green,Greenland,647,"////////////////////////////////////////////////////////////////////////////////; /// Static function; ///; /// Probably the most famous of the various map projections, the Mercator projection; /// takes its name from Mercator who presented it in 1569. It is a cylindrical, conformal projection; /// with no distortion along the equator.; /// The Mercator projection has been used extensively for world maps in which the distortion towards; /// the polar regions grows rather large, thus incorrectly giving the impression that, for example,; /// Greenland is larger than South America. In reality, the latter is about eight times the size of; /// Greenland. Also, the Former Soviet Union looks much bigger than Africa or South America. One may wonder; /// whether this illusion has had any influence on U.S. foreign policy.' (Source: GMT); /// code from Ernst-Jan Buis",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:109,Integrability,rout,routines,109,"// Range() could change the size of the pad pixmap and therefore should; // be called before the other paint routines",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6,Testability,log,log,6,"// if log scale in X, replace xmin,max by the log",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:46,Testability,log,log,46,"// if log scale in X, replace xmin,max by the log",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:6,Testability,log,log,6,"// if log scale in Y, replace ymin,max by the log",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:46,Testability,log,log,46,"// if log scale in Y, replace ymin,max by the log",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:22,Testability,log,log,22,"// empty histogram in log scale",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:7,Testability,log,log,7,"// For log scales, histogram coordinates are log10(ymin) and; // log10(ymax). Final adjustment (if not option ""Same""); // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; // Maximum and Minimum are not defined.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:160,Testability,log,logarithmic,160,"// For log scales, histogram coordinates are log10(ymin) and; // log10(ymax). Final adjustment (if not option ""Same""); // or ""+"" for ymax) of ymax and ymin for logarithmic scale, if; // Maximum and Minimum are not defined.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:137,Availability,error,error,137,"////////////////////////////////////////////////////////////////////////////////; /// This function returns the best format to print the error value (e); /// knowing the parameter value (v) and the format (f) used to print it.",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:11,Deployability,patch,patch,11,"// apply a patch from Oliver Freyermuth to set the title in the projection; // using the range of the projected Y values",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:11,Deployability,patch,patch,11,"// apply a patch from Oliver Freyermuth to set the title in the projection; // using the range of the projected X values",MatchSource.CODE_COMMENT,hist/histpainter/src/THistPainter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:709,Energy Efficiency,adapt,adapted,709,"// @(#)root/histpainter:$Id$; // Author: Rene Brun, Evgueni Tcherniaev, Olivier Couet 12/12/94; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*! \class TPainter3dAlgorithms; \ingroup Histpainter; \brief The Legos and Surfaces painter class. 3D graphics representations package. This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet; and Evgueni Tcherniaev. This class is a subset of the original system. It has been converted to a C++; class by Rene Brun.; */",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:709,Modifiability,adapt,adapted,709,"// @(#)root/histpainter:$Id$; // Author: Rene Brun, Evgueni Tcherniaev, Olivier Couet 12/12/94; /*************************************************************************; * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /*! \class TPainter3dAlgorithms; \ingroup Histpainter; \brief The Legos and Surfaces painter class. 3D graphics representations package. This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet; and Evgueni Tcherniaev. This class is a subset of the original system. It has been converted to a C++; class by Rene Brun.; */",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:174,Integrability,depend,depending,174,"////////////////////////////////////////////////////////////////////////////////; /// Normal default constructor; ///; /// rmin[3], rmax[3] are the limits of the lego object depending on; /// the selected coordinate system",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:86,Usability,Clear,Clear,86,"////////////////////////////////////////////////////////////////////////////////; /// Clear screen",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:302,Availability,error,error,302,"////////////////////////////////////////////////////////////////////////////////; /// Set correspondence between function and color levels; ///; /// \param[in] nl number of levels; /// \param[in] fl function levels; /// \param[in] icl colors for levels; ///; /// \param[out] irep return code (0 OK, -1 error).",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Availability,Error,Error,3,"// Error(where, ""function levels must be in increasing order"");",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Availability,Error,Error,3,"// Error(where, ""negative color index (%d)"", icl[i]);",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:253,Availability,Error,Errors,253,"////////////////////////////////////////////////////////////////////////////////; /// Fill polygon with function values at vertexes; ///; /// \param[in] n number of vertexes; /// \param[in] p polygon; /// \param[in] f function values at nodes; ///; /// Errors:; /// - illegal number of vertexes in polygon; /// - illegal call of FillPolygon: no levels",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:223,Availability,Error,Error,223,"////////////////////////////////////////////////////////////////////////////////; /// Find level lines for face; ///; /// \param[in] np number of nodes; /// \param[in] f face; /// \param[in] t additional function; ///; /// Error: number of points for line not equal 2",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:74,Testability,LOG,LOG,74,"// Compute the cell position in cartesian coordinates; // and compute the LOG if necessary",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate v and tt arrays",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:168,Modifiability,variab,variables,168,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots in polar coordinates; ///; /// \param[in] iordr order of variables (0 - R,PHI; 1 - PHI,R); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:246,Modifiability,variab,variable,246,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots in polar coordinates; ///; /// \param[in] iordr order of variables (0 - R,PHI; 1 - PHI,R); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:300,Modifiability,variab,variable,300,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots in polar coordinates; ///; /// \param[in] iordr order of variables (0 - R,PHI; 1 - PHI,R); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate v and tt arrays",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:174,Modifiability,variab,variables,174,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots in cylindrical coordinates; ///; /// \param[in] iordr order of variables (0 - Z,PHI; 1 - PHI,Z); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:252,Modifiability,variab,variable,252,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots in cylindrical coordinates; ///; /// \param[in] iordr order of variables (0 - Z,PHI; 1 - PHI,Z); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:306,Modifiability,variab,variable,306,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots in cylindrical coordinates; ///; /// \param[in] iordr order of variables (0 - Z,PHI; 1 - PHI,Z); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate v and tt arrays",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:210,Modifiability,variab,variables,210,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots spheric coordinates; ///; /// \param[in] ipsdr pseudo-rapidity flag; /// \param[in] iordr order of variables (0 - THETA,PHI; 1 - PHI,THETA); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:296,Modifiability,variab,variable,296,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots spheric coordinates; ///; /// \param[in] ipsdr pseudo-rapidity flag; /// \param[in] iordr order of variables (0 - THETA,PHI; 1 - PHI,THETA); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:350,Modifiability,variab,variable,350,"////////////////////////////////////////////////////////////////////////////////; /// Draw stack of lego-plots spheric coordinates; ///; /// \param[in] ipsdr pseudo-rapidity flag; /// \param[in] iordr order of variables (0 - THETA,PHI; 1 - PHI,THETA); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:3,Energy Efficiency,Allocate,Allocate,3,"// Allocate v and tt arrays",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:366,Availability,error,error,366,"////////////////////////////////////////////////////////////////////////////////; /// Set light source; ///; /// \param[in] nl source number: 1 off all light sources, 0 set diffused light; /// \param[in] yl intensity of the light source; /// \param[in] xscr, yscr, zscr direction of the light (in respect of the screen); ///; /// \param[out] irep reply (0 - O.K, -1 error)",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:9,Modifiability,variab,variables,9,/* Local variables */,MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:9,Modifiability,variab,variables,9,/* Local variables */,MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:9,Modifiability,variab,variables,9,/* Local variables */,MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:9,Modifiability,variab,variables,9,/* Local variables */,MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:362,Availability,error,error,362,"////////////////////////////////////////////////////////////////////////////////; /// Set Spectrum; ///; /// \param[in] nl number of levels; /// \param[in] fmin MIN function value; /// \param[in] fmax MAX function value; /// \param[in] ic initial color index (for 1st level); /// \param[in] idc color index increment; ///; /// \param[out] irep reply (0 O.K., -1 error)",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:9,Modifiability,variab,variables,9,/* Local variables */,MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:74,Testability,LOG,LOG,74,"// Compute the cell position in cartesian coordinates; // and compute the LOG if necessary",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:62,Availability,error,errors,62,"// The colors on the surface can represent the content or the errors.; // if (fSumw2.fN) t[i] = gCurrentHist->GetBinError(icx, iyt + iya);; // else t[i] = f[i * 3 + 3];",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:156,Modifiability,variab,variables,156,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in polar coordinates; ///; /// \param[in] iordr order of variables (0 - R,PHI, 1 - PHI,R); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:234,Modifiability,variab,variable,234,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in polar coordinates; ///; /// \param[in] iordr order of variables (0 - R,PHI, 1 - PHI,R); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:288,Modifiability,variab,variable,288,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in polar coordinates; ///; /// \param[in] iordr order of variables (0 - R,PHI, 1 - PHI,R); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:162,Modifiability,variab,variables,162,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in cylindrical coordinates; ///; /// \param[in] iordr order of variables (0 - Z,PHI; 1 - PHI,Z); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:240,Modifiability,variab,variable,240,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in cylindrical coordinates; ///; /// \param[in] iordr order of variables (0 - Z,PHI; 1 - PHI,Z); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:294,Modifiability,variab,variable,294,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in cylindrical coordinates; ///; /// \param[in] iordr order of variables (0 - Z,PHI; 1 - PHI,Z); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:201,Modifiability,variab,variables,201,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in spheric coordinates; ///; /// \param[in] ipsdr pseudo-rapidity flag; /// \param[in] iordr order of variables (0 - THETA,PHI; 1 - PHI,THETA); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:287,Modifiability,variab,variable,287,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in spheric coordinates; ///; /// \param[in] ipsdr pseudo-rapidity flag; /// \param[in] iordr order of variables (0 - THETA,PHI; 1 - PHI,THETA); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:341,Modifiability,variab,variable,341,"////////////////////////////////////////////////////////////////////////////////; /// Draw surface in spheric coordinates; ///; /// \param[in] ipsdr pseudo-rapidity flag; /// \param[in] iordr order of variables (0 - THETA,PHI; 1 - PHI,THETA); /// \param[in] na number of steps along 1st variable; /// \param[in] nb number of steps along 2nd variable; /// \param[in] chopt specific options; ///; /// - `chopt` = 'BF' from BACK to FRONT; /// - `chopt` = 'FB' from FRONT to BACK",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:517,Availability,error,error,517,"////////////////////////////////////////////////////////////////////////////////; /// Set surface property coefficients; ///; /// \param[in] qqa diffusion coefficient for diffused light [0.,1.]; /// \param[in] qqd diffusion coefficient for direct light [0.,1.]; /// \param[in] qqs diffusion coefficient for reflected light [0.,1.]; /// \param[in] nnqs power coefficient for reflected light (.GE.1); ///; /// Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); ///; /// \param[out] irep reply (0 - O.K, -1 error)",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:352,Energy Efficiency,power,power,352,"////////////////////////////////////////////////////////////////////////////////; /// Set surface property coefficients; ///; /// \param[in] qqa diffusion coefficient for diffused light [0.,1.]; /// \param[in] qqd diffusion coefficient for direct light [0.,1.]; /// \param[in] qqs diffusion coefficient for reflected light [0.,1.]; /// \param[in] nnqs power coefficient for reflected light (.GE.1); ///; /// Lightness model formula: Y = YD*QA + > YLi*(QD*cosNi+QS*cosRi); ///; /// \param[out] irep reply (0 - O.K, -1 error)",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:86,Testability,Test,Test,86,"////////////////////////////////////////////////////////////////////////////////; /// Test edge against face (triangle); ///; /// \param[in] del precision; /// \param[in] xyz nodes; /// \param[in] i1 1-st node of edge; /// \param[in] i2 2-nd node of edge; /// \param[in] iface triangular face; /// \param[in] abcd face plane; ///; /// \param[out] irep 1: edge under face, 0: no decision, +1: edge before face",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:52,Testability,log,logic,52,"// F I N D X - , Y - , Z - C R I T I C A L; // This logic works for parallel projection only.; // For central projection another logic should be implemented.",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:129,Testability,log,logic,129,"// F I N D X - , Y - , Z - C R I T I C A L; // This logic works for parallel projection only.; // For central projection another logic should be implemented.",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx:38,Testability,log,logic,38,"// L O O P A L O N G G R I D; // This logic works for both (parallel & central) projections.",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.h:33,Availability,mask,masks,33,"///< Indices of subsets of n-bit masks (n is from 1 to 30)",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.h:12,Availability,mask,masks,12,"///< Set of masks (30+29+28+...+1)=465; ///@}; ///@{; /// @name Marching Cubes; /// Construction of iso-surfaces, see publication CERN-CN-95-17",MatchSource.CODE_COMMENT,hist/histpainter/src/TPainter3dAlgorithms.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPainter3dAlgorithms.h
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:707,Deployability,Update,Update,707,"////////////////////////////////////////////////////////////////////////////////; /*! \class TPaletteAxis; \ingroup Histpainter; \brief The palette painting class. A `TPaletteAxis` object is used to display the color palette when; drawing 2-d histograms. The `TPaletteAxis` is automatically created drawn when drawing a 2-D; histogram when the option ""Z"" is specified. A `TPaletteAxis` object is added to the histogram list of functions and; can be retrieved doing:. TPaletteAxis *palette = (TPaletteAxis*)h->GetListOfFunctions()->FindObject(""palette"");. then the pointer `palette` can be used to change the palette attributes. Because the palette is created at painting time only, one must issue a:. gPad->Update();. before retrieving the palette pointer in order to create the palette. The following; macro gives an example. Begin_Macro(source); {; auto h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; auto palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; }; End_Macro. `TPaletteAxis` inherits from `TBox` and `TPave`. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; In this case no optimization can be done. It is responsibility of the; user to adjust minimum, maximum of the histogram and/or the contour levels; to get a reasonable look of the plot.; Only overlap of the labels is avoided if too many c",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:1079,Deployability,Update,Update,1079,"////////////////////////////////////////////////////////////////////////; /*! \class TPaletteAxis; \ingroup Histpainter; \brief The palette painting class. A `TPaletteAxis` object is used to display the color palette when; drawing 2-d histograms. The `TPaletteAxis` is automatically created drawn when drawing a 2-D; histogram when the option ""Z"" is specified. A `TPaletteAxis` object is added to the histogram list of functions and; can be retrieved doing:. TPaletteAxis *palette = (TPaletteAxis*)h->GetListOfFunctions()->FindObject(""palette"");. then the pointer `palette` can be used to change the palette attributes. Because the palette is created at painting time only, one must issue a:. gPad->Update();. before retrieving the palette pointer in order to create the palette. The following; macro gives an example. Begin_Macro(source); {; auto h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; auto palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; }; End_Macro. `TPaletteAxis` inherits from `TBox` and `TPave`. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; In this case no optimization can be done. It is responsibility of the; user to adjust minimum, maximum of the histogram and/or the contour levels; to get a reasonable look of the plot.; Only overlap of the labels is avoided if too many contour ",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:1224,Modifiability,inherit,inherits,1224,"rawing 2-d histograms. The `TPaletteAxis` is automatically created drawn when drawing a 2-D; histogram when the option ""Z"" is specified. A `TPaletteAxis` object is added to the histogram list of functions and; can be retrieved doing:. TPaletteAxis *palette = (TPaletteAxis*)h->GetListOfFunctions()->FindObject(""palette"");. then the pointer `palette` can be used to change the palette attributes. Because the palette is created at painting time only, one must issue a:. gPad->Update();. before retrieving the palette pointer in order to create the palette. The following; macro gives an example. Begin_Macro(source); {; auto h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; auto palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; }; End_Macro. `TPaletteAxis` inherits from `TBox` and `TPave`. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; In this case no optimization can be done. It is responsibility of the; user to adjust minimum, maximum of the histogram and/or the contour levels; to get a reasonable look of the plot.; Only overlap of the labels is avoided if too many contour levels are used. This option is especially useful with user defined contours.; An example is shown here:. Begin_Macro(source); {; gStyle->SetOptStat(0);; auto c = new TCanvas(""c"",""exa_CJUST"",300,10,400,400);; auto hpxpy = new",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:1316,Modifiability,inherit,inherited,1316,"n when drawing a 2-D; histogram when the option ""Z"" is specified. A `TPaletteAxis` object is added to the histogram list of functions and; can be retrieved doing:. TPaletteAxis *palette = (TPaletteAxis*)h->GetListOfFunctions()->FindObject(""palette"");. then the pointer `palette` can be used to change the palette attributes. Because the palette is created at painting time only, one must issue a:. gPad->Update();. before retrieving the palette pointer in order to create the palette. The following; macro gives an example. Begin_Macro(source); {; auto h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; auto palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; }; End_Macro. `TPaletteAxis` inherits from `TBox` and `TPave`. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; In this case no optimization can be done. It is responsibility of the; user to adjust minimum, maximum of the histogram and/or the contour levels; to get a reasonable look of the plot.; Only overlap of the labels is avoided if too many contour levels are used. This option is especially useful with user defined contours.; An example is shown here:. Begin_Macro(source); {; gStyle->SetOptStat(0);; auto c = new TCanvas(""c"",""exa_CJUST"",300,10,400,400);; auto hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; // Fill histograms randoml",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:1780,Performance,optimiz,optimization,1780,"tte. The following; macro gives an example. Begin_Macro(source); {; auto h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; auto palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; }; End_Macro. `TPaletteAxis` inherits from `TBox` and `TPave`. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; In this case no optimization can be done. It is responsibility of the; user to adjust minimum, maximum of the histogram and/or the contour levels; to get a reasonable look of the plot.; Only overlap of the labels is avoided if too many contour levels are used. This option is especially useful with user defined contours.; An example is shown here:. Begin_Macro(source); {; gStyle->SetOptStat(0);; auto c = new TCanvas(""c"",""exa_CJUST"",300,10,400,400);; auto hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; // Fill histograms randomly; TRandom3 randomNum;; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; randomNum.Rannor(px,py);; hpxpy->Fill(px,py);; }; hpxpy->SetMaximum(200);; Double_t zcontours[5] = {0, 20, 40, 80, 120};; hpxpy->SetContour(5, zcontours);; hpxpy->GetZaxis()->SetTickSize(0.01);; hpxpy->GetZaxis()->SetLabelOffset(0.01);; gPad->SetRightMargin(0.13);; hpxpy->SetTitle(""User contours, CJUST"");; hpxpy->Draw(""COL Z CJUST"");; }; End_Macro; */; ////////////////////////////////////////////////",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:1980,Safety,avoid,avoided,1980,"auto h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; auto palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; }; End_Macro. `TPaletteAxis` inherits from `TBox` and `TPave`. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; In this case no optimization can be done. It is responsibility of the; user to adjust minimum, maximum of the histogram and/or the contour levels; to get a reasonable look of the plot.; Only overlap of the labels is avoided if too many contour levels are used. This option is especially useful with user defined contours.; An example is shown here:. Begin_Macro(source); {; gStyle->SetOptStat(0);; auto c = new TCanvas(""c"",""exa_CJUST"",300,10,400,400);; auto hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; // Fill histograms randomly; TRandom3 randomNum;; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; randomNum.Rannor(px,py);; hpxpy->Fill(px,py);; }; hpxpy->SetMaximum(200);; Double_t zcontours[5] = {0, 20, 40, 80, 120};; hpxpy->SetContour(5, zcontours);; hpxpy->GetZaxis()->SetTickSize(0.01);; hpxpy->GetZaxis()->SetLabelOffset(0.01);; gPad->SetRightMargin(0.13);; hpxpy->SetTitle(""User contours, CJUST"");; hpxpy->Draw(""COL Z CJUST"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// Palette default constructor.",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:1603,Testability,log,log,1603," used to change the palette attributes. Because the palette is created at painting time only, one must issue a:. gPad->Update();. before retrieving the palette pointer in order to create the palette. The following; macro gives an example. Begin_Macro(source); {; auto h2 = new TH2F(""h2"",""Example of a resized palette "",40,-4,4,40,-20,20);; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2->Fill(px,5*py);; }; gStyle->SetPalette(1);; h2->Draw(""COLZ"");; gPad->Update();; auto palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; palette->SetY2NDC(0.7);; }; End_Macro. `TPaletteAxis` inherits from `TBox` and `TPave`. The methods; allowing to specify the palette position are inherited from these two classes. The palette can be interactively moved and resized. The context menu; can be used to set the axis attributes. It is possible to select a range on the axis to set the min/max in z. As default labels and ticks are drawn by `TGAxis` at equidistant (lin or log); points as controlled by SetNdivisions.; If option ""CJUST"" is given labels and ticks are justified at the; color boundaries defined by the contour levels.; In this case no optimization can be done. It is responsibility of the; user to adjust minimum, maximum of the histogram and/or the contour levels; to get a reasonable look of the plot.; Only overlap of the labels is avoided if too many contour levels are used. This option is especially useful with user defined contours.; An example is shown here:. Begin_Macro(source); {; gStyle->SetOptStat(0);; auto c = new TCanvas(""c"",""exa_CJUST"",300,10,400,400);; auto hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; // Fill histograms randomly; TRandom3 randomNum;; Float_t px, py;; for (Int_t i = 0; i < 25000; i++) {; randomNum.Rannor(px,py);; hpxpy->Fill(px,py);; }; hpxpy->SetMaximum(200);; Double_t zcontours[5] = {0, 20, 40, 80, 120};; hpxpy->SetContour(5, zcontours);; hpxpy->GetZaxis()->SetTickSize(0.01);; hpxpy->GetZa",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:306,Deployability,Update,Update,306,"////////////////////////////////////////////////////////////////////////////////; /// Returns the color index of the bin (i,j).; ///; /// This function should be used after an histogram has been plotted with the; /// option COL or COLZ like in the following example:; ///; /// h2->Draw(""COLZ"");; /// gPad->Update();; /// TPaletteAxis *palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; /// Int_t ci = palette->GetBinColor(20,15);; ///; /// Then it is possible to retrieve the RGB components in the following way:; ///; /// TColor *c = gROOT->GetColor(ci);; /// float x,y,z;; /// c->GetRGB(x,y,z);",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx:309,Deployability,Update,Update,309,"////////////////////////////////////////////////////////////////////////////////; /// Returns the color index of the given z value; ///; /// This function should be used after an histogram has been plotted with the; /// option COL or COLZ like in the following example:; ///; /// h2->Draw(""COLZ"");; /// gPad->Update();; /// TPaletteAxis *palette = (TPaletteAxis*)h2->GetListOfFunctions()->FindObject(""palette"");; /// Int_t ci = palette->GetValueColor(30.);; ///; /// Then it is possible to retrieve the RGB components in the following way:; ///; /// TColor *c = gROOT->GetColor(ci);; /// float x,y,z;; /// c->GetRGB(x,y,z);",MatchSource.CODE_COMMENT,hist/histpainter/src/TPaletteAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TPaletteAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:222,Usability,Feedback,Feedback,222,"/// \file ROOT/RAxis.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-03-23; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:38,Modifiability,inherit,inheritance-based,38,"/// Virtual destructor needed in this inheritance-based design",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:243,Performance,optimiz,optimized,243,"/// Check if two axis have the same bin borders; ///; /// Default implementation should work for any RAxis type, but is quite; /// inefficient as it does virtual GetBinFrom calls in a loop. RAxis; /// implementations are encouraged to provide optimized overrides for common; /// axis binning comparison scenarios.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:18,Integrability,interface,interfaces,18,"///\name Iterator interfaces; ///\{; /// Get a const_iterator pointing to the first regular bin.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:272,Availability,reliab,reliable,272,"///\}; /// Find the adjusted bin index (returning `kUnderflowBin` for underflow and `kOverflowBin`; /// for overflow) for the given coordinate.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:235,Availability,reliab,reliable,235,"/// Find the raw bin index (not adjusted) for the given coordinate.; /// The resulting raw bin is 0-based.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:265,Availability,reliab,reliable,265,"/// Find the adjusted bin index (returning `kUnderflowBin` for underflow and; /// `kOverflowBin` for overflow) for the given coordinate.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:44,Modifiability,extend,extend,44,"// namespace Internal; /** An axis that can extend its range, keeping the number of its bins unchanged.; The axis is constructed with an initial range. Apart from its ability to; grow, this axis behaves like a RAxisEquidistant.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:120,Modifiability,extend,extends,120,"/// Grow this axis to make the ""virtual bin"" toBin in-range. This keeps the; /// non-affected axis limit unchanged, and extends the other axis limit such; /// that a number of consecutive bins are merged.; ///; /// Example, assuming an initial RAxisGrow with 10 bins from 0. to 1.:; /// - `Grow(0)`: that (virtual) bin spans from -0.1 to 0. To include it; /// in the axis range, the lower limit must be shifted. The minimal number; /// of bins that can be merged is 2, thus the new axis will span from; /// -1. to 1.; /// - `Grow(-1)`: that (virtual) bin spans from -0.2 to 0.1. To include it; /// in the axis range, the lower limit must be shifted. The minimal number; /// of bins that can be merged is 2, thus the new axis will span from; /// -1. to 1.; /// - `Grow(50)`: that (virtual) bin spans from 4.9 to 5.0. To include it; /// in the axis range, the higher limit must be shifted. Five bins need to; /// be merged, making the new axis range 0. to 5.0.; ///; /// \param toBin - the ""virtual"" bin number, as if the axis had an infinite; /// number of bins with the current bin width. For instance, for an axis; /// with ten bins in the range 0. to 1., the coordinate 2.05 has the virtual; /// bin index 20.; /// \return Returns the number of bins that were merged to reach the value.; /// A value of 1 means that no bins were merged (toBin was in the original; /// axis range).",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:78,Modifiability,variab,variable,78,"// namespace Internal; /**; An axis with non-equidistant bins (also known as ""variable binning""). It is; defined by an array of bin borders - one more than the number of; (non-overflow-) bins it has! As an example, an axis with two bin needs three; bin borders:; - lower edge of the first bin;; - higher edge of the first bin, identical to the lower edge of the second; bin;; - higher edge of the second bin. This axis cannot grow; the size of new bins would not be well defined.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:239,Availability,reliab,reliable,239,"/// Find the raw bin index (not adjusted) for the given coordinate `x`.; /// The resulting raw bin is 1-based.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:217,Availability,reliab,reliable,217,"/// Find the bin index (adjusted with under- and overflow) for the given coordinate `x`.; /// \note Passing a bin border coordinate can either return the bin above or; /// below the bin border. I.e. don't do that for reliable results!",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:24,Modifiability,extend,extended,24,"/// This axis cannot be extended.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:4,Security,Access,Access,4,"/// Access to the bin borders used by this axis.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:767,Security,hash,hashing,767,"// namespace Internal; /**; \class RAxisLabels; A RAxisGrow that has a label assigned to each bin and a bin width of 1. While filling still works through coordinates (i.e. arrays of doubles),; RAxisLabels allows to convert a string to a bin number or the bin's coordinate; center. The number of labels and the number of bins reported by RAxisGrow might; differ: the RAxisGrow will only grow when seeing a Fill(), while the RAxisLabels; will add a new label whenever `GetBinCenter()` is called. Implementation details:; Filling happens often; `GetBinCenter()` needs to be fast. Thus the unordered_map.; The painter needs the reverse: it wants the label for bin 0, bin 1 etc. The axis; should only store the bin labels once; referencing them is (due to re-allocation,; hashing etc) non-trivial. So instead, build a `vector<string_view>` for the few; times the axis needs to be painted.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxis.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxisConfig.hxx:228,Usability,Feedback,Feedback,228,"/// \file ROOT/RAxisConfig.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2020-02-05; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxisConfig.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxisConfig.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxisConfig.hxx:41,Modifiability,config,configure,41,"/**; \class RAxisConfig; Objects used to configure the different axis types. It can store the; properties of all ROOT-provided axis types, together with the type of the axis. TODO: that's what a variant will be invented for!; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxisConfig.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxisConfig.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxisConfig.hxx:42,Deployability,configurat,configuration,42,"///< The kind of axis represented by this configuration",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxisConfig.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxisConfig.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxisConfig.hxx:42,Modifiability,config,configuration,42,"///< The kind of axis represented by this configuration",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RAxisConfig.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxisConfig.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:222,Usability,Feedback,Feedback,222,"/// \file ROOT/RHist.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-03-23; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:51,Security,access,access,51,"/// Pointer type to `HistImpl_t::Fill`, for faster access.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,Availability,avail,available,37,"/// Constructor overload that's only available for a 1-dimensional histogram.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,Availability,avail,available,37,"/// Constructor overload that's only available for a 1-dimensional histogram,; /// also passing the histogram title.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,Availability,avail,available,37,"/// Constructor overload that's only available for a 2-dimensional histogram.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,Availability,avail,available,37,"/// Constructor overload that's only available for a 2-dimensional histogram,; /// also passing the histogram title.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,Availability,avail,available,37,"/// Constructor overload that's only available for a 3-dimensional histogram.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:37,Availability,avail,available,37,"/// Constructor overload that's only available for a 3-dimensional histogram,; /// also passing the histogram title.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:4,Security,Access,Access,4,"/// Access the ImplBase_t this RHist points to.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:157,Energy Efficiency,efficient,efficient,157,"/// For each coordinate in `xN`, add `weightN[i]` to the bin at coordinate; /// `xN[i]`. The sizes of `xN` and `weightN` must be the same. This is more; /// efficient than many separate calls to `Fill()`.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:157,Energy Efficiency,efficient,efficient,157,"/// For each coordinate in `xN`, add `weightN[i]` to the bin at coordinate; /// `xN[i]`. The sizes of `xN` and `weightN` must be the same. This is more; /// efficient than many separate calls to `Fill()`.; /// Overload for passing initializer lists.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:41,Energy Efficiency,efficient,efficient,41,"/// Swap *this and other.; ///; /// Very efficient; swaps the `fImpl` pointers.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:40,Energy Efficiency,efficient,efficient,40,"/// Swap two histograms.; ///; /// Very efficient; swaps the `fImpl` pointers.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:136,Integrability,depend,depending,136,"/// Make a RHistImpl-derived object reflecting the RAxisConfig array.; ///; /// Delegate to the appropriate MakeNextAxis instantiation, depending on the; /// axis type selected in the RAxisConfig.; /// \param title - title of the derived object.; /// \param axes - `RAxisConfig` objects describing the axis of the resulting; /// RHistImpl.; /// \param processedAxisArgs - the RAxisBase-derived axis objects describing the; /// axes of the resulting RHistImpl. There are `IDIM` of those; in the end; /// (`IDIM` == `GetNDim()`), all `axes` have been converted to; /// `processedAxisArgs` and the RHistImpl constructor can be invoked, passing; /// the `processedAxisArgs`.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:502,Availability,error,error,502,"///\}; /// Add two histograms.; ///; /// This operation may currently only be performed if the two histograms have; /// the same axis configuration, use the same precision, and if `from` records; /// at least the same statistics as `to` (recording more stats is fine).; ///; /// Adding histograms with incompatible axis binning will be reported at runtime; /// with an `std::runtime_error`. Insufficient statistics in the source; /// histogram will be detected at compile-time and result in a compiler error.; ///; /// In the future, we may either adopt a more relaxed definition of histogram; /// addition or provide a mechanism to convert from one histogram type to; /// another. We currently favor the latter path.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:134,Deployability,configurat,configuration,134,"///\}; /// Add two histograms.; ///; /// This operation may currently only be performed if the two histograms have; /// the same axis configuration, use the same precision, and if `from` records; /// at least the same statistics as `to` (recording more stats is fine).; ///; /// Adding histograms with incompatible axis binning will be reported at runtime; /// with an `std::runtime_error`. Insufficient statistics in the source; /// histogram will be detected at compile-time and result in a compiler error.; ///; /// In the future, we may either adopt a more relaxed definition of histogram; /// addition or provide a mechanism to convert from one histogram type to; /// another. We currently favor the latter path.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:134,Modifiability,config,configuration,134,"///\}; /// Add two histograms.; ///; /// This operation may currently only be performed if the two histograms have; /// the same axis configuration, use the same precision, and if `from` records; /// at least the same statistics as `to` (recording more stats is fine).; ///; /// Adding histograms with incompatible axis binning will be reported at runtime; /// with an `std::runtime_error`. Insufficient statistics in the source; /// histogram will be detected at compile-time and result in a compiler error.; ///; /// In the future, we may either adopt a more relaxed definition of histogram; /// addition or provide a mechanism to convert from one histogram type to; /// another. We currently favor the latter path.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:78,Performance,perform,performed,78,"///\}; /// Add two histograms.; ///; /// This operation may currently only be performed if the two histograms have; /// the same axis configuration, use the same precision, and if `from` records; /// at least the same statistics as `to` (recording more stats is fine).; ///; /// Adding histograms with incompatible axis binning will be reported at runtime; /// with an `std::runtime_error`. Insufficient statistics in the source; /// histogram will be detected at compile-time and result in a compiler error.; ///; /// In the future, we may either adopt a more relaxed definition of histogram; /// addition or provide a mechanism to convert from one histogram type to; /// another. We currently favor the latter path.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:452,Safety,detect,detected,452,"///\}; /// Add two histograms.; ///; /// This operation may currently only be performed if the two histograms have; /// the same axis configuration, use the same precision, and if `from` records; /// at least the same statistics as `to` (recording more stats is fine).; ///; /// Adding histograms with incompatible axis binning will be reported at runtime; /// with an `std::runtime_error`. Insufficient statistics in the source; /// histogram will be detected at compile-time and result in a compiler error.; ///; /// In the future, we may either adopt a more relaxed definition of histogram; /// addition or provide a mechanism to convert from one histogram type to; /// another. We currently favor the latter path.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:22,Deployability,configurat,configuration,22,"// Enforce ""same axis configuration"" policy.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:22,Modifiability,config,configuration,22,"// Enforce ""same axis configuration"" policy.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHist.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBinIter.hxx:229,Usability,Feedback,Feedback,229,"/// \file ROOT/RHistBinIter.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-08-07; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistBinIter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBinIter.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBinIter.hxx:90,Security,access,access,90,"/**; \class RHistBinRef; Represents a bin reference. Value of the bin iteration. Provides access to bin content, bin geometry (from, to, center), and statistics; (for instance higher moments) associated to the bin.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistBinIter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBinIter.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBinIter.hxx:22,Security,access,access,22,"///\{; ///\name Value access",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistBinIter.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBinIter.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBufferedFill.hxx:234,Usability,Feedback,Feedback,234,"/// \file ROOT/RHistBufferedFill.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-07-03; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistBufferedFill.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBufferedFill.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBufferedFill.hxx:236,Performance,multi-thread,multi-threaded,236,"// namespace Internal; /** \class RHistBufferedFill; Buffers calls to Fill(). Once the buffer is full, on destruction of when calling Flush(), it sends the; buffers off as an ideally vectorizable FillN() operation. It also serves as a; multi-threaded way of filling the same histogram, reducing the locking; frequency. The HIST template can be either a RHist instance, a RHistImpl instance, or; a RHistLockedFill instance.; **/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistBufferedFill.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBufferedFill.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBufferedFill.hxx:3,Integrability,synchroniz,synchronize,3,"// synchronize!",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistBufferedFill.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistBufferedFill.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx:236,Usability,Feedback,Feedback,236,"/// \file ROOT/RHistConcurrentFill.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-07-03; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistConcurrentFill.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx:126,Performance,multi-thread,multi-threaded,126,/**; \class RHistConcurrentFiller; Buffers a thread's Fill calls and submits them to the; RHistConcurrentFillManager. Enables multi-threaded filling.; **/,MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistConcurrentFill.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx:52,Integrability,synchroniz,synchronization,52,"/**; \class RHistConcurrentFillManager; Manages the synchronization of calls to FillN(). The HIST template can be a RHist instance. This class hands out; RHistConcurrentFiller objects that can concurrently fill the histogram. They; buffer calls to Fill() until the buffer is full, and then swap the buffer; with that of the RHistConcurrentFillManager. The manager than fills the; histogram.; **/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistConcurrentFill.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx:193,Performance,concurren,concurrently,193,"/**; \class RHistConcurrentFillManager; Manages the synchronization of calls to FillN(). The HIST template can be a RHist instance. This class hands out; RHistConcurrentFiller objects that can concurrently fill the histogram. They; buffer calls to Fill() until the buffer is full, and then swap the buffer; with that of the RHistConcurrentFillManager. The manager than fills the; histogram.; **/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistConcurrentFill.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistConcurrentFill.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:226,Usability,Feedback,Feedback,226,"/// \file ROOT/RHistData.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-06-14; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:105,Integrability,depend,depending,105,"/// Get a reference to the bin corresponding to `binidx` of the correct bin; /// content array; /// i.e. depending if `binidx` is a regular bin or an under- / overflow bin.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:117,Integrability,depend,depending,117,"/// Get a reference to the bin corresponding to `binidx` of the correct bin; /// content array (non-const); /// i.e. depending if `binidx` is a regular bin or an under- / overflow bin.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:57,Deployability,configurat,configuration,57,"/// Merge with other RHistStatContent, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:57,Modifiability,config,configuration,57,"/// Merge with other RHistStatContent, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:72,Deployability,configurat,configuration,72,"/// Merge with other RHistStatTotalSumOfWeights data, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:72,Modifiability,config,configuration,72,"/// Merge with other RHistStatTotalSumOfWeights data, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:79,Deployability,configurat,configuration,79,"/// Merge with other RHistStatTotalSumOfSquaredWeights data, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:79,Modifiability,config,configuration,79,"/// Merge with other RHistStatTotalSumOfSquaredWeights data, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:105,Integrability,depend,depending,105,"/// Get a reference to the bin corresponding to `binidx` of the correct bin; /// content array; /// i.e. depending if `binidx` is a regular bin or an under- / overflow bin.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:117,Integrability,depend,depending,117,"/// Get a reference to the bin corresponding to `binidx` of the correct bin; /// content array (non-const); /// i.e. depending if `binidx` is a regular bin or an under- / overflow bin.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:68,Deployability,configurat,configuration,68,"/// Merge with other `RHistStatUncertainty` data, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:68,Modifiability,config,configuration,68,"/// Merge with other `RHistStatUncertainty` data, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:112,Deployability,configurat,configuration,112,"// FIXME: Add a way to query the inner data; /// Merge with other RHistDataMomentUncert data, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:112,Modifiability,config,configuration,112,"// FIXME: Add a way to query the inner data; /// Merge with other RHistDataMomentUncert data, assuming same bin configuration.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:29,Integrability,Interface,Interface,29,"/** \class RHistStatRuntime; Interface implementing a pure virtual functions `DoFill()`, `DoFillN()`.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:127,Availability,avail,available,127,"/// Calculate the bin content's uncertainty for the given bin, using Poisson; /// statistics on the absolute bin content. Only available if no base provides; /// this functionality. Requires `GetContent()`.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:57,Security,access,accessors,57,"/** \class RHistData; A `RHistImplBase`'s data, provides accessors to all its statistics.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:4,Deployability,Integrat,Integrate,4,"/// Integrate other statistical data into the current data.; ///; /// The implementation assumes that the other statistics were recorded with; /// the same binning configuration, and that the statistics of `OtherData`; /// are a superset of those recorded by the active `RHistData` instance.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:164,Deployability,configurat,configuration,164,"/// Integrate other statistical data into the current data.; ///; /// The implementation assumes that the other statistics were recorded with; /// the same binning configuration, and that the statistics of `OtherData`; /// are a superset of those recorded by the active `RHistData` instance.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:4,Integrability,Integrat,Integrate,4,"/// Integrate other statistical data into the current data.; ///; /// The implementation assumes that the other statistics were recorded with; /// the same binning configuration, and that the statistics of `OtherData`; /// are a superset of those recorded by the active `RHistData` instance.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:164,Modifiability,config,configuration,164,"/// Integrate other statistical data into the current data.; ///; /// The implementation assumes that the other statistics were recorded with; /// the same binning configuration, and that the statistics of `OtherData`; /// are a superset of those recorded by the active `RHistData` instance.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx:127,Availability,avail,available,127,"/// Calculate the bin content's uncertainty for the given bin, using Poisson; /// statistics on the absolute bin content. Only available if no base provides; /// this functionality. Requires `GetContent()`.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistData.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistData.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:226,Usability,Feedback,Feedback,226,"/// \file ROOT/RHistImpl.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-03-23; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:378,Integrability,interface,interface,378,"/**; \class RHistImplPrecisionAgnosticBase; Base class for `RHistImplBase` that abstracts out the histogram's `PRECISION`. For operations such as painting a histogram, the `PRECISION` (type of the bin; content) is not relevant; painting will cast the underlying bin type to double.; To facilitate this, `RHistImplBase` itself inherits from the; `RHistImplPrecisionAgnosticBase` interface.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:326,Modifiability,inherit,inherits,326,"/**; \class RHistImplPrecisionAgnosticBase; Base class for `RHistImplBase` that abstracts out the histogram's `PRECISION`. For operations such as painting a histogram, the `PRECISION` (type of the bin; content) is not relevant; painting will cast the underlying bin type to double.; To facilitate this, `RHistImplBase` itself inherits from the; `RHistImplPrecisionAgnosticBase` interface.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:86,Usability,Simpl,Simply,86,"/// Number of bins of this histogram, including all overflow and underflow; /// bins. Simply the product of all axes' total number of bins.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:86,Usability,Simpl,Simply,86,"/// Number of bins of this histogram, excluding all overflow and underflow; /// bins. Simply the product of all axes' number of regular bins.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:100,Deployability,configurat,configuration,100,"/**; \class RHistImplBase; Interface class for `RHistImpl`. `RHistImpl` is templated for a specific configuration of axes. To enable access; through `RHist`, `RHistImpl` inherits from `RHistImplBase`, exposing only dimension; (`DIMENSION`) and bin type (`PRECISION`).; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:27,Integrability,Interface,Interface,27,"/**; \class RHistImplBase; Interface class for `RHistImpl`. `RHistImpl` is templated for a specific configuration of axes. To enable access; through `RHist`, `RHistImpl` inherits from `RHistImplBase`, exposing only dimension; (`DIMENSION`) and bin type (`PRECISION`).; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:100,Modifiability,config,configuration,100,"/**; \class RHistImplBase; Interface class for `RHistImpl`. `RHistImpl` is templated for a specific configuration of axes. To enable access; through `RHist`, `RHistImpl` inherits from `RHistImplBase`, exposing only dimension; (`DIMENSION`) and bin type (`PRECISION`).; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:170,Modifiability,inherit,inherits,170,"/**; \class RHistImplBase; Interface class for `RHistImpl`. `RHistImpl` is templated for a specific configuration of axes. To enable access; through `RHist`, `RHistImpl` inherits from `RHistImplBase`, exposing only dimension; (`DIMENSION`) and bin type (`PRECISION`).; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:133,Security,access,access,133,"/**; \class RHistImplBase; Interface class for `RHistImpl`. `RHistImpl` is templated for a specific configuration of axes. To enable access; through `RHist`, `RHistImpl` inherits from `RHistImplBase`, exposing only dimension; (`DIMENSION`) and bin type (`PRECISION`).; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:4,Integrability,Interface,Interface,4,"/// Interface function to fill a vector or array of coordinates with; /// corresponding weights.; /// \note the size of `xN` and `weightN` must be the same!",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:4,Integrability,Interface,Interface,4,"/// Interface function to fill a vector or array of coordinates.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:10,Security,access,access,10,"/// Const access to statistics.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:14,Security,access,access,14,"/// Non-const access to statistics.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:207,Integrability,depend,depending,207,"/// Recursively computes zero-based local bin indices, given...; ///; /// - A zero-based global bin index; /// - The number of considered bins on each axis (can be either `GetNBinsNoOver`; /// or `GetNBins` depending on what you are trying to do); /// - A policy of treating all bins as regular (i.e. no negative indices)",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:219,Integrability,depend,depending,219,"/// Recursively computes a zero-based global bin index, given...; ///; /// - A set of zero-based per-axis bin indices; /// - The number of considered bins on each axis (can be either `GetNBinsNoOver`; /// or `GetNBins` depending on what you are trying to do); /// - A policy of treating all bins qs regular (i.e. no negative indices)",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:20,Security,access,access,20,"/// Normalized axes access, converting from actual axis type to base class.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:207,Integrability,depend,depending,207,"/// Computes a zero-based global bin index, given...; ///; /// - A set of zero-based per-axis bin indices; /// - The number of considered bins on each axis (can be either `GetNBinsNoOver`; /// or `GetNBins` depending on what you are trying to do); /// - A policy of treating all bins qs regular (i.e. no negative indices)",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:195,Integrability,depend,depending,195,"/// Computes zero-based local bin indices, given...; ///; /// - A zero-based global bin index; /// - The number of considered bins on each axis (can be either `GetNBinsNoOver`; /// or `GetNBins` depending on what you are trying to do); /// - A policy of treating all bins as regular (i.e. no negative indices)",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:1373,Availability,recover,recover,1373,"-7 3 4 -8; // -9 -10 -11 -12 <- No regular bins on the overflow line of axis 1; //; // As we go to higher dimensions, the geometry becomes more complex, but; // if we replace ""line"" with ""plane"", we get a similar picture in 3D when we; // slide along axis 2:; //; // No regular bins on the Some of them on the No regular bins again; // UF plane of axis 2 regular planes of ax.2 on the OF plane of ax.2; //; // -1 -2 -3 -4 -17 -18 -19 -20 -29 -30 -31 -32; // -5 -6 -7 -8 -21 1 2 -22 -33 -34 -35 -36; // -9 -10 -11 -12 -23 3 4 -24 -37 -37 -39 -40; // -13 -14 -15 -16 -25 -26 -27 -28 -41 -42 -43 -44; //; // We can generalize this to N dimensions by saying that as we slide along; // the last axis of an N-d histogram, we see an hyperplane full of overflow; // bins, then some hyperplanes with regular bins in the ""middle"" surrounded; // by overflow bins, then a last hyperplane full of overflow bins.; //; // From this, we can devise a recursive algorithm to recover the number of; // regular bins before the overflow bin we're currently looking at:; //; // - Start by processing the last histogram axis.; // - Ignore the first and last hyperplane on this axis, which only contain; // underflow and overflow bins respectively.; // - Count how many complete hyperplanes of regular bins lie before us on; // this axis, which we can do indirectly in our overflow bin based; // reasoning by computing the perimeter of the regular region and dividing; // our ""regular"" overflow bin count by that amount.; // - Now we counted previous hyperplanes on this last histogram axis, but; // we need to process the hyperplane that our bin is located in, if any.; // * For this, we reduce our overflow bin count to a count of; // _unaccounted_ overflow bins in the current hyperplane...; // * ...which allows us to recursively continue the computation by; // processing the next (well, previous) histogram axis in the context; // of this hyperplane, in the same manner as above.; //; // Alright, now that the general ",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:2081,Energy Efficiency,reduce,reduce,2081," along axis 2:; //; // No regular bins on the Some of them on the No regular bins again; // UF plane of axis 2 regular planes of ax.2 on the OF plane of ax.2; //; // -1 -2 -3 -4 -17 -18 -19 -20 -29 -30 -31 -32; // -5 -6 -7 -8 -21 1 2 -22 -33 -34 -35 -36; // -9 -10 -11 -12 -23 3 4 -24 -37 -37 -39 -40; // -13 -14 -15 -16 -25 -26 -27 -28 -41 -42 -43 -44; //; // We can generalize this to N dimensions by saying that as we slide along; // the last axis of an N-d histogram, we see an hyperplane full of overflow; // bins, then some hyperplanes with regular bins in the ""middle"" surrounded; // by overflow bins, then a last hyperplane full of overflow bins.; //; // From this, we can devise a recursive algorithm to recover the number of; // regular bins before the overflow bin we're currently looking at:; //; // - Start by processing the last histogram axis.; // - Ignore the first and last hyperplane on this axis, which only contain; // underflow and overflow bins respectively.; // - Count how many complete hyperplanes of regular bins lie before us on; // this axis, which we can do indirectly in our overflow bin based; // reasoning by computing the perimeter of the regular region and dividing; // our ""regular"" overflow bin count by that amount.; // - Now we counted previous hyperplanes on this last histogram axis, but; // we need to process the hyperplane that our bin is located in, if any.; // * For this, we reduce our overflow bin count to a count of; // _unaccounted_ overflow bins in the current hyperplane...; // * ...which allows us to recursively continue the computation by; // processing the next (well, previous) histogram axis in the context; // of this hyperplane, in the same manner as above.; //; // Alright, now that the general plan is sorted out, let's compute some; // quantities that we are going to need, namely the total number of bins per; // hyperplane (overflow and regular) and the number of regular bins per; // hyperplane on the hyperplanes that have them.; //",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:1373,Safety,recover,recover,1373,"-7 3 4 -8; // -9 -10 -11 -12 <- No regular bins on the overflow line of axis 1; //; // As we go to higher dimensions, the geometry becomes more complex, but; // if we replace ""line"" with ""plane"", we get a similar picture in 3D when we; // slide along axis 2:; //; // No regular bins on the Some of them on the No regular bins again; // UF plane of axis 2 regular planes of ax.2 on the OF plane of ax.2; //; // -1 -2 -3 -4 -17 -18 -19 -20 -29 -30 -31 -32; // -5 -6 -7 -8 -21 1 2 -22 -33 -34 -35 -36; // -9 -10 -11 -12 -23 3 4 -24 -37 -37 -39 -40; // -13 -14 -15 -16 -25 -26 -27 -28 -41 -42 -43 -44; //; // We can generalize this to N dimensions by saying that as we slide along; // the last axis of an N-d histogram, we see an hyperplane full of overflow; // bins, then some hyperplanes with regular bins in the ""middle"" surrounded; // by overflow bins, then a last hyperplane full of overflow bins.; //; // From this, we can devise a recursive algorithm to recover the number of; // regular bins before the overflow bin we're currently looking at:; //; // - Start by processing the last histogram axis.; // - Ignore the first and last hyperplane on this axis, which only contain; // underflow and overflow bins respectively.; // - Count how many complete hyperplanes of regular bins lie before us on; // this axis, which we can do indirectly in our overflow bin based; // reasoning by computing the perimeter of the regular region and dividing; // our ""regular"" overflow bin count by that amount.; // - Now we counted previous hyperplanes on this last histogram axis, but; // we need to process the hyperplane that our bin is located in, if any.; // * For this, we reduce our overflow bin count to a count of; // _unaccounted_ overflow bins in the current hyperplane...; // * ...which allows us to recursively continue the computation by; // processing the next (well, previous) histogram axis in the context; // of this hyperplane, in the same manner as above.; //; // Alright, now that the general ",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:252,Usability,simpl,simple,252,"// ...so we need to retrieve and bring back the regular bin count, and this; // is where the fun begins.; //; // The main difficulty is that the number of regular bins is not fixed as; // one slides along a histogram axis. Using a 2D binning case as a simple; // motivating example...; //; // -1 -2 -3 -4 <- No regular bins on the underflow line of axis 1; // -5 1 2 -6 <- Some of them on middle lines of axis 1; // -7 3 4 -8; // -9 -10 -11 -12 <- No regular bins on the overflow line of axis 1; //; // As we go to higher dimensions, the geometry becomes more complex, but; // if we replace ""line"" with ""plane"", we get a similar picture in 3D when we; // slide along axis 2:; //; // No regular bins on the Some of them on the No regular bins again; // UF plane of axis 2 regular planes of ax.2 on the OF plane of ax.2; //; // -1 -2 -3 -4 -17 -18 -19 -20 -29 -30 -31 -32; // -5 -6 -7 -8 -21 1 2 -22 -33 -34 -35 -36; // -9 -10 -11 -12 -23 3 4 -24 -37 -37 -39 -40; // -13 -14 -15 -16 -25 -26 -27 -28 -41 -42 -43 -44; //; // We can generalize this to N dimensions by saying that as we slide along; // the last axis of an N-d histogram, we see an hyperplane full of overflow; // bins, then some hyperplanes with regular bins in the ""middle"" surrounded; // by overflow bins, then a last hyperplane full of overflow bins.; //; // From this, we can devise a recursive algorithm to recover the number of; // regular bins before the overflow bin we're currently looking at:; //; // - Start by processing the last histogram axis.; // - Ignore the first and last hyperplane on this axis, which only contain; // underflow and overflow bins respectively.; // - Count how many complete hyperplanes of regular bins lie before us on; // this axis, which we can do indirectly in our overflow bin based; // reasoning by computing the perimeter of the regular region and dividing; // our ""regular"" overflow bin count by that amount.; // - Now we counted previous hyperplanes on this last histogram axis, but; // we need t",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx:27,Integrability,interface,interface,27,"/// \{; /// \name Iterator interface",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistImpl.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistImpl.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistUtils.hxx:227,Usability,Feedback,Feedback,227,"/// \file ROOT/RHistUtils.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2016-06-01; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome!; /*************************************************************************; * Copyright (C) 1995-2016, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistUtils.hxx:4,Testability,Log,Log,4,"/// Log channel for Hist diagnostics.",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistUtils.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistUtils.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx:226,Usability,Feedback,Feedback,226,"/// \file ROOT/RHistView.hxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-08-06; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx:445,Energy Efficiency,adapt,adaptor,445,"/*; * Need RHist::iterator for full range, takes a predicate for ""in range?""; * Returns true for RHist; for RHistView, checks range, returns false if not in; * range. i+= 7 then does i++ seven times and checks at each step.; * iterator is simply an int with a predicate functor. end is end of the; * histogram - i.e. the number of bins (incl over / underflow).; *; * Add is then an operation (through a functor) on two bins.; *; * Drawing: need adaptor from RHist<n,p>::GetBinContent(...) to; * RHistPrecNormalizer<n>::Get(i) that casts the bin content to a double. That; * should be in internal but outside the drawing library (that needs to; * communicate through abstract interfaces and can thus not instantiate; * templates with user precision parameters.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx:675,Integrability,interface,interfaces,675,"/*; * Need RHist::iterator for full range, takes a predicate for ""in range?""; * Returns true for RHist; for RHistView, checks range, returns false if not in; * range. i+= 7 then does i++ seven times and checks at each step.; * iterator is simply an int with a predicate functor. end is end of the; * histogram - i.e. the number of bins (incl over / underflow).; *; * Add is then an operation (through a functor) on two bins.; *; * Drawing: need adaptor from RHist<n,p>::GetBinContent(...) to; * RHistPrecNormalizer<n>::Get(i) that casts the bin content to a double. That; * should be in internal but outside the drawing library (that needs to; * communicate through abstract interfaces and can thus not instantiate; * templates with user precision parameters.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx:445,Modifiability,adapt,adaptor,445,"/*; * Need RHist::iterator for full range, takes a predicate for ""in range?""; * Returns true for RHist; for RHistView, checks range, returns false if not in; * range. i+= 7 then does i++ seven times and checks at each step.; * iterator is simply an int with a predicate functor. end is end of the; * histogram - i.e. the number of bins (incl over / underflow).; *; * Add is then an operation (through a functor) on two bins.; *; * Drawing: need adaptor from RHist<n,p>::GetBinContent(...) to; * RHistPrecNormalizer<n>::Get(i) that casts the bin content to a double. That; * should be in internal but outside the drawing library (that needs to; * communicate through abstract interfaces and can thus not instantiate; * templates with user precision parameters.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx:239,Usability,simpl,simply,239,"/*; * Need RHist::iterator for full range, takes a predicate for ""in range?""; * Returns true for RHist; for RHistView, checks range, returns false if not in; * range. i+= 7 then does i++ seven times and checks at each step.; * iterator is simply an int with a predicate functor. end is end of the; * histogram - i.e. the number of bins (incl over / underflow).; *; * Add is then an operation (through a functor) on two bins.; *; * Drawing: need adaptor from RHist<n,p>::GetBinContent(...) to; * RHistPrecNormalizer<n>::Get(i) that casts the bin content to a double. That; * should be in internal but outside the drawing library (that needs to; * communicate through abstract interfaces and can thus not instantiate; * templates with user precision parameters.; */",MatchSource.CODE_COMMENT,hist/histv7/inc/ROOT/RHistView.hxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHistView.hxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/speed/histspeedtest.cxx:146,Usability,Feedback,Feedback,146,"/// \file histspeedtest.cxx; ///; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /// \author Axel Naumann <axel@cern.ch>",MatchSource.CODE_COMMENT,hist/histv7/speed/histspeedtest.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/speed/histspeedtest.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/speed/histspeedtest.cxx:239,Availability,error,error,239,"/* DataTypes:. THistDataContent; THistDataUncertainty; THistDataMomentUncert; THistDataRuntime; and; MyTHistDataNoStat; MyTHistDataContent; MyTHistDataMomentUncert. /opt/build/root_builds/rootcling.cmake/include/ROOT/THistBinIter.h:53:50: error: no member named 'GetUncertainty' in; 'ROOT::Experimental::THistDataContent<2, double, ROOT::Experimental::THistDataDefaultStorage>::TBinStat<double>' auto; GetUncertainty() const { return GetStat().GetUncertainty(); }. new ones (STATCLASSES). THistStatContent; THistStatUncertainty; THistStatTotalSumOfWeights; THistStatTotalSumOfSquaredWeights; THistDataMomentUncert. */",MatchSource.CODE_COMMENT,hist/histv7/speed/histspeedtest.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/speed/histspeedtest.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/speed/histspeedtest.cxx:39,Availability,failure,failure,39,"// these are copy/paste to work around failure to properly instantiate the template :(",MatchSource.CODE_COMMENT,hist/histv7/speed/histspeedtest.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/speed/histspeedtest.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx:217,Usability,Feedback,Feedback,217,"/// \file RAxis.cxx; /// \ingroup HistV7; /// \author Axel Naumann <axel@cern.ch>; /// \date 2015-08-06; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /*************************************************************************; * Copyright (C) 1995-2015, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,hist/histv7/src/RAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx:14,Performance,optimiz,optimized,14,"// This is an optimized override for the equidistant-equidistant case,; // fall back to the default implementation if we're not in that case.",MatchSource.CODE_COMMENT,hist/histv7/src/RAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx:18,Availability,failure,failure,18,"// If not, report failure",MatchSource.CODE_COMMENT,hist/histv7/src/RAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx:14,Performance,optimiz,optimized,14,"// This is an optimized override for the irregular-irregular case,; // fall back to the default implementation if we're not in that case.",MatchSource.CODE_COMMENT,hist/histv7/src/RAxis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/src/RAxis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx:3,Testability,Test,Test,3,"// Test ""0 + x = x""",MatchSource.CODE_COMMENT,hist/histv7/test/add.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx:3,Testability,Test,Test,3,"// Test ""x + 0 = x""",MatchSource.CODE_COMMENT,hist/histv7/test/add.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx:3,Testability,Test,Test,3,"// Test ""x + x = 2*x""",MatchSource.CODE_COMMENT,hist/histv7/test/add.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx:3,Testability,Test,Test,3,"// Test ""x - x = 0""",MatchSource.CODE_COMMENT,hist/histv7/test/add.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx:3,Testability,Test,Test,3,"// Test ""x + y"" with less STAT",MatchSource.CODE_COMMENT,hist/histv7/test/add.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx:14,Testability,test,tests,14,"// Implicitly tests ROOT-8485.",MatchSource.CODE_COMMENT,hist/histv7/test/add.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/add.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx:11,Integrability,Wrap,WrappedAtomic,11,"/// \class WrappedAtomic.; /// \brief Provides copy constructor for `atomic` and `+=` even for floats.; ///; /// It provides the operations needed for `Hist` with atomic bin content.",MatchSource.CODE_COMMENT,hist/histv7/test/atomics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx:8,Integrability,wrap,wrapped,8,"/// The wrapped atomic value.",MatchSource.CODE_COMMENT,hist/histv7/test/atomics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx:10,Testability,test,tests,10,/** Basic tests for histograms of integral precision using vector<atomic> storage.; */,MatchSource.CODE_COMMENT,hist/histv7/test/atomics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx:3,Testability,Test,Test,3,"// Test creation of RHistImpl with atomic precision.",MatchSource.CODE_COMMENT,hist/histv7/test/atomics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx:3,Testability,Test,Test,3,"// Test filling of RHistImpl with atomic precision.",MatchSource.CODE_COMMENT,hist/histv7/test/atomics.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/atomics.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:3,Testability,Test,Test,3,"// Test RAxisConfig and conversion to concrete axis types",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:10,Testability,test,test,10,"// Common test items for RAxisBase child classes",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:10,Testability,test,test,10,"// Common test items for RAxisEquidistant child classes",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:211,Testability,test,test,211,"// NOTE: Result of GetBinFrom on underflow bins, GetBinTo on overflow bins and; // GetBinCenter on either is considered unspecified for now. If we do; // ultimately decide to specify this behavior, please add a test here.",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:16,Testability,test,test,16,"// FIXME: Can't test RAxisGrow::Grow() as this method is not implemented.; // Once it's implemented, please factor out commonalities with; // the RAxisLabels test.",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:158,Testability,test,test,158,"// FIXME: Can't test RAxisGrow::Grow() as this method is not implemented.; // Once it's implemented, please factor out commonalities with; // the RAxisLabels test.",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:29,Deployability,configurat,configuration,29,"// Notice that the RAxisBase configuration is _not_ updated when new; // labels are added. This is by design, according to the RAxisLabels docs.; // The configuration would be updated on Grow(), but we can't test Grow(); // right now since it isn't implemented yet...",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:52,Deployability,update,updated,52,"// Notice that the RAxisBase configuration is _not_ updated when new; // labels are added. This is by design, according to the RAxisLabels docs.; // The configuration would be updated on Grow(), but we can't test Grow(); // right now since it isn't implemented yet...",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:153,Deployability,configurat,configuration,153,"// Notice that the RAxisBase configuration is _not_ updated when new; // labels are added. This is by design, according to the RAxisLabels docs.; // The configuration would be updated on Grow(), but we can't test Grow(); // right now since it isn't implemented yet...",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:176,Deployability,update,updated,176,"// Notice that the RAxisBase configuration is _not_ updated when new; // labels are added. This is by design, according to the RAxisLabels docs.; // The configuration would be updated on Grow(), but we can't test Grow(); // right now since it isn't implemented yet...",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:29,Modifiability,config,configuration,29,"// Notice that the RAxisBase configuration is _not_ updated when new; // labels are added. This is by design, according to the RAxisLabels docs.; // The configuration would be updated on Grow(), but we can't test Grow(); // right now since it isn't implemented yet...",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:153,Modifiability,config,configuration,153,"// Notice that the RAxisBase configuration is _not_ updated when new; // labels are added. This is by design, according to the RAxisLabels docs.; // The configuration would be updated on Grow(), but we can't test Grow(); // right now since it isn't implemented yet...",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:208,Testability,test,test,208,"// Notice that the RAxisBase configuration is _not_ updated when new; // labels are added. This is by design, according to the RAxisLabels docs.; // The configuration would be updated on Grow(), but we can't test Grow(); // right now since it isn't implemented yet...",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:16,Testability,test,test,16,"// FIXME: Can't test RAxisGrow::Grow() as this method is not implemented.; // Once it's implemented, please factor out commonalities with; // the RAxisGrow test.; // Now let's add some new bins",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx:156,Testability,test,test,156,"// FIXME: Can't test RAxisGrow::Grow() as this method is not implemented.; // Once it's implemented, please factor out commonalities with; // the RAxisGrow test.; // Now let's add some new bins",MatchSource.CODE_COMMENT,hist/histv7/test/axis.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/axis.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/biniter.cxx:3,Testability,Test,Tests,3,"// Tests the number of bins",MatchSource.CODE_COMMENT,hist/histv7/test/biniter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/biniter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/biniter.cxx:3,Testability,Test,Tests,3,"// Tests the bin ref: fill, retrieve.",MatchSource.CODE_COMMENT,hist/histv7/test/biniter.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/biniter.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx:72,Deployability,configurat,configuration,72,"// Generic test that an N-dimensional histogram with a certain axis; // configuration is binned correctly.",MatchSource.CODE_COMMENT,hist/histv7/test/binning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx:72,Modifiability,config,configuration,72,"// Generic test that an N-dimensional histogram with a certain axis; // configuration is binned correctly.",MatchSource.CODE_COMMENT,hist/histv7/test/binning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx:11,Testability,test,test,11,"// Generic test that an N-dimensional histogram with a certain axis; // configuration is binned correctly.",MatchSource.CODE_COMMENT,hist/histv7/test/binning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx:45,Deployability,configurat,configuration,45,"// Build an RHistImpl with the provided axis configuration",MatchSource.CODE_COMMENT,hist/histv7/test/binning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx:45,Modifiability,config,configuration,45,"// Build an RHistImpl with the provided axis configuration",MatchSource.CODE_COMMENT,hist/histv7/test/binning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx:51,Availability,failure,failure,51,"// Make googletest report the current bin index on failure",MatchSource.CODE_COMMENT,hist/histv7/test/binning.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/binning.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx:25,Performance,concurren,concurrentfill,25,"// Functions for testing concurrentfill",MatchSource.CODE_COMMENT,hist/histv7/test/concurrentfill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx:17,Testability,test,testing,17,"// Functions for testing concurrentfill",MatchSource.CODE_COMMENT,hist/histv7/test/concurrentfill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx:38,Performance,concurren,concurrentfill,38,"// Test consistancy of the hist after concurrentfill",MatchSource.CODE_COMMENT,hist/histv7/test/concurrentfill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx:3,Testability,Test,Test,3,"// Test consistancy of the hist after concurrentfill",MatchSource.CODE_COMMENT,hist/histv7/test/concurrentfill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx:3,Testability,Test,Test,3,"// Test flush and fill manually",MatchSource.CODE_COMMENT,hist/histv7/test/concurrentfill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/concurrentfill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH.. constructors and especially GetNBins(), GetNDim() and GetBinContent() from RHistImpl.hxx; // Test RH1F constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:106,Testability,Test,Test,106,"// Test RH.. constructors and especially GetNBins(), GetNDim() and GetBinContent() from RHistImpl.hxx; // Test RH1F constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH1D constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH1I constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH1C constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH1LL constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH2F constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH2D constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH2I constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH2C constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH2LL constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH3F constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH3D constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH3I constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH3C constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RH3LL constructor",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RHist constructor with 4 dimensions",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx:3,Testability,Test,Test,3,"// Test RHist constructor with title",MatchSource.CODE_COMMENT,hist/histv7/test/constructors.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/constructors.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill(), FillN(), GetEntries(), GetBinContent(), GetBinUncertainty(); // RHist::Fill for 1D; // Test Fill() without weight and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:103,Testability,Test,Test,103,"// Test Fill(), FillN(), GetEntries(), GetBinContent(), GetBinUncertainty(); // RHist::Fill for 1D; // Test Fill() without weight and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() without weight and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() without weight and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with NaN and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with NaN and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with NaN and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with NaN and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with NaN and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with NaN and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() with weights and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() with weights and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:26,Testability,Test,Test,26,"// RHist::Fill for 2D; // Test Fill() without weight and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() without weight and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() without weight and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() with weights and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() with weights and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:26,Testability,Test,Test,26,"// RHist::Fill for 3D; // Test Fill() without weight and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() without weight and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() without weight and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test Fill() with weight and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() without weights and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() with weights and GetEntries()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() with weights and GetBinContent()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx:3,Testability,Test,Test,3,"// Test FillN() and GetBinUncertainty()",MatchSource.CODE_COMMENT,hist/histv7/test/fill.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/test/fill.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Performance,optimiz,optimization,5,"///< optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Availability,error,error,24,"///< [fNPeaks] array of error values of x positions of 2D peaks, output parameters",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Availability,error,error,24,"///< [fNPeaks] array of error values of y positions of 2D peaks, output parameters",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:36,Availability,error,errors,36,"///< [fNPeaks] array of x positions errors of 1D ridges, output parameters",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:36,Availability,error,errors,36,"///< [fNPeaks] array of y positions errors of 1D ridges, output parameters",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:35,Availability,error,errors,35,"///< [fNPeaks] array of amplitudes errors of 2D peaks, output parameters",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:35,Availability,error,errors,35,"///< [fNPeaks] array of amplitudes errors of 1D ridges in x direction, output parameters",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:35,Availability,error,errors,35,"///< [fNPeaks] array of amplitudes errors of 1D ridges in y direction, output parameters",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:32,Availability,error,errors,32,"///< [fNPeaks] array of volumes errors of 2D peaks, output parameters",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of sigma x parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of sigma y parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of correlation coefficient",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of t parameter for 2D peaks",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of s parameter for 2D peaks",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of t parameter for 1D ridges in x direction",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of t parameter for 1D ridges in y direction",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of s parameter for 1D ridges in x direction",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of s parameter for 1D ridges in y direction",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of b parameter for 1D ridges in x direction",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of b parameter for 1D ridges in y direction",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of background a0 parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of background ax parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Availability,error,error,5,"///< error value of background ay parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate x positions of 2D peaks (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate y positions of 2D peaks (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate x positions of 1D ridges (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate y positions of 1D ridges (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in x direction (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 1D ridges in y direction (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of sigma x parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of sigma y parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of correlation coefficient, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of t parameter for 2D peaks, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of s parameter for 2D peaks, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of t parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of t parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of s parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of s parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of b parameter for 1D ridges in x direction, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of b parameter for 1D ridges in y direction, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of a0 parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of ax parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,Testability,log,logical,5,"///< logical value of ay parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Fit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h:36,Modifiability,enhance,enhanced,36,"///< first channel x of filtered or enhanced region",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Transform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h:35,Modifiability,enhance,enhanced,35,"///< last channel x of filtered or enhanced region",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Transform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h:36,Modifiability,enhance,enhanced,36,"///< first channel y of filtered or enhanced region",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Transform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h:35,Modifiability,enhance,enhanced,35,"///< last channel y of filtered or enhanced region",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Transform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h:43,Modifiability,enhance,enhanced,43,"///< multiplication coefficient applied in enhanced region;",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrum2Transform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Transform.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Performance,optimiz,optimization,5,"///< optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:33,Availability,error,errors,33,"///< [fNPeaks] array of position errors",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:34,Availability,error,errors,34,"///< [fNPeaks] array of amplitude errors",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:24,Availability,error,errors,24,"///< [fNPeaks] array of errors of peak areas",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Availability,error,error,5,"///< error value of sigma parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Availability,error,error,5,"///< error value of t parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Availability,error,error,5,"///< error value of b parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Availability,error,error,5,"///< error value of s parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Availability,error,error,5,"///< error value of background a0 parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Availability,error,error,5,"///< error value of background a1 parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Availability,error,error,5,"///< error value of background a2 parameter",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate positions (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:24,Testability,log,logical,24,"///< [fNPeaks] array of logical values which allow to fix appropriate amplitudes (not fit). However they are present in the estimated functional",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Testability,log,logical,5,"///< logical value of sigma parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Testability,log,logical,5,"///< logical value of t parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Testability,log,logical,5,"///< logical value of b parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Testability,log,logical,5,"///< logical value of s parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Testability,log,logical,5,"///< logical value of a0 parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Testability,log,logical,5,"///< logical value of a1 parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h:5,Testability,log,logical,5,"///< logical value of a2 parameter, which allows to fix the parameter (not to fit).",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumFit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumFit.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumTransform.h:34,Modifiability,enhance,enhanced,34,"///< first channel of filtered or enhanced region",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumTransform.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumTransform.h:33,Modifiability,enhance,enhanced,33,"///< last channel of filtered or enhanced region",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumTransform.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumTransform.h:43,Modifiability,enhance,enhanced,43,"///< multiplication coefficient applied in enhanced region;",MatchSource.CODE_COMMENT,hist/spectrum/inc/TSpectrumTransform.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrumTransform.h
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:738,Energy Efficiency,Efficient,Efficient,738,"/** \class TSpectrum; \ingroup Spectrum; \brief Advanced Spectra Processing; \author Miroslav Morhac. \legacy{TSpectrum, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. This class contains advanced spectra processing functions for:. - One-dimensional background estimation; - One-dimensional smoothing; - One-dimensional deconvolution; - One-dimensional peak search. The algorithms in this class have been published in the following references:. 1. M.Morhac et al.: Background elimination methods for multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Physics Research A 401 (1997) 113-132.; 2. M.Morhac et al.: Efficient one- and two-dimensional Gold deconvolution and its application to gamma-ray spectra decomposition. Nuclear Instruments and Methods in Physics Research A 401 (1997) 385-408.; 3. M.Morhac et al.: Identification of peaks in multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Research Physics A 443(2000), 108-125. */",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:320,Performance,perform,performed,320,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional peak search function; ///; /// This function searches for peaks in source spectrum in hin; /// The number of found peaks and their positions are written into; /// the members fNpeaks and fPositionX.; /// The search is performed in the current histogram range.; ///; /// #### Parameters:; ///; /// - hin: pointer to the histogram of source spectrum; /// - sigma: sigma of searched peaks, for details we refer to manual; /// - threshold: (default=0.05) peaks with amplitude less than; /// threshold*highest_peak are discarded. 0<threshold<1; ///; /// By default, the background is removed before deconvolution.; /// Specify the option ""nobackground"" to not remove the background.; ///; /// By default the ""Markov"" chain algorithm is used.; /// Specify the option ""noMarkov"" to disable this algorithm; /// Note that by default the source spectrum is replaced by a new spectrum; ///; /// By default a polymarker object is created and added to the list of; /// functions of the histogram. The histogram is drawn with the specified; /// option and the polymarker object drawn on top of the histogram.; /// The polymarker coordinates correspond to the npeaks peaks found in; /// the histogram.; ///; /// A pointer to the polymarker object can be retrieved later via:; /// ~~~ {.cpp}; /// TList *functions = hin->GetListOfFunctions();; /// TPolyMarker *pm = (TPolyMarker*)functions->FindObject(""TPolyMarker"");; /// ~~~; /// Specify the option ""goff"" to disable the storage and drawing of the; /// polymarker.; ///; /// To disable the final drawing of the histogram with the search results (in case; /// you want to draw it yourself) specify ""nodraw"" in the options parameter.",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:993,Availability,error,error,993,"////////////////////////////////////////////////////////////////; /// This function calculates background spectrum from source spectrum.; /// The result is placed in the vector pointed by spectrum pointer.; /// The goal is to separate the useful information (peaks) from useless; /// information (background).; ///; /// - method is based on Sensitive Nonlinear Iterative Peak (SNIP) clipping; /// algorithm.; /// - new value in the channel ""i"" is calculated; ///; /// \f[; /// v_p(i) = min \left\{ v_{p-1}(i)^{\frac{\left[v_{p-1}(i+p)+v_{p-1}(i-p)\right]}{2}} \right\}; /// \f]; ///; /// where p = 1, 2, ..., numberIterations. In fact it represents second order; /// difference filter (-1,2,-1).; ///; /// One can also change the; /// direction of the change of the clipping window, the order of the clipping; /// filter, to include smoothing, to set width of smoothing window and to include; /// the estimation of Compton edges. On successful completion it returns 0. On; /// error it returns pointer to the string describing error.; ///; /// #### Parameters:; ///; /// - spectrum: pointer to the vector of source spectrum; /// - ssize: length of the spectrum vector; /// - numberIterations: maximal width of clipping window,; /// - direction: direction of change of clipping window.; /// Possible values: kBackIncreasingWindow, kBackDecreasingWindow; /// - filterOrder: order of clipping filter.; /// Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; /// - smoothing: logical variable whether the smoothing operation in the; /// estimation of background will be included.; /// Possible values: kFALSE, kTRUE; /// - smoothWindow: width of smoothing window.; /// Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; /// kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; /// - compton: logical variable whether the estimation of Compton edge will be; /// included. Possible values: kFALSE, kTRUE.; ///; /// #### References:; ///; /// 1. C. G Rya",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1043,Availability,error,error,1043,"////////////////////////////////////////////////////////////////; /// This function calculates background spectrum from source spectrum.; /// The result is placed in the vector pointed by spectrum pointer.; /// The goal is to separate the useful information (peaks) from useless; /// information (background).; ///; /// - method is based on Sensitive Nonlinear Iterative Peak (SNIP) clipping; /// algorithm.; /// - new value in the channel ""i"" is calculated; ///; /// \f[; /// v_p(i) = min \left\{ v_{p-1}(i)^{\frac{\left[v_{p-1}(i+p)+v_{p-1}(i-p)\right]}{2}} \right\}; /// \f]; ///; /// where p = 1, 2, ..., numberIterations. In fact it represents second order; /// difference filter (-1,2,-1).; ///; /// One can also change the; /// direction of the change of the clipping window, the order of the clipping; /// filter, to include smoothing, to set width of smoothing window and to include; /// the estimation of Compton edges. On successful completion it returns 0. On; /// error it returns pointer to the string describing error.; ///; /// #### Parameters:; ///; /// - spectrum: pointer to the vector of source spectrum; /// - ssize: length of the spectrum vector; /// - numberIterations: maximal width of clipping window,; /// - direction: direction of change of clipping window.; /// Possible values: kBackIncreasingWindow, kBackDecreasingWindow; /// - filterOrder: order of clipping filter.; /// Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; /// - smoothing: logical variable whether the smoothing operation in the; /// estimation of background will be included.; /// Possible values: kFALSE, kTRUE; /// - smoothWindow: width of smoothing window.; /// Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; /// kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; /// - compton: logical variable whether the estimation of Compton edge will be; /// included. Possible values: kFALSE, kTRUE.; ///; /// #### References:; ///; /// 1. C. G Rya",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:5660,Availability,error,error,5660,"d_order.C:; ///; /// Second order difference filter removes linear (quasi-linear) background and; /// preserves symmetrical peaks. However if the shape of the background is more; /// complex one can employ higher-order clipping filters.; ///; /// Example of the influence of clipping filter difference order on the estimated; /// background for fNnumberIterations=40, 2-nd order red line, 4-th order blue line,; /// 6-th order green line and 8-th order magenta line, and using decreasing; /// clipping window algorithm.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_order.C; /// End_Macro; ///; /// ### Example 6 script Background_smooth.C:; ///; /// The estimate of the background can be influenced by noise present in the; /// spectrum. We proposed the algorithm of the background estimate with; /// simultaneous smoothing. In the original algorithm without smoothing, the; /// estimated background snatches the lower spikes in the noise. Consequently,; /// the areas of peaks are biased by this error.; ///; /// \image html TSpectrum_Background_smooth1.jpg Principle of background estimation algorithm with simultaneous smoothing.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_smooth.C; /// End_Macro; ///; /// ### Example 8 script Background_compton.C:; ///; /// Sometimes it is necessary to include also the Compton edges into the estimate of; /// the background. This example presents the synthetic spectrum; /// with Compton edges. The background was estimated using the 8-th order filter; /// with the estimation of the Compton edges using decreasing; /// clipping window algorithm (numberIterations=10) with smoothing; /// (smoothingWindow=5).; ///; /// Example of the estimate of the background with Compton edges (red line) for; /// numberIterations=10, 8-th order difference filter, using decreasing clipping; /// window algorithm and smoothing (smoothingWindow=5).; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Bac",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3834,Energy Efficiency,green,green,3834,"cro; ///; /// ### Example 2 script Background_decr.C:; ///; /// In Example 1. one can notice that at the edges of the peaks the estimated; /// background goes under the peaks. An alternative approach is to decrease the; /// clipping window from a given value numberIterations to the value of one, which; /// is presented in this example.; ///; /// Example of the estimation of background for numberIterations=6 using; /// decreasing clipping window algorithm. Original spectrum is shown in black; /// color, estimated background in red color.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_decr.C; /// End_Macro; ///; /// ### Example 3 script Background_width.C:; ///; /// The question is how to choose the width of the clipping window, i.e.,; /// numberIterations parameter. The influence of this parameter on the estimated; /// background is illustrated in Example 3.; ///; /// Example of the influence of clipping window width on the estimated background; /// for numberIterations=4 (red line), 6 (orange line) 8 (green line) using decreasing; /// clipping window algorithm.; ///; /// in general one should set this parameter so that the value; /// 2*numberIterations+1 was greater than the widths of preserved objects (peaks).; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_width.C; /// End_Macro; ///; /// ### Example 4 script Background_width2.C:; ///; /// another example for very complex spectrum is given here.; ///; /// Example of the influence of clipping window width on the estimated background; /// for numberIterations=10 (red line), 20 (blue line), 30 (green line) and; /// 40 (magenta line) using decreasing clipping window algorithm.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_width2.C; /// End_Macro; ///; /// ### Example 5 script Background_order.C:; ///; /// Second order difference filter removes linear (quasi-linear) background and; /// preserves symmetrical peaks. However if the shape of t",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:4413,Energy Efficiency,green,green,4413,"torials/spectrum/Background_decr.C; /// End_Macro; ///; /// ### Example 3 script Background_width.C:; ///; /// The question is how to choose the width of the clipping window, i.e.,; /// numberIterations parameter. The influence of this parameter on the estimated; /// background is illustrated in Example 3.; ///; /// Example of the influence of clipping window width on the estimated background; /// for numberIterations=4 (red line), 6 (orange line) 8 (green line) using decreasing; /// clipping window algorithm.; ///; /// in general one should set this parameter so that the value; /// 2*numberIterations+1 was greater than the widths of preserved objects (peaks).; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_width.C; /// End_Macro; ///; /// ### Example 4 script Background_width2.C:; ///; /// another example for very complex spectrum is given here.; ///; /// Example of the influence of clipping window width on the estimated background; /// for numberIterations=10 (red line), 20 (blue line), 30 (green line) and; /// 40 (magenta line) using decreasing clipping window algorithm.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_width2.C; /// End_Macro; ///; /// ### Example 5 script Background_order.C:; ///; /// Second order difference filter removes linear (quasi-linear) background and; /// preserves symmetrical peaks. However if the shape of the background is more; /// complex one can employ higher-order clipping filters.; ///; /// Example of the influence of clipping filter difference order on the estimated; /// background for fNnumberIterations=40, 2-nd order red line, 4-th order blue line,; /// 6-th order green line and 8-th order magenta line, and using decreasing; /// clipping window algorithm.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_order.C; /// End_Macro; ///; /// ### Example 6 script Background_smooth.C:; ///; /// The estimate of the background can be influenced by noise present ",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:5061,Energy Efficiency,green,green,5061,"widths of preserved objects (peaks).; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_width.C; /// End_Macro; ///; /// ### Example 4 script Background_width2.C:; ///; /// another example for very complex spectrum is given here.; ///; /// Example of the influence of clipping window width on the estimated background; /// for numberIterations=10 (red line), 20 (blue line), 30 (green line) and; /// 40 (magenta line) using decreasing clipping window algorithm.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_width2.C; /// End_Macro; ///; /// ### Example 5 script Background_order.C:; ///; /// Second order difference filter removes linear (quasi-linear) background and; /// preserves symmetrical peaks. However if the shape of the background is more; /// complex one can employ higher-order clipping filters.; ///; /// Example of the influence of clipping filter difference order on the estimated; /// background for fNnumberIterations=40, 2-nd order red line, 4-th order blue line,; /// 6-th order green line and 8-th order magenta line, and using decreasing; /// clipping window algorithm.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_order.C; /// End_Macro; ///; /// ### Example 6 script Background_smooth.C:; ///; /// The estimate of the background can be influenced by noise present in the; /// spectrum. We proposed the algorithm of the background estimate with; /// simultaneous smoothing. In the original algorithm without smoothing, the; /// estimated background snatches the lower spikes in the noise. Consequently,; /// the areas of peaks are biased by this error.; ///; /// \image html TSpectrum_Background_smooth1.jpg Principle of background estimation algorithm with simultaneous smoothing.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_smooth.C; /// End_Macro; ///; /// ### Example 8 script Background_compton.C:; ///; /// Sometimes it is necessary to include also the Compton e",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1513,Modifiability,variab,variable,1513,"t\{ v_{p-1}(i)^{\frac{\left[v_{p-1}(i+p)+v_{p-1}(i-p)\right]}{2}} \right\}; /// \f]; ///; /// where p = 1, 2, ..., numberIterations. In fact it represents second order; /// difference filter (-1,2,-1).; ///; /// One can also change the; /// direction of the change of the clipping window, the order of the clipping; /// filter, to include smoothing, to set width of smoothing window and to include; /// the estimation of Compton edges. On successful completion it returns 0. On; /// error it returns pointer to the string describing error.; ///; /// #### Parameters:; ///; /// - spectrum: pointer to the vector of source spectrum; /// - ssize: length of the spectrum vector; /// - numberIterations: maximal width of clipping window,; /// - direction: direction of change of clipping window.; /// Possible values: kBackIncreasingWindow, kBackDecreasingWindow; /// - filterOrder: order of clipping filter.; /// Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; /// - smoothing: logical variable whether the smoothing operation in the; /// estimation of background will be included.; /// Possible values: kFALSE, kTRUE; /// - smoothWindow: width of smoothing window.; /// Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; /// kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; /// - compton: logical variable whether the estimation of Compton edge will be; /// included. Possible values: kFALSE, kTRUE.; ///; /// #### References:; ///; /// 1. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; /// quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; /// (1988), 396-402.; ///; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo:; /// Background elimination methods for multidimensional gamma-ray spectra. NIM,; /// A401 (1997) 113-132.; ///; /// 3. D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; /// spectroscopy. NIM 214 (1983), 431-434.; ///; /// ### Example 1 ",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1866,Modifiability,variab,variable,1866,"ndow and to include; /// the estimation of Compton edges. On successful completion it returns 0. On; /// error it returns pointer to the string describing error.; ///; /// #### Parameters:; ///; /// - spectrum: pointer to the vector of source spectrum; /// - ssize: length of the spectrum vector; /// - numberIterations: maximal width of clipping window,; /// - direction: direction of change of clipping window.; /// Possible values: kBackIncreasingWindow, kBackDecreasingWindow; /// - filterOrder: order of clipping filter.; /// Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; /// - smoothing: logical variable whether the smoothing operation in the; /// estimation of background will be included.; /// Possible values: kFALSE, kTRUE; /// - smoothWindow: width of smoothing window.; /// Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; /// kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; /// - compton: logical variable whether the estimation of Compton edge will be; /// included. Possible values: kFALSE, kTRUE.; ///; /// #### References:; ///; /// 1. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; /// quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; /// (1988), 396-402.; ///; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo:; /// Background elimination methods for multidimensional gamma-ray spectra. NIM,; /// A401 (1997) 113-132.; ///; /// 3. D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; /// spectroscopy. NIM 214 (1983), 431-434.; ///; /// ### Example 1 script Background_incr.C:; ///; /// Example of the estimation of background for number of iterations=6.; /// Original spectrum is shown in black color, estimated background in red color.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_incr.C; /// End_Macro; ///; /// ### Example 2 script Background_decr.C:; ///; /// In Example 1. one can notice that a",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1505,Testability,log,logical,1505,"t\{ v_{p-1}(i)^{\frac{\left[v_{p-1}(i+p)+v_{p-1}(i-p)\right]}{2}} \right\}; /// \f]; ///; /// where p = 1, 2, ..., numberIterations. In fact it represents second order; /// difference filter (-1,2,-1).; ///; /// One can also change the; /// direction of the change of the clipping window, the order of the clipping; /// filter, to include smoothing, to set width of smoothing window and to include; /// the estimation of Compton edges. On successful completion it returns 0. On; /// error it returns pointer to the string describing error.; ///; /// #### Parameters:; ///; /// - spectrum: pointer to the vector of source spectrum; /// - ssize: length of the spectrum vector; /// - numberIterations: maximal width of clipping window,; /// - direction: direction of change of clipping window.; /// Possible values: kBackIncreasingWindow, kBackDecreasingWindow; /// - filterOrder: order of clipping filter.; /// Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; /// - smoothing: logical variable whether the smoothing operation in the; /// estimation of background will be included.; /// Possible values: kFALSE, kTRUE; /// - smoothWindow: width of smoothing window.; /// Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; /// kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; /// - compton: logical variable whether the estimation of Compton edge will be; /// included. Possible values: kFALSE, kTRUE.; ///; /// #### References:; ///; /// 1. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; /// quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; /// (1988), 396-402.; ///; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo:; /// Background elimination methods for multidimensional gamma-ray spectra. NIM,; /// A401 (1997) 113-132.; ///; /// 3. D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; /// spectroscopy. NIM 214 (1983), 431-434.; ///; /// ### Example 1 ",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1858,Testability,log,logical,1858,"ndow and to include; /// the estimation of Compton edges. On successful completion it returns 0. On; /// error it returns pointer to the string describing error.; ///; /// #### Parameters:; ///; /// - spectrum: pointer to the vector of source spectrum; /// - ssize: length of the spectrum vector; /// - numberIterations: maximal width of clipping window,; /// - direction: direction of change of clipping window.; /// Possible values: kBackIncreasingWindow, kBackDecreasingWindow; /// - filterOrder: order of clipping filter.; /// Possible values: kBackOrder2, kBackOrder4, kBackOrder6, kBackOrder8; /// - smoothing: logical variable whether the smoothing operation in the; /// estimation of background will be included.; /// Possible values: kFALSE, kTRUE; /// - smoothWindow: width of smoothing window.; /// Possible values: kBackSmoothing3, kBackSmoothing5, kBackSmoothing7,; /// kBackSmoothing9, kBackSmoothing11, kBackSmoothing13, kBackSmoothing15.; /// - compton: logical variable whether the estimation of Compton edge will be; /// included. Possible values: kFALSE, kTRUE.; ///; /// #### References:; ///; /// 1. C. G Ryan et al.: SNIP, a statistics-sensitive background treatment for the; /// quantitative analysis of PIXE spectra in geoscience applications. NIM, B34; /// (1988), 396-402.; ///; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo:; /// Background elimination methods for multidimensional gamma-ray spectra. NIM,; /// A401 (1997) 113-132.; ///; /// 3. D. D. Burgess, R. J. Tervo: Background estimation for gamma-ray; /// spectroscopy. NIM 214 (1983), 431-434.; ///; /// ### Example 1 script Background_incr.C:; ///; /// Example of the estimation of background for number of iterations=6.; /// Original spectrum is shown in black color, estimated background in red color.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Background_incr.C; /// End_Macro; ///; /// ### Example 2 script Background_decr.C:; ///; /// In Example 1. one can notice that a",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:354,Availability,error,error,354,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional markov spectrum smoothing function; ///; /// This function calculates smoothed spectrum from source spectrum based on; /// Markov chain method. The result is placed in the array pointed by source; /// pointer. On successful completion it returns 0. On error it returns pointer; /// to the string describing error.; ///; /// #### Parameters:; ///; /// - source: pointer to the array of source spectrum; /// - ssize: length of source array; /// - averWindow: width of averaging smoothing window; ///; /// The goal of this function is the suppression of the statistical fluctuations.; /// The algorithm is based on discrete Markov chain, which has very simple; /// invariant distribution:; ///; /// \f[; /// U_2 = \frac{p_{1,2}}{p_{2,1}}U_1, U_3 = \frac{p_{2,3}}{p_{3,2}}U_2U_1, ... , U_n = \frac{p_{n-1,n}}{p_{n,n-1}}U_{n-1}...U_2U_1; /// \f]; /// \f$ U_1\f$ being defined from the normalization condition; /// \f$ \sum_{i=1}^{n} U_i=1\f$. \f$ n \f$ is the length of the smoothed spectrum and; /// \f[; /// p_{i,i\pm 1} = A_i\sum_{k=1}^{m} exp\left[ \frac{y(i\pm k)-y(i)}{y(i\pm k)+y(i)}\right]; /// \f]; ///; /// #### Reference:; ///; /// 1. Z.K. Silagadze, A new algorithm for automatic photopeak searches.; /// NIM A 376 (1996), 451.; ///; /// ### Example 14 - script Smoothing.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Smoothing.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:409,Availability,error,error,409,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional markov spectrum smoothing function; ///; /// This function calculates smoothed spectrum from source spectrum based on; /// Markov chain method. The result is placed in the array pointed by source; /// pointer. On successful completion it returns 0. On error it returns pointer; /// to the string describing error.; ///; /// #### Parameters:; ///; /// - source: pointer to the array of source spectrum; /// - ssize: length of source array; /// - averWindow: width of averaging smoothing window; ///; /// The goal of this function is the suppression of the statistical fluctuations.; /// The algorithm is based on discrete Markov chain, which has very simple; /// invariant distribution:; ///; /// \f[; /// U_2 = \frac{p_{1,2}}{p_{2,1}}U_1, U_3 = \frac{p_{2,3}}{p_{3,2}}U_2U_1, ... , U_n = \frac{p_{n-1,n}}{p_{n,n-1}}U_{n-1}...U_2U_1; /// \f]; /// \f$ U_1\f$ being defined from the normalization condition; /// \f$ \sum_{i=1}^{n} U_i=1\f$. \f$ n \f$ is the length of the smoothed spectrum and; /// \f[; /// p_{i,i\pm 1} = A_i\sum_{k=1}^{m} exp\left[ \frac{y(i\pm k)-y(i)}{y(i\pm k)+y(i)}\right]; /// \f]; ///; /// #### Reference:; ///; /// 1. Z.K. Silagadze, A new algorithm for automatic photopeak searches.; /// NIM A 376 (1996), 451.; ///; /// ### Example 14 - script Smoothing.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Smoothing.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:752,Usability,simpl,simple,752,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional markov spectrum smoothing function; ///; /// This function calculates smoothed spectrum from source spectrum based on; /// Markov chain method. The result is placed in the array pointed by source; /// pointer. On successful completion it returns 0. On error it returns pointer; /// to the string describing error.; ///; /// #### Parameters:; ///; /// - source: pointer to the array of source spectrum; /// - ssize: length of source array; /// - averWindow: width of averaging smoothing window; ///; /// The goal of this function is the suppression of the statistical fluctuations.; /// The algorithm is based on discrete Markov chain, which has very simple; /// invariant distribution:; ///; /// \f[; /// U_2 = \frac{p_{1,2}}{p_{2,1}}U_1, U_3 = \frac{p_{2,3}}{p_{3,2}}U_2U_1, ... , U_n = \frac{p_{n-1,n}}{p_{n,n-1}}U_{n-1}...U_2U_1; /// \f]; /// \f$ U_1\f$ being defined from the normalization condition; /// \f$ \sum_{i=1}^{n} U_i=1\f$. \f$ n \f$ is the length of the smoothed spectrum and; /// \f[; /// p_{i,i\pm 1} = A_i\sum_{k=1}^{m} exp\left[ \frac{y(i\pm k)-y(i)}{y(i\pm k)+y(i)}\right]; /// \f]; ///; /// #### Reference:; ///; /// 1. Z.K. Silagadze, A new algorithm for automatic photopeak searches.; /// NIM A 376 (1996), 451.; ///; /// ### Example 14 - script Smoothing.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Smoothing.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:381,Availability,error,error,381,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional deconvolution function; ///; /// This function calculates deconvolution from source spectrum according to; /// response spectrum using Gold deconvolution algorithm. The result is placed; /// in the vector pointed by source pointer. On successful completion it; /// returns 0. On error it returns pointer to the string describing error. If; /// desired after every numberIterations one can apply boosting operation; /// (exponential function with exponent given by boost coefficient) and repeat; /// it numberRepetitions times.; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum; /// - response: pointer to the vector of response spectrum; /// - ssize: length of source and response spectra; /// - numberIterations, for details we refer to the reference given below; /// - numberRepetitions, for repeated boosted deconvolution; /// - boost, boosting coefficient; ///; /// The goal of this function is the improvement of the resolution in spectra,; /// decomposition of multiplets. The mathematical formulation of; /// the convolution system is:; ///; /// \f[; /// y(i) = \sum_{k=0}^{N-1} h(i-k)x(k), i=0,1,2,...,N-1; /// \f]; ///; /// where h(i) is the impulse response function, x, y are input and output; /// vectors, respectively, N is the length of x and h vectors. In matrix form; /// we have:; /**; \f[; \begin{bmatrix}; y(0) \\; y(1) \\; \dots \\; y(2N-2) \\; y(2N-1); \end{bmatrix}; =; \begin{bmatrix}; h(0) & 0 & 0 & \dots & 0 \\; h(1) & h(0) & 0 & \dots & \dots \\; \dots & h(1) & h(0) & \dots & \dots \\; \dots & \dots & h(1) & \dots & \dots \\; \dots & \dots & \dots & \dots & \dots \\; h(N-1) & \dots & \dots &\dots & 0 \\; 0 & h(N-1) & \dots & \dots & h(0) \\; 0 & 0 & h(N-1) & \dots & h(1) \\; \dots & \dots & \dots & \dots & \dots \\; 0 & 0 & 0 & \dots & h(N-1); \end{bmatrix}; \begin{bmatrix}; x(0) \\; x(1) \\; \dots \\; x(N-1); \end{bmatrix}; \",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:431,Availability,error,error,431,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional deconvolution function; ///; /// This function calculates deconvolution from source spectrum according to; /// response spectrum using Gold deconvolution algorithm. The result is placed; /// in the vector pointed by source pointer. On successful completion it; /// returns 0. On error it returns pointer to the string describing error. If; /// desired after every numberIterations one can apply boosting operation; /// (exponential function with exponent given by boost coefficient) and repeat; /// it numberRepetitions times.; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum; /// - response: pointer to the vector of response spectrum; /// - ssize: length of source and response spectra; /// - numberIterations, for details we refer to the reference given below; /// - numberRepetitions, for repeated boosted deconvolution; /// - boost, boosting coefficient; ///; /// The goal of this function is the improvement of the resolution in spectra,; /// decomposition of multiplets. The mathematical formulation of; /// the convolution system is:; ///; /// \f[; /// y(i) = \sum_{k=0}^{N-1} h(i-k)x(k), i=0,1,2,...,N-1; /// \f]; ///; /// where h(i) is the impulse response function, x, y are input and output; /// vectors, respectively, N is the length of x and h vectors. In matrix form; /// we have:; /**; \f[; \begin{bmatrix}; y(0) \\; y(1) \\; \dots \\; y(2N-2) \\; y(2N-1); \end{bmatrix}; =; \begin{bmatrix}; h(0) & 0 & 0 & \dots & 0 \\; h(1) & h(0) & 0 & \dots & \dots \\; \dots & h(1) & h(0) & \dots & \dots \\; \dots & \dots & h(1) & \dots & \dots \\; \dots & \dots & \dots & \dots & \dots \\; h(N-1) & \dots & \dots &\dots & 0 \\; 0 & h(N-1) & \dots & \dots & h(0) \\; 0 & 0 & h(N-1) & \dots & h(1) \\; \dots & \dots & \dots & \dots & \dots \\; 0 & 0 & 0 & \dots & h(N-1); \end{bmatrix}; \begin{bmatrix}; x(0) \\; x(1) \\; \dots \\; x(N-1); \end{bmatrix}; \",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:8324,Availability,error,error,8324,"// the unconstrained space of independent variables. From physical point of; /// view we are interested only in a meaningful solution. Therefore, we have to; /// employ regularisation techniques (e.g. Gold deconvolution) and/or to; /// confine the space of allowed solutions to subspace of positive solutions.; ///; /// \image html TSpectrum_Deconvolution_wide3.jpg Fig. 14 The same spectrum like in Fig. 13, outlined bars show the contents of present components (peaks).; /// \image html TSpectrum_Deconvolution_wide4.jpg Fig. 15 Least squares solution of the system of linear equations without regularisation.; ///; /// ### Example 9 - script Deconvolution_wide.C; ///; /// When we employ Gold deconvolution algorithm we obtain the result given in; /// Fig. 16. One can observe that the resulting spectrum is smooth. On the; /// other hand the method is not able to decompose completely the peaks in the; /// spectrum.; ///; /// Example of Gold deconvolution for closely positioned wide peaks. The original; /// source spectrum is drawn with black color, the spectrum after the deconvolution; /// (10000 iterations) with red color.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution_wide.C; /// End_Macro; ///; /// ### Example 10 - script Deconvolution_wide_boost.C :; ///; /// Further let us employ boosting operation into deconvolution (Fig. 17).; ///; /// The original source spectrum is drawn with black color, the spectrum after; /// the deconvolution with red color. Number of iterations = 200, number of; /// repetitions = 50 and boosting coefficient = 1.2.; ///; /// One can observe that peaks are decomposed practically to delta functions.; /// Number of peaks is correct, positions of big peaks as well as their areas; /// are relatively well estimated. However there is a considerable error in; /// the estimation of the position of small right hand peak.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution_wide_boost.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3765,Energy Efficiency,Efficient,Efficient,3765,",3,...,L; x^{0} = [1,1, ..., 1]^T; \f]; */; /// Where L is given number of iterations (numberIterations parameter).; ///; /// #### Boosted deconvolution:; ///; /// 1. Set the initial solution:; /// \f$ x^{(0)} = [1,1,...,1]^{T} \f$; /// 2. Set required number of repetitions R and iterations L.; /// 3. Set r = 1.; /// 4. Using Gold deconvolution algorithm for k=1,2,...,L find; /// \f$ x^{(L)} \f$; /// 5. If r = R stop calculation, else; ///; /// 1. Apply boosting operation, i.e., set; /// \f$ x^{(0)}(i) = [x^{(L)}(i)]^{p} \f$; /// i=0,1,...N-1 and p is boosting coefficient >0.; /// 2. r = r + 1; /// 3. continue in 4.; ///; /// #### References:; ///; /// 1. Gold R., ANL-6984, Argonne National Laboratories, Argonne Ill, 1964.; /// 2. Coote G.E., Iterative smoothing and deconvolution of one- and two-dimensional; /// elemental distribution data, NIM B 130 (1997) 118.; /// 3. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo: Efficient one- and two-dimensional Gold deconvolution and; /// its application to gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; /// 4. Morhac; M., Matouoek V., Kliman J., Efficient algorithm of multidimensional; /// deconvolution and its application to nuclear data processing, Digital Signal; /// Processing 13 (2003) 144.; ///; /// ### Example 8 - script Deconvolution.C :; ///; /// response function (usually peak) should be shifted left to the first; /// non-zero channel (bin).; ///; /// \image html TSpectrum_Deconvolution2.jpg Principle how the response matrix is composed inside of the Deconvolution function.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution.C; /// End_Macro; ///; /// ### Examples of Gold deconvolution method:; ///; /// First let us study the influence of the number of iterations on the; /// deconvolved spectrum (Fig. 12).; ///; /// \image html TSpectrum_Deconvolution_wide1.jpg Fig. 12 Study of Gold deconvolution algorithm.The original source spectrum is drawn with black color, s",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3950,Energy Efficiency,Efficient,Efficient,3950,")} = [1,1,...,1]^{T} \f$; /// 2. Set required number of repetitions R and iterations L.; /// 3. Set r = 1.; /// 4. Using Gold deconvolution algorithm for k=1,2,...,L find; /// \f$ x^{(L)} \f$; /// 5. If r = R stop calculation, else; ///; /// 1. Apply boosting operation, i.e., set; /// \f$ x^{(0)}(i) = [x^{(L)}(i)]^{p} \f$; /// i=0,1,...N-1 and p is boosting coefficient >0.; /// 2. r = r + 1; /// 3. continue in 4.; ///; /// #### References:; ///; /// 1. Gold R., ANL-6984, Argonne National Laboratories, Argonne Ill, 1964.; /// 2. Coote G.E., Iterative smoothing and deconvolution of one- and two-dimensional; /// elemental distribution data, NIM B 130 (1997) 118.; /// 3. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo: Efficient one- and two-dimensional Gold deconvolution and; /// its application to gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; /// 4. Morhac; M., Matouoek V., Kliman J., Efficient algorithm of multidimensional; /// deconvolution and its application to nuclear data processing, Digital Signal; /// Processing 13 (2003) 144.; ///; /// ### Example 8 - script Deconvolution.C :; ///; /// response function (usually peak) should be shifted left to the first; /// non-zero channel (bin).; ///; /// \image html TSpectrum_Deconvolution2.jpg Principle how the response matrix is composed inside of the Deconvolution function.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution.C; /// End_Macro; ///; /// ### Examples of Gold deconvolution method:; ///; /// First let us study the influence of the number of iterations on the; /// deconvolved spectrum (Fig. 12).; ///; /// \image html TSpectrum_Deconvolution_wide1.jpg Fig. 12 Study of Gold deconvolution algorithm.The original source spectrum is drawn with black color, spectrum after 100 iterations with red color, spectrum after 1000 iterations with blue color, spectrum after 10000 iterations with green color and spectrum after 100000 iterations with magenta color.; ///; //",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:4948,Energy Efficiency,green,green,4948,"1 (1997) 385-408.; /// 4. Morhac; M., Matouoek V., Kliman J., Efficient algorithm of multidimensional; /// deconvolution and its application to nuclear data processing, Digital Signal; /// Processing 13 (2003) 144.; ///; /// ### Example 8 - script Deconvolution.C :; ///; /// response function (usually peak) should be shifted left to the first; /// non-zero channel (bin).; ///; /// \image html TSpectrum_Deconvolution2.jpg Principle how the response matrix is composed inside of the Deconvolution function.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution.C; /// End_Macro; ///; /// ### Examples of Gold deconvolution method:; ///; /// First let us study the influence of the number of iterations on the; /// deconvolved spectrum (Fig. 12).; ///; /// \image html TSpectrum_Deconvolution_wide1.jpg Fig. 12 Study of Gold deconvolution algorithm.The original source spectrum is drawn with black color, spectrum after 100 iterations with red color, spectrum after 1000 iterations with blue color, spectrum after 10000 iterations with green color and spectrum after 100000 iterations with magenta color.; ///; /// For relatively narrow peaks in the above given example the Gold; /// deconvolution method is able to decompose overlapping peaks practically to; /// delta - functions. In the next example we have chosen a synthetic data; /// (spectrum, 256 channels) consisting of 5 very closely positioned, relatively; /// wide peaks (sigma =5), with added noise (Fig. 13). Thin lines represent; /// pure Gaussians (see Table 1); thick line is a resulting spectrum with; /// additive noise (10% of the amplitude of small peaks).; ///; /// \image html TSpectrum_Deconvolution_wide2.jpg Fig. 13 Testing example of synthetic spectrum composed of 5 Gaussians with added noise.; ///; /// | Peak # | Position | Height | Area |; /// |----------|----------|--------|--------|; /// | 1 | 50 | 500 | 10159 |; /// | 2 | 70 | 3000 | 60957 |; /// | 3 | 80 | 1000 | 20319 |; /// | 4 | 100 | 5",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:6542,Modifiability,variab,variables,6542,"e noise (10% of the amplitude of small peaks).; ///; /// \image html TSpectrum_Deconvolution_wide2.jpg Fig. 13 Testing example of synthetic spectrum composed of 5 Gaussians with added noise.; ///; /// | Peak # | Position | Height | Area |; /// |----------|----------|--------|--------|; /// | 1 | 50 | 500 | 10159 |; /// | 2 | 70 | 3000 | 60957 |; /// | 3 | 80 | 1000 | 20319 |; /// | 4 | 100 | 5000 | 101596 |; /// | 5 | 110 | 500 | 10159 |; ///; /// Table 1 Positions, heights and areas of peaks in the spectrum shown in Fig. 13.; ///; /// In ideal case, we should obtain the result given in Fig. 14. The areas of; /// the Gaussian components of the spectrum are concentrated completely to; /// delta-functions. When solving the overdetermined system of linear equations; /// with data from Fig. 13 in the sense of minimum least squares criterion; /// without any regularisation we obtain the result with large oscillations; /// (Fig. 15). From mathematical point of view, it is the optimal solution in; /// the unconstrained space of independent variables. From physical point of; /// view we are interested only in a meaningful solution. Therefore, we have to; /// employ regularisation techniques (e.g. Gold deconvolution) and/or to; /// confine the space of allowed solutions to subspace of positive solutions.; ///; /// \image html TSpectrum_Deconvolution_wide3.jpg Fig. 14 The same spectrum like in Fig. 13, outlined bars show the contents of present components (peaks).; /// \image html TSpectrum_Deconvolution_wide4.jpg Fig. 15 Least squares solution of the system of linear equations without regularisation.; ///; /// ### Example 9 - script Deconvolution_wide.C; ///; /// When we employ Gold deconvolution algorithm we obtain the result given in; /// Fig. 16. One can observe that the resulting spectrum is smooth. On the; /// other hand the method is not able to decompose completely the peaks in the; /// spectrum.; ///; /// Example of Gold deconvolution for closely positioned wide peak",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:5604,Testability,Test,Testing,5604,"ectrum (Fig. 12).; ///; /// \image html TSpectrum_Deconvolution_wide1.jpg Fig. 12 Study of Gold deconvolution algorithm.The original source spectrum is drawn with black color, spectrum after 100 iterations with red color, spectrum after 1000 iterations with blue color, spectrum after 10000 iterations with green color and spectrum after 100000 iterations with magenta color.; ///; /// For relatively narrow peaks in the above given example the Gold; /// deconvolution method is able to decompose overlapping peaks practically to; /// delta - functions. In the next example we have chosen a synthetic data; /// (spectrum, 256 channels) consisting of 5 very closely positioned, relatively; /// wide peaks (sigma =5), with added noise (Fig. 13). Thin lines represent; /// pure Gaussians (see Table 1); thick line is a resulting spectrum with; /// additive noise (10% of the amplitude of small peaks).; ///; /// \image html TSpectrum_Deconvolution_wide2.jpg Fig. 13 Testing example of synthetic spectrum composed of 5 Gaussians with added noise.; ///; /// | Peak # | Position | Height | Area |; /// |----------|----------|--------|--------|; /// | 1 | 50 | 500 | 10159 |; /// | 2 | 70 | 3000 | 60957 |; /// | 3 | 80 | 1000 | 20319 |; /// | 4 | 100 | 5000 | 101596 |; /// | 5 | 110 | 500 | 10159 |; ///; /// Table 1 Positions, heights and areas of peaks in the spectrum shown in Fig. 13.; ///; /// In ideal case, we should obtain the result given in Fig. 14. The areas of; /// the Gaussian components of the spectrum are concentrated completely to; /// delta-functions. When solving the overdetermined system of linear equations; /// with data from Fig. 13 in the sense of minimum least squares criterion; /// without any regularisation we obtain the result with large oscillations; /// (Fig. 15). From mathematical point of view, it is the optimal solution in; /// the unconstrained space of independent variables. From physical point of; /// view we are interested only in a meaningful solution. Therefo",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:393,Availability,error,error,393,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional deconvolution function.; ///; /// This function calculates deconvolution from source spectrum according to; /// response spectrum using Richardson-Lucy deconvolution algorithm. The result; /// is placed in the vector pointed by source pointer. On successful completion; /// it returns 0. On error it returns pointer to the string describing error.; /// If desired after every numberIterations one can apply boosting operation; /// (exponential function with exponent given by boost coefficient) and repeat; /// it numberRepetitions times (see Gold deconvolution).; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum; /// - response: pointer to the vector of response spectrum; /// - ssize: length of source and response spectra; /// - numberIterations, for details we refer to the reference given above; /// - numberRepetitions, for repeated boosted deconvolution; /// - boost, boosting coefficient; ///; /// ### Richardson-Lucy deconvolution algorithm:; ///; /// For discrete systems it has the form:; /**; \f[; x^{(n)}(i) = x^{(n-1)}(i) \sum_{j=0}^{N-1}h(i,j)\frac{y(j)}{\sum_{k=0}^{M-1}h(j,k)x^{(n-1)}(k)} \\; i \in \left<0,M-1\right>; \f]; */; /// for positive input data and response matrix this iterative method forces; /// the deconvoluted spectra to be non-negative. The Richardson-Lucy; /// iteration converges to the maximum likelihood solution for Poisson statistics; /// in the data.; ///; /// #### References:; ///; /// 1. Abreu M.C. et al., A four-dimensional deconvolution method to correct NA38; /// experimental data, NIM A 405 (1998) 139.; /// 2. Lucy L.B., A.J. 79 (1974) 745.; /// 3. Richardson W.H., J. Opt. Soc. Am. 62 (1972) 55.; ///; /// ### Examples of Richardson-Lucy deconvolution method:; ///; /// ### Example 11 - script DeconvolutionRL_wide.C :; ///; /// When we employ Richardson-Lucy deconvolution algorithm to our data from; /// F",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:443,Availability,error,error,443,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional deconvolution function.; ///; /// This function calculates deconvolution from source spectrum according to; /// response spectrum using Richardson-Lucy deconvolution algorithm. The result; /// is placed in the vector pointed by source pointer. On successful completion; /// it returns 0. On error it returns pointer to the string describing error.; /// If desired after every numberIterations one can apply boosting operation; /// (exponential function with exponent given by boost coefficient) and repeat; /// it numberRepetitions times (see Gold deconvolution).; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum; /// - response: pointer to the vector of response spectrum; /// - ssize: length of source and response spectra; /// - numberIterations, for details we refer to the reference given above; /// - numberRepetitions, for repeated boosted deconvolution; /// - boost, boosting coefficient; ///; /// ### Richardson-Lucy deconvolution algorithm:; ///; /// For discrete systems it has the form:; /**; \f[; x^{(n)}(i) = x^{(n-1)}(i) \sum_{j=0}^{N-1}h(i,j)\frac{y(j)}{\sum_{k=0}^{M-1}h(j,k)x^{(n-1)}(k)} \\; i \in \left<0,M-1\right>; \f]; */; /// for positive input data and response matrix this iterative method forces; /// the deconvoluted spectra to be non-negative. The Richardson-Lucy; /// iteration converges to the maximum likelihood solution for Poisson statistics; /// in the data.; ///; /// #### References:; ///; /// 1. Abreu M.C. et al., A four-dimensional deconvolution method to correct NA38; /// experimental data, NIM A 405 (1998) 139.; /// 2. Lucy L.B., A.J. 79 (1974) 745.; /// 3. Richardson W.H., J. Opt. Soc. Am. 62 (1972) 55.; ///; /// ### Examples of Richardson-Lucy deconvolution method:; ///; /// ### Example 11 - script DeconvolutionRL_wide.C :; ///; /// When we employ Richardson-Lucy deconvolution algorithm to our data from; /// F",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:437,Availability,error,error,437,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional unfolding function; ///; /// This function unfolds source spectrum according to response matrix columns.; /// The result is placed in the vector pointed by source pointer.; /// The coefficients of the resulting vector represent contents of the columns; /// (weights) in the input vector. On successful completion it returns 0. On; /// error it returns pointer to the string describing error. If desired after; /// every numberIterations one can apply boosting operation (exponential; /// function with exponent given by boost coefficient) and repeat it; /// numberRepetitions times. For details we refer to [1].; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum; /// - respMatrix: pointer to the matrix of response spectra; /// - ssizex: length of source spectrum and # of rows of the response; /// matrix. ssizex must be >= ssizey.; /// - ssizey: length of destination coefficients and # of columns of the response; /// matrix.; /// - numberIterations: number of iterations; /// - numberRepetitions: number of repetitions for boosted deconvolution.; /// It must be greater or equal to one.; /// - boost: boosting coefficient, applies only if numberRepetitions is; /// greater than one.; ///; /// ### Unfolding:; ///; /// The goal is the decomposition of spectrum to a given set of component spectra.; ///; /// The mathematical formulation of the discrete linear system is:; ///; /// \f[; /// y(i) = \sum_{k=0}^{N_y-1} h(i,k)x(k), i = 0,1,2,...,N_x-1; /// \f]; /**; \f[; \begin{bmatrix}; y(0) \\; y(1) \\; \dots \\; y(N_x-1); \end{bmatrix}; =; \begin{bmatrix}; h(0,0) & h(0,1) & \dots & h(0,N_y-1) \\; h(1,0) & h(1,1) & \dots & h(1,N_y-1) \\; \dots \\; h(N_x-1,0) & h(N_x-1,1) & \dots & h(N_x-1,N_y-1); \end{bmatrix}; \begin{bmatrix}; x(0) \\; x(1) \\; \dots \\; x(N_y-1); \end{bmatrix}; \f]; */; ///; /// #### References:; ///; /// 1. Jandel M., Morhac; M., Kl",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:487,Availability,error,error,487,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional unfolding function; ///; /// This function unfolds source spectrum according to response matrix columns.; /// The result is placed in the vector pointed by source pointer.; /// The coefficients of the resulting vector represent contents of the columns; /// (weights) in the input vector. On successful completion it returns 0. On; /// error it returns pointer to the string describing error. If desired after; /// every numberIterations one can apply boosting operation (exponential; /// function with exponent given by boost coefficient) and repeat it; /// numberRepetitions times. For details we refer to [1].; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum; /// - respMatrix: pointer to the matrix of response spectra; /// - ssizex: length of source spectrum and # of rows of the response; /// matrix. ssizex must be >= ssizey.; /// - ssizey: length of destination coefficients and # of columns of the response; /// matrix.; /// - numberIterations: number of iterations; /// - numberRepetitions: number of repetitions for boosted deconvolution.; /// It must be greater or equal to one.; /// - boost: boosting coefficient, applies only if numberRepetitions is; /// greater than one.; ///; /// ### Unfolding:; ///; /// The goal is the decomposition of spectrum to a given set of component spectra.; ///; /// The mathematical formulation of the discrete linear system is:; ///; /// \f[; /// y(i) = \sum_{k=0}^{N_y-1} h(i,k)x(k), i = 0,1,2,...,N_x-1; /// \f]; /**; \f[; \begin{bmatrix}; y(0) \\; y(1) \\; \dots \\; y(N_x-1); \end{bmatrix}; =; \begin{bmatrix}; h(0,0) & h(0,1) & \dots & h(0,N_y-1) \\; h(1,0) & h(1,1) & \dots & h(1,N_y-1) \\; \dots \\; h(N_x-1,0) & h(N_x-1,1) & \dots & h(N_x-1,N_y-1); \end{bmatrix}; \begin{bmatrix}; x(0) \\; x(1) \\; \dots \\; x(N_y-1); \end{bmatrix}; \f]; */; ///; /// #### References:; ///; /// 1. Jandel M., Morhac; M., Kl",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1703,Deployability,continuous,continuous,1703,"ks.; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum.; /// - destVector: pointer to the vector of resulting deconvolved spectrum.; /// - ssize: length of source spectrum.; /// - sigma: sigma of searched peaks, for details we refer to manual.; /// - threshold: threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual.; /// - backgroundRemove: logical variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),;",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1994,Deployability,continuous,continuous,1994,"elected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual.; /// - backgroundRemove: logical variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),; /// 309-320.; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo.:Identification of peaks in; /// multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; /// 3. Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; /// A 376 (1996), 451.; ///; /// Examples of peak sear",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3637,Energy Efficiency,green,green,3637,"common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),; /// 309-320.; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo.:Identification of peaks in; /// multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; /// 3. Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; /// A 376 (1996), 451.; ///; /// Examples of peak searching method:; ///; /// The SearchHighRes function provides users with the possibility to vary the; /// input parameters and with the access to the output deconvolved data in the; /// destination spectrum. Based on the output data one can tune the parameters.; ///; /// ### Example 15 - script SearchHR1.C:; ///; /// One-dimensional spectrum with found peaks denoted by markers, 3 iterations; /// steps in the deconvolution.; ///; /// #### Script:; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/SearchHR1.C; /// End_Macro; ///; /// ### Example 16 - script SearchHR3.C:; ///; /// Influence of number of iterations (3-red, 10-blue, 100- green, 1000-magenta),; /// sigma=8, smoothing width=3.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/SearchHR3.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1126,Modifiability,variab,variable,1126,"This function searches for peaks in source spectrum. It is based on; /// deconvolution method. First the background is removed (if desired), then; /// Markov smoothed spectrum is calculated (if desired), then the response; /// function is generated according to given sigma and deconvolution is; /// carried out. The order of peaks is arranged according to their heights in; /// the spectrum after background elimination. The highest peak is the first in; /// the list. On success it returns number of found peaks.; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum.; /// - destVector: pointer to the vector of resulting deconvolved spectrum.; /// - ssize: length of source spectrum.; /// - sigma: sigma of searched peaks, for details we refer to manual.; /// - threshold: threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual.; /// - backgroundRemove: logical variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; ///",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1302,Modifiability,variab,variable,1302,"then the response; /// function is generated according to given sigma and deconvolution is; /// carried out. The order of peaks is arranged according to their heights in; /// the spectrum after background elimination. The highest peak is the first in; /// the list. On success it returns number of found peaks.; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum.; /// - destVector: pointer to the vector of resulting deconvolved spectrum.; /// - ssize: length of source spectrum.; /// - sigma: sigma of searched peaks, for details we refer to manual.; /// - threshold: threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual.; /// - backgroundRemove: logical variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image htm",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3225,Performance,tune,tune,3225,"common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),; /// 309-320.; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo.:Identification of peaks in; /// multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; /// 3. Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; /// A 376 (1996), 451.; ///; /// Examples of peak searching method:; ///; /// The SearchHighRes function provides users with the possibility to vary the; /// input parameters and with the access to the output deconvolved data in the; /// destination spectrum. Based on the output data one can tune the parameters.; ///; /// ### Example 15 - script SearchHR1.C:; ///; /// One-dimensional spectrum with found peaks denoted by markers, 3 iterations; /// steps in the deconvolution.; ///; /// #### Script:; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/SearchHR1.C; /// End_Macro; ///; /// ### Example 16 - script SearchHR3.C:; ///; /// Influence of number of iterations (3-red, 10-blue, 100- green, 1000-magenta),; /// sigma=8, smoothing width=3.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/SearchHR3.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:2132,Safety,detect,detect,2132,"al variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),; /// 309-320.; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo.:Identification of peaks in; /// multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; /// 3. Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; /// A 376 (1996), 451.; ///; /// Examples of peak searching method:; ///; /// The SearchHighRes function provides users with the possibility to vary the; /// input parameters and with the acc",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:3120,Security,access,access,3120,"common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image html TSpectrum_Searching1.jpg Fig. 27 An example of one-dimensional synthetic spectrum with found peaks denoted by markers.; ///; /// #### References:; ///; /// 1. M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967),; /// 309-320.; /// 2. M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky,; /// I. Turzo.:Identification of peaks in; /// multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; /// 3. Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; /// A 376 (1996), 451.; ///; /// Examples of peak searching method:; ///; /// The SearchHighRes function provides users with the possibility to vary the; /// input parameters and with the access to the output deconvolved data in the; /// destination spectrum. Based on the output data one can tune the parameters.; ///; /// ### Example 15 - script SearchHR1.C:; ///; /// One-dimensional spectrum with found peaks denoted by markers, 3 iterations; /// steps in the deconvolution.; ///; /// #### Script:; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/SearchHR1.C; /// End_Macro; ///; /// ### Example 16 - script SearchHR3.C:; ///; /// Influence of number of iterations (3-red, 10-blue, 100- green, 1000-magenta),; /// sigma=8, smoothing width=3.; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/SearchHR3.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1118,Testability,log,logical,1118,"This function searches for peaks in source spectrum. It is based on; /// deconvolution method. First the background is removed (if desired), then; /// Markov smoothed spectrum is calculated (if desired), then the response; /// function is generated according to given sigma and deconvolution is; /// carried out. The order of peaks is arranged according to their heights in; /// the spectrum after background elimination. The highest peak is the first in; /// the list. On success it returns number of found peaks.; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum.; /// - destVector: pointer to the vector of resulting deconvolved spectrum.; /// - ssize: length of source spectrum.; /// - sigma: sigma of searched peaks, for details we refer to manual.; /// - threshold: threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual.; /// - backgroundRemove: logical variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; ///",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:1294,Testability,log,logical,1294,"then the response; /// function is generated according to given sigma and deconvolution is; /// carried out. The order of peaks is arranged according to their heights in; /// the spectrum after background elimination. The highest peak is the first in; /// the list. On success it returns number of found peaks.; ///; /// #### Parameters:; ///; /// - source: pointer to the vector of source spectrum.; /// - destVector: pointer to the vector of resulting deconvolved spectrum.; /// - ssize: length of source spectrum.; /// - sigma: sigma of searched peaks, for details we refer to manual.; /// - threshold: threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual.; /// - backgroundRemove: logical variable, set if the removal of; /// background before deconvolution is desired.; /// - deconIterations-number of iterations in deconvolution operation.; /// - markov: logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow: averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method).; ///; /// ### Peaks searching:; ///; /// The goal of this function is to identify automatically the peaks in spectrum; /// with the presence of the continuous background and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification are:; ///; /// - non-sensitivity to noise, i.e., only statistically; /// relevant peaks should be identified.; /// - non-sensitivity of the algorithm to continuous; /// background.; /// - ability to identify peaks close to the edges of the; /// spectrum region. Usually peak finders fail to detect them.; /// - resolution, decomposition of Double_tts and multiplets.; /// The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma.; ///; /// \image htm",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:201,Deployability,release,release,201,"////////////////////////////////////////////////////////////////////////////////; /// Old name of SearcHighRes introduced for back compatibility.; /// This function will be removed after the June 2006 release",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:103,Integrability,interface,interface,103,"////////////////////////////////////////////////////////////////////////////////; /// Static function, interface to TSpectrum::Search.",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:103,Integrability,interface,interface,103,"////////////////////////////////////////////////////////////////////////////////; /// Static function, interface to TSpectrum::Background.",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1409,Availability,avail,available,1409,"ectrum:$Id$; // Author: Miroslav Morhac 17/01/2006; /** \class TSpectrum2; \ingroup Spectrum; \brief Advanced 2-dimensional spectra processing; \author Miroslav Morhac. \legacy{TSpectrum2, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. This class contains advanced spectra processing functions. - One-dimensional background estimation functions; - Two-dimensional background estimation functions; - One-dimensional smoothing functions; - Two-dimensional smoothing functions; - One-dimensional deconvolution functions; - Two-dimensional deconvolution functions; - One-dimensional peak search functions; - Two-dimensional peak search functions. The algorithms in this class have been published in the following references:. 1. M.Morhac et al.: Background elimination methods for multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Physics Research A 401 (1997) 113-132.; 2. M.Morhac et al.: Efficient one- and two-dimensional Gold deconvolution and its application to gamma-ray spectra decomposition. Nuclear Instruments and Methods in Physics Research A 401 (1997) 385-408.; 3. M.Morhac et al.: Identification of peaks in multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Research Physics A 443(2000), 108-125. These NIM papers are also available as doc or ps files from:. - [SpectrumDec.ps.gz](ftp://root.cern/root/SpectrumDec.ps.gz); - [SpectrumSrc.ps.gz](ftp://root.cern/root/SpectrumSrc.ps.gz); - [SpectrumBck.ps.gz](ftp://root.cern/root/SpectrumBck.ps.gz). See also the; [online documentation](https://root.cern/guides/tspectrum-manual) and; [tutorials](https://root.cern/doc/master/group__tutorial__spectrum.html). All the figures in this page were prepared using the DaqProVis; system, Data Acquisition, Processing and Visualization system,; developed at the Institute of Physics, Slovak Academy of Sciences, Bratislava,; Slovakia.; */",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1029,Energy Efficiency,Efficient,Efficient,1029,"ectrum:$Id$; // Author: Miroslav Morhac 17/01/2006; /** \class TSpectrum2; \ingroup Spectrum; \brief Advanced 2-dimensional spectra processing; \author Miroslav Morhac. \legacy{TSpectrum2, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. This class contains advanced spectra processing functions. - One-dimensional background estimation functions; - Two-dimensional background estimation functions; - One-dimensional smoothing functions; - Two-dimensional smoothing functions; - One-dimensional deconvolution functions; - Two-dimensional deconvolution functions; - One-dimensional peak search functions; - Two-dimensional peak search functions. The algorithms in this class have been published in the following references:. 1. M.Morhac et al.: Background elimination methods for multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Physics Research A 401 (1997) 113-132.; 2. M.Morhac et al.: Efficient one- and two-dimensional Gold deconvolution and its application to gamma-ray spectra decomposition. Nuclear Instruments and Methods in Physics Research A 401 (1997) 385-408.; 3. M.Morhac et al.: Identification of peaks in multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Research Physics A 443(2000), 108-125. These NIM papers are also available as doc or ps files from:. - [SpectrumDec.ps.gz](ftp://root.cern/root/SpectrumDec.ps.gz); - [SpectrumSrc.ps.gz](ftp://root.cern/root/SpectrumSrc.ps.gz); - [SpectrumBck.ps.gz](ftp://root.cern/root/SpectrumBck.ps.gz). See also the; [online documentation](https://root.cern/guides/tspectrum-manual) and; [tutorials](https://root.cern/doc/master/group__tutorial__spectrum.html). All the figures in this page were prepared using the DaqProVis; system, Data Acquisition, Processing and Visualization system,; developed at the Institute of Physics, Slovak Academy of Sciences, Bratislava,; Slovakia.; */",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1689,Usability,guid,guides,1689,"ectrum:$Id$; // Author: Miroslav Morhac 17/01/2006; /** \class TSpectrum2; \ingroup Spectrum; \brief Advanced 2-dimensional spectra processing; \author Miroslav Morhac. \legacy{TSpectrum2, For modeling a spectrum fitting and estimating the background one can use RooFit while for deconvolution and unfolding one can use TUnfold.}. This class contains advanced spectra processing functions. - One-dimensional background estimation functions; - Two-dimensional background estimation functions; - One-dimensional smoothing functions; - Two-dimensional smoothing functions; - One-dimensional deconvolution functions; - Two-dimensional deconvolution functions; - One-dimensional peak search functions; - Two-dimensional peak search functions. The algorithms in this class have been published in the following references:. 1. M.Morhac et al.: Background elimination methods for multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Physics Research A 401 (1997) 113-132.; 2. M.Morhac et al.: Efficient one- and two-dimensional Gold deconvolution and its application to gamma-ray spectra decomposition. Nuclear Instruments and Methods in Physics Research A 401 (1997) 385-408.; 3. M.Morhac et al.: Identification of peaks in multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Research Physics A 443(2000), 108-125. These NIM papers are also available as doc or ps files from:. - [SpectrumDec.ps.gz](ftp://root.cern/root/SpectrumDec.ps.gz); - [SpectrumSrc.ps.gz](ftp://root.cern/root/SpectrumSrc.ps.gz); - [SpectrumBck.ps.gz](ftp://root.cern/root/SpectrumBck.ps.gz). See also the; [online documentation](https://root.cern/guides/tspectrum-manual) and; [tutorials](https://root.cern/doc/master/group__tutorial__spectrum.html). All the figures in this page were prepared using the DaqProVis; system, Data Acquisition, Processing and Visualization system,; developed at the Institute of Physics, Slovak Academy of Sciences, Bratislava,; Slovakia.; */",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:273,Performance,perform,performed,273,"////////////////////////////////////////////////////////////////////////////////; /// This function searches for peaks in source spectrum in hin; /// The number of found peaks and their positions are written into; /// the members fNpeaks and fPositionX.; /// The search is performed in the current histogram range.; ///; /// Function parameters:; /// - hin: pointer to the histogram of source spectrum; /// - sigma: sigma of searched peaks, for details we refer to manual; /// - threshold: (default=0.05) peaks with amplitude less than; /// threshold*highest_peak are discarded. 0<threshold<1; ///; /// By default, the background is removed before deconvolution.; /// Specify the option ""nobackground"" to not remove the background.; ///; /// By default the ""Markov"" chain algorithm is used.; /// Specify the option ""noMarkov"" to disable this algorithm; /// Note that by default the source spectrum is replaced by a new spectrum; ///; /// By default a polymarker object is created and added to the list of; /// functions of the histogram. The histogram is drawn with the specified; /// option and the polymarker object drawn on top of the histogram.; /// The polymarker coordinates correspond to the npeaks peaks found in; /// the histogram.; /// A pointer to the polymarker object can be retrieved later via:; /// ~~~ {.cpp}; /// TList *functions = hin->GetListOfFunctions();; /// TPolyMarker *pm = (TPolyMarker*)functions->FindObject(""TPolyMarker""); /// ~~~; /// Specify the option ""goff"" to disable the storage and drawing of the; /// polymarker.",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:6,Testability,log,logic,6,"//The logic in the loop should be improved to use the fact; //that fPositionX,Y give a precise position inside a bin.; //The current algorithm takes the center of the bin only.",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1267,Modifiability,extend,extended,1267,"////////////////////////////////////////////////////////////////////////////////; /// This function calculates smoothed spectrum from source spectrum; /// based on Markov chain method.; /// The result is placed in the array pointed by source pointer.; ///; /// Function parameters:; /// - source-pointer to the array of source spectrum; /// - ssizex-x length of source; /// - ssizey-y length of source; /// - averWindow-width of averaging smoothing window; ///; /// ### Smoothing; ///; /// Goal: Suppression of statistical fluctuations the algorithm is based on discrete; /// Markov chain, which has very simple invariant distribution; /// \f[; /// U_2 = \frac{p_{1.2}}{p_{2,1}}U_1, U_3 = \frac{p_{2,3}}{p_{3,2}}U_2 U_1, ... , U_n = \frac{p_{n-1,n}}{p_{n,n-1}}U_{n-1} ... U_2 U_1; /// \f]; /// \f$U_1\f$ being defined from the normalization condition \f$ \sum_{i=1}^{n} U_i = 1\f$; /// n is the length of the smoothed spectrum and; /// \f[; /// p_{i,i\pm1} = A_i \sum_{k=1}^{m} exp\left[\frac{y(i\pm k)-y(i)}{y(i\pm k)+y(i)}\right]; /// \f]; /// is the probability of the change of the peak position from channel i to the channel i+1.; /// \f$A_i\f$ is the normalization constant so that\f$ p_{i,i-1}+p_{i,i+1}=1\f$ and m is a width; /// of smoothing window. We have extended this algorithm to two dimensions.; ///; /// #### Reference:; ///; /// [1] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451.; ///; /// ### Example 4 - Smooth.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Smooth.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:605,Usability,simpl,simple,605,"////////////////////////////////////////////////////////////////////////////////; /// This function calculates smoothed spectrum from source spectrum; /// based on Markov chain method.; /// The result is placed in the array pointed by source pointer.; ///; /// Function parameters:; /// - source-pointer to the array of source spectrum; /// - ssizex-x length of source; /// - ssizey-y length of source; /// - averWindow-width of averaging smoothing window; ///; /// ### Smoothing; ///; /// Goal: Suppression of statistical fluctuations the algorithm is based on discrete; /// Markov chain, which has very simple invariant distribution; /// \f[; /// U_2 = \frac{p_{1.2}}{p_{2,1}}U_1, U_3 = \frac{p_{2,3}}{p_{3,2}}U_2 U_1, ... , U_n = \frac{p_{n-1,n}}{p_{n,n-1}}U_{n-1} ... U_2 U_1; /// \f]; /// \f$U_1\f$ being defined from the normalization condition \f$ \sum_{i=1}^{n} U_i = 1\f$; /// n is the length of the smoothed spectrum and; /// \f[; /// p_{i,i\pm1} = A_i \sum_{k=1}^{m} exp\left[\frac{y(i\pm k)-y(i)}{y(i\pm k)+y(i)}\right]; /// \f]; /// is the probability of the change of the peak position from channel i to the channel i+1.; /// \f$A_i\f$ is the normalization constant so that\f$ p_{i,i-1}+p_{i,i+1}=1\f$ and m is a width; /// of smoothing window. We have extended this algorithm to two dimensions.; ///; /// #### Reference:; ///; /// [1] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376 (1996), 451.; ///; /// ### Example 4 - Smooth.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Smooth.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:2029,Energy Efficiency,Efficient,Efficient,2029,"ematical formulation of the 2-dimensional convolution system is; ///; ///\f[; /// y(i_1,i_2) = \sum_{k_1=0}^{N_1-1} \sum_{k_2=0}^{N_2-1} h(i_1-k_1,i_2-k_2)x(k_1,k_2); ///\f]; ///\f[; /// i_1 = 0,1,2, ... ,N_1-1, i_2 = 0,1,2, ... ,N_2-1; ///\f]; ///; /// where h(i,j) is the impulse response function, x, y are input and output; /// matrices, respectively, \f$ N_1, N_2\f$ are the lengths of x and h matrices; ///; /// - let us assume that we know the response and the output matrices (spectra) of the above given system.; /// - the deconvolution represents solution of the overdetermined system of linear equations, i.e., the; /// calculation of the matrix x.; /// - from numerical stability point of view the operation of deconvolution is; /// extremely critical (ill-posed problem) as well as time consuming operation.; /// - the Gold deconvolution algorithm proves to work very well even for 2-dimensional; /// systems. Generalisation of the algorithm for 2-dimensional systems was presented in [1], [2].; /// - for Gold deconvolution algorithm as well as for boosted deconvolution algorithm we refer also to TSpectrum; ///; /// #### References:; ///; /// [1] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:; /// Efficient one- and two-dimensional Gold deconvolution and its application to; /// gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; ///; /// [2] Morhac; M., Matouoek V., Kliman J., Efficient algorithm of multidimensional; /// deconvolution and its application to nuclear data processing, Digital Signal; /// Processing 13 (2003) 144.; ///; /// ### Example 5 - Deconvolution2_1.c; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution2_1.C; /// End_Macro; ///; /// ### Example 6 - Deconvolution2_2.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution2_2.C; /// End_Macro; ///; /// ### Example 7 - Deconvolution2_HR.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution2_HR.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:2220,Energy Efficiency,Efficient,Efficient,2220,"ematical formulation of the 2-dimensional convolution system is; ///; ///\f[; /// y(i_1,i_2) = \sum_{k_1=0}^{N_1-1} \sum_{k_2=0}^{N_2-1} h(i_1-k_1,i_2-k_2)x(k_1,k_2); ///\f]; ///\f[; /// i_1 = 0,1,2, ... ,N_1-1, i_2 = 0,1,2, ... ,N_2-1; ///\f]; ///; /// where h(i,j) is the impulse response function, x, y are input and output; /// matrices, respectively, \f$ N_1, N_2\f$ are the lengths of x and h matrices; ///; /// - let us assume that we know the response and the output matrices (spectra) of the above given system.; /// - the deconvolution represents solution of the overdetermined system of linear equations, i.e., the; /// calculation of the matrix x.; /// - from numerical stability point of view the operation of deconvolution is; /// extremely critical (ill-posed problem) as well as time consuming operation.; /// - the Gold deconvolution algorithm proves to work very well even for 2-dimensional; /// systems. Generalisation of the algorithm for 2-dimensional systems was presented in [1], [2].; /// - for Gold deconvolution algorithm as well as for boosted deconvolution algorithm we refer also to TSpectrum; ///; /// #### References:; ///; /// [1] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:; /// Efficient one- and two-dimensional Gold deconvolution and its application to; /// gamma-ray spectra decomposition. NIM, A401 (1997) 385-408.; ///; /// [2] Morhac; M., Matouoek V., Kliman J., Efficient algorithm of multidimensional; /// deconvolution and its application to nuclear data processing, Digital Signal; /// Processing 13 (2003) 144.; ///; /// ### Example 5 - Deconvolution2_1.c; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution2_1.C; /// End_Macro; ///; /// ### Example 6 - Deconvolution2_2.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution2_2.C; /// End_Macro; ///; /// ### Example 7 - Deconvolution2_HR.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Deconvolution2_HR.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1426,Deployability,continuous,continuous,1426,"igma and deconvolution is carried out.; ///; /// Function parameters:; /// - source-pointer to the matrix of source spectrum; /// - dest-pointer to the matrix of resulting deconvolved spectrum; /// - ssizex-x length of source spectrum; /// - ssizey-y length of source spectrum; /// - sigma-sigma of searched peaks, for details we refer to manual; /// - threshold-threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual; /// - backgroundRemove-logical variable, set if the removal of; /// background before deconvolution is desired; /// - deconIterations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; /// - resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for identification of peaks in the presence of; /// background",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1781,Deployability,continuous,continuous,1781,"manual; /// - backgroundRemove-logical variable, set if the removal of; /// background before deconvolution is desired; /// - deconIterations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; /// - resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967), 309-320.; ///; /// [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification; /// of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); /// 108-125.; ///; /// [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; /// (1996), 451.; ///; /// ### Examples of peak searching method; ///; /// SearchHighRes function provides users with the possibility; /// to vary t",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:878,Modifiability,variab,variable,878,"////////////////////////////////////////////////////////////////////////////////; /// This function searches for peaks in source spectrum; /// It is based on deconvolution method. First the background is; /// removed (if desired), then Markov spectrum is calculated; /// (if desired), then the response function is generated; /// according to given sigma and deconvolution is carried out.; ///; /// Function parameters:; /// - source-pointer to the matrix of source spectrum; /// - dest-pointer to the matrix of resulting deconvolved spectrum; /// - ssizex-x length of source spectrum; /// - ssizey-y length of source spectrum; /// - sigma-sigma of searched peaks, for details we refer to manual; /// - threshold-threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual; /// - backgroundRemove-logical variable, set if the removal of; /// background before deconvolution is desired; /// - deconIterations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Us",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1051,Modifiability,variab,variable,1051,"////////////////////////////////////////////////////////////////////////////////; /// This function searches for peaks in source spectrum; /// It is based on deconvolution method. First the background is; /// removed (if desired), then Markov spectrum is calculated; /// (if desired), then the response function is generated; /// according to given sigma and deconvolution is carried out.; ///; /// Function parameters:; /// - source-pointer to the matrix of source spectrum; /// - dest-pointer to the matrix of resulting deconvolved spectrum; /// - ssizex-x length of source spectrum; /// - ssizey-y length of source spectrum; /// - sigma-sigma of searched peaks, for details we refer to manual; /// - threshold-threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual; /// - backgroundRemove-logical variable, set if the removal of; /// background before deconvolution is desired; /// - deconIterations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Us",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:2978,Performance,tune,tune,2978," in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; /// - resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967), 309-320.; ///; /// [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification; /// of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); /// 108-125.; ///; /// [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; /// (1996), 451.; ///; /// ### Examples of peak searching method; ///; /// SearchHighRes function provides users with the possibility; /// to vary the input parameters and with the access to the output deconvolved data; /// in the destination spectrum. Based on the output data one can tune the; /// parameters.; ///; /// ### Example 8 - Src.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src.C; /// End_Macro; ///; /// ### Example 9 - Src2.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src2.C; /// End_Macro; ///; /// ### Example 10 - Src3.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src3.C; /// End_Macro; ///; /// ### Example 11 - Src4.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src4.C; /// End_Macro; ///; /// ### Example 12 - Src5.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src5.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:2028,Safety,detect,detect,2028,"l variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; /// - resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967), 309-320.; ///; /// [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification; /// of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); /// 108-125.; ///; /// [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; /// (1996), 451.; ///; /// ### Examples of peak searching method; ///; /// SearchHighRes function provides users with the possibility; /// to vary the input parameters and with the access to the output deconvolved data; /// in the destination spectrum. Based on the output data one can tune the; /// parameters.; ///; /// ### Example 8 - Src.C; ///; /// Beg",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:2873,Security,access,access,2873," in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Usually peak finders fail to detect them; /// - resolution, decomposition of doublets and multiplets. The algorithm should be able to recognise close positioned peaks.; /// - ability to identify peaks with different sigma; ///; /// #### References:; ///; /// [1] M.A. Mariscotti: A method for identification of peaks in the presence of; /// background and its application to spectrum analysis. NIM 50 (1967), 309-320.; ///; /// [2] M. Morhac;, J. Kliman, V. Matouoek, M. Veselsky, I. Turzo.:Identification; /// of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); /// 108-125.; ///; /// [3] Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; /// (1996), 451.; ///; /// ### Examples of peak searching method; ///; /// SearchHighRes function provides users with the possibility; /// to vary the input parameters and with the access to the output deconvolved data; /// in the destination spectrum. Based on the output data one can tune the; /// parameters.; ///; /// ### Example 8 - Src.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src.C; /// End_Macro; ///; /// ### Example 9 - Src2.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src2.C; /// End_Macro; ///; /// ### Example 10 - Src3.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src3.C; /// End_Macro; ///; /// ### Example 11 - Src4.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src4.C; /// End_Macro; ///; /// ### Example 12 - Src5.C; ///; /// Begin_Macro(source); /// ../../../tutorials/spectrum/Src5.C; /// End_Macro",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:870,Testability,log,logical,870,"////////////////////////////////////////////////////////////////////////////////; /// This function searches for peaks in source spectrum; /// It is based on deconvolution method. First the background is; /// removed (if desired), then Markov spectrum is calculated; /// (if desired), then the response function is generated; /// according to given sigma and deconvolution is carried out.; ///; /// Function parameters:; /// - source-pointer to the matrix of source spectrum; /// - dest-pointer to the matrix of resulting deconvolved spectrum; /// - ssizex-x length of source spectrum; /// - ssizey-y length of source spectrum; /// - sigma-sigma of searched peaks, for details we refer to manual; /// - threshold-threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual; /// - backgroundRemove-logical variable, set if the removal of; /// background before deconvolution is desired; /// - deconIterations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Us",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:1043,Testability,log,logical,1043,"////////////////////////////////////////////////////////////////////////////////; /// This function searches for peaks in source spectrum; /// It is based on deconvolution method. First the background is; /// removed (if desired), then Markov spectrum is calculated; /// (if desired), then the response function is generated; /// according to given sigma and deconvolution is carried out.; ///; /// Function parameters:; /// - source-pointer to the matrix of source spectrum; /// - dest-pointer to the matrix of resulting deconvolved spectrum; /// - ssizex-x length of source spectrum; /// - ssizey-y length of source spectrum; /// - sigma-sigma of searched peaks, for details we refer to manual; /// - threshold-threshold value in % for selected peaks, peaks with; /// amplitude less than threshold*highest_peak/100; /// are ignored, see manual; /// - backgroundRemove-logical variable, set if the removal of; /// background before deconvolution is desired; /// - deconIterations-number of iterations in deconvolution operation; /// - markov-logical variable, if it is true, first the source spectrum; /// is replaced by new spectrum calculated using Markov; /// chains method.; /// - averWindow-averaging window of searched peaks, for details; /// we refer to manual (applies only for Markov method); ///; /// ### Peaks searching; ///; /// Goal: to identify automatically the peaks in spectrum with the presence of the; /// continuous background, one-fold coincidences (ridges) and statistical; /// fluctuations - noise.; ///; /// The common problems connected with correct peak identification in two-dimensional coincidence spectra are; ///; /// - non-sensitivity to noise, i.e., only statistically relevant peaks should be identified; /// - non-sensitivity of the algorithm to continuous background; /// - non-sensitivity to one-fold coincidences (coincidences peak - background in both dimensions) and their crossings; /// - ability to identify peaks close to the edges of the spectrum region. Us",MatchSource.CODE_COMMENT,hist/spectrum/src/TSpectrum2.cxx,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx
